<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tech | hplonline]]></title>
  <link href="http://hupili.github.io/backup-hplonline/blog/categories/tech/atom.xml" rel="self"/>
  <link href="http://hupili.github.io/backup-hplonline/"/>
  <updated>2013-05-04T16:48:34+08:00</updated>
  <id>http://hupili.github.io/backup-hplonline/</id>
  <author>
    <name><![CDATA[hplonline]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[再谈stl的rotate]]></title>
    <link href="http://hupili.github.io/backup-hplonline/blog/2011/04/09/%E5%86%8D%E8%B0%88stl%E7%9A%84rotate/"/>
    <updated>2011-04-09T14:07:00+08:00</updated>
    <id>http://hupili.github.io/backup-hplonline/blog/2011/04/09/再谈stl的rotate</id>
    <content type="html"><![CDATA[<p>(hplonline)2011.4.9</p>


<p> </p>


<p>两年前写了这篇：<a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/ecf54b34b9e94646241f14b1.html">http://hi.baidu.com/hplonline/blog/item/ecf54b34b9e94646241f14b1.html</a></p>


<p>主要是为了测试stl的萃取机制，即根据不同的迭代器tag，来选择不同的函数版本。</p>


<p>留言非常有价值，建议感兴趣的同学围观。</p>


<p> </p>


<p>其中，<span style="color: rgb(255, 0, 0);">random_access_iterator</span>的实现非常精辟，当时想记下，似乎搞忘了，没见到下文。</p>


<p> </p>


<p><span style="color: rgb(0, 85, 255);">》》rotate函数</span></p>


<p>可以抽象成这种模型rotate(int *a, int k, int n)，</p>


<p>对于传入的数组a，有n个元素，要求循环向前移动k次。</p>


<p>每次循环移动的意思是，a[i]=a[i + 1]，而a[n-1] = a[0]。</p>


<p> </p>


<p>stl里面，为了与其他用迭代器描述的接口吻合，</p>


<p>使用迭代器来给出k和n等价的信息，对于int*型的迭代器，接口如下：</p>


<p>rotate(int *begin, int *mid, int *end)</p>


<p> </p>


<p>从rotate函数的描述中，我们可以瞬间得到一个简单的算法，</p>


<p>就是循环向前移动k次，那么时间消耗是 k*n。</p>


<p>对于k比较大的时候（大于n/2），可以做个优化，</p>


<p>改为循环后移n-k位，时间消耗(n-k)*n。</p>


<p>这个算法的时间上界是n^2的，空间消耗是常数的。</p>


<p> </p>


<p>另外一个简单算法是通过空间换时间。</p>


<p>如果rotate的接口不要求in-place，或者给了等长的buffer，可以这样搞：</p>


<p>（1）将a[k ~ n-1]复制到buffer[0 ~ n-k]<br/>（2）将a[0 ~ k-1]复制到buffer[k ~ n-1]</p>


<p>这个算法的时间和空间都是n了。</p>


<p> </p>


<p>这个rotate函数在面试题里面经常出现，</p>


<p>一般要求的是时间O(n)，空间O(1)，而且是in-place的。</p>


<p> </p>


<p><span style="color: rgb(0, 85, 255);">》》三种tag</span></p>


<br/>我看的是g++下的代码，在 stl_algo.h 文件中。<br/><br/><span style="color: rgb(170, 0, 255);">forward_iterator_tag</span><br/>这种类型的迭代器只能像前移动，所以算法实现上很纠结。<br/>大体过程是不断交换[first, mid) 和 [mid, last) 两个区间的元素。<br/>没有多少复杂的数学推导，想清楚过程就行了，故不赘述。<br/>以<span style="color: rgb(255, 0, 0);">交换</span>作为<span style="color: rgb(255, 0, 0);">单位操作</span>，时间消耗是n。<br/>（注意，这三个算法的空间复杂度都是O(1)，时间O(n)。<br/>所以不谈复杂度，谈具体消耗，并且要指明单位操作。）<br/><br/><span style="color: rgb(170, 0, 255);">bidirectional_iterator_tag</span><br/>这种类型的迭代器可以双向移动，于是它是支持reverse操作的。<br/>估计大部分人在网上看到的面试题，都是讲的这套算法，如下：<br/>reverse(begin, mid)<br/>reverse(mid, end)<br/>reverse(begin, end)<br/>以<span style="color: rgb(255, 0, 0);">交换</span>作为<span style="color: rgb(255, 0, 0);">单位操作</span>，时间消耗是2*n。<br/><br/><span style="color: rgb(170, 0, 255);">random_access_iterator_tag</span><br/>以<strong><span style="color: rgb(255, 0, 0);">赋值</span></strong>作为单位操作，时间消耗是 d + n，<br/>其中，d=gcd(n, k)。<br/><br/>关于时间消耗的实测印证，在前面的文章中能找到：<br/><a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/ecf54b34b9e94646241f14b1.html">http://hi.baidu.com/hplonline/blog/item/ecf54b34b9e94646241f14b1.html</a><br/><br/>可以知道，bidirectional版本最耗时，是forward版本的两倍。<br/>random版本与n和k的具体值有关，但是d不会超过n，且一般都非常小。<br/>random版本用的不是<span style="color: rgb(255, 0, 0);">交换</span>，而是<span style="color: rgb(255, 0, 0);">轮换</span>，所以单位操作是幅值。<br/>从实测可以看到，耗时大约为forward版本的1/3。<br/><br/><span style="color: rgb(0, 85, 255);">》》random_access_iterator</span><br/><br/>stl的这段代码太飘逸了，下划线不说，还全用指针优化。<br/>感觉不适合阅读，所以就贴在本篇最后了，下面分析一个我改写的简化版。<br/><br/>void my_rotate(int *begin, int *mid, int *end){<br/>    int n = end - begin ;<br/>    int k = mid - begin ;<br/>    int d = __gcd(n, k) ;<br/>    int i, j ;<br/>    <span style="color: rgb(255, 0, 0);">// (i + k * j) % n % d == i % d</span><br/>    for ( i = 0 ; i &lt; d ; i ++ ){<br/>        int tmp = begin[i] ;<br/>        int last = i ;<br/>        for ( j = (i + k) % n ; j != i ; j = (j + k) % n){<br/>            begin[last] = begin[j] ;    <br/>            last = j ;<br/>        }    <br/>        begin[last] = tmp ;<br/>    }<br/>}<br/><br/>先举个例子，取n=5，k=2。原序列：<br/>0 1 2 3 4 <br/>rotate过后的序列：<br/>2 3 4 0 1<br/>这里，原序列中的某个元素，rotate后的位置是可以直接确定的。<br/>注意到我们只有O(1)的空间可以用，所以从0号元素开始，做下列操作：<br/>（1）备份0号元素<br/>（2）2 --&gt; 0<br/>（3）4 --&gt; 2<br/>（4）1 --&gt; 4<br/>（5）3 --&gt; 1<br/>（6）将备份的0号元素放到3<br/><br/>这个例子中，只用了一次轮换，就完了，但并非所有的输入都可以在一次轮换做完。<br/>比如可以试下n=4，k=2。<br/>第一次轮换从0开始，<br/>0 1 2 3 --&gt; 2 1 0 3<br/>第二次轮换从1开始，<br/>2 1 0 3 --&gt; 2 3 0 1<br/><br/>我的简化版本中，有两重循环。<br/>内层对应的就是单次轮换，外层对应的就是第i轮，i是起点。<br/><br/><span style="color: rgb(0, 85, 255);">》》证明</span><br/><br/>现在需要证明这个算法是完备的，关键的结论就是代码中飘红的这句注释：<br/><span style="color: rgb(255, 0, 0);">// (i + k * j) % n % d == i % d</span><br/>由于d=gdc(n, k)，这个结论比较容易证明。<br/><br/>左边的<span style="color: rgb(255, 0, 0);">(i + k * j) % n</span>，反映的就是内层循环。<br/>每个元素被它后面（模n）的第k个元素替换。<br/>从前面举的例子来看，这样一轮替换有时候会完，有时候有剩。<br/>现在就是推出剩了多少，并且怎么把剩的轮换也做了。<br/>对lhs模d，可以发现得到了一个与j无关的式子，<span style="color: rgb(255, 0, 0);">i%d</span>。<br/>相当于把n个元素划分成了d组，一次轮换只使得i这组换到了rotate之后的位置。<br/>所以需且只需选择d个不同的起点，做多次轮换就行了。<br/><br/><span style="color: rgb(0, 85, 255);">》》from stl_algo.h</span><br/><br/>  /**<br/>   *  @if maint<br/>   *  This is a helper function for the rotate algorithm.<br/>   *  @endif<br/>  */<br/>  template&lt;typename _RandomAccessIterator&gt;<br/>    void<br/>    __rotate(_RandomAccessIterator __first,<br/>         _RandomAccessIterator __middle,<br/>         _RandomAccessIterator __last,<br/>         random_access_iterator_tag)<br/>    {<br/>      // concept requirements<br/>      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept&lt;<br/>        _RandomAccessIterator&gt;)<br/><br/>      if ((__first == __middle) || (__last  == __middle))<br/>    return;<br/><br/>      typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type<br/>    _Distance;<br/>      typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type<br/>    _ValueType;<br/><br/>      const _Distance __n = __last   - __first;<br/>      const _Distance __k = __middle - __first;<br/>      const _Distance __l = __n - __k;<br/><br/>      if (__k == __l)<br/>    {<br/>      std::swap_ranges(__first, __middle, __middle);<br/>      return;<br/>    }<br/><br/>      const _Distance __d = __gcd(__n, __k);<br/><br/>      for (_Distance __i = 0; __i &lt; __d; __i++)<br/>    {<br/>      const _ValueType __tmp = *__first;<br/>      _RandomAccessIterator __p = __first;<br/><br/>      if (__k &lt; __l)<br/>        {<br/>          for (_Distance __j = 0; __j &lt; __l / __d; __j++)<br/>        {<br/>          if (__p &gt; __first + __l)<br/>            {<br/>              *__p = *(__p - __l);<br/>              __p -= __l;<br/>            }<br/><br/>          *__p = *(__p + __k);<br/>          __p += __k;<br/>        }<br/>        }<br/>      else<br/>        {<br/>          for (_Distance __j = 0; __j &lt; __k / __d - 1; __j ++)<br/>        {<br/>          if (__p &lt; __last - __k)<br/>            {<br/>              *__p = *(__p + __k);<br/>              __p += __k;<br/>            }<br/>          *__p = * (__p - __l);<br/>          __p -= __l;<br/>        }<br/>        }<br/><br/>      *__p = __tmp;<br/>      ++__first;<br/>    }<br/>    }<br/><br/>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[paper] XORs in The Air: Practical Wireless Network Coding（翻译、二）]]></title>
    <link href="http://hupili.github.io/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%BA%8C%EF%BC%89/"/>
    <updated>2011-02-01T00:24:00+08:00</updated>
    <id>http://hupili.github.io/backup-hplonline/blog/2011/02/01/[paper]XORsinTheAir:PracticalWirelessNetworkCoding（翻译、二）</id>
    <content type="html"><![CDATA[<p>(hplonline)2011.1.31</p>


<h1><span><span>3<span style="font: 7pt &quot;Times New Roman&quot;;">      
</span></span></span><span>COPE</span><span style="font-family: 宋体;">综述</span></h1>




<p class="MsoNormal"><span style="font-family: 宋体;">术语表：</span></p>




<table class="MsoTableGrid" style="border-collapse: collapse; border: medium none;" border="1" cellpadding="0" cellspacing="0"><tbody><tr><td style="width: 122.4pt; border: 1pt solid windowtext; padding: 0cm 5.4pt;" valign="top" width="163">
  <p class="MsoNormal"><span style="font-family: 宋体;">术语</span></p>
  </td>
  <td style="width: 303.7pt; border-width: 1pt 1pt 1pt medium; border-style: solid solid solid none; border-color: windowtext windowtext windowtext -moz-use-text-color; padding: 0cm 5.4pt;" valign="top" width="405">
  <p class="MsoNormal"><span style="font-family: 宋体;">定义</span></p>
  </td>
 </tr><tr><td style="width: 122.4pt; border-width: medium 1pt 1pt; border-style: none solid solid; border-color: -moz-use-text-color windowtext windowtext; padding: 0cm 5.4pt;" valign="top" width="163">
  <p class="MsoNormal"><span style="font-family: 宋体;">本地包</span></p>
  </td>
  <td style="width: 303.7pt; border-width: medium 1pt 1pt medium; border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; padding: 0cm 5.4pt;" valign="top" width="405">
  <p class="MsoNormal"><span style="font-family: 宋体;">没有编码的包（来自上层交付、从邻居收到、从介质偷听到）</span></p>
  </td>
 </tr><tr><td style="width: 122.4pt; border-width: medium 1pt 1pt; border-style: none solid solid; border-color: -moz-use-text-color windowtext windowtext; padding: 0cm 5.4pt;" valign="top" width="163">
  <p class="MsoNormal"><span style="font-family: 宋体;">编码包、</span><span>XOR</span><span style="font-family: 宋体;">包</span></p>
  </td>
  <td style="width: 303.7pt; border-width: medium 1pt 1pt medium; border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; padding: 0cm 5.4pt;" valign="top" width="405">
  <p class="MsoNormal"><span style="font-family: 宋体;">将多个本地包</span><span>XOR</span><span style="font-family: 宋体;">在一起形成</span></p>
  </td>
 </tr><tr><td style="width: 122.4pt; border-width: medium 1pt 1pt; border-style: none solid solid; border-color: -moz-use-text-color windowtext windowtext; padding: 0cm 5.4pt;" valign="top" width="163">
  <p class="MsoNormal"><span style="font-family: 宋体;">下一跳集</span></p>
  </td>
  <td style="width: 303.7pt; border-width: medium 1pt 1pt medium; border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; padding: 0cm 5.4pt;" valign="top" width="405">
  <p class="MsoNormal"><span style="font-family: 宋体;">一个编码包中，所有本地包的下一跳节点组成的集合。</span></p>
  </td>
 </tr><tr><td style="width: 122.4pt; border-width: medium 1pt 1pt; border-style: none solid solid; border-color: -moz-use-text-color windowtext windowtext; padding: 0cm 5.4pt;" valign="top" width="163">
  <p class="MsoNormal"><span style="font-family: 宋体;">包编号</span></p>
  </td>
  <td style="width: 303.7pt; border-width: medium 1pt 1pt medium; border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; padding: 0cm 5.4pt;" valign="top" width="405">
  <p class="MsoNormal"><span style="font-family: 宋体;">一个包的</span><span>IP</span><span style="font-family: 宋体;">源地址和</span><span>IP</span><span style="font-family: 宋体;">序列号的</span><span>32</span><span style="font-family: 宋体;">位</span><span>hash</span><span style="font-family: 宋体;">值</span></p>
  </td>
 </tr><tr><td style="width: 122.4pt; border-width: medium 1pt 1pt; border-style: none solid solid; border-color: -moz-use-text-color windowtext windowtext; padding: 0cm 5.4pt;" valign="top" width="163">
  <p class="MsoNormal"><span style="font-family: 宋体;">输出队列</span></p>
  </td>
  <td style="width: 303.7pt; border-width: medium 1pt 1pt medium; border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; padding: 0cm 5.4pt;" valign="top" width="405">
  <p class="MsoNormal"><span style="font-family: 宋体;">每个节点有一个</span><span>FIFO</span><span style="font-family: 宋体;">队列，用于保存所有待转发的包</span></p>
  </td>
 </tr><tr><td style="width: 122.4pt; border-width: medium 1pt 1pt; border-style: none solid solid; border-color: -moz-use-text-color windowtext windowtext; padding: 0cm 5.4pt;" valign="top" width="163">
  <p class="MsoNormal"><span style="font-family: 宋体;">存储池</span></p>
  </td>
  <td style="width: 303.7pt; border-width: medium 1pt 1pt medium; border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; padding: 0cm 5.4pt;" valign="top" width="405">
  <p class="MsoNormal"><span style="font-family: 宋体;">存储在过去的</span><span>T</span><span style="font-family: 宋体;">分钟内，听到的所有包</span></p>
  </td>
 </tr><tr><td style="width: 122.4pt; border-width: medium 1pt 1pt; border-style: none solid solid; border-color: -moz-use-text-color windowtext windowtext; padding: 0cm 5.4pt;" valign="top" width="163">
  <p class="MsoNormal"><span style="font-family: 宋体;">编码增益</span></p>
  </td>
  <td style="width: 303.7pt; border-width: medium 1pt 1pt medium; border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; padding: 0cm 5.4pt;" valign="top" width="405">
  <p class="MsoNormal"><span style="font-family: 宋体;">不编码所需的传输次数，比上编码后所需的传输次数</span></p>
  </td>
 </tr><tr><td style="width: 122.4pt; border-width: medium 1pt 1pt; border-style: none solid solid; border-color: -moz-use-text-color windowtext windowtext; padding: 0cm 5.4pt;" valign="top" width="163">
  <p class="MsoNormal"><span style="font-family: 宋体;">编码</span><span>+MAC</span><span style="font-family: 宋体;">增益</span></p>
  </td>
  <td style="width: 303.7pt; border-width: medium 1pt 1pt medium; border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; padding: 0cm 5.4pt;" valign="top" width="405">
  <p class="MsoNormal"><span style="font-family: 宋体;">当</span><span>COPE</span><span style="font-family: 宋体;">使用</span><span>802.11</span><span style="font-family: 宋体;">作为</span><span>MAC</span><span style="font-family: 宋体;">协议，并且所有节点都积压的时候，所得的收益</span></p>
  </td>
 </tr></tbody></table>


<p class="MsoNormal"><span> </span></p>




<p class="MsoNormal"><span><span>       </span>COPE</span><span style="font-family: 宋体;">就是在</span><span>MAC</span><span style="font-family: 宋体;">和</span><span>IP</span><span style="font-family: 宋体;">间插入一个编码层，利用各种信息尽可能地在一次传输中混合多个包。主要技术有三：</span></p>




<h2><span><span>3.1<span style="font: 7pt &quot;Times New Roman&quot;;">            
</span></span></span><span style="font-family: 黑体;">机遇侦听（</span><span>opportunistic
listening</span><span style="font-family: 黑体;">）。</span></h2>




<p class="MsoNormal" style="text-indent: 21pt;"><span>COPE</span><span style="font-family: 宋体;">将所有节点的网卡设会混杂模式，存储在</span><span>T</span><span style="font-family: 宋体;">时间（默认</span><span>0.5s</span><span style="font-family: 宋体;">）内偷听到的所有包。</span></p>




<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">所有节点会广播自己的接收报告（</span><span>reception reports</span><span style="font-family: 宋体;">），告诉邻居自己自己所存的包有哪些。接收报告一般是附属在数据包上的，如果没有数据发送，也会周期性地广播控制包。</span></p>




<h2><span><span>3.2<span style="font: 7pt &quot;Times New Roman&quot;;">            
</span></span></span><span style="font-family: 黑体;">机遇编码（</span><span>opportunistic
coding</span><span style="font-family: 黑体;">）</span></h2>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">关键问题是，把哪些包</span><span>XOR</span><span style="font-family: 宋体;">到一起可以达到最大的吞吐。一个节点在发送的时候，需要最大化一次传输中本地包的数量（从后面的工程上的种种近似可以看到，作者并没有达到这个准则），并且要保证下一跳集中的每个节点都能够解码。</span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">一个例子，（看图不说话）：</span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">当前网络的状况：</span></p>




<p class="MsoNormal" style="text-align: center;" align="center"><span><span><img class="blogimg" src="http://hiphotos.baidu.com/hplonline/pic/item/f6fb9aefa74c0ebecf1b3ea2.jpg" border="0"/></span><br/><br/></span></p>




<p class="MsoNormal"><span><span>       </span>B</span><span style="font-family: 宋体;">的输出队列中，每个包的下一跳：</span></p>




<p class="MsoNormal" style="text-align: center;" align="center"><span><span><img class="blogimg" src="http://hiphotos.baidu.com/hplonline/pic/item/e234be8f55de3dbff11f36a2.jpg" border="0"/></span><br/><br/></span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">可选的编码方案：（</span><span>1</span><span style="font-family: 宋体;">、无法解码，直接</span><span>pass</span><span style="font-family: 宋体;">；</span><span>2</span><span style="font-family: 宋体;">、均可解码，但不是最优；</span><span>3</span><span style="font-family: 宋体;">、最优的）</span></p>




<p class="MsoNormal" style="text-align: center;" align="center"><span><span><img class="blogimg" src="http://hiphotos.baidu.com/hplonline/pic/item/88cfb631bdea9df95fdf0ea2.jpg" border="0"/></span><br/><br/></span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">一个简单的法则：一个节点要将</span><span>p1,p2…pn</span><span style="font-family: 宋体;">，</span><span>n</span><span style="font-family: 宋体;">个本地混在起，传给</span><span>r1,r2…rn</span><span style="font-family: 宋体;">，</span><span>n</span><span style="font-family: 宋体;">个下一跳，当且仅当</span><span>ri</span><span style="font-family: 宋体;">有</span><span>n-1</span><span style="font-family: 宋体;">个</span><span>pj(j!=i)</span><span style="font-family: 宋体;">。</span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">这个法则保证了，每个下一跳集中的节点都能解码。当一个节点有机会发送的时候，它选择满足上述法则的最大的</span><span>n</span><span style="font-family: 宋体;">，进而最大化编码的收益。（实际上，只有当上层协议认为下层是可靠的时候，并且流量对延迟不敏感的时候，这才有可能最大化。以</span><span>TCP</span><span style="font-family: 宋体;">为例，如果每次选出的</span><span>n</span><span style="font-family: 宋体;">个包，使得</span><span>n</span><span style="font-family: 宋体;">最大，但却不一定包含输出队列前面的包，这将导致</span><span>TCP</span><span style="font-family: 宋体;">的超时。或者上层协议并不关心包的交付，如</span><span>UDP</span><span style="font-family: 宋体;">）</span></p>




<h2><span><span>3.3<span style="font: 7pt &quot;Times New Roman&quot;;">            
</span></span></span><span style="font-family: 黑体;">获得邻居信息</span></h2>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">如前所述，通过接收报告，可以通知邻居自己拥有的本地包信息。在严重拥塞的时候，接收报告也可能丢失；在流量很小的时候，接收报告的到来可能很迟，以至于附近的节点已经进行了次优的编码选择。所以一个节点不能仅依赖于接收报告，而要猜测邻居所拥有的包。</span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">有些无线路由协议会计算每个节点对之间的投递概率（</span><span>delivery
probability</span><span style="font-family: 宋体;">），并用该值来决定好的传送路径。</span><span>ETX</span><span style="font-family: 宋体;">（</span><span>expected
transmission count</span><span style="font-family: 宋体;">）周期性地计算投递概率，并把投递概率的倒数作为每条链路的权值，广播出去，用链路状态协议计算出最短路径。</span></p>




<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">（投递概率的计算方法是，每个节点以</span><span>t</span><span style="font-family: 宋体;">为周期广播探针包，并维护一个计数器，统计过去</span><span>w</span><span style="font-family: 宋体;">时间内收到的探针包的数量，设当前时间为</span><span>T</span><span style="font-family: 宋体;">，</span><span>counter(T-w,T)/(w/t)</span><span style="font-family: 宋体;">即是投递概率</span><span>p</span><span style="font-family: 宋体;">。这意味着，某条链路上发送包成功的事件服从</span><span>B(n,p)</span><span style="font-family: 宋体;">，那么平均发送次数为</span><span>1/p</span><span style="font-family: 宋体;">，该值即为这条链路的</span><span>ETX</span><span style="font-family: 宋体;">。一个路径上，所有链路的</span><span>ETX</span><span style="font-family: 宋体;">之和，即是这个路径的</span><span>ETX</span><span style="font-family: 宋体;">）。</span></p>




<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">当</span><span>COPE</span><span style="font-family: 宋体;">缺乏绝对信息的时候（指收到邻居的接收报告），它使用上一跳和下一跳之间的投递概率来作为该邻居拥有这个包的概率。</span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">当</span><span>COPE</span><span style="font-family: 宋体;">猜测失败的时候，会导致一些下一跳无法解码。相应的包会被重传，并且可能和另外一组包编码到一起。</span></p>




<p class="MsoNormal"><span> </span></p>




<h1><span><span>4<span style="font: 7pt &quot;Times New Roman&quot;;">      
</span></span></span><span>COPE</span><span style="font-family: 宋体;">带来的增益</span></h1>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">吞吐量的增益来自编码机会，而编码机会又由流量模式决定。这节深入剖析预期的吞吐量增益，以及影响它的因素。</span></p>




<h2><span><span>4.1<span style="font: 7pt &quot;Times New Roman&quot;;">            
</span></span></span><span style="font-family: 黑体;">编码增益</span></h2>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">定义：无编码时的传输次数，比上有编码时最少的传输次数。</span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">在</span><span>Alic-Bob</span><span style="font-family: 宋体;">的例子中，编码增益是</span><span>4/3</span><span style="font-family: 宋体;">。</span></p>




<p class="MsoNormal"><span><span>       </span>COPE</span><span style="font-family: 宋体;">的最大编码增益是多少？任意图下，普通网络编码对单播流量的增益上界目前还是未决问题，见</span><span>[36]</span><span style="font-family: 宋体;">、</span><span>[16]</span><span style="font-family: 宋体;">。尽管如此，可以分析一些简单的拓扑，来发掘影响</span><span>COPE</span><span style="font-family: 宋体;">编码增益的因素。基本假设：完全相同的节点；全向无线信号；在信号半径内可以完美侦听；在信号半径外则无法被听到；如果两个节点可以相互听到，路由协议会使用直接链路。此外，下面的分析假设了无限的流量，并且只考虑稳定状态。</span></p>




<p class="MsoNormal"><span><span>       </span></span><b><span style="font-family: 宋体;">定理</span><span>4.1</span></b><b><span style="font-family: 宋体;">，在没有机遇侦听的情况下，最大的编码增益是</span><span>2</span></b><b><span style="font-family: 宋体;">，并且是可达的。</span><span/></b></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">这个定理可以通过下图的构造来证明，详见附录</span><span>A</span><span style="font-family: 宋体;">。</span></p>




<p class="MsoNormal" style="text-align: center;" align="center"><span><span><img class="blogimg" src="http://hiphotos.baidu.com/hplonline/pic/item/47a498583a831a8f9d8204a2.jpg" border="0"/></span><br/><br/></span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">我们并不知道在有机遇侦听的情况下，最大的编码增益是怎样的，但我们知道</span><span>COPE</span><span style="font-family: 宋体;">至少是有收益的。如下图例：</span></p>




<p class="MsoNormal" style="text-align: center;" align="center"><span><span><img class="blogimg" src="http://hiphotos.baidu.com/hplonline/pic/item/91e013d84fb4186432fa1ca2.jpg" border="0"/></span><br/><br/></span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">这个是</span><span>Alic-Bob</span><span style="font-family: 宋体;">例子的一个扩展。两组流量在链路上是不相交的。编码增益很容易得到，</span><span>4/3</span><span style="font-family: 宋体;">。这个结论很重要，因为在实际的网络中，只能找到很少的一些流量，他们拥有相同的路径，但方向不同；而许多不链路不相交的流量，在一个中继节点相交确是很容易发生的情况，于是可以把这些包通过机遇侦听和猜测编码到一起。</span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">下图（</span><span>c</span><span style="font-family: 宋体;">）是上面（</span><span>b</span><span style="font-family: 宋体;">）的一个扩展，编码增益达到</span><span>8/5</span><span style="font-family: 宋体;">。</span></p>




<p class="MsoNormal" style="text-align: center;" align="center"><span><span><img class="blogimg" src="http://hiphotos.baidu.com/hplonline/pic/item/ecf54b346c80991f241f14a2.jpg" border="0"/></span><br/><br/></span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">实际中观测到的收益比理论的要小，原因有编码机会的缺失、包头开销（</span><span>COPE</span><span style="font-family: 宋体;">要在</span><span>IP</span><span style="font-family: 宋体;">前面加上许多自己的信息）、介质中的损失率。尽管如此，</span><span>COPE</span><span style="font-family: 宋体;">可以将传输的信息率增加到大于介质的比特率，这使得即使当介质被充分使用的时候，</span><span>COPE</span><span style="font-family: 宋体;">依然带来收益。这与其他提升无线网吞吐量的方式不同，比如</span><span>[6]</span><span style="font-family: 宋体;">的机遇路由（</span><span>opportunistic
routing</span><span style="font-family: 宋体;">），当网络不完全的拥塞的时候，可以更好地利用介质，但不会增加网络容量。</span></p>




<h2><span><span>4.2<span style="font: 7pt &quot;Times New Roman&quot;;">            
</span></span></span><span style="font-family: 黑体;">编码</span><span>+MAC</span><span style="font-family: 黑体;">增益</span></h2>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">实际实验中，会发现增益超过了理论上的编码增益。这是因为</span><span>COPE</span><span style="font-family: 宋体;">编码和</span><span>MAC</span><span style="font-family: 宋体;">之间的交互，产生了有益的副作用，所以叫做编码</span><span>+MAC</span><span style="font-family: 宋体;">增益。</span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">以</span><span>Alice-Bob</span><span style="font-family: 宋体;">的图为例。在没有编码的情况下，要使网络达到最大的吞吐，</span><span>Relay</span><span style="font-family: 宋体;">的发送速率（发送机会）需要是</span><span>Alice</span><span style="font-family: 宋体;">和</span><span>Bob</span><span style="font-family: 宋体;">两倍。但</span><span>802.11</span><span style="font-family: 宋体;">的</span><span>MAC</span><span style="font-family: 宋体;">协议为了保证公平性，三个节点的发送机会是相等的。这就使得在</span><span>Relay</span><span style="font-family: 宋体;">中，有一半的包无法发出去。在使用</span><span>COPE</span><span style="font-family: 宋体;">的情况下，</span><span>Relay</span><span style="font-family: 宋体;">可以同时发送来自</span><span>Alice</span><span style="font-family: 宋体;">和</span><span>Bob</span><span style="font-family: 宋体;">的包，相比没有</span><span>COPE</span><span style="font-family: 宋体;">的时候，吞吐量变成了</span><span>2</span><span style="font-family: 宋体;">倍。</span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">编码</span><span>+MAC</span><span style="font-family: 宋体;">增益假设所有节点都持续有数据发送，但受</span><span>MAC</span><span style="font-family: 宋体;">分配的带宽所限制。在存在单点瓶颈的时候，编码</span><span>+MAC</span><span style="font-family: 宋体;">增益可以由该节点带</span><span>COPE</span><span style="font-family: 宋体;">的排出率（</span><span>draining rate</span><span style="font-family: 宋体;">，指一个中继节点，把输出队列中的包发送出去的速率），比上不带</span><span>COPE</span><span style="font-family: 宋体;">的排出率来计算。</span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">“</span><span>X</span><span style="font-family: 宋体;">”拓扑中编码</span><span>+MAC</span><span style="font-family: 宋体;">增益是</span><span>2</span><span style="font-family: 宋体;">，“十字”拓扑中，编码</span><span>+MAC</span><span style="font-family: 宋体;">增益是</span><span>4</span><span style="font-family: 宋体;">。编码</span><span>+MAC</span><span style="font-family: 宋体;">增益的理论上界为：</span></p>




<p class="MsoNormal"><span><span>       </span></span><b><span style="font-family: 宋体;">定理</span><span>4.2</span></b><b><span style="font-family: 宋体;">，在没有机遇侦听的情况下，</span><span>COPE</span></b><b><span style="font-family: 宋体;">的编码</span><span>+MAC</span></b><b><span style="font-family: 宋体;">增益是</span><span>2</span></b><b><span style="font-family: 宋体;">，并且可达到。</span><span/></b></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">证明见附录</span><span>B</span><span style="font-family: 宋体;">。</span></p>




<p class="MsoNormal"><span><span>       </span></span><b><span style="font-family: 宋体;">定理</span><span>4.3</span></b><b><span style="font-family: 宋体;">，在有机遇侦听的情况下，</span><span>COPE</span></b><b><span style="font-family: 宋体;">的编码</span><span>+MAC</span></b><b><span style="font-family: 宋体;">增益是无穷。</span><span/></b></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">可以通过构造的有无穷边的“轮”拓扑来证明，如下：</span></p>




<p class="MsoNormal" style="text-align: center;" align="center"><span><span><img class="blogimg" src="http://hiphotos.baidu.com/hplonline/pic/item/8ed7f2dcd88b13f0cc1166a2.jpg" border="0"/></span><br/><br/></span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">下表对</span><span>COPE</span><span style="font-family: 宋体;">的增益做一个总结：</span></p>




<p class="MsoNormal" style="text-align: center;" align="center"><span><span><img class="blogimg" src="http://hiphotos.baidu.com/hplonline/pic/item/d217f60381ce7fd9d53f7ca2.jpg" border="0"/></span></span></p>


<h1><span><span>5<span style="font: 7pt &quot;Times New Roman&quot;;">      
</span></span></span><span><span>    </span></span><span style="font-family: 宋体;">实现</span><span>COPE</span></h1>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">因为要把</span><span>COPE</span><span style="font-family: 宋体;">集成到现有的协议栈中，下面主要是一些系统级的问题。</span></p>




<h2><span><span>5.1<span style="font: 7pt &quot;Times New Roman&quot;;">            
</span></span></span><span style="font-family: 黑体;">包编码算法</span></h2>




<p class="MsoNormal"><span><span>       </span></span><b><span style="font-family: 宋体;">原则</span><span>1</span></b><b><span style="font-family: 宋体;">：不延迟本应该发送的包。</span></b><span style="font-family: 宋体;">当无线信道空闲的时候，取出输出队列中的第一个包，检查是否有其他可以</span><span>XOR</span><span style="font-family: 宋体;">在一起的包。如果没有编码机会，</span><span>COPE</span><span style="font-family: 宋体;">不会等待可能的匹配包，而是直接发送。（实际上这个原则和前面“最大化编码的本地包数量”是不兼容的，但这里的原则是更好的工程上的方案）</span></p>




<p class="MsoNormal"><span><span>       </span></span><b><span style="font-family: 宋体;">原则</span><span>2</span></b><b><span style="font-family: 宋体;">：尽量将长度相近的包</span><span>XOR</span></b><b><span style="font-family: 宋体;">在一起。</span></b><span style="font-family: 宋体;">因为把短包</span><span>XOR</span><span style="font-family: 宋体;">到长包中的时候，会额外补零，导致带宽利用率不高。经验研究表明，网络中的包长度成双模态分布，在</span><span>40</span><span style="font-family: 宋体;">和</span><span>1500</span><span style="font-family: 宋体;">有两个峰。</span></p>




<p class="MsoNormal"><span><span>       </span></span><b><span style="font-family: 宋体;">原则</span><span>3</span></b><b><span style="font-family: 宋体;">：</span><span>COPE</span></b><b><span style="font-family: 宋体;">不会把同样下一跳的包</span><span>XOR</span></b><b><span style="font-family: 宋体;">在一起</span></b><span style="font-family: 宋体;">。否则，下一跳无法解码。这样，</span><span>COPE</span><span style="font-family: 宋体;">只需要给每个邻居维护两个虚队列，分别对应大包和小包就行了（默认一</span><span>100bytes</span><span style="font-family: 宋体;">做阈值）。</span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">编码算法：先从输出队列中取出队头的包，判断是大包还是小包。在相同尺寸的虚队列中去搜索可以</span><span>XOR</span><span style="font-family: 宋体;">在一起的包。为防止乱序，</span><span>COPE</span><span style="font-family: 宋体;">只考察每个虚队列的队头。当一种尺寸的队列都搜索完的时候，才会搜索另一种尺寸的队列。在这些限制条件下，</span><span>COPE</span><span style="font-family: 宋体;">只用考察</span><span>2M</span><span style="font-family: 宋体;">个包头就行了（</span><span>M</span><span style="font-family: 宋体;">是邻居的数量）。</span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">另一个主要问题是乱序。</span><span>TCP</span><span style="font-family: 宋体;">会把乱序当作是网络拥塞的信号。</span><span>COPE</span><span style="font-family: 宋体;">按照输出队列的顺序发包，并且搜索虚队列的时候，只考察队首，这极大程度地规避了乱序的问题。尽管如此，由于</span><span>COPE</span><span style="font-family: 宋体;">分了大小包队列，所以乱序仍然可能发生。比如，当需要重传的时候，可能是由于组装</span><span>XOR</span><span style="font-family: 宋体;">包的时候进行了错误的猜测，导致某节点无法解码。</span><span>COPE</span><span style="font-family: 宋体;">有一个重排模块可以把</span><span>TCP</span><span style="font-family: 宋体;">分组排序后再递交上层。</span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">最后，要使得编码包所到达的节点有最大的解码可能性。</span><span>COPE</span><span style="font-family: 宋体;">必须要决定某个本地包是否可以被邻居解码。当该邻居是这个本地包的上一跳，或者收到了从该邻居发来的接收报告时，答案是肯定的。当上述条件不成立的时候，</span><span>COPE</span><span style="font-family: 宋体;">利用路由协议计算出的投递概率来估计某下一跳含有一个本地包的概率。</span><span>COPE</span><span style="font-family: 宋体;">确保下一跳集中每个节点都能解码的概率足够大。</span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">某下一跳能解码的概率是，它含有除它所需本地包外其他所有包的概率乘积：</span><span>PD=P1*P2…*P(n-1)</span><span style="font-family: 宋体;">。假设</span><span>COPE</span><span style="font-family: 宋体;">已经决定了编码</span><span>n-1</span><span style="font-family: 宋体;">个包，当决定第</span><span>n</span><span style="font-family: 宋体;">个包的时候，它考察</span><span>n</span><span style="font-family: 宋体;">个下一跳的</span><span>PD</span><span style="font-family: 宋体;">，是否都大于一个阈值</span><span>G</span><span style="font-family: 宋体;">（默认</span><span>0.8</span><span style="font-family: 宋体;">）。这样保证了所有下一跳节点都有至少</span><span>G</span><span style="font-family: 宋体;">的概率解码。最后，为了公平性，在虚队列间循环的时候使用随机顺序。</span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">每个节点的数据结构如下：</span></p>




<p class="MsoNormal" style="margin-left: 41.75pt; text-indent: -21pt;"><span style="font-family: Wingdings;"><span>l<span style="font: 7pt &quot;Times New Roman&quot;;">        
</span></span></span><span style="font-family: 宋体;">输出队列。</span><span>FIFO</span><span style="font-family: 宋体;">的队列，包含了所有待转发的包。</span></p>




<p class="MsoNormal" style="margin-left: 41.75pt; text-indent: -21pt;"><span style="font-family: Wingdings;"><span>l<span style="font: 7pt &quot;Times New Roman&quot;;">        
</span></span></span><span style="font-family: 宋体;">对每个邻居维护两个虚队列，对应大包和小包。虚队列中是一堆指针，指向输出队列的元素。</span></p>




<p class="MsoNormal" style="margin-left: 41.75pt; text-indent: -21pt;"><span style="font-family: Wingdings;"><span>l<span style="font: 7pt &quot;Times New Roman&quot;;">        
</span></span></span><span style="font-family: 宋体;">包信息表。是一个以包编号为</span><span>key</span><span style="font-family: 宋体;">的</span><span>hash</span><span style="font-family: 宋体;">表，对输出队列中的每个包，它记录了该节点邻居拥有该包的可能性。</span></p>




<p class="MsoNormal" style="margin-left: 20.75pt;"><span style="font-family: 宋体;">当</span><span>MAC</span><span style="font-family: 宋体;">层表示可以发包的时候，</span><span>COPE</span><span style="font-family: 宋体;">执行的算法如下：</span></p>




<p class="MsoNormal" style="margin-left: 20.75pt; text-align: center;" align="center"><span><span><img class="blogimg" src="http://hiphotos.baidu.com/hplonline/pic/item/c5ed3ffacf46d2d89f5146a2.jpg" border="0"/></span><br/><br/></span></p>




<p class="MsoNormal" style="text-indent: 20.75pt;"><span style="font-family: 宋体;">（循环部分用红框标出，注意并非是按照顺序迭代，前面已经说过了，是根据</span><span>[1,M]</span><span style="font-family: 宋体;">的随机排列来迭代的）</span></p>




<p class="MsoNormal"><span> </span></p>


<br/><p class="MsoNormal"><span> </span></p><br/>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[paper] XORs in The Air: Practical Wireless Network Coding（翻译、三）]]></title>
    <link href="http://hupili.github.io/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%89%EF%BC%89/"/>
    <updated>2011-02-01T00:24:00+08:00</updated>
    <id>http://hupili.github.io/backup-hplonline/blog/2011/02/01/[paper]XORsinTheAir:PracticalWirelessNetworkCoding（翻译、三）</id>
    <content type="html"><![CDATA[<p>(hplonline)2011.2.1</p>


<h2><span><span>5.2<span style="font: 7pt &quot;Times New Roman&quot;;">            
</span></span></span><span style="font-family: 黑体;">包解码算法</span></h2>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">解码算法比较简单。每个节点都维护有一个存储池，拥有所侦听到的包的拷贝，并且以包编号为</span><span>key</span><span style="font-family: 宋体;">组织成一个</span><span>hash</span><span style="font-family: 宋体;">表。收到编码包的时候，只需要在存储池中搜索</span><span>n-1</span><span style="font-family: 宋体;">个已经侦听到的包，即可完成解码。存储池会周期地（几秒）做垃圾回收。</span></p>




<h2><span><span>5.3<span style="font: 7pt &quot;Times New Roman&quot;;">            
</span></span></span><span style="font-family: 黑体;">伪广播</span></h2>




<p class="MsoNormal"><span><span>       </span>802.11</span><span style="font-family: 宋体;">有两种工作模式：单播和广播。</span><span>COPE</span><span style="font-family: 宋体;">需要将包广播到附近的节点，所以很自然地想到使用广播模式。但广播模式有两个问题：低可靠；缺乏回退机制。</span></p>




<p class="MsoNormal"><span><span>       </span>802.11</span><span style="font-family: 宋体;">工作在单播模式时，会立即</span><span>ack</span><span style="font-family: 宋体;">一个已经收到的包。</span><span>802.11</span><span style="font-family: 宋体;">通过</span><span>MAC</span><span style="font-family: 宋体;">层的重传机制保证可靠性。没有收到</span><span>ack</span><span style="font-family: 宋体;">会被当作拥塞的信号，发送方会使用指数的随机回退，这样使得多个节点可以共享介质。</span></p>




<p class="MsoNormal"><span><span>       </span>802.11</span><span style="font-family: 宋体;">的广播模式，接收方是有多个，所以无法确定谁应该</span><span>ack</span><span style="font-family: 宋体;">。没有</span><span>ack</span><span style="font-family: 宋体;">，故无法重传和保证可靠性。同时，也无法侦测到冲突。如果有大量积压的节点，共享广播信道，它们会持续地用最高速率发送分组，导致非常高的冲突率。</span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">伪广播的实质是在</span><span>802.11</span><span style="font-family: 宋体;">单播包上捎带一个</span><span>XOR</span><span style="font-family: 宋体;">头，里面指明了该编码包的所有下一跳节点，而该单播包的</span><span>MAC</span><span style="font-family: 宋体;">目的地设为下一跳集中的一个即可。由于所有节点都是混杂模式，他们可以听到</span><span>MAC</span><span style="font-family: 宋体;">地址不属于自己的包。当收到包的时候，该节点检查</span><span>XOR</span><span style="font-family: 宋体;">头，如果自己在下一跳集中，则处理该包；否则将该包放入存储池中，当作机遇侦听得到的包。由于所有的包都是单播，可以利用</span><span>802.11</span><span style="font-family: 宋体;">的冲突检测和回退机制。</span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">伪广播比广播更可靠。因为一个单播包被重传的时候，增大了周围节点偷听到它的概率。</span></p>




<h2><span><span>5.4<span style="font: 7pt &quot;Times New Roman&quot;;">            
</span></span></span><span style="font-family: 黑体;">每跳</span><span>ack</span><span style="font-family: 黑体;">和重传</span></h2>




<h3><span><span>5.4.1<span style="font: 7pt &quot;Times New Roman&quot;;">      
</span></span></span><span style="font-family: 宋体;">原因？</span></h3>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">编码包要求下一跳集中的节点都发送</span><span>ack</span><span style="font-family: 宋体;">，有两个原因：发送放只能得到一个</span><span>MAC</span><span style="font-family: 宋体;">层的</span><span>ack</span><span style="font-family: 宋体;">，就是实际上设置为</span><span>MAC</span><span style="font-family: 宋体;">目的地址的那个节点，其他节点可能没有收到编码包；即使各节点收到编码包，可能由于发送节点的错误猜测，导致无法解码。</span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">标准解法是进行局部的</span><span>ack</span><span style="font-family: 宋体;">和重传。如果某编码包中的本地包没有收到</span><span>ack</span><span style="font-family: 宋体;">，</span><span>COPE</span><span style="font-family: 宋体;">会在超时后进行重传，很可能和其他的本地包一起编码。</span></p>




<h3><span><span>5.4.2<span style="font: 7pt &quot;Times New Roman&quot;;">      
</span></span></span><span style="font-family: 宋体;">异步</span><span>ack</span><span style="font-family: 宋体;">和重传</span></h3>




<p class="MsoNormal"><span><span>       </span>802.11</span><span style="font-family: 宋体;">在</span><span>MAC</span><span style="font-family: 宋体;">层实现了同步的</span><span>ack</span><span style="font-family: 宋体;">。如果对于每个</span><span>COPE</span><span style="font-family: 宋体;">编码的本地包，都进行同步的</span><span>ack</span><span style="font-family: 宋体;">的话，效率会非常低（需要额外的介质争用）。主要思想还是做捎带。接收节点可以将</span><span>ack</span><span style="font-family: 宋体;">累积起来，然后捎带在自己后续发出的编码包中。如果没有数据发送，那么节点会在控制包中周期地送出</span><span>ack</span><span style="font-family: 宋体;">。</span></p>




<h2><span><span>5.5<span style="font: 7pt &quot;Times New Roman&quot;;">            
</span></span></span><span style="font-family: 黑体;">防止</span><span>TCP</span><span style="font-family: 黑体;">乱序</span></h2>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">由于异步</span><span>ack</span><span style="font-family: 宋体;">，还有之前叙述的重传等原因，乱序是无法完全规避的。</span><span>COPE</span><span style="font-family: 宋体;">做了一个排序模块。但自己是收到包的目的，并且上层协议是</span><span>TCP</span><span style="font-family: 宋体;">的时候，会将包排序了再上交。这个需要利用到</span><span>TCP</span><span style="font-family: 宋体;">的序列号。如果收到的包并不会导致一个空洞，则直接交给上层，否则，进行积累，直到空洞被补上或者超时。</span></p>


<h1><span><span>6<span style="font: 7pt &quot;Times New Roman&quot;;">      
</span></span></span><span style="font-family: 宋体;">实现细节</span></h1>




<h2><span><span>6.1<span style="font: 7pt &quot;Times New Roman&quot;;">            
</span></span></span><span style="font-family: 黑体;">包格式</span></h2>




<p class="MsoNormal" style="text-align: center;" align="center"><span><span><img class="blogimg" src="http://hiphotos.baidu.com/hplonline/pic/item/e3f5b409e7e85f756a60fba3.jpg" border="0"/></span><br/><br/></span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">图已经很详细了，主要就是三个部分：</span></p>




<p class="MsoNormal" style="margin-left: 41.75pt; text-indent: -21pt;"><span style="font-family: Wingdings;"><span>l<span style="font: 7pt &quot;Times New Roman&quot;;">        
</span></span></span><span style="font-family: 宋体;">该编码包中，各本地包的信息，（包编号，下一跳）。</span></p>




<p class="MsoNormal" style="margin-left: 41.75pt; text-indent: -21pt;"><span style="font-family: Wingdings;"><span>l<span style="font: 7pt &quot;Times New Roman&quot;;">        
</span></span></span><span style="font-family: 宋体;">接收报告，（源</span><span>IP</span><span style="font-family: 宋体;">，上一个</span><span>IP</span><span style="font-family: 宋体;">序列号，位图）</span></p>




<p class="MsoNormal" style="margin-left: 41.75pt; text-indent: -21pt;"><span style="font-family: Wingdings;"><span>l<span style="font: 7pt &quot;Times New Roman&quot;;">        
</span></span></span><span>Ack</span><span style="font-family: 宋体;">捎带。包含一个局部的</span><span>SEQ</span><span style="font-family: 宋体;">，用于局部</span><span>ack</span><span style="font-family: 宋体;">和重传。每个</span><span>ack</span><span style="font-family: 宋体;">条目包含，（邻居标识，上一个局部</span><span>ack</span><span style="font-family: 宋体;">编号，位图）</span></p>




<p class="MsoNormal" style="text-indent: 20.75pt;"><span style="font-family: 宋体;">比较有意思的是，</span><span>COPE</span><span style="font-family: 宋体;">如何在一个条目中，实现多个序列号（</span><span>IP</span><span style="font-family: 宋体;">序列号或者</span><span>ack</span><span style="font-family: 宋体;">号）。</span><span>COPE</span><span style="font-family: 宋体;">使用（上一编号，位图）的表达方式。由于存储池中包的序列号和</span><span>ack</span><span style="font-family: 宋体;">的序列号都有数据局部性，所以使用上一编号</span><span>+</span><span style="font-family: 宋体;">位图可以压缩信息。以</span><span>ack</span><span style="font-family: 宋体;">的一个条目为例：</span><span>{A,50,01111111}</span><span style="font-family: 宋体;">，这个</span><span>ack</span><span style="font-family: 宋体;">表示该节点从</span><span>A</span><span style="font-family: 宋体;">收到了</span><span>50</span><span style="font-family: 宋体;">号，以及</span><span>43-49</span><span style="font-family: 宋体;">号，但</span><span>42</span><span style="font-family: 宋体;">号还是缺失的。</span></p>




<p class="MsoNormal" style="text-indent: 20.75pt;"><span><span>       </span></span><span style="font-family: 宋体;">虽然</span><span>COPE</span><span style="font-family: 宋体;">有累积</span><span>ack</span><span style="font-family: 宋体;">的机制，但并不保证链路级的可靠性。每个节点都只重传少数几次（默认为</span><span>2</span><span style="font-family: 宋体;">），然后放弃。</span></p>




<h2><span><span>6.2<span style="font: 7pt &quot;Times New Roman&quot;;">            
</span></span></span><span style="font-family: 黑体;">控制流程</span></h2>




<p class="MsoNormal" style="text-align: center;" align="center"><span><span><img class="blogimg" src="http://hiphotos.baidu.com/hplonline/pic/item/2790d0b41f6687228ad4b2a3.jpg" border="0"/></span><br/><br/></span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">如图，看就明白。</span></p>




<h1><span><span>7<span style="font: 7pt &quot;Times New Roman&quot;;">      
</span></span></span><span style="font-family: 宋体;">实验结论</span></h1>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">（很多数据和图，太啰嗦，需要的时候查阅原文即可）</span></p>




<h1><span><span>8<span style="font: 7pt &quot;Times New Roman&quot;;">      
</span></span></span><span style="font-family: 宋体;">讨论和总结</span></h1>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">这篇文章的</span><span>COPE</span><span style="font-family: 宋体;">主要是用于固定的无线</span><span>mesh</span><span style="font-family: 宋体;">网，所有节点并不是资源有限的。更普遍地，</span><span>COPE</span><span style="font-family: 宋体;">可以用于满足下列条件的无线多跳网：</span></p>




<p class="MsoNormal" style="margin-left: 41.75pt; text-indent: -21pt;"><span style="font-family: Wingdings;"><span>l<span style="font: 7pt &quot;Times New Roman&quot;;">        
</span></span></span><span style="font-family: 宋体;">内存。</span><span>COPE</span><span style="font-family: 宋体;">需要当前正在网络中传输的包，已经到达目的的包没有必要存储。存储容量的计算方法是：带宽</span><span>*</span><span style="font-family: 宋体;">延迟。比如</span><span>11Mb/s</span><span style="font-family: 宋体;">的环境下，当往返时间</span><span>50ms</span><span style="font-family: 宋体;">时（</span><span>RTT</span><span style="font-family: 宋体;">，</span><span>Round-Trip Time</span><span style="font-family: 宋体;">），大约需要</span><span>70kB</span><span style="font-family: 宋体;">的存储空间。</span></p>




<p class="MsoNormal" style="margin-left: 41.75pt; text-indent: -21pt;"><span style="font-family: Wingdings;"><span>l<span style="font: 7pt &quot;Times New Roman&quot;;">        
</span></span></span><span style="font-family: 宋体;">全向天线。这是为了机遇侦听的顺利进行。</span></p>




<p class="MsoNormal" style="margin-left: 41.75pt; text-indent: -21pt;"><span style="font-family: Wingdings;"><span>l<span style="font: 7pt &quot;Times New Roman&quot;;">        
</span></span></span><span style="font-family: 宋体;">功率需求。当前的</span><span>COPE</span><span style="font-family: 宋体;">实现，并不优化节点的功率使用，并且假设节点的能量是无限制的。</span></p>




<p class="MsoNormal" style="text-indent: 20.75pt;"><span>COPE</span><span style="font-family: 宋体;">不仅使用与</span><span>Wifi</span><span style="font-family: 宋体;">的网络，还可以和其他</span><span>MAC</span><span style="font-family: 宋体;">协议一起使用，如</span><span>WiMax</span><span style="font-family: 宋体;">和</span><span>TDMA</span><span style="font-family: 宋体;">。将</span><span>COPE</span><span style="font-family: 宋体;">改造适应传感器网络也是可行的，不过有一些小问题。首先，在任意时间，传感器网络中只有一个子集的传感器处于唤醒状态。传感器网络可能更倾向于节能，而不是吞吐量提高。</span><span>COPE</span><span style="font-family: 宋体;">还可以用于蜂窝中继技术，在基站和移动设备中间建立中继站，形成多跳蜂窝中继网。实际上，爱立信已经动手了</span><span>~</span><span style="font-family: 宋体;">不过他们的中继站只会把双工流量混在一起，和</span><span>Alice-Bob</span><span style="font-family: 宋体;">那个例子一样。</span></p>




<p class="MsoNormal" style="text-indent: 20.75pt;"><span style="font-family: 宋体;">学术界有若干方法增加无线网的吞吐，包括更精确的拥塞控制、更好的路由、有效的</span><span>MAC</span><span style="font-family: 宋体;">协议。</span><span>COPE</span><span style="font-family: 宋体;">是非常重要的一步，可以帮助我们认识到无线网的承载能力；即，如何最大化单次传输中的信息量。编码机制，通常用在应用层和物理层。</span><span>COPE</span><span style="font-family: 宋体;">和其他一些项目，</span><span>[7][21]</span><span style="font-family: 宋体;">，将编码引入网络中，并且可以和转发、路由、可靠交付等集成在一起。</span></p>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[paper] XORs in The Air: Practical Wireless Network Coding（翻译、一）]]></title>
    <link href="http://hupili.github.io/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%80%EF%BC%89/"/>
    <updated>2011-02-01T00:22:00+08:00</updated>
    <id>http://hupili.github.io/backup-hplonline/blog/2011/02/01/[paper]XORsinTheAir:PracticalWirelessNetworkCoding（翻译、一）</id>
    <content type="html"><![CDATA[<p>(hplonline)2011.1.31</p>


<p>偶然读到的一篇网络编码方面文章，作为这个领域的入门材料，应该是很赞的。正好又做了翻译，不share出来就可惜了。这个领域的许多研究，正如这篇文章所说，主要是集中在理论和多播。一方面，理论让人感觉到生涩；另一方面，多播的应用环境本来就不是很显然，有点人工制造的味道。比如网络编码的经典蝶形图，一个宿从多个源收数据在大多数时候应该是没这需求的。我们能想到的多播应用环境，应该也就是类似vod之类的，当多个用户点播不同片源的时候，中间节点可以从编码上得到收益。然而在无线网中，网络编码很自然的有了需求。无线网本身有广播的特点，而大部分MAC协议，比如802.11，却利用比较复杂的规则，使得上层能拿到一个单播、“可靠”的接口。在大多数研究中， 也会把无线网抽象成点对点的形式，再套上有线网中成熟的方案。问题是解决了，但不一定拿到了最高的收益。这篇文章从无线切入，是一个很好的点。另外，关于Network Coding，这篇文章只用到了简单的XOR，这就使得我们这样的数学盲也能够理解。更令我眼前一亮的是许多工程上的考究。以前感觉学术界做事情，总是理论上非常好，实际应用的时候，受种种限制，结果没用。这篇文章提供了完整的解决方案，可以把COPE集成进现有协议栈。如果对802.11的MAC、无线路由协议（非IP的路由）、TCP等的细节比较了解的话，会有豁然开朗的感觉。即使忘干净了， 也正好可以复习一下，发现当年课堂上应付考试背的条条框框居然在这里被巧妙地用上了。</p>


<p>下面的部分也不是严格意义上的翻译，算是意译吧。专有名词不一定翻得准，就把原文中的term括在后面了。有些地方做了扩充，是根据自己的理解来的，在括号里面。像ETX等，原文只是简单提出，并给出参考文献。作者认为ETX就像TCP一样，对读者来说是个常识。。于是我又被赤裸裸地鄙视了，然后去找了相关资料，在相关部分做了下简述。</p>


<p>===================================（<a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/3f37a9ccc1a8261100e92839.html">转载提示</a>，第四条）</p>


<p>

</p>


<h1 style="margin-left: 0cm; text-indent: 0cm;"><span style="font-family: 宋体;">摘要</span></h1>




<p class="MsoNormal" style="text-indent: 21pt;"><span>COPE</span><span style="font-family: 宋体;">，一种新的无线</span><span>mesh</span><span style="font-family: 宋体;">网架构。主要是建立在网络编码理论上，让中间节点在存储转发之外，还可以把多个包混在一起，从而增加吞吐量。网络编码先前的工作主要集中在理论推导和多播流量。这篇文章主要的工作是把理论带入实践，处理通常情况下的单播、动态和突发流量、以及把</span><span>COPE</span><span style="font-family: 宋体;">集成到现有协议栈中的其他问题。在</span><span>20</span><span style="font-family: 宋体;">节点的网络中测试了</span><span>COPE</span><span style="font-family: 宋体;">的性能，网络吞吐量有极大的增加。根据流量模式、拥塞程度、传送层协议不同，获得的在增益从百分之几到几倍不等。</span></p>




<h1><span><span>1<span style="font: 7pt &quot;Times New Roman&quot;;">      
</span></span></span><span style="font-family: 宋体;">简介</span></h1>




<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">无线网不可或缺，（一堆废话）。当前无线网的主要问题是吞吐量有限，并且不可扩展到高密度的大型网络。（主要还是无线介质共享，带来的冲突问题）</span></p>




<p class="MsoNormal" style="text-indent: 21pt;"><span>COPE</span><span style="font-family: 宋体;">在</span><span>MAC</span><span style="font-family: 宋体;">和</span><span>IP</span><span style="font-family: 宋体;">中间插入一个编码层，发掘编码机会，并试图在一次传输中转发多个包。</span></p>




<p class="MsoNormal" style="text-align: center;" align="center"><span><span><img class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/5adca6af93570a9d7dd92aa2.jpg" border="0"/></span><br/><br/></span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">用这个图来解释下</span><span>COPE</span><span style="font-family: 宋体;">的基本原理。当前方法（</span><span>a</span><span style="font-family: 宋体;">），</span><span>Alice</span><span style="font-family: 宋体;">和</span><span>Bob</span><span style="font-family: 宋体;">各向对方发送一个包，总共需要</span><span>4</span><span style="font-family: 宋体;">次传输。由于</span><span>Alice</span><span style="font-family: 宋体;">和</span><span>Bob</span><span style="font-family: 宋体;">都知道自己发出去的包是什么，所以</span><span>Relay</span><span style="font-family: 宋体;">可以将两个包</span><span>XOR</span><span style="font-family: 宋体;">在一起。接收方将</span><span>Relay</span><span style="font-family: 宋体;">发来的包与自己本地的包</span><span>XOR</span><span style="font-family: 宋体;">之后，即可得到发送方的包。这样传输次数只有</span><span>3</span><span style="font-family: 宋体;">次。</span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">实际上，</span><span>COPE</span><span style="font-family: 宋体;">带来的收益远比上面这个例子要大。利用无线介质本身广播的特点，让传输路径周围的节点都能侦听到该包。每个节点都将听到的包存储一段时间，并且向自己周围的节点报告。节点在发送包的时候，可以利用周围节点报告的信息，来实现<b>机遇编码</b>（</span><span>opportunistic
coding</span><span style="font-family: 宋体;">）。在所有下一跳节点均能解码的情况下，</span><span>COPE</span><span style="font-family: 宋体;">会尽可能地混合多个包。这让</span><span>COPE</span><span style="font-family: 宋体;">可以在发送包的时候，带上反方向的流量，如</span><span>Alice-Bob</span><span style="font-family: 宋体;">的例子所示，并且可以混上更多的包。</span></p>




<p class="MsoNormal"><span><span>       </span>COPE</span><span style="font-family: 宋体;">的两个基本原则：</span></p>




<p class="MsoNormal" style="margin-left: 41.75pt; text-indent: -21pt;"><span style="font-family: Wingdings;"><span>l<span style="font: 7pt &quot;Times New Roman&quot;;">        
</span></span></span><span>COPE</span><span style="font-family: 宋体;">不使用点对点的无线网抽象方式，而是利用无线网的广播特性。网络设计者通常是将无线网抽象成点对点的方式，然后讲有线网的转发、路由技术应用于无线网。</span><span>COPE</span><span style="font-family: 宋体;">需要利用无线网的广播特性，而不是通过人工抽象去隐藏它。</span></p>




<p class="MsoNormal" style="margin-left: 41.75pt; text-indent: -21pt;"><span style="font-family: Wingdings;"><span>l<span style="font: 7pt &quot;Times New Roman&quot;;">        
</span></span></span><span>COPE</span><span style="font-family: 宋体;">利用网络编码。以往这方面的工作主要是理论和多播流量的，</span><span>COPE</span><span style="font-family: 宋体;">会解决单播、动态突发流量，还有其他实践问题。</span></p>




<p class="MsoNormal" style="text-indent: 20.75pt;"><span> </span></p>




<p class="MsoNormal" style="text-indent: 20.75pt;"><span style="font-family: 宋体;">他们</span><span>05</span><span style="font-family: 宋体;">年发表了</span><span>opportunistic
wireless network coding</span><span style="font-family: 宋体;">的文章，参考文献</span><span>[23]</span><span style="font-family: 宋体;">。这篇文章的不同点在</span><span>3</span><span style="font-family: 宋体;">个方面</span><span>:</span></p>




<p class="MsoNormal" style="margin-left: 41.75pt; text-indent: -21pt;"><span style="font-family: Wingdings;"><span>l<span style="font: 7pt &quot;Times New Roman&quot;;">        
</span></span></span><span style="font-family: 宋体;">这是无线网络编码的第一个实现，将</span><span>COPE</span><span style="font-family: 宋体;">无缝集成到现有的协议栈中，支持</span><span>TCP</span><span style="font-family: 宋体;">和</span><span>UDP</span><span style="font-family: 宋体;">，并且运行了真实的应用程序来试验。</span></p>




<p class="MsoNormal" style="margin-left: 41.75pt; text-indent: -21pt;"><span style="font-family: Wingdings;"><span>l<span style="font: 7pt &quot;Times New Roman&quot;;">        
</span></span></span><span style="font-family: 宋体;">在</span><span>linux</span><span style="font-family: 宋体;">内核和</span><span>Roofnet</span><span style="font-family: 宋体;">平台上实现了</span><span>COPE</span><span style="font-family: 宋体;">，第一次在无线网环境中部署网络编码。</span></p>




<p class="MsoNormal" style="margin-left: 41.75pt; text-indent: -21pt;"><span style="font-family: Wingdings;"><span>l<span style="font: 7pt &quot;Times New Roman&quot;;">        
</span></span></span><span style="font-family: 宋体;">研究了</span><span>COPE</span><span style="font-family: 宋体;">的性能，揭示了</span><span>COPE</span><span style="font-family: 宋体;">和无线信道、路由协议、高层应用的交互。研究结果总结如下：</span></p>




<p class="MsoNormal" style="margin-left: 62.75pt; text-indent: -21pt;"><span style="font-family: Wingdings;"><span>n<span style="font: 7pt &quot;Times New Roman&quot;;">        
</span></span></span><span style="font-family: 宋体;">网络编码有实践收益，可以极大增加无线网的吞吐量。</span></p>




<p class="MsoNormal" style="margin-left: 62.75pt; text-indent: -21pt;"><span style="font-family: Wingdings;"><span>n<span style="font: 7pt &quot;Times New Roman&quot;;">        
</span></span></span><span style="font-family: 宋体;">实验中，当无线信道拥塞、伴有大量随机的</span><span>UDP</span><span style="font-family: 宋体;">包的时候，增益大概</span><span>3-4</span><span style="font-family: 宋体;">倍。</span></p>




<p class="MsoNormal" style="margin-left: 62.75pt; text-indent: -21pt;"><span style="font-family: Wingdings;"><span>n<span style="font: 7pt &quot;Times New Roman&quot;;">        
</span></span></span><span style="font-family: 宋体;">如果上层流量没有拥塞控制，比如</span><span>UDP</span><span style="font-family: 宋体;">，</span><span>COPE</span><span style="font-family: 宋体;">的增益比理论还大。这个额外增益主要是因为编码使得路由的发送队列更短，减小了拥塞的下行链路上丢包的可能性。（被丢弃的实际上包已经消耗了部分网络资源）</span></p>




<p class="MsoNormal" style="margin-left: 62.75pt; text-indent: -21pt;"><span style="font-family: Wingdings;"><span>n<span style="font: 7pt &quot;Times New Roman&quot;;">        
</span></span></span><span style="font-family: 宋体;">在通过一个</span><span>AP</span><span style="font-family: 宋体;">连接到</span><span>Internet</span><span style="font-family: 宋体;">的无线</span><span>mesh</span><span style="font-family: 宋体;">网上，吞吐量增益根据上下行流量比例不同，从</span><span>5%</span><span style="font-family: 宋体;">到</span><span>70%</span><span style="font-family: 宋体;">不等。</span></p>




<p class="MsoNormal" style="margin-left: 62.75pt; text-indent: -21pt;"><span style="font-family: Wingdings;"><span>n<span style="font: 7pt &quot;Times New Roman&quot;;">        
</span></span></span><span style="font-family: 宋体;">隐藏终端将导致很高的冲突率，即使配置成</span><span>802.11</span><span style="font-family: 宋体;">的最大重传次数也无法掩盖。这种情况下，</span><span>TCP</span><span style="font-family: 宋体;">的发送速率不足以产生足够的编码机会。（因为</span><span>TCP</span><span style="font-family: 宋体;">在流控上的特点是，线性增加，乘法减少。当冲突发生的时候，发送窗口会折半。发送的包骤降，导致编码机会变得更少）。当没有隐藏终端问题的时候，</span><span>TCP</span><span style="font-family: 宋体;">的吞吐量平均增加</span><span>38%</span><span style="font-family: 宋体;">。</span></p>




<p class="MsoNormal"><span> </span></p>




<h1><span><span>2<span style="font: 7pt &quot;Times New Roman&quot;;">      
</span></span></span><span style="font-family: 宋体;">背景和相关工作</span></h1>




<p class="MsoNormal" style="text-align: center;" align="center"><span><span><img class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/a8d2915084487c33843524a2.jpg" border="0"/></span><br/><br/></span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">上一幅网络编码方面经典的蝶状图。这个演示的是</span><span>S1</span><span style="font-family: 宋体;">向</span><span>R1</span><span style="font-family: 宋体;">和</span><span>R2</span><span style="font-family: 宋体;">发送的多播流量</span><span>a</span><span style="font-family: 宋体;">，</span><span>S2</span><span style="font-family: 宋体;">向</span><span>R1</span><span style="font-family: 宋体;">和</span><span>R2</span><span style="font-family: 宋体;">发送的多播流量</span><span>b</span><span style="font-family: 宋体;">。</span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">网络编码方面最早的工作是</span><span>Ahiswede</span><span style="font-family: 宋体;">做的</span><span>[2]</span><span style="font-family: 宋体;">，他展示了允许路由混合多个包中的信息，可以达到多播的容量。紧接着是</span><span>Li</span><span style="font-family: 宋体;">的工作，</span><span>[26]</span><span style="font-family: 宋体;">，他证明了线性编码就可以达到容量上界。</span><span style="font-size: 9pt;">Koetter and M´edard</span><span style="font-family: 宋体;">提出了多项式复杂度的编解码算法，</span><span>[24]</span><span style="font-family: 宋体;">，</span><span style="font-size: 9pt;">Ho et al.</span><span style="font-family: 宋体;">把他们的结论扩展到了随机编码，</span><span>[17]</span><span style="font-family: 宋体;">。</span><span>[11]</span><span style="font-family: 宋体;">、</span><span>[31]</span><span style="font-family: 宋体;">，是最近研究无线网络编码的文献。</span><span style="font-size: 9pt;">Lun et al.</span><span style="font-family: 宋体;">，研究了全向天线情况下的无线网络编码，指出最小化通信开销的问题可以被表达为一个线性规划问题，并且可以分布式求解。前面这些文章都是理论的，并且研究多播流量。</span><span>[39]</span><span style="font-family: 宋体;">，</span><span>[16]</span><span style="font-family: 宋体;">，</span><span>[37]</span><span style="font-family: 宋体;">研究了单播拓扑，并且正式网络编码比纯粹转发的吞吐量要高。这篇文章就是要将理论运用于实践，并提供一个为通用单播流量实现的协议。</span></p>




<p class="MsoNormal"><span><span>       </span></span><span style="font-family: 宋体;">为了提高无线网的吞吐量，在系统级优化上，也有许多研究。</span><span>[10]</span><span style="font-family: 宋体;">、</span><span>[5]</span><span style="font-family: 宋体;">、</span><span>[12]</span><span style="font-family: 宋体;">寻找更好的路由度量（</span><span>routing
metric</span><span style="font-family: 宋体;">）。</span><span>[33]</span><span style="font-family: 宋体;">微调</span><span>TCP</span><span style="font-family: 宋体;">协议。</span><span>[6]</span><span style="font-family: 宋体;">、</span><span>[22]</span><span style="font-family: 宋体;">、</span><span>[15]</span><span style="font-family: 宋体;">改进路由和</span><span>MAC</span><span style="font-family: 宋体;">协议。</span></p>


<p><span/><br/><p class="MsoNormal" style="text-align: center;" align="center"><span><br/></span></p><br/></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用Makefile来拓扑排序]]></title>
    <link href="http://hupili.github.io/backup-hplonline/blog/2011/01/15/%E7%94%A8Makefile%E6%9D%A5%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <updated>2011-01-15T13:53:00+08:00</updated>
    <id>http://hupili.github.io/backup-hplonline/blog/2011/01/15/用Makefile来拓扑排序</id>
    <content type="html"><![CDATA[<p>(hplonline)2011.1.15</p>


<p> </p>


<p>我，其实是来灌水的。</p>


<p> </p>


<p>只要知道什么是拓扑排序，什么是makefile，那看下面代码就成了：</p>


<p>#!/bin/bash<br/># all goals<br/>echo "all:\\" &gt; Makefile<br/>awk '{print $1; print $2}' input | sort -u | awk '{print $0," \\"}' &gt;&gt; Makefile<br/>echo "" &gt;&gt; Makefile<br/># single solution<br/>awk '{print $1; print $2}' input | sort -u | awk '{print $0,":\n\techo",$0}' &gt;&gt; Makefile<br/># dependency <br/>sed 's/ /:/g' input &gt;&gt; Makefile<br/>make -s</p>


<p> </p>


<p>输入文件：<span style="color: rgb(15, 153, 50);">$ cat input</span><br/>1 2<br/>1 3<br/>2 4<br/>4 3<br/>5 2</p>


<p>测试输出：<span style="color: rgb(15, 153, 50);">$ ./topo.sh </span><br/>3<br/>4<br/>2<br/>1<br/>5</p>


<p> </p>


<p>如果有循环依赖，make会自己报出来，像这样：</p>


<p>make: Circular 4 &lt;- 3 dependency dropped.</p>


<p> </p>


<p> </p>


<p> </p>


<p> </p>

]]></content>
  </entry>
  
</feed>
