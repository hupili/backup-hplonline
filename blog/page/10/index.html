
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>hplonline</title>
  <meta name="author" content="hplonline">

  
  <meta name="description" content="(hplonline)2009.10.20 》Using ARP to Implement Transparent Subnet Gateways Routers: Explicit subnets Hosts: Transparent subnets 对路由使用明确子网方式 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hupili.github.io/backup-hplonline/blog/page/10">
  <link href="/backup-hplonline/favicon.png" rel="icon">
  <link href="/backup-hplonline/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/backup-hplonline/atom.xml" rel="alternate" title="hplonline" type="application/atom+xml">
  <script src="/backup-hplonline/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/backup-hplonline/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/backup-hplonline/">hplonline</a></h1>
  
    <h2>backup from 2006 to 2012 (original hi.baidu.com/hplonline/)</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/backup-hplonline/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hupili.github.io/backup-hplonline" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/backup-hplonline/">Blog</a></li>
  <li><a href="/backup-hplonline/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/10/20/RFC1027%E7%AC%94%E8%AE%B0%EF%BC%8C%E4%BD%BF%E7%94%A8ARP%E5%AE%9E%E7%8E%B0%E9%80%8F%E6%98%8E%E5%AD%90%E7%BD%91%E7%BD%91%E5%85%B3/">RFC1027笔记，使用ARP实现透明子网网关</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-10-20T11:43:00+08:00" pubdate data-updated="true">Oct 20<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.10.20</p>


<p>》Using ARP to Implement Transparent Subnet Gateways</p>


<p> Routers: Explicit subnets<br/>
 Hosts: Transparent subnets</p>


<p>对路由使用明确子网方式<br/>
对主机使用透明子网方式</p>


<p>》》Status of this Memo</p>


<p>     This RFC describes the use of the Ethernet Address Resolution<br/>
     Protocol (ARP) by subnet gateways to permit hosts on the connected<br/>
     subnets to communicate without being aware of the existence of<br/>
     subnets, using the technique of &#8220;Proxy ARP&#8221; [6].  It is based on<br/>
     RFC-950 [1], RFC-922 [2], and RFC-826 [3] and is a restricted subset<br/>
     of the mechanism of RFC-925 [4].  Distribution of this memo is<br/>
     unlimited.</p>


<p>交代了该RFC解决的问题和目的：<br/>
让网关使用ARP来允许主机在不知子网存在的情况下进行通信，<br/>
使用的是“代理ARP”的技术。<br/>
（&#8221;Requirements for Internet Gateways&#8221;, RFC-1009）</p>


<p>》》Motivation</p>


<p>University of Texas at Austin拥有一个庞大的以太网。<br/>
由于空间尺寸较大，以及流量较大，<br/>
用集线器将他们连在一起变得不现实。<br/>
故考虑使用子网划分的方式。</p>


<p>但是许多设备商还未开始支持子网，<br/>
并且同时修改运行中的若干种操作系统不现实。</p>


<p>这种情况下，需要一种能够将子网存在隐蔽的技术。<br/>
由于当时的LAN都支持ARP，所以选择了代理ARP的技术。</p>


<p>》》2.  Design</p>


<p>》》》2.1  Basic method</p>


<p>用来做ARP代理的网关有两个名字：<br/>
transparent subnet gateway or ARP subnet gateway.</p>


<p>     With this approach, all ARP subnet handling is done in the ARP<br/>
     subnet gateways.  No changes to the normal ARP protocol or routing<br/>
     need to be made to the source and target hosts.  From the host point<br/>
     of view, there are no subnets, and their physical networks are<br/>
     simply one big IP network.  If a host has an implementation of<br/>
     subnets, its network masks must be set to cover only the IP network<br/>
     number, excluding the subnet bits, for the system to work properly.</p>


<p>主机可以在不用更改ARP协议的情况下进行通信，<br/>
但是如果一个主机支持子网，<br/>
其使用的掩码应该只覆盖到IP网地址的位（A,B,C类），<br/>
不应该覆盖到子网地址的位。</p>


<p>》》》2.2  Routing</p>


<p>     As part of the implementation of subnets, it is expected that the<br/>
     elements of routing tables will include network numbers including<br/>
     both the IP network number and the subnet bits, as specified by the<br/>
     subnet mask, where appropriate.  When an ARP request is seen, the<br/>
     ARP subnet gateway can determine whether it knows a route to the<br/>
     target host by looking in the ordinary routing table.  If attempts<br/>
     to reach foreign IP networks are eliminated early (see Sanity Checks<br/>
     below), only a request for an address on the local IP network will<br/>
     reach this point.  We will assume that the same network mask applies<br/>
     to every subnet of the same IP network.  The network mask of the<br/>
     network interface on which the ARP request arrived can then be<br/>
     applied to the target IP address to produce the network part to be<br/>
     looked up in the routing table.</p>


<p>路由表应该应该包含IP网络地址的条目和子网地址的条目。<br/>
当ARP REQUEST 到达的时候，router检查原路由表，<br/>
来决定是否知道去向目的主机网络的路径。</p>


<p>假定在同一IP网络下的所有子网使用相同的网络掩码，<br/>
（不覆盖子网地址的位）<br/>
所以收到ARP REQUEST 的router接口的网络掩码<br/>
可以用来和目的IP地址一起生成网络地址部分。</p>


<p>     In 4.3BSD (and probably in other operating systems), a default route<br/>
     is possible.  This default route specifies an address to forward a<br/>
     packet to when no other route is found.  The default route must not<br/>
     be used when checking for a route to the target host of an ARP<br/>
     request.  If the default route were used, the check would always<br/>
     succeed.  But the host specified by the default route is unlikely to<br/>
     know about subnet routing (since it is usually an Internet gateway),<br/>
     and thus packets sent to it will probably be lost.  This special<br/>
     case in the routing lookup method is the only implementation change<br/>
     needed to the routing mechanism.</p>


<p>在支持默认网关（DG）的平台上，<br/>
不能查询该条目，否则的话，路由永远是成功的。<br/>
但DG一般是一个Internet Gateway，<br/>
可能并不支持子网路由，<br/>
所以发过去的包一般会丢失。<br/>
路由查表中的这点特殊情况是实现透明子网网关时<br/>
唯一需要对路由机制作出的改变。</p>


<p>     If the network interfaces on which the request was received and<br/>
     through which the route to the target passes are the same, the<br/>
     gateway must not reply.  In this case, either the target host is on<br/>
     the same physical network as the gateway (and thus the host should<br/>
     reply for itself), or this gateway is not on the most direct path to<br/>
     the desired network, i.e., there is another gateway on the same<br/>
     physical network that is on a more direct path and the other gateway<br/>
     should respond.</p>


<p>如果收到REQUEST的接口和<br/>
报文中目的节点所在网络的转发接口是一样的，<br/>
那么就不应该作出响应。<br/>
这里的情况有两种：<br/>
1.源和目的主机在同一物理网络内，<br/>
     那么目的主机会自己进行响应。<br/>
2.有一个距离源主机更近的网关进行响应。</p>


<p>     RFC-925 [4] describes a general mechanism for dynamic subnet routing<br/>
     using Proxy ARP and routing caches in the gateways.  Our technique<br/>
     is restricted subset of RFC-925, in which we use static subnet<br/>
     routes which are determined administratively.  As a result, our<br/>
     transparent subnet gateways require no new network routing table<br/>
     entries nor ARP cache entries; the only tables which are affected<br/>
     are the ARP caches in the host.</p>


<p>使用的是静态路由的条目，<br/>
需要由管理员配置。</p>


<p>     In our implementation, routing loops are prevented by proper<br/>
     administration of the subnet routing tables in the gateways.<br/>
     The simplest subnet organization to administer is a tree structure,<br/>
     which cannot have loops.  However, it may be desirable for<br/>
     reliability or traffic accommodation to have more than one gateway<br/>
     (or path) between two physical networks.  ARP subnet gateways may be<br/>
     used in such a situation:  a requesting host will use the first ARP<br/>
     response it receives, even if more than one gateway supplies one.<br/>
     This may even provide a rudimentary load balancing service, since if<br/>
     two gateways are otherwise similar, the one most lightly loaded is<br/>
     the more likely to reply first.</p>


<p>在该实现中，路由环应该由合理配置的子网路由表来避免。<br/>
最简单的组织方式是一个树状结构。<br/>
有时为了可靠性和流量均衡，需要在两个网络间设置多条路径。<br/>
ARP子网网关回复的时候，host选择第一个到达的响应。<br/>
因为轻负载的网关应该能更快地响应。</p>


<p>     More complex mechanisms could be built in the form of gateway-to-<br/>
     gateway protocols, and will no doubt become necessary in networks<br/>
     with large numbers of subnets and gateways, in the same way that<br/>
     gateway-to-gateway protocols are generally necessary among IP<br/>
     gateways.</p>


<p>更复杂的机制可以建立在G2G（网关到网关）协议上，<br/>
在较大的网络中，这是很有必要的，<br/>
G2G协议常以同样的方式用在IP网关中。</p>


<p>》》》2.4  Sanity checks</p>


<p>     Care must be taken by the network and gateway administrators to keep<br/>
     the network masks the same on all the subnet gateway machines.  The<br/>
     most common error is to set the network mask on a host without a<br/>
     subnet implementation to include the subnet number.  This causes the<br/>
     host to fail to attempt to send packets to hosts not on its local<br/>
     subnet.  Adjusting its routing tables will not help, since it will<br/>
     not know how to route to subnets.</p>


<p>在没有实现子网的主机上，不应该配置出子网掩码。</p>


<p>     If the IP networks of the source and target hosts of an ARP request<br/>
     are different, an ARP subnet gateway implementation should not<br/>
     reply.  This is to prevent the ARP subnet gateway from being used to<br/>
     reach foreign IP networks and thus possibly bypass security checks<br/>
     provided by IP gateways.</p>


<p>如果ARP REQUEST 中的源IP和目的IP的IP网络地址不相同，<br/>
则不应该进行回复，<br/>
以避免主机绕过安全检查而访问外域网络。</p>


<p>     An ARP subnet gateway implementation must not reply if the physical<br/>
     networks of the source and target of an ARP request are the same.<br/>
     In this case, either the target host is presumably either on the<br/>
     same physical network as the source host and can answer for itself,<br/>
     or the target host lies in the same direction from the gateway as<br/>
     does the source host, and an ARP reply from the would cause a loop.</p>


<p>对源和目的来自同一物理网络的REQUEST 不予以响应，<br/>
主要是为了避免产生环。<br/>
（与2.2中描述类似）</p>


<p>     An ARP request for a broadcast address must elicit no reply,<br/>
     regardless of the source address or physical networks involved.  If<br/>
     the gateway were to respond with an ARP reply in this situation, it<br/>
     would be inviting the original source to send actual traffic to a<br/>
     broadcast address.  This could result in the &#8220;Chernobyl effect&#8221;<br/>
     wherein every host on the network replies to such traffic, causing<br/>
     network &#8220;meltdown&#8221;.</p>


<p>不应该响应对广播地址的REQUEST。</p>


<p>     To permit multiple subnets per physical network, an ARP subnet<br/>
     gateway must use the physical network interface, not the subnet<br/>
     number to determine when to reply to an ARP request.  That is, it<br/>
     should send a proxy ARP reply only when the source network interface<br/>
     differs from the target network interface. In addition, appropriate<br/>
     routing table entries for these &#8220;phantom&#8221; subnets must be added to<br/>
     the subnet gateway routing tables.</p>


<p>在一个物理网络上拥有多个子网的时候，<br/>
要通过源和目的的接口来判断是否作出回复。</p>


<p>》》》2.6  Broadcast addresses</p>


<p>     There are two kinds of IP broadcast addresses:  main IP directed<br/>
     network broadcast and subnet broadcast.  An IP network broadcast<br/>
     address consists of the network number plus a well-known value in<br/>
     the rest (local part) of the address.  An IP subnet broadcast is<br/>
     similar, except both the IP network number and the subnet number<br/>
     bits are included.  RFC-922 standardized the use of all ones in the<br/>
     local part, but there were two conventions in use before that:  all<br/>
     ones and all zeros.  For example, 4.2BSD used all zeros, and 4.3BSD<br/>
     uses all ones.  Thus there are four kinds of IP directed broadcast<br/>
     addresses still currently in use on many networks.</p>


<p>对网络的广播使用 网络地址+local part，<br/>
对子网的广播使用 网络地址+local part，<br/>
关于local part：<br/>
4.2BSD使用的是全0<br/>
4.3BSD使用的是全1</p>


<p>     Thus a subnet gateway in a network with hosts that do not understand<br/>
     subnets must take care not to use subnet broadcast addresses:<br/>
     instead it must use the IP network directed broadcast address<br/>
     instead.</p>


<p>在拥有不支持子网的主机的网络上的子网网关，<br/>
不应该使用子网广播地址，<br/>
应该使用IP网络的直接广播地址。</p>


<p>》》3.  Implementation in 4.3BSD</p>


<p>不看了，越过</p>


<p>》》4.  Availability</p>


<p>该实现的网址<br/><a href="http://sally.utexas.edu/">http://sally.utexas.edu/</a><br/>
或者（？？）<br/><a href="ftp://sally.utexas.edu/">ftp://sally.utexas.edu/</a><br/>
我这里访问不了。</p>


<p> </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/10/19/RFC925%E7%AC%94%E8%AE%B0%2Cmulti-lan%E4%B8%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%28%E4%BF%97%E7%A7%B0%E7%9A%84%E4%BB%A3%E7%90%86ARP%29/">RFC925笔记,multi-lan下的地址解析(俗称的代理ARP)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-10-19T22:38:00+08:00" pubdate data-updated="true">Oct 19<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.10.19</p>


<p>》多网地址解析</p>


<p>》》主题<br/>
Explicit subnets<br/>
Transparent subnets（Extended ARP）</p>


<p>明确的（不隐藏的）子网，<br/>
透明的子网（扩展arp）</p>


<p>》》INTRODUCTION</p>


<p>    The problem of treating a set of local area networks (LANs) as one<br/>
    Internet network has generated some interest and concern.  It is<br/>
    inappropriate to give each LAN within an site a distinct Internet<br/>
    network number.  It is desirable to hide the details of the<br/>
    interconnections between the LANs within an site from people,<br/>
    gateways, and hosts outside the site.  The question arises on how to<br/>
    best do this, and even how to do it at all.  One proposal is to use<br/>
    &#8220;explicit subnets&#8221; [1].  The explicit subnet scheme is a call to<br/>
    recursively apply the mechanisms the Internet uses to manage networks<br/>
    to the problem of managing LANs within one network.  In this note I<br/>
    urge another approach: the use of &#8220;transparent subnets&#8221; supported by<br/>
    a multi-LAN extension of the Address Resolution Protocol [2].</p>


<p>将一组LAN当作一个Internet网络具有实用价值：<br/>
1.给予一个站点内的所有LAN一个唯一的网络地址是不合适的<br/>
2.需要将网络的连接细节隐藏起来（对人 ，对网关，对站外主机）</p>


<p>》》OVERVIEW</p>


<p>概要性地叙述了一下ARP协议的工作方式。</p>


<p>》》代理的方式</p>


<p>文档将用BOX来指代这种设备，<br/>
现在一般的router中都有实现。</p>


<p>       Case 1: If the mapping for the host is found in the cache for the<br/>
       LAN that the query came from, the BOX does not respond (letting<br/>
       the sought host respond for itself).</p>


<p>如果报文中的&lt;IA,HA&gt;在与之同子网的chache中，不处理</p>


<p>       Case 2: If the mapping for the host is found in the cache for a<br/>
       different LAN than the query came from, the BOX sends a reply<br/>
       giving its own HA on the LAN the query came from.  The BOX acts as<br/>
       an agent for the destination host.</p>


<p>如果报文中的&lt;IA,HA&gt;在与之不同子网的chache中，以自己的HA响应。</p>


<p>       Case 3: If the mapping is not found in any of the caches then, the<br/>
       BOX must try to find out the the address, and then respond as in<br/>
       case 1 or 2.</p>


<p>如果没有该地址对，则必须试法找到。</p>


<p>       In case 3, the BOX has to do some magic.</p>


<p>          The BOX keeps a search list of sought hosts.  Each entry<br/>
          includes the IA of the host sought, the interface the ARP was<br/>
          received on, and the source addresses of the original request.<br/>
          When case 3 occurs, the search list is checked.  If the sought<br/>
          host is already listed the search is terminated, if not the<br/>
          search is propagated.</p>


<p>维护一个SH表（sought hosts，被寻找过的主机）。<br/>
每个条目包含该主机的IA，ARP报文来自的接口，请求的源地址。<br/>
如果SH在表内了，查找过程终止，否则进一步搜索。</p>


<p>          To propagate the search, an entry is first made on the search<br/>
          list, then the BOX composes and sends an ARP packet on each of<br/>
          its interfaces except the interface the instigating ARP packet<br/>
          was received on.  If a reply is received, the information is<br/>
          entered into the appropriate cache, the entry is deleted from<br/>
          the search list and a response to the search instigating ARP is<br/>
          made as in case 1 or 2.  If no reply is received, give up and<br/>
          do nothing &#8211; no response is sent to the instigating host (the<br/>
          entry stays on the search list).</p>


<p>在除了收到 发起ARP REQUEST报文 之外的接口上，发送ARP REQUEST。<br/>
如果收到回复，将信息放进对应的chache，<br/>
从搜索表中删除该条目，按照case1或2的方法对收到的ARP REQUEST 响应。<br/>
如果没有收到回复，则什么也不做（搜索表中依然保持此条目）</p>


<p>（如果网络中有一台带这样功能的router，<br/>
则我们不断ARP REQUEST并不存在的地址，<br/>
可想而知，该router的搜索表会不断增长，直到爆掉）</p>


<p>    The entries in the caches and the search list must time out.</p>


<p>由于存在上面那个邪恶的想法，<br/>
需要使用超时来解决。</p>


<p>    For every ARP request that is received, the BOX must also put the<br/>
    sending host&#8217;s IA:HA address mapping into the cache for the LAN it<br/>
    was received on.</p>


<p>对于收到的所有ARP请求，router都应该进行记录<br/>
（这与host的处理不同，<br/>
host仅记录目的地址是自身的ARP报文中的源IA:HA对）</p>


<p>（可想而知，如果网络上主机很多的话，<br/>
router的负担会很大）</p>


<p>》》关于超时的细节</p>


<p>          First, the hosts try to get the address resolved using ARP.<br/>
          They may actually make several attempts before giving up if a<br/>
          host is not responding.  One must have an good estimate of the<br/>
          length of time that a host may keep trying.  Call this time T1.</p>


<p>主机可能会不断重试请求一个不存在的地址，<br/>
需要估计其保持尝试的时间T1.</p>


<p>          Second, there is the time that an entry stays on the search<br/>
          list, or the time between BOX generated ARPs to resolve these<br/>
          addresses.  Call this time T2.</p>


<p>             Note that this time (T2) must be greater than the sum of the<br/>
             T1s for the longest loop of LANs.</p>


<p>搜索表中的条目具有存在时间T2。<br/>
T2要比最长网络环情况下，所有T1的和要大。</p>


<p>          Third, there is the time that entries stay in the cache for<br/>
          each LAN.  Call this time T3.</p>


<p>          The relationship must be  T1 &lt; T2 &lt; T3.</p>


<p>映射条目在chache中存在的时间T3。<br/>
这三个时间的关系是T1 &lt; T2 &lt; T3。</p>


<p>             One suggestion is that T1 be less than one minute, T2 be ten<br/>
             minutes, and T3 be one hour.</p>


<p>建议T1短于1分钟，T2约10分钟，T3一个小时</p>


<p>          If the environment is very stable, making T3 longer will result<br/>
          in fewer searches (less overhead in ARP traffic).  If the<br/>
          environment is very dynamic making T3 shorter will result in<br/>
          more rapid adaptation to the changes.</p>


<p>如果网络环境稳定，让T3更长可以减小开销。<br/>
如果环境不稳定，减短T3可以更好地适应。</p>


<p>          Another possibility is to restart the timer on the cache<br/>
          entries each time they are referenced, and have a small value<br/>
          for T3.  This would result in entries that are frequently used<br/>
          staying in the cache, but infrequently used information being<br/>
          discarded quickly.  Unfortunately there is no necessary<br/>
          relationship between frequency of use and correctness.  This<br/>
          method could result in an out-of-date entry persisting in a<br/>
          cache for a very long time if ARP requests for that address<br/>
          mapping were received at just less than the time out period.</p>


<p>另外的一个可能性是在每次条目被引用（referenced）的时候，<br/>
刷新定时器，并且设置一个很小的T3值。<br/>
这样可能导致频繁应用的信息一直在表中，<br/>
而非频繁引用的信息很快超时。<br/>
如果一个条目被频繁引用但已经过期(out of date)，<br/>
则该方法导致该条目长期存在于ARP表中。</p>


<p>》》多response的取舍</p>


<p>       ARP, as currently defined, will take the most recent information<br/>
       as the best and most up-to-date.  In a complicated multi-LAN<br/>
       environment where there are loops in the connectivity it is likely<br/>
       that one will get two (or more) responses to an ARP request for a<br/>
       host on some other LAN.  It is probable that the first response<br/>
       will be from the BOX that is the most efficient path.</p>


<p>       The one change to the host implementation of ARP that is suggested<br/>
       here is to prevent later responses from replacing the mapping<br/>
       recorded from the first response.</p>


<p>认为收到的第一个arp包是来自最有效的路径上的router。</p>


<p>当一个host运行的是扩展arp时（即假设存在代理arp的情况），<br/>
会选择收到的第一个ARP RESPONSE 添加到自己的ARP表中。<br/>
这样就给攻击留下了可能性，<br/>
一旦先收到了错误的arp包，则会丢弃正确的响应。</p>


<p>》》潜在问题(potential problems)</p>


<p>1.错误的chache条目<br/>
2.不用arp的主机<br/>
3.不能广播的LAN<br/>
4.表的尺寸<br/>
5.无限传输环<br/>
6.广播</p>


<p>》》关于广播</p>


<p>1.This IP Network<br/>
即网络地址+全1的主机地址。<br/>
router要转发</p>


<p>2.This LAN Only<br/>
即 255.255.255.255 ，<br/>
router不转发</p>


<p>3.Another LAN Only<br/>
有人建议给每个网络一个特殊地址</p>


<p>》》DISCUSSION</p>


<p>扩展ARP的机制在于让普通的host不用知道自己身处一个multi-LAN的环境。</p>


<p>       If a host took the trouble to analyze its local cache of IA:AH<br/>
       address mappings it might discover that several of the IAs mapped<br/>
       to the same HA.  And if it took timing measurements it might<br/>
       discover that some hosts responded with less delay that others.<br/>
       And further, it might be able to find a correlation between these<br/>
       discoveries.  But few hosts would take the trouble.</p>


<p>一个host可能通过发现若干IA映射到了同一个HA，<br/>
或者发现不同host响应ARP REQUEST的速度不一致，<br/>
来发现自己在一个multi-LAN的环境。</p>


<p>       1. How does the host discover if the destination is in this LAN or<br/>
       some other LAN?<br/>
       2. How do the BOXes that connect LANs know which BOXes are the<br/>
       routes to which LANs?</p>


<p>对这两个问的回答都是，host和router不应该知道网络的拓扑。</p>


<p>》》关于协议的选用：<br/>
       For example: use ARP within the LAN and have the BOX send ARP<br/>
       replies and act as a agent (as in the extended ARP scheme), but<br/>
       use a BOX-to-BOX protocol to get the &#8220;which hosts are where&#8221;<br/>
       information into the BOXes (as in the explicit subnet scheme).</p>


<p>可以使用普通ARP，作为代理，<br/>
也可以使用BOX-to-BOX protocol，用来在router之间传递信息。</p>


<p>》》SUMMARY</p>


<p>    Please note that neither this note nor [1] proposes a specific<br/>
    routing procedure or BOX-to-BOX protocol.  This is because such a<br/>
    routing procedure is a very hard problem.  The plan proposed here<br/>
    will let us get started on using multi-LAN environments in a<br/>
    reasonable way.  If we later decide on a routing procedure to be used<br/>
    between the BOXes we can redo the BOXes without having to redo the<br/>
    hosts.</p>


<p>如果将来要在BOX之间运行路由过程，<br/>
则不用更改主机，仅用更改BOX即可。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/10/18/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%9D%BE%E5%BC%9B%28SubGradientMethod%29/">拉格朗日松弛(SubGradient Method)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-10-18T14:10:00+08:00" pubdate data-updated="true">Oct 18<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.10.18</p>


<p>数学规划中常用拉格朗日松弛法来分解问题。<br/>
前段时间，曾经尝试用了一下这个方法来解带约束的最短路。<br/>
由于老师的课件中仅仅是一个原理性的介绍，<br/>
没有具体的操作办法，所以一直不理解要怎么更新乘子（u）。</p>


<p>当时直接把u拿来二分了，<br/>
其效果类似一个种加权，<br/>
后来想了下，即使是二分，<br/>
也应该在对数尺上做，<br/>
否则乘子的绝对值不一样的时候精度不一样。</p>


<p>前几天去找了上学期最优化的老师。<br/>
专业人士就是不一样，<br/>
手头有不少人类进步的电梯（电子书）。</p>


<p>其中，这本<br/>
《DECOMPosition techniques in math programming1》<br/>
讲得比较详细，又有例子，容易看懂。</p>


<p>这里按照书中描述的原理作一个<br/>
用subgradient(SG)法更新乘子的试验。<br/>
查词典叫“次梯度”，<br/>
我不知道怎么翻译，<br/>
也不知道其数学定义，<br/>
反正按照书中所述地使用就行了。</p>


<p>问题和算法都描述在了代码的注释里了。</p>


<p><font color="#0000ff">程序：</font></p>


<p>% &gt;&gt;1.primal problem:<br/>
% minimize f(x,y) = x^2 + y^2<br/>
% subject to:<br/>
%      -x - y &lt;= -4 <br/>
%      x &gt;= 0 <br/>
%      y &gt;= 0 <br/>
% &gt;&gt;2.Lagrangian function is<br/>
% L(x,y,u) = x^2 + y^2 + u(-x - y + 4)<br/>
% subject to x &gt;= 0 ,y &gt;= 0<br/>
% &gt;&gt;3.subproblem of L<br/>
% phi1(u) = minimize L1(u) = x^2 - u * x + 2 * u , s.t. x&gt;=0<br/>
% phi2(u) = minimize L2(u) = y^2 - u * y + 2 * u , s.t. y&gt;=0<br/>
% &gt;&gt;4.solving subproblem<br/>
% xc = u / 2 <br/>
% yc = u / 2<br/>
% &gt;&gt;5.s vector = [-x - y + 4] , (here only 1 component)<br/>
% <br/>
% &gt;&gt;SG method for LR multiplier updating (algorithm)<br/>
% 1).set u0 , a , b , v = 1 ,<br/>
% 2).get xc , yc from decomposed problem<br/>
% 3).u(v+1) = u(v) + 1/(a+b*v) * (s / abs(s))<br/>
% 4).convergence checking <br/>
%      if stop condition meeted , x_star = xc , y_star = yc<br/>
%      else v = v + 1 , goto 2 ,</p>


<p>clear ;<br/>
clc ;<br/>
close all ;</p>


<p>a = 1 ;<br/>
b = 0.1 ;<br/>
v = 1 ;<br/>
u = 3 ;<br/>
V = 2000 ;</p>


<p>%iteration begin<br/>
while v &lt; V <br/>
     xc(v) = u(v) / 2 ;<br/>
     yc(v) = u(v) / 2 ; % see &gt;&gt;4<br/>
     f(v) = xc(v).^2 + yc(v).^2 ;<br/>
     L(v) = xc(v).^2 + yc(v).^2 + u(v)*(-xc(v) - yc(v) + 4) ;<br/>
     k(v) = 1 / (a + b * v) ;<br/>
     s(v) = [-xc(v) - yc(v) + 4] ; % see &gt;&gt;5<br/>
     u(v + 1) = u(v) + k(v) * ( s(v) / abs(s(v))) ;<br/>
     %no convergence checking here<br/>
     v = v + 1 ;<br/>
end<br/>
[u(1:end-1)&#8217; , xc&#8217; , yc&#8217; , f&#8217; , L&#8217;] <br/>
xc(end) , yc(end)</p>


<p><font color="#0000ff">输出：</font></p>


<p>ans =<br/>
     2.0025<br/>
ans =<br/>
     2.0025</p>


<p>理论计算的最优答案是（2,2）<br/>
相差不大，还行</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/10/16/UDP%2CIP%2CRIP%E7%9A%84%E9%B8%A1%E8%9B%8B%E9%97%AE%E9%A2%98/">UDP,IP,RIP的鸡蛋问题</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-10-16T11:18:00+08:00" pubdate data-updated="true">Oct 16<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.10.16</p>


<p>所谓鸡蛋问题，就是搞辩论的人常用的<br/>
“鸡生蛋还是蛋生鸡”</p>


<p>一个辩论的人没搞过这个问题，<br/>
就犹如在OJ上刷了几年题，<br/>
但是<font color="#ff0000">A+B</font>都空着一样。<br/>
（我在POJ上的A+B是空的。。。猥琐一笑。。）</p>


<p>现在来谈谈这几个协议，<br/>
以下各句描述应该都是成立的：</p>


<p><font color="#ff9900">1.UDP是建立在IP之上的<br/>
2.如果我们开始发UDP的包了，那下面的IP显然是通了<br/>
3.IP要解决路由选择问题，也就是这时两点间的路由已经解决了<br/>
4.IP解决路由要依靠各种路由选择协议，比如RIP<br/>
5.RIP的信息是封装在UDP里面发送的</font><br/><font color="#0000ff">（然后现在从又1开始读）</font></p>


<p>那么在一个仅用RIP作路由选择协议的网络里，<br/>
。。。？</p>


<p>由于这是一个环，所以看起来比鸡蛋问题要高级一点。<br/>
第一个人提出鸡蛋问题的时候很经典，<br/>
而后来者就大多沦于无聊的诡辩之中。</p>


<p>破解上面这个环只需要明确一些东西就行了：</p>


<p>1.直连的路由之间可以用各种方式去发现对方，<br/>
  并不涉及路由选择协议。<br/>
2.同一网络的两个路由端口之间属于直接交付<br/>
3.RIP是在相邻路由之间交换信息，不涉及选路</p>


<p>所以，回来看上面的5句话，<br/>
它们属于那种half-truth。<br/>
RIP建立在UDP上，UDP建立在IP上，<br/><font color="#ff0000">但RIP所发送的UDP包并不需要跨越网络</font>，<br/>
所以不涉及选路（路由）。</p>


<p>可见，这类鸡蛋问题都普遍存在漏洞。</p>


<p>反过来看鸡蛋问题，<br/>
也就是一个定义问题。<br/>
鸡蛋：一种叫“鸡”的东西生的蛋<br/>
鸡：从一种叫“鸡蛋”的东西孵出来的生物</p>


<p>两种定义，随便选一个丢一个，问题直接就解决了。</p>


<p>但是大部分人喜欢先作循环定义，<br/>
然后诡辩之，<br/>
属于舍本逐末之举。</p>


<p>想起大一的数学老师，<br/>
不断跟我们强调“定义”，<br/>
从定义里面才能发现数学的味道。<br/>
真是一个有思想的人啊。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/10/06/%E7%82%B9%E5%88%B0%E7%82%B9%E9%93%BE%E8%B7%AF%E7%9A%84%E4%B8%89%E7%A7%8DIP%E5%88%86%E9%85%8D%E6%8A%80%E6%9C%AF/">点到点链路的三种IP分配技术</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-10-06T22:05:00+08:00" pubdate data-updated="true">Oct 6<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.10.6<br/><br/>
》任务：总结点到点链路的三种IP分配技术的具体实现及其优缺点(参考RFC1812)<br/><font color="#0000ff"><br/>
》》先看前言</font><br/><br/>
In this, he stands squarely on the shoulders of those<br/>
who have gone before him, and depends largely on expert contributors<br/>
for text.  Any credit is theirs; the errors are his.<br/><br/>
老外很搞。。即使是写技术文档。<br/>
（所有的荣誉都是前辈的，所有的错误都是自己的）<br/><br/><font color="#0000ff">》》读下目录</font><br/><br/>
3.3.5 Point-to-Point Protocol - PPP &#8230;&#8230;&#8230;&#8230;&#8230;&#8230;..   35<br/>
估计在这一节里面<br/><br/>
5.3.7 Martian Address Filtering &#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;   96<br/>
这个名词很好玩，火星地址。。。<br/>
读了下正文，其实就是指的禁止在网络上传送的地址，<br/>
比如专用地址，回路地址127等等。<br/><br/><font color="#0000ff">》》浏览一下简介(introduction)</font><br/><br/>
This memo should be read in conjunction with the Requirements for<br/>
Internet Hosts RFCs ([INTRO:2] and [INTRO:3]).  Internet hosts and<br/>
routers must both be capable of originating IP datagrams and receiving<br/>
IP datagrams destined for them.  The major distinction between<br/>
Internet hosts and routers is that routers implement forwarding<br/>
algorithms, while Internet hosts do not require forwarding<br/>
capabilities.  Any Internet host acting as a router must adhere to the<br/>
requirements contained in this memo.<br/><br/>
指出Internet主机和路由都能够发包和收取目的地为他们自身的IP包。<br/>
基于这个定义（或requirement），一个路由器也应该具有IP地址。<br/>
（虽然按照常理来看，点到点链路只有唯一出口，不用考虑IP地址也应该转发）<br/><br/><font color="#0000ff">》》跳到3.3.5节</font><br/><br/>
》》》3.3.5.1 introduction<br/><br/>
It is critical that an implementor understand the semantics of the<br/>
option negotiation mechanism.  Options are a means for a local device<br/>
to indicate to a remote peer what the local device will accept from<br/>
the remote peer, not what it wishes to send.  It is up to the remote<br/>
peer to decide what is most convenient to send within the confines of<br/>
the set of options that the local device has stated that it can<br/>
accept.  Therefore it is perfectly acceptable and normal for a remote<br/>
peer to ACK all the options indicated in an LCP Configuration Request<br/>
(CR) even if the remote peer does not support any of those options.<br/>
Again, the options are simply a mechanism for either device to<br/>
indicate to its peer what it will accept, not necessarily what it<br/>
will send.<br/><br/>
本地提出option，远端决定最适合的选项。<br/>
最好情况下，远端会ACK所有的选项。<br/>
LCP配置选项仅仅是用来向对端指出可以接收的，<br/>
并非必要发送的。<br/><br/>
》》》3.3.5.2 Link Control Protocol (LCP) Options<br/><br/>
The PPP Link Control Protocol (LCP) offers a number of options that<br/>
may be negotiated.  These options include (among others) address and<br/>
control field compression, protocol field compression, asynchronous<br/>
character map, Maximum Receive Unit (MRU), Link Quality Monitoring<br/>
(LQM), magic number (for loopback detection), Password Authentication<br/>
Protocol (PAP), Challenge Handshake Authentication Protocol (CHAP),<br/>
and the 32-bit Frame Check Sequence (FCS).<br/><br/>
可能协商的选项：<br/>
地址，控制字段压缩，协议字段压缩，异步字符表，最大接收单元，<br/>
链路质量监测，magic number（。。。？），密码认证协议，<br/>
挑战握手认证协议，32bit的帧校验序列（FCS)<br/><br/>
（之后有各项的“讨论”和“实现”）<br/><br/>
》》》3.3.5.3 IP Control Protocol (IPCP) Options<br/><br/>
Routers operating at link speeds of 19,200 BPS or less SHOULD<br/>
implement and offer to perform Van Jacobson header compression.<br/>
Routers that implement VJ compression SHOULD implement an<br/>
administrative control enabling or disabling it.<br/><br/>
链路速度在19200BPS以下需要实现VJ头压缩策略，<br/>
实现VJ压缩策略的路由器需要同时实现可管理的“开启/禁止”开关。<br/><br/><font color="#0000ff">》》发现老师提示了阅读2.2.7节。于是跳过去</font><br/><br/>
Traditionally, each network interface on an IP host or router has its<br/>
own IP address.  This can cause inefficient use of the scarce IP<br/>
address space, since it forces allocation of an IP network prefix to<br/>
every point-to-point link.<br/><br/>
传统上，每个主机或者路由的每个接口都分有IP。<br/>
在每个P2P链路上也分配得有IP地址，<br/>
这样会浪费本来就很稀缺的IP地址资源。<br/><br/>
To solve this problem, a number of people have proposed and<br/>
implemented the concept of unnumbered point to point lines.  An<br/>
unnumbered point to point line does not have any network prefix<br/>
associated with it.  As a consequence, the network interfaces<br/>
connected to an unnumbered point to point line do not have IP<br/>
addresses.<br/><br/>
人们发明了无编号的P2P线路，<br/>
无编号P2P线路没有与之相关的网络前缀，<br/>
所以该线路上的网络接口没有IP地址。<br/><br/><br/>
Because the IP architecture has traditionally assumed that all<br/>
interfaces had IP addresses, these unnumbered interfaces cause some<br/>
interesting dilemmas.  For example, some IP options (e.g., Record<br/>
Route) specify that a router must insert the interface address into<br/>
the option, but an unnumbered interface has no IP address.  Even more<br/>
fundamental (as we shall see in chapter 5) is that routes contain the<br/>
IP address of the next hop router.  A router expects that this IP<br/>
address will be on an IP (sub)net to which the router is connected.<br/>
That assumption is of course violated if the only connection is an<br/>
unnumbered point to point line.<br/><br/>
由于IP架构假设所有的接口都有IP地址，导致了若干窘境。<br/>
如，一些IP选项要求路由器把接口地址插入其中，<br/>
但无编号的接口没有IP地址。<br/><br/>
更为基本的是，路由（信息）包含吓一跳路由的IP地址，<br/>
路由器期望这个地址是在其所直连的网路（子网）上面。<br/>
当仅有的连接为一条P2P链路的时候，<br/>
该假设被破坏掉了。<br/><br/>
To get around these difficulties, two schemes have been conceived.<br/>
The first scheme says that two routers connected by an unnumbered<br/>
point to point line are not really two routers at all, but rather two<br/>
half-routers that together make up a single virtual router.  The<br/>
unnumbered point to point line is essentially considered to be an<br/>
internal bus in the virtual router.  The two halves of the virtual<br/>
router must coordinate their activities in such a way that they act<br/>
exactly like a single router.<br/><br/>
方案一：<br/>
将P2P线路所连的两个路由器看作一个虚拟路由器。<br/>
无编号的P2P线路被当作虚拟路由器的内部总线。<br/>
虚拟路由器的两半需要协调其行为，<br/>
以便从外部看来像一个路由器。<br/><br/><br/>
This scheme fits in well with the IP architecture, but suffers from<br/>
two important drawbacks.  The first is that, although it handles the<br/>
common case of a single unnumbered point to point line, it is not<br/>
readily extensible to handle the case of a mesh of routers and<br/>
unnumbered point to point lines.  The second drawback is that the<br/>
interactions between the half routers are necessarily complex and are<br/>
not standardized, effectively precluding the connection of equipment<br/>
from different vendors using unnumbered point to point lines.<br/><br/>
该方案能很好地适应IP架构，但在两方面存在缺陷。<br/>
第一方面是，它虽然能很好地处理常规的单条P2P线路，<br/>
但并非能稳定地扩展到处理一个路由网络以及若干无编号P2P线路。<br/>
第二方面是，两个 半路由器 间的交互非常复杂，并且非标准化，<br/>
导致不同生产商提供的设备使用P2P线路连接受阻。<br/><br/><br/>
Because of these drawbacks, this memo has adopted an alternate<br/>
scheme, which has been invented multiple times but which is probably<br/>
originally attributable to Phil Karn.  In this scheme, a router that<br/>
has unnumbered point to point lines also has a special IP address,<br/>
called a router-id in this memo.  The router-id is one of the<br/>
router&#8217;s IP addresses (a router is required to have at least one IP<br/>
address).  This router-id is used as if it is the IP address of all<br/>
unnumbered interfaces.<br/><br/>
该备忘录采用一个变通的方法，<br/>
给无编号P2P线路上的路由分配一个特殊IP地址，<br/>
在该备忘录里面，被称为router-id。<br/>
router-id是路由器所具有的某个IP地址<br/>
（一个路由器至少要有一个IP地址）。<br/>
这个router-id被当作所有无编号接口的IP地址。<br/><br/><font color="#0000ff">》》搜索“unnumbered”关键词</font><br/><br/>
》》》4.2.2.2 Addresses in Options: RFC 791 Section 3.1<br/><br/>
Each unnumbered interface<br/>
MUST be associated with a particular router-id.  This association<br/>
MUST NOT change (even across reboots) without reconfiguration of the<br/>
router.<br/><br/>
每一个无编号的接口都要与一个独特的（唯一？）的router-id关联。<br/>
这个关联除非重新配置，否则即使重启也不应该改变。<br/><br/>
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;<br/>
差不多读了这些就知道个大概了。<br/><font color="#ff9900">1.直接给IP是一种方法<br/>
2.虚拟路由器，（不分配也是一种分配。。。具体情况与马哲老师讨论）<br/>
3.router-id（路由器的某个IP）</font><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/10/05/%E6%A0%BC%E5%BC%8F%E5%8C%96RFC%E6%96%87%E6%A1%A3/">格式化RFC文档</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-10-05T20:27:00+08:00" pubdate data-updated="true">Oct 5<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.10.5</p>


<p><font color="#0000ff">起因：</font></p>


<p>RFC文档的介绍：<a href="http://baike.baidu.com/view/6108.htm">http://baike.baidu.com/view/6108.htm</a><br/>
对于学习网络来说，是相当重要的资料。</p>


<p>可以在IETF的网站上下载：<br/><a href="http://www.ietf.org/rfc/rfcXXXX.txt">http://www.ietf.org/rfc/rfcXXXX.txt</a><br/>
XXXX换成编号对应的编号。</p>


<p>比较郁闷的是，文档是按照txt格式发布的，<br/>
而且文档很长，往往都有上百页，<br/>
随便打开一个，即可看到细细的滚动条。。。<br/>
浏览起来可谓不方便。</p>


<p>在网上搜了下，也有些做了这个的软件，<br/>
不过就这么个功能还要<font color="#ff0000">注册</font>，囧。<br/>
于是自己弄一个基本的，把txt转成html，<br/>
主要完成这些功能：<br/><font color="#ff9900">1.分页存为.htm文件<br/>
2.每页后面加上previous,next,return<br/>
    这几个功能，表示上一页，下一页，返回目录<br/>
3.识别为目录的条目，添加超链接到对应的.htm文件<br/>
4.将每页的头两行（页号行，rfc编号行）加色，主要是减缓视觉疲劳。。</font></p>


<p>实现上需要考虑的一点东西：<br/><font color="#ff9900">1.每页很标准的56行，这样可以简化分页工作<br/>
2.txt文档中的诸如空格，小于号等需要替换成html实体<br/>
3.生成目录页content.htm，其他的按照页码排为xxx.htm<br/>
4.将文章居中，但是又要保持段落本身的缩进，</font><br/>
     开始试着用&lt;center&gt;&lt;/center&gt;标签来做，<br/>
     组合了如&lt;p&gt;&lt;div&gt;&lt;span&gt;等等，没达到效果。<br/>
     最后是：<br/>
     &lt;table align=center&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;<br/>
     文字文字&lt;br&gt;<br/>
     文字文字&lt;br&gt;<br/>
     &lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;<br/>
     这样解决的。<br/>
     （非常感谢<a target="_blank" href="http://www.shallway.net/">shallway</a>同学）</p>


<p><font color="#0000ff">程序：</font></p>


<p>（<font color="#ff0000">为了简化程序，在当前目录下手工建立名为&#8221;rfc&#8221;的文件夹，否则无法使用</font>）</p>


<p>#include &lt;stdio.h&gt;<br/>
#include &lt;string.h&gt;</p>


<p>const int PAGE_LINE = 56 ;</p>


<p>#define TEXT_BEGIN &#8220;&lt;table align=center&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&#8221;<br/>
#define TEXT_END &#8220;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#8221;</p>


<p>const char single_char[] = {&#8217; &#8217; , &#8216;&lt;&#8217; , &#8216;&gt;&#8217; , &#8216;&amp;&#8217; , &#8216;&#34;&#8217; , &#8216;&#39;&#8217; } ;<br/>
const char *entity_name[] = {&#8220;&amp;#160;&#8221; , &#8220;&amp;#60;&#8221; , &#8220;&amp;#62;&#8221; , &#8220;&amp;#38;&#8221; , &#8220;&amp;#34;&#8221; , &#8220;&amp;#39;&#8221; } ;<br/>
const int entity_num = sizeof(single_char) ;<br/>
//conert between html entity and visual element<br/>
void convert(char *src , char *dst){<br/>
     int n , i ;<br/>
     while ( *src ){<br/>
         for ( i = 0 ; i &lt; entity_num ; i ++ ){<br/>
             if ( single_char[i] == *src ) break ;<br/>
         }<br/>
         if ( i == entity_num ){<br/>
             *dst = *src ;<br/>
             dst ++ ;<br/>
         }else{<br/>
             n = sprintf(dst , &#8220;%s&#8221; , entity_name[i]) ;<br/>
             dst += n ;<br/>
         }         <br/>
         src ++ ;<br/>
     }<br/>
     *dst = &#8216;\0&#8217; ;<br/>
}</p>


<p>//make a content with link to the pages<br/>
void make_link(char *s , FILE *fp){<br/>
     char *p = strstr(s , &#8220;&#8230;.&#8221;) ;<br/>
     if ( !p ) return ;<br/>
     char tmp1[1000] , tmp2[1000] ;<br/>
     int page ;<br/>
     sscanf(p , &#8220;%[^0123456789]%d&#8221; , tmp1 , &amp;page) ;<br/>
     convert(s , tmp1) ;<br/>
     sprintf(tmp2 , &#8220;&lt;a href=%d.htm&gt;%s&lt;/a&gt;&#8221; , page , tmp1) ;<br/>
     fprintf(fp , &#8220;%s&lt;br&gt;\n&#8221; , tmp2) ;<br/>
}</p>


<p>//add color to title<br/>
//just to avoid visual fatigue<br/>
void add_title_color(char *src , char *dst){<br/>
     sprintf(dst , &#8220;&lt;font color = red&gt;%s&lt;/font&gt;&#8221; , src) ;<br/>
}</p>


<p>int main(){<br/>
     freopen(&#8220;rfc.txt&#8221; , &#8220;r&#8221; , stdin) ;<br/>
     int i = 0 , file = 0 ;<br/>
     char buf[1000] ;<br/>
     char addr[500] ;<br/>
     char text[1000] ;</p>


<p>     //reopen file for each page <br/>
     freopen(&#8220;rfc&#92;0.htm&#8221; , &#8220;w&#8221; , stdout) ;<br/>
     printf(TEXT_BEGIN) ;</p>


<p>     //for the content<br/>
     FILE *fp = fopen(&#8220;rfc&#92;content.htm&#8221; , &#8220;w&#8221;) ;<br/>
     fprintf(fp , &#8220;&lt;p&gt;&lt;center&gt;&lt;font color = red size = 24&gt;content&lt;/font&gt;&lt;/center&gt;&lt;/p&gt;&lt;p&gt;&lt;center&gt;\n&#8221;) ;<br/>
     <br/>
     while ( gets(buf) ){<br/>
         i ++ ;<br/>
         if ( i == PAGE_LINE ) {<br/>
             int pre = file - 1 ;<br/>
             int next = file + 1 ;<br/>
             if ( pre &lt; 0 ) pre = 0 ;<br/>
             printf(&#8220;&lt;center&gt;&lt;a href=%d.htm&gt;【previous】&lt;/a&gt;&#8221;<br/>
                 &#8220;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&#8221;<br/>
                 &#8220;&lt;a href=%d.htm&gt;【next】&lt;/a&gt;&#8221;<br/>
                 &#8220;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&#8221;<br/>
                 &#8220;&lt;a href=content.htm&gt;【return】&lt;/a&gt;&lt;/center&gt;&#8221;, pre , next) ;<br/>
             i = 0 ;<br/>
             file ++ ;<br/>
             sprintf(addr , &#8220;rfc&#92;%d.htm&#8221; , file) ;<br/>
             printf(TEXT_END) ;<br/>
             freopen(addr , &#8220;w&#8221; , stdout) ;<br/>
             printf(TEXT_BEGIN) ;<br/>
         }<br/>
         if ( file &lt; 10 ) {<br/>
             //assume content appears only in the beginning <br/>
             //maybe 9 pages .<br/>
             make_link(buf , fp) ;<br/>
         }<br/>
         convert(buf , text) ;<br/>
         if ( i == 2 || i == 4 ){<br/>
             strcpy(buf , text) ;<br/>
             add_title_color(buf , text) ;<br/>
         }<br/>
         printf(&#8220;%s&lt;br&gt;&#8221; , text) ;<br/>
     }<br/>
     <br/>
     //end of pages<br/>
     printf(&#8220;&lt;center&gt;&lt;a href=%d.htm&gt;【previous】&lt;/a&gt;&#8221;<br/>
         &#8220;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&#8221;<br/>
         &#8220;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&#8221;<br/>
         &#8220;&lt;a href=content.htm&gt;【return】&lt;/a&gt;&lt;/center&gt;&#8221;<br/>
         TEXT_END , file - 1) ;</p>


<p>     //end of content<br/>
     fprintf(fp , &#8220;&lt;/center&gt;&lt;/p&gt;&#8221;) ;<br/>
     fclose(fp) ;<br/>
     return 0 ;<br/>
}</p>


<p><font color="#0000ff">后记：</font></p>


<p>现在仅仅实现一些基本的功能，<br/>
感觉有时间把这个做丰富还是相当有必要的，<br/>
毕竟以后可能有很多时间和RFC打交道。</p>


<p>暂时考虑到的功能：<br/><font color="#ff9900">1.为目录生成树状列表，转到任意页<br/>
2.搜索功能，关键词加亮<br/>
3.自动从IETF网站拉取任意编号的文档（只要存在）<br/>
4.更智能的格式化</font><br/>
     比如，下面这段话<br/>
     Every implementor is urged to read [INTRO:4] and<br/>
     应该为 [INTRO:4] 这样的加上超链接。<br/>
     又如，下面这个<br/>
     This document is an updated version of RFC 1716<br/>
     应该为 RFC 1716 加上链接到相关的文档。<br/><font color="#ff9900">5.书签功能<br/>
6.批注功能<br/>
7.更多的加色功能，主要用于缓解视觉疲劳</font></p>


<p> </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/10/04/%E6%8C%89CIDR%E6%96%B9%E5%BC%8F%E8%81%9A%E5%90%88%E7%9A%84%E4%B8%AD%E5%9B%BD%E8%B7%AF%E7%94%B1/">按CIDR方式聚合的中国路由</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-10-04T21:01:00+08:00" pubdate data-updated="true">Oct 4<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p> </p>


<p>(hplonline)2009.10.4</p>


<p><font color="#ff0000">（重要提示，UESTC.SCIE.NE.07的人如果无意搜到此页，<br/>
麻烦不要直接使用，或者你们注明出处）</font></p>


<p><font color="#0000ff">预处理：</font></p>


<p>首先，要找到数据，来自APNIC的ftp服务器：<br/><a href="http://ftp.apnic.net/stats/apnic/">http://ftp.apnic.net/stats/apnic/</a></p>


<p>这里面有按照各年记录的地址，<br/>
assigned-apnic-latest就是最新的。</p>


<p>既然是统计我们国家的，对数据进行一下预处理。<br/>
这个处理是很简单的，用excel就行了。<br/>
按照|分割数据导入，用自动筛选，国家一栏为CN的取出来就搞定。</p>


<p>然后手上就是规整的跟我们国家有关的数据，类似这样：</p>


<p>apnic|CN|ipv4|58.14.0.0|131072|20050224|allocated<br/>
apnic|CN|ipv4|58.16.0.0|65536|20050125|allocated<br/>
apnic|CN|ipv4|58.17.0.0|32768|20050201|allocated<br/>
apnic|CN|ipv4|58.17.128.0|32768|20050215|allocated<br/>
apnic|CN|ipv4|58.18.0.0|65536|20050301|allocated</p>


<p><font color="#0000ff">CIDR聚合方法：</font></p>


<p>上面的数据，主要关注的是4、5两栏。<br/>
58.14.0.0|131072<br/>
前面是分配得到的IP地址的起始，<br/>
后面是从该地址开始的地址个数。<br/>
个数全部是按照2的方幂给出的，<br/>
也就是说对该数字取2为底的对数，<br/>
就得到了主机号所占的位数。<br/>
32减之就得到了网络号的位数。<br/>
上面这些网段用这种算法可以看做：<br/>
58.14.0.0/15<br/>
58.16.0.0/16<br/>
58.17.0.0/17<br/>
58.17.128.0/17<br/>
58.18.0.0/16</p>


<p>要聚合的两条路由一定是相同的网络前缀长度L，<br/>
他们网络地址的前L-1位都相同，<br/>
第L位是一条为1，一条为0。<br/>
这样，我们就可以合并出一条新的网络前缀为L-1的路由，<br/>
其网络地址就是较小的那一个（第L位为0的那个）。</p>


<p>比如：<br/>
58.17.0.0/17<br/>
58.17.128.0/17<br/>
可以聚合为：<br/>
58.17.0.0/16</p>


<p>这个过程应该不断重复，直到没有可以合并的为止，<br/>
像上面这些网段，还可以继续合并。<br/>
58.16.0.0/16<br/>
58.17.0.0/16<br/>
==&gt;58.16.0.0/15</p>


<p><font color="#0000ff">程序：</font></p>


<p>由于数据文件中的有些列是不用的，<br/>
采用scanf的字符集合方法可以比较方便地找到&#8221;|&#8221;，<br/>
具体情况见：<a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/2c875ffb70e6201f6c22eb75.html">scanf的三点用法</a>。</p>


<p>IP地址按照点分十进制读入，<br/>
然后处理成一个unsigned long 型，<br/>
这样，在比较前缀的时候，<br/>
只需要与相关的网络掩码相与就行了。</p>


<p>比较戳瓢的是==的优先级比&amp;高，<br/>
忘打括号了，调了半天。。</p>


<p>#include &lt;stdio.h&gt;<br/>
#include &lt;list&gt;</p>


<p>using namespace std ;</p>


<p>typedef unsigned long ULONG ;<br/>
typedef unsigned char UCHAR ;</p>


<p>typedef struct addr_type{<br/>
     ULONG ip ;<br/>
     int suffix ;<br/>
}ADDR ;</p>


<p>list&lt;ADDR&gt; addrs[34] ;<br/>
ULONG mask[33] ;</p>


<p>void init_mask(){<br/>
     int i ;<br/>
     ULONG t = ~0 ;<br/>
     for ( i = 0 ; i &lt;= 32 ; i ++ ){<br/>
         mask[i] = ~t ;<br/>
         t &gt;&gt;= 1 ;<br/>
     }<br/>
}</p>


<p>int main()<br/>
{<br/>
     init_mask() ;<br/>
     ADDR tmp ;<br/>
     char buf[500] ;<br/>
     ULONG a[4] ;<br/>
     int hosts ;<br/>
     int origin_ip = 0 ;<br/>
     int new_ip = 0 ;</p>


<p>     freopen(&#8220;CN.txt&#8221; , &#8220;r&#8221; , stdin) ;<br/>
     freopen(&#8220;out.txt&#8221; , &#8220;w&#8221; , stdout) ;</p>


<p>     while (scanf(&#8220;%[^|]&#8221; , buf) == 1) {<br/>
         getchar() ;//puts(buf) ;<br/>
         scanf(&#8220;%[^|]&#8221; , buf) ;getchar() ;//puts(buf) ;<br/>
         scanf(&#8220;%[^|]&#8221; , buf) ;getchar() ;//puts(buf) ;<br/>
         scanf(&#8220;%[^|]&#8221; , buf) ;getchar() ;//puts(buf) ;<br/>
         sscanf(buf , &#8220;%d.%d.%d.%d&#8221; , a , a + 1 , a + 2 , a + 3) ;<br/>
         tmp.ip = ((a[0] * 256 + a[1]) * 256 + a[2]) * 256 + a[3] ;<br/>
         scanf(&#8220;%[^|]&#8221; , buf) ;getchar() ;//puts(buf) ;<br/>
         sscanf(buf , &#8220;%d&#8221; , &amp;hosts) ;<br/>
         tmp.suffix = 0 ;<br/>
         while ( hosts != 1 ){<br/>
             hosts &gt;&gt;= 1 ;<br/>
             tmp.suffix ++ ;<br/>
         }<br/>
         gets(buf) ;         <br/>
         addrs[tmp.suffix].push_back(tmp) ;<br/>
         origin_ip ++ ;<br/>
     }</p>


<p>     int i ;<br/>
     bool found ; <br/>
     for ( i = 1 ; i &lt;= 32 ; i ++ ){<br/>
         ULONG tmp_mask = mask[32 - i - 1] ;<br/>
         found = true ;<br/>
         while ( found ){<br/>
             found = false ;<br/>
             list&lt;ADDR&gt;::iterator it1,it2 ;<br/>
             for ( it1 = addrs[i].begin() ; it1 != addrs[i].end() ; it1 ++ ){<br/>
                 it2 = it1 ;<br/>
                 it2 ++ ;<br/>
                 for ( ; it2 != addrs[i].end() ; it2 ++ ){<br/>
                     if ( ((*it2).ip &amp; tmp_mask) == ((*it1).ip &amp; tmp_mask) ){<br/>
                         //== is prior to &amp; !!!<br/>
                         found = true ;<br/>
                         break ;<br/>
                     }<br/>
                 }<br/>
                 if ( found ) break ;<br/>
             }<br/>
             if ( found ){<br/>
                 tmp.ip = (*it1).ip &amp; tmp_mask ;<br/>
                 tmp.suffix = (*it1).suffix + 1 ;<br/>
                 addrs[i + 1].push_back(tmp) ;<br/>
                 addrs[i].erase(it1) ;<br/>
                 addrs[i].erase(it2) ;<br/>
             }<br/>
         }<br/>
     }<br/>
     for ( i = 0 ; i &lt; 32 ; i ++ ){<br/>
         list&lt;ADDR&gt;::iterator it ;<br/>
         for ( it = addrs[i].begin() ; it != addrs[i].end() ; it ++ ){<br/>
             printf(&#8220;%d.%d.%d.%d/%d\n&#8221; ,<br/>
                 UCHAR((*it).ip &gt;&gt; 24) , <br/>
                 UCHAR((*it).ip &gt;&gt; 16) , <br/>
                 UCHAR((*it).ip &gt;&gt; 8) , <br/>
                 UCHAR((*it).ip) , <br/>
                 32 - (*it).suffix) ;<br/>
             new_ip ++ ;<br/>
         }<br/>
     }<br/>
     printf(&#8220;%d,%d&#8221; , origin_ip , new_ip) ;<br/>
     return 0;<br/>
}</p>


<p>貌似是STL的原因，用debug要跑很久，<br/>
用release瞬间就出来了。。</p>


<p>具体的条目就不列出了，<br/>
对比一下聚合前后的路由数：<br/>
前：1634<br/>
后：860</p>


<p> </p>


<p> </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/10/02/%E5%9C%A8%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4%EF%BC%88VC6%29/">在栈上分配空间（VC6)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-10-02T19:55:00+08:00" pubdate data-updated="true">Oct 2<span>nd</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.10.2</p>


<p>有的时候，在某个函数里面要动态分配一段内存，<br/>
这段内存仅仅是作为这个函数处理所用的临时空间，<br/>
并不用在该函数之外的其他地方。</p>


<p>用new比malloc慢就不说了，<br/>
如果还想比malloc快一点，可以直接在栈上分配。</p>


<p>而栈上一般都是编译器放的局部变量。<br/>
因为在编译期间，可以计算得到该函数内部需要的空间，<br/>
进入该函数时，除了在栈上保护相关的寄存器外，<br/>
就是从esp当前的位置向下拉出一段距离，<br/>
供给局部变量使用，<br/>
并且局部变量的偏移位置是预先可以知道的。</p>


<p>由于C中没有直接提供对栈的操作，<br/>
只有使用内联汇编。<br/>
又由于不同环境的汇编不太一样，<br/>
加之不同编译器的栈使用策略可能也不一样。<br/>
以下的内容就选在环境VISTA.VC6.DEBUG下了。</p>


<p>定义了几个宏，好写起来方便一点。<br/>
顺便比较一下和用malloc分配的耗时。</p>


<p><font color="#0000ff">程序：</font></p>


<p>#include &lt;stdio.h&gt;<br/>
#include &lt;stdlib.h&gt;<br/>
#include &lt;time.h&gt;</p>


<p>const int N = 1024 ;<br/>
const int M = 100000 ;</p>


<p>//在需要内存分配的地方调用<br/>
//char *p ;<br/>
//StackAlloc(512) ;<br/>
//StackPtr(p) ;<br/>
#define StackAlloc(x) __asm sub esp , x ;<br/>
#define StackPtr(p) __asm mov p , esp ;</p>


<p>//在函数返回之前归还内存<br/>
//否则debug模式下会报错<br/>
#define StackFree(x) __asm add esp , x ;</p>


<p>void fun1(int n){<br/>
     char *p ;<br/>
     StackAlloc(n) ;<br/>
     StackPtr(p) ;<br/>
     //do something ;<br/>
     StackFree(n) ;<br/>
}</p>


<p>void fun2(int n){<br/>
     char *p ;<br/>
     p = (char*)malloc(n) ;<br/>
     //do something ;<br/>
     free(p) ;<br/>
}</p>


<p>int main(){<br/>
     int i ;<br/>
     int tmp ;</p>


<p>     __asm mov tmp , esp ;<br/>
     printf(&#8220;%d\n&#8221; , tmp) ;<br/>
     clock_t tt = 0 ;<br/>
     for ( i = 0 ; i &lt; M ; i ++ ){<br/>
         fun2(N) ;<br/>
     }<br/>
     __asm mov tmp , esp ;<br/>
     printf(&#8220;%d\n&#8221; , tmp) ;<br/>
     printf(&#8220;%d\n&#8221; , clock() - tt) ;</p>


<p>     return 0 ;<br/>
}</p>


<p>fun1:<br/>
1244912<br/>
1244912<br/>
3</p>


<p>fun2:<br/>
1244912<br/>
1244912<br/>
85</p>


<p>先打印出来的esp指针，<br/>
是为了说明堆栈是平衡的。。</p>


<p> </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/09/26/C%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%8F%90%E5%8D%87%E9%97%AE%E9%A2%98/">C中的原型提升问题</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-09-26T16:33:00+08:00" pubdate data-updated="true">Sep 26<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.9.26</p>


<p>很早看过K&amp;R风格和ANSI风格的函数声明及定义。<br/>
一直觉得是习惯问题，才发现这个跟原型提升很有关系。</p>


<p><font color="#0000ff">》原型提升：（32位）</font><br/>
char，short等在运算和传参的时候提升成int型的。<br/>
float提升成double型的。</p>


<p>这样做的最初目的无疑是简化编译器的设计，<br/>
但是在函数调用上确实存在一点问题。<br/>
下面的实验需要将相关函数的实现放在<font color="#ff0000">不同</font>的<font color="#ff0000">C</font>文件里面，<br/>
如果在同一个文件里面，编译器往往能掌握足够的信息，<br/>
也就看不出有什么问题了。</p>


<p><font color="#0000ff">》K&amp;R风格：</font></p>


<p>定义：<br/>
void show(f,i)<br/>
float f ;<br/>
int i ;<br/>
{<br/>
     printf(&#8220;%f,%d\n&#8221; , f , i) ;<br/>
}<br/>
声明：<br/>
void show() ;</p>


<p><font color="#0000ff">》ANSI风格：</font></p>


<p>定义：<br/>
void show(float f,int i)<br/>
{<br/>
     printf(&#8220;%f,%d\n&#8221; , f , i) ;<br/>
}<br/>
声明：<br/>
void show(float f , int i) ;</p>


<p><font color="#0000ff">》测试代码：</font></p>


<p>int main(){<br/>
     float f = 1.0 ;<br/>
     int i = 1 ;<br/>
     show(f , i) ;<br/>
     return 0 ;<br/>
}</p>


<p>用K&amp;R风格的声明及定义，<br/>
以及ANSI风格的声明及定义，<br/>
在策略上是匹配的，所以没有什么问题。<br/>
输出均为：<br/>
1.000000,1</p>


<p><font color="#0000ff">》K&amp;R风格定义+ANSI声明：</font></p>


<p>输出为：<br/>
0.000000,0</p>


<p>由于编译器看到的声明是<br/>
void show(float f , int i) ;<br/>
所以对于f变量不提升为double。</p>


<p>而在实现文件中<br/>
void show(f,i)<br/>
float f ;<br/>
int i ;<br/>
由于是K&amp;R风格的定义，<br/>
编译器会认为栈中先存放的是提升过的double型，<br/>
以及一个int型，总共12个字节。<br/>
默认的行为是，先取出前面的8个字节，<br/>
按照double转float的规则附给f。<br/>
紧接着的4个字节直接放到i变量里面。</p>


<p>由于中间的4个字节在调用端是push的1进去，<br/>
按照double数据的表示方法，<br/>
前面的8个字节会被看做一个指数负得很多的数，<br/>
所以输出的是0。</p>


<p>而打印出来的i为0，是因为这个时候栈上那几个字节为0，<br/>
这个值是不定的，根据栈的情况表现不同。</p>


<p><font color="#0000ff">》ANSI风格定义+K&amp;R声明：</font></p>


<p>输出为：<br/>
0.000000,1072693248</p>


<p>由于编译器看到的声明为：<br/>
void show() ;<br/>
这里没有提供任何类型方面的信息，<br/>
所以对f变量进行提升后才传入，<br/>
这个时候实际push到栈上的内容有12个字节。</p>


<p>而实现文件中<br/>
void show(float f,int i)<br/>
由于是ANSI风格的定义，<br/>
会认为低端4个字节就是float，<br/>
跟着的4个字节是int。</p>


<p>这样等于说把调用端传进来的double(1.0)拆成了两段。</p>


<p>由于double的0-51位表达的是尾数，<br/>
而尾数的表达是省略最前面的1的，<br/>
也就是后面这些位都是0了（表示1.0000000&#8230;.，二进制)<br/>
（具体参看将二进制实数正规化的资料）<br/>
这样一个全0的东西按照float来理解的话，就是0了。</p>


<p>而高四位的内容包含了原来double的符号位和指数和部分尾数。<br/>
指数的表达是偏移了2^10-1过后的，（double总共有11为为指数位）<br/>
再加上后面尾数位的20个0，<br/>
所以这个数字按照int的方式来观察，得到的是<br/>
(0 + 2^10-1) * 2^20 = 1072693248</p>


<p><font color="#0000ff">》总结</font></p>


<p>原型提升是件相当邪恶的事情，<br/>
不过只要保证声明和定义的一致，<br/>
就没有问题了。。</p>


<p>在这篇的实验中，其实还用到了printf的原型提升。</p>


<p>之前研究<a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/c0e3b9de2e24355fcdbf1afc.html">printf和scanf对浮点数的处理</a>时，<br/>
完全是从汇编的角度看出来的这么个结论。<br/>
结果后来发现，10多年前的N本书都讲过这个问题。。。</p>


<p>而同样的东西，从不同的角度来理解一下，确实很有意义。</p>


<p>另外，<br/>
看书比实验学得确实要快，<br/>
但实验得来的结论往往更牢固。</p>


<p>不知道谭老师的书啥时候才能把这些东西加进去呢，<br/>
要不地球人都以为仅仅是写法风格上的问题。。<br/>
还得蒙多少小朋友在鼓里啊。。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/09/24/%E5%B0%8F%E6%97%B6%E5%80%99%E7%8E%A9%E8%AE%A1%E7%AE%97%E5%99%A8%E7%9A%84%E6%9E%81%E9%99%90/">小时候玩计算器的极限</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-09-24T16:38:00+08:00" pubdate data-updated="true">Sep 24<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.9.24<br/><br/>
我想很多人都有过这样的经历。<br/>
上数学课上得很无聊，<br/>
正好手边有个计算器可以玩，<br/>
于是就重复地做一个操作。<br/><br/>
而我当时的计算器很人性化，<br/>
直接按“=”号，就可以重复上一步的操作。<br/>
比如，先来个1+1，<br/>
然后就一路“=”号地按起走，<br/>
显示的结果就是2、3、4、5、。。。<br/><br/>
当然，像简单的四则运算也没啥有趣的。<br/>
倒是按那些当时根本不知道含义的符号，<br/>
却发现了几个极限。先说两个简单的。<br/><br/><font color="#0000ff">1.开根号<br/><br/></font>当时觉得这个键特牛X，<br/>
因为随便输入一个正数，<br/>
然后不断地按它，<br/>
发现最后总能显示为1。<br/><br/>
于是当年给根号下了一个定义：<br/><font color="#ff0000">这是让一个正数最终变成1的运算。</font><br/>
而且它很智能化。。<br/>
比1大的它就不断减小，<br/>
比1小的它就不断增大。。<br/><br/>
解释这个问题其实很简单，按一次根号为：<br/>
x<sup>(1/2)<br/></sup>
按n次根号就是：<br/>
x<sup>(1/(2<sup>n))<br/></sup></sup>
按无穷多次根号就成了：<br/>
x<sup>0=1<br/><br/></sup>
由于计算器的精度问题，<br/>
不到无穷次，就可以按到0了。<br/><br/><font color="#0000ff">2.sin</font><br/><br/>
对这个运算，当年也同样很搞笑地归纳过：<br/><font color="#ff0000">这是一个让数变成0的运算</font><br/><br/>
拿正数来说，<br/>
sinx&lt;x在各种地方都证过了。<br/>
于是你每按一次都得减小一点。<br/>
而sinx=x只有0这里有根。<br/>
自然只有按到这个时候才会停止。。<br/><br/><font color="#0000ff">3.cos</font><br/><br/>
相比前面的两个，cos的结论就不那么显然了。<br/>
而且也是直到最近听讲座的时候，<br/>
看到老师讲了道题才反应过来。<br/><br/>
随便从一个数出发，不断地做cos的运算，<br/>
以0.5为例，如图：<br/><br/><span><img width="393" height="294" border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/a5658654d0aecf333b293532.jpg"/></span><br/>
其实可以发现，最后总会到达某个数字。<br/>
不过这个数字相比0和1而言，就没有任何特殊性了。<br/>
（0是加法的证同元素，1是乘法的证同元素。）<br/><br/>
在MATLAB里面可以算得，这个数字大约是：<br/><font color="#ff0000">.73908513321516064165531208767387</font><br/><br/>
它是cosx=x的根。（按到最后数字不变，所以相等）<br/><br/>
我们这个操作相当于是coscoscoscos&#8230;.cosx，<br/>
本质上是个极限，如果极限存在的话，<br/>
就可以用cosx=x的公式来计算。<br/><br/>
所以，比较重要的一步是得证明他存在。<br/>
不好弄公式，就如图了。<br/><span><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/6d3387102af6062d203f2e51.jpg"/></span><br/><p class="MsoNormal"><span>u<sub>1</sub></span><span>是定值，所以右端逼近</span><span>0</span><span>。</span></p></p>

<p class="MsoNormal"><span>不仅证明了</span><span>u<sub>n+1</sub></span><span>是有极限的，而且极限是</span><span>a</span><span>。</span></p>


<br/>


<p>这个证明里面的放缩实在是一个经验性的东西。<br/>
亏得老师经常做这种题啊，我反正是想不到的。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/backup-hplonline/blog/page/11/">&larr; Older</a>
    
    <a href="/backup-hplonline/blog/archives">Blog Archives</a>
    
    <a class="next" href="/backup-hplonline/blog/page/9/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/backup-hplonline/blog/2013/05/04/test/">Test</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/04/09/%E5%86%8D%E8%B0%88stl%E7%9A%84rotate/">再谈stl的rotate</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%BA%8C%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、二）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%89%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、三）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%80%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、一）</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - hplonline -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
