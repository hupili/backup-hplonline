
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>hplonline</title>
  <meta name="author" content="hplonline">

  
  <meta name="description" content="(hplonline)2009.8.13Boson NetSim：
相当好用的一个软件。
据说仿真从CCNA到CCNP的实验都足够了。
软件带有图形界面的拓扑设计，比较方便。
仿真的时候，所有的运行过程都在这个软件内，
所以失真度还是比较大，
不过仿真二字的言下之意就是有失真。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hupili.github.io/backup-hplonline/blog/page/12">
  <link href="/backup-hplonline/favicon.png" rel="icon">
  <link href="/backup-hplonline/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/backup-hplonline/atom.xml" rel="alternate" title="hplonline" type="application/atom+xml">
  <script src="/backup-hplonline/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/backup-hplonline/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/backup-hplonline/">hplonline</a></h1>
  
    <h2>backup from 2006 to 2012 (original hi.baidu.com/hplonline/)</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/backup-hplonline/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hupili.github.io/backup-hplonline" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/backup-hplonline/">Blog</a></li>
  <li><a href="/backup-hplonline/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/08/13/BosonNetSim%E8%BD%AF%E4%BB%B6%EF%BC%88%E9%99%84StandAloneLab%E7%AC%94%E8%AE%B0%EF%BC%89/">Boson NetSim软件（附Stand Alone Lab笔记）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-08-13T19:26:00+08:00" pubdate data-updated="true">Aug 13<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.8.13<br/><br/><font color="#0000ff">Boson NetSim：</font><br/><br/>
相当好用的一个软件。<br/>
据说仿真从CCNA到CCNP的实验都足够了。<br/><br/><span><img class="blogimg" border="0" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/28eb2b3f38fe96c556e72360.jpg"/></span><br/><br/><br/>
软件带有图形界面的拓扑设计，比较方便。<br/>
仿真的时候，所有的运行过程都在这个软件内，<br/>
所以失真度还是比较大，<br/>
不过仿真二字的言下之意就是有失真。<br/><br/>
值得一提的是这个lab navigator，<br/>
按照难度分成了若干类。<br/><br/>
之前拿这个软件的时候，<br/>
同学给的包里顺带捎了一份国人做的入门教程。<br/>
拿到当天也就试了下，<br/>
不过除了照这一阵乱敲之外，<br/>
硬是没有懂起啥东西。<br/><br/>
而这个软件自带的lab view相当不错，<br/>
有不长不短的解释，<br/>
命令也很详细，不像国人的资料，<br/>
老是有很多缩写，<br/>
还得自己输进去来看全称。<br/><br/>
把里面的Stand Alone Labs做完，<br/>
就大致知道了交换机和路由的基本玩法，<br/>
然后可以适时进阶，或者找点更专业，<br/>
更逼真的仿真软件来玩玩。<br/>
或者这个时候，再看看一些市面流行的实验，<br/>
基本也能看懂。<br/><br/>
这几天把入门级的lab都做完了，<br/>
发现以前用的tp-link之类的路由器纯属家用型玩具。<br/>
cisco的货果然好玩，内容非常丰富。<br/>
要是有实物就更好玩了。<br/><br/><font color="#0000ff">Stand Alone Lab笔记：</font><br/><br/>
（仅仅是为了玩玩设备，并非为考试准备，<br/>
所以是在没有相关理论基础的情况下做的，<br/>
有的地方可能看起来很可笑<img src="http://img.baidu.com/hi/jx/j_0015.gif"/>）<br/><br/>
1.<br/>
配置好端口后，可以先ping一下自身该端口的地址，<br/>
确定该端口是否通畅。<br/>
或者show interfaces xxx yyy<br/><br/>
2.ppp+chap<br/><br/>
enable password<br/>
username ??? password ???<br/>
ppp authentication chap<br/>
encapsulation ppp<br/><br/>
当出现A端可以ping通自身，而B端连自身都无法ping通的时候。<br/>
在B端show int se0可以看到：<br/>
Serial0 is up, line protocol is down<br/>
表示se0已经被打开，但是没有得到对方的认证。<br/><br/>
这个时候试着在A端重设密码：<br/>
enable password ???<br/><br/>
或者在B端重设用户名+密码：<br/>
username xxx password yyy <br/><br/>
3.reload命令<br/>
感觉貌似有问题，<br/>
在配置过frame-relay的dlci之后，<br/>
reload并不清除。<br/>
而在之后的地方又没有找到删除该号的方法。<br/>
可能是仿真系统的问题。<br/><br/>
4.<br/>
show ip int e0<br/>
可以看到access-list有关的信息。<br/>
形如：<br/>
Outgoing access list is not set<br/>
Inbound  access list is not set<br/><br/>
show int e0<br/>
看不到<br/><br/>
5.<br/>
wildcar mask<br/>
通配符的掩码<br/>
为1的部分表示用来支持通配的位。<br/>
比如：<br/>
permit tcp 24.17.2.16 0.0.0.15 any eq telnet log<br/>
即是把24.17.2.16子网来的telnet包都放行。<br/>
这个通配符可以视作是子网掩码取反<br/>
如果通配符为0.0.0.0，即是要完全匹配地址，<br/>
他和host关键字是一个意思。<br/><br/>
6.访问控制表<br/>
在conf t状态下：<br/>
access-list创建的是无名字的表<br/>
ip access-list extended xxxxx创建的是有名字的表<br/><br/>
7.<br/>
access list 的最后有个隐含的阻止一切数据包的条目<br/><br/>
8.<br/>
switch 的 interfaces 命令后面，<br/>
可以跟vlan配置关于vlan的ip地址，<br/>
也可以跟range指定一个范围：<br/>
int range fa0/2-5<br/><br/>
但是这个模拟系统中？没有提示。<br/>
不知道是设备本身的问题，还是模拟系统的问题。<br/><br/>
9.<br/>
(switch)<br/>
在#提示下，可以vlan database进入vlan的配置。<br/>
在#(config)提示下，直接vlan也可以<br/><br/>
10.<br/>
貌似不同型号的交换机在端口配置的地方区别比较大。<br/>
高端型号有switchport项，里面可以配置若干内容。<br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/08/11/LCA-tarjan%28POJ1470%29/">LCA-tarjan(POJ1470)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-08-11T15:57:00+08:00" pubdate data-updated="true">Aug 11<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.8.11<br/><br/>
LCA(Lowest Common Ancestor)。<br/>
可以转化为RMQ问题，即可在线计算（边读入询问边给出解答）。<br/>
这里试下tarjan，只能离线计算（读入所有询问后，一起解答）。<br/><br/>
去年的这个时候就听说了这个算法，<br/>
看了一些资料，感觉跟讲绕口令似的，<br/>
有些还有点小问题，实在是没看懂。<br/>
今天又来试下，再刷一道题，感觉心安理得了。<br/><br/><font color="#0000ff">tarjan：</font><br/><br/>
tarjan的主干是一个<font color="#ff0000">dfs</font>的过程。<br/>
用树的遍历来看，属于<font color="#ff0000">后根遍历</font>。<br/>
精华在于，<font color="#ff0000">先读入所有的query，然后一次性把相关的都处理掉</font>。<br/><br/>
维护一个并查集，集合的代表元素是该集合内所有节点的共同的根，<br/>
并且这个根有个性质，是“当前”离整个树的根最远。<br/><br/>
给每个节点一个标记done[u]，表示该节点是否已经完成。<br/>
完成的意义为，该节点孩子都处理完了，<br/>
本身相关的query也处理完了，从dfs过程返回上一层。<br/><br/>
每从一个孩子返回的时候，把他所在的集合并到他的父亲上面去。<br/><br/>
对于节点u。处理所有有关的询问(u,v)，分四种情况：<br/><br/>
1.如果v是u的子孙，那么这个时候v已经处理完成了。<br/>
而u就是LCA(u,v),并且由于v已经并到了u的集合中。<br/>
find_set(v) == u。<br/><br/>
2.如果u是v的子孙，因为有了第一条处理，<br/>
可以在询问(v,u)得到解答。<br/>
于是拆除这个询问，添加一个(v,u)。<br/>
这个时候显然的done[v] = false 。<br/><br/>
3.v和u没有直系的关系，v已经被处理完成了。<br/>
根据dfs的顺序来看，<br/>
v到LCA(u，v）的所有所有点都被并在了LCA(u，v）的集合里面。<br/>
并且由于刚处理到u，所以u是没有被完成的。<br/>
自然LCA(u，v）不可能被处理完成。<br/>
所以他还没有被并到更底层的根上面去。<br/>
于是这个时候find_set(v) == LCA(u，v）。<br/><br/>
4.v和u没有直系的关系，v还没有被处理。<br/>
因为有了第3条的处理，<br/>
直接把这个询问拆除，添加询问(v,u)即可。<br/>
这样在处理v的时候，可以解答这个询问。<br/><br/>
仔细看来，3、4条的叙述方式可以用来包含1、2条的。<br/><br/>
写出来是这样的：<br/><br/><p class="MsoNormal"><font color="#ff9900"><span>init_tarjan</span></font></p></p>

<p class="MsoNormal"><font color="#ff9900"><span><span>       </span>done[1..n] = false</span></font></p>


<p class="MsoNormal"><font color="#ff9900"><span><span>       </span>f[1..n] = 0</span></font></p>


<p class="MsoNormal"><font color="#ff9900"><span>end</span></font></p>


<p class="MsoNormal"><font color="#ff9900"><span> </span></font></p>


<p class="MsoNormal"><font color="#ff9900"><span>tarjan(u)</span></font></p>


<p class="MsoNormal"><font color="#ff9900"><span> </span></font></p>


<p class="MsoNormal"><font color="#ff9900"><span><span>       </span>for each child v of u do </span></font></p>


<p class="MsoNormal"><font color="#ff9900"><span><span>              </span>tarjan(v)</span></font></p>


<p class="MsoNormal"><font color="#ff9900"><span><span>              </span>f[v] = u </span></font></p>


<p class="MsoNormal"><font color="#ff9900"><span><span>       </span>end</span></font></p>


<p class="MsoNormal"><font color="#ff9900"><span><span>       </span></span></font></p>


<p class="MsoNormal"><font color="#ff9900"><span><span>       </span>for each query (u,v) of u do</span></font></p>


<p class="MsoNormal"><font color="#ff9900"><span><span>              </span>if done[v] then</span></font></p>


<p class="MsoNormal"><font color="#ff9900"><span><span>                     </span>ancestor[u,v] = find_set(v)</span></font></p>


<p class="MsoNormal"><font color="#ff9900"><span><span>              </span>else</span></font></p>


<p class="MsoNormal"><font color="#ff9900"><span><span>                     </span>addquery(v,u)</span></font></p>


<p class="MsoNormal"><font color="#ff9900"><span><span>              </span>end</span></font></p>


<p class="MsoNormal"><font color="#ff9900"><span><span>       </span>end</span></font></p>


<p class="MsoNormal"><font color="#ff9900"><span><span>       </span></span></font></p>


<p class="MsoNormal"><font color="#ff9900"><span><span>       </span>done[u] = true</span></font></p>


<p class="MsoNormal"><font color="#ff9900"><span> </span></font></p>


<p class="MsoNormal"><font color="#ff9900"><span>end</span></font></p>


<br/><br/>


<p>算法结构就是这样，但是刚接触到的时候，<br/>
肯定会在编码上存在诸多疑惑。<br/>
这个只有拿到一个具体的题来，刷掉之就知道怎么回事了。<br/><br/><font color="#0000ff">POJ1470：</font><br/><br/>
这道题在读入上确实制造了不少麻烦，<br/>
但刷过一定数量的水题后就有能力很迅速地把他们处理掉。<br/><br/>
题目描述也很露骨，直接可以看出来该用啥算法。<br/><br/>
剩下的就是编码的问题。<br/>
空间给的并不多，而且没有指出最多的询问有多少。<br/>
所以只有用链表，而为了保证高效，<br/>
得用静态分配空间的链表的写法，把空间分够就行。<br/><br/>
首先，树的结构用邻接链表来存。<br/>
因为要完成的是快速取得孩子的功能，又要省空间。<br/><br/>
对于询问(u,v)也拿另一个临街链表来存，<br/>
把v直接放到u的邻接链表里面。<br/>
因为要完成的是迅速取得“与u相关的询问”这一操作。<br/><br/>
玩过这种写法的同学一下就搞出来了，<br/>
长期用malloc或者new的同学，得花点时间体会一下。<br/>
确实可以对效率达到很大的改进。<br/><br/>
代码：<br/><br/><p class="MsoNormal"><span>#include &lt;stdio.h&gt;</span></p></p>

<p class="MsoNormal"><span>#include &lt;string.h&gt;</span></p>


<p class="MsoNormal"><span> </span></p>


<p class="MsoNormal"><span>const int MAXN = 910 ;</span></p>


<p class="MsoNormal"><span>const int MAXQ = 8000000 ;</span></p>


<p class="MsoNormal"><span> </span></p>


<p class="MsoNormal"><span>typedef struct list_type{</span></p>


<p class="MsoNormal"><span><span>       </span>int v ;</span></p>


<p class="MsoNormal"><span><span>       </span>struct list_type *next ;</span></p>


<p class="MsoNormal"><span>}LIST ;</span></p>


<p class="MsoNormal"><span> </span></p>


<p class="MsoNormal"><span>LIST space[MAXQ] , *spacehead ;</span></p>


<p class="MsoNormal"><span>LIST *children[MAXN] ;</span></p>


<p class="MsoNormal"><span> </span></p>


<p class="MsoNormal"><span>LIST *query[MAXN] ;</span></p>


<p class="MsoNormal"><span> </span></p>


<p class="MsoNormal"><span>int n ;</span></p>


<p class="MsoNormal"><span>int f[MAXN] ;</span></p>


<p class="MsoNormal"><span>int times[MAXN] ;</span></p>


<p class="MsoNormal"><span>bool done[MAXN] ;</span></p>


<p class="MsoNormal"><span>int root ;</span></p>


<p class="MsoNormal"><span> </span></p>


<p class="MsoNormal"><span>void init(){</span></p>


<p class="MsoNormal"><span><span>       </span>spacehead = space ;</span></p>


<p class="MsoNormal"><span><span>       </span>memset(children , NULL , sizeof(children)) ;</span></p>


<p class="MsoNormal"><span><span>       </span>memset(query , NULL , sizeof(query)) ;</span></p>


<p class="MsoNormal"><span><span>       </span>memset(f , 0 , sizeof(f)) ;</span></p>


<p class="MsoNormal"><span><span>       </span>memset(times , 0 , sizeof(times)) ;</span></p>


<p class="MsoNormal"><span><span>       </span>memset(done , false , sizeof(done)) ;</span></p>


<p class="MsoNormal"><span>}</span></p>


<p class="MsoNormal"><span> </span></p>


<p class="MsoNormal"><span>int find_set(int x){</span></p>


<p class="MsoNormal"><span><span>       </span></span><span>int fa = x ;</span></p>


<p class="MsoNormal"><span><span>       </span>int t ;</span></p>


<p class="MsoNormal"><span><span>       </span></span><span>while ( f[fa] != fa ){</span></p>


<p class="MsoNormal"><span><span>              </span>fa = f[fa] ;</span></p>


<p class="MsoNormal"><span><span>       </span>}</span></p>


<p class="MsoNormal"><span><span>       </span>while ( x != fa ){</span></p>


<p class="MsoNormal"><span><span>              </span>t = f[x] ;</span></p>


<p class="MsoNormal"><span><span>              </span>f[x] = fa ;</span></p>


<p class="MsoNormal"><span><span>              </span></span><span>x = t ;</span></p>


<p class="MsoNormal"><span><span>       </span>}</span></p>


<p class="MsoNormal"><span><span>       </span>return fa ;</span></p>


<p class="MsoNormal"><span>}</span></p>


<p class="MsoNormal"><span> </span></p>


<p class="MsoNormal"><span>void union_set(int a , int b){</span></p>


<p class="MsoNormal"><span><span>       </span>a = find_set(a) ;</span></p>


<p class="MsoNormal"><span><span>       </span>b = find_set(b) ;</span></p>


<p class="MsoNormal"><span><span>       </span>if ( a != b ) f[b] = a ;</span></p>


<p class="MsoNormal"><span>}</span></p>


<p class="MsoNormal"><span> </span></p>


<p class="MsoNormal"><span>void ignore(char ch){</span></p>


<p class="MsoNormal"><span><span>       </span>while ( (getchar() != ch)) ;</span></p>


<p class="MsoNormal"><span>}</span></p>


<p class="MsoNormal"><span> </span></p>


<p class="MsoNormal"><span>void addnode(LIST* l[] , int u , int v){</span></p>


<p class="MsoNormal"><span><span>       </span>spacehead-&gt;v = v ;</span></p>


<p class="MsoNormal"><span><span>       </span>spacehead-&gt;next = l[u] ;</span></p>


<p class="MsoNormal"><span><span>       </span>l[u] = spacehead ;</span></p>


<p class="MsoNormal"><span><span>       </span>spacehead ++ ;</span></p>


<p class="MsoNormal"><span>}</span></p>


<p class="MsoNormal"><span> </span></p>


<p class="MsoNormal"><span>void input_tree(){</span></p>


<p class="MsoNormal"><span><span>       </span></span><span>int i , j , u , v , m ;</span></p>


<p class="MsoNormal"><span><span>       </span>bool c[MAXN] ;</span></p>


<p class="MsoNormal"><span><span>       </span></span><span>memset(c , false , sizeof(c)) ;</span></p>


<p class="MsoNormal"><span><span>       </span></span><span>for ( i = 1 ; i &lt;= n ; i ++ ){</span></p>


<p class="MsoNormal"><span><span>              </span>scanf(&#8220;%d&#8221; , &amp;u) ;</span></p>


<p class="MsoNormal"><span><span>              </span>ignore(&#8216;:&#8217;) ;</span></p>


<p class="MsoNormal"><span><span>              </span>ignore(&#8216;(&#8216;) ;</span></p>


<p class="MsoNormal"><span><span>              </span>scanf(&#8220;%d&#8221; , &amp;m) ;</span></p>


<p class="MsoNormal"><span><span>              </span></span><span>ignore(&#8216;)&#8217;) ;</span></p>


<p class="MsoNormal"><span><span>              </span>for ( j = 0 ; j &lt; m ; j ++ ){</span></p>


<p class="MsoNormal"><span><span>                     </span>scanf(&#8220;%d&#8221; , &amp;v) ;</span></p>


<p class="MsoNormal"><span><span>                     </span>addnode(children , u , v) ;</span></p>


<p class="MsoNormal"><span><span>                     </span>c[v] = true ;</span></p>


<p class="MsoNormal"><span><span>              </span>}</span></p>


<p class="MsoNormal"><span><span>       </span>}</span></p>


<p class="MsoNormal"><span><span>       </span>for ( i = 1 ; i &lt;= n ; i ++ ){</span></p>


<p class="MsoNormal"><span><span>              </span>if ( !c[i] ) {</span></p>


<p class="MsoNormal"><span><span>                     </span>root = i ;</span></p>


<p class="MsoNormal"><span><span>                     </span>break ;</span></p>


<p class="MsoNormal"><span><span>              </span>}</span></p>


<p class="MsoNormal"><span><span>       </span>}</span></p>


<p class="MsoNormal"><span>}</span></p>


<p class="MsoNormal"><span> </span></p>


<p class="MsoNormal"><span>void input_query(){</span></p>


<p class="MsoNormal"><span><span>       </span></span><span>int i , m , u , v ;</span></p>


<p class="MsoNormal"><span><span>       </span>scanf(&#8220;%d&#8221; , &amp;m) ;</span></p>


<p class="MsoNormal"><span><span>       </span>for ( i = 0 ; i &lt; m ; i ++ ){</span></p>


<p class="MsoNormal"><span><span>              </span>ignore(&#8216;(&#8216;) ;</span></p>


<p class="MsoNormal"><span><span>              </span>scanf(&#8220;%d%d&#8221; , &amp;u , &amp;v) ;</span></p>


<p class="MsoNormal"><span><span>              </span></span><span>ignore(&#8216;)&#8217;) ;</span></p>


<p class="MsoNormal"><span><span>              </span>addnode(query , u , v) ;</span></p>


<p class="MsoNormal"><span><span>       </span>}</span></p>


<p class="MsoNormal"><span>}</span></p>


<p class="MsoNormal"><span> </span></p>


<p class="MsoNormal"><span style="color: red;">void tarjan(int u){</span></p>


<p class="MsoNormal"><span style="color: red;"><span>       </span></span><span style="color: red;">f[u] = u ;</span></p>


<p class="MsoNormal"><span style="color: red;"><span>       </span>LIST *p = children[u] ;</span></p>


<p class="MsoNormal"><span style="color: red;"><span>       </span></span><span style="color: red;">while ( p ){</span></p>


<p class="MsoNormal"><span style="color: red;"><span>              </span>tarjan(p-&gt;v) ;</span></p>


<p class="MsoNormal"><span style="color: red;"><span>              </span></span><span style="color: red;">f[p-&gt;v] = u ;</span></p>


<p class="MsoNormal"><span style="color: red;"><span>              </span>p = p-&gt;next ;<span>         </span></span></p>


<p class="MsoNormal"><span style="color: red;"><span>       </span>}</span></p>


<p class="MsoNormal"><span style="color: red;"><span>       </span>p = query[u] ;</span></p>


<p class="MsoNormal"><span style="color: red;"><span>       </span></span><span style="color: red;">while ( p ){</span></p>


<p class="MsoNormal"><span style="color: red;"><span>              </span>if ( done[p-&gt;v] ) {</span></p>


<p class="MsoNormal"><span style="color: red;"><span>              </span><span>       </span>int anc = find_set(p-&gt;v) ;</span></p>


<p class="MsoNormal"><span style="color: red;"><span>                     </span>times[anc] ++ ;</span></p>


<p class="MsoNormal"><span style="color: red;"><span>              </span>}else{</span></p>


<p class="MsoNormal"><span style="color: red;"><span>                     </span>addnode(query , p-&gt;v , u) ;</span></p>


<p class="MsoNormal"><span style="color: red;"><span>              </span>}</span></p>


<p class="MsoNormal"><span style="color: red;"><span>              </span>p = p-&gt;next ;</span></p>


<p class="MsoNormal"><span style="color: red;"><span>       </span>}</span></p>


<p class="MsoNormal"><span style="color: red;"><span>       </span>done[u] = true ;</span></p>


<p class="MsoNormal"><span style="color: red;">}</span></p>


<p class="MsoNormal"><span> </span></p>


<p class="MsoNormal"><span>void output(){</span></p>


<p class="MsoNormal"><span><span>       </span>int i ;</span></p>


<p class="MsoNormal"><span><span>       </span>for ( i = 1 ; i &lt;= n ; i ++ ){</span></p>


<p class="MsoNormal"><span><span>              </span>if ( times[i] != 0 ) {</span></p>


<p class="MsoNormal"><span><span>                     </span>printf(&#8220;%d:%d\n&#8221; , i , times[i]) ;</span></p>


<p class="MsoNormal"><span><span>              </span>}<span>            </span></span></p>


<p class="MsoNormal"><span><span>       </span>}</span></p>


<p class="MsoNormal"><span>}</span></p>


<p class="MsoNormal"><span> </span></p>


<p class="MsoNormal"><span>int main(){</span></p>


<p class="MsoNormal"><span> </span></p>


<p class="MsoNormal"><span>//<span>     </span>freopen(&#8220;in.txt&#8221; , &#8220;r&#8221; , stdin) ;</span></p>


<p class="MsoNormal"><span> </span></p>


<p class="MsoNormal"><span><span>       </span>while ( scanf(&#8220;%d&#8221; , &amp;n) == 1 ){</span></p>


<p class="MsoNormal"><span><span>              </span>init() ;</span></p>


<p class="MsoNormal"><span><span>              </span>input_tree() ;</span></p>


<p class="MsoNormal"><span><span>              </span>input_query() ;</span></p>


<p class="MsoNormal"><span><span>              </span>tarjan(root) ;</span></p>


<p class="MsoNormal"><span><span>              </span>output() ;</span></p>


<p class="MsoNormal"><span><span>       </span>}</span></p>


<p class="MsoNormal"><span><span>       </span>return 0 ;</span></p>


<p class="MsoNormal"><span>}</span></p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/08/10/SparseTable%E8%A7%A3%E5%86%B3RMQ%E9%97%AE%E9%A2%98%EF%BC%88POJ3368%29/">Sparse Table解决RMQ问题（POJ3368)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-08-10T15:36:00+08:00" pubdate data-updated="true">Aug 10<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.8.10<br/><br/>
解决RMQ问题的方法还是相当多的。<br/>
今天终于尝试了一下Sparse Table。<br/>
这是一个时间上：<br/>
预处理n<em>log(n)，查询O(1)<br/>
空间上：<br/>
n</em>log(n)的方法。<br/><br/><font color="#0000ff">Sparse Table：</font><br/><br/>
用A[]来记原序列，用 M[i][j]来表示：<br/>
A[i] 到 A[i + 2<sup>j</sup> - 1]这一段的最小值<font color="#ff0000">的下标</font>。<br/><br/>
有一个图示如下：<br/><span><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/01d259435bc100389213c623.jpg" small="0" class="blogimg"/></span><br/>
来自：<a href="http://www.topcoder.com/tc?module=Static&amp;d1=tutorials&amp;d2=lowestCommonAncestor#Sparse_Table_(ST)_algorithm" target="_blank">tc的这篇</a><br/><br/>
该数组的尺寸为M[max_n][max_logn]<br/>
max_logn=floor(log2(max_n))<br/><br/>
所以空间复杂度是显而易见的。<br/>
而对该数组的每个元素，能在O(1)的时间计算出来的话，<br/>
那么时间复杂度也就等同了。<br/>
O(nlogn)<br/><br/><font color="#0000ff">Sparse Table的计算：</font><br/><br/>
首先，含单个元素的区域最小值就是他本身：<br/>
M[i][0] = i ; <br/>
其他的值，按照j递增的顺序计算：<br/>
M[i][j] = index of max{ M[i][j - 1] , M[i + 2<sup>(j-1)][j]</sup> }<br/><br/>
相当于是个区间长度倍增的过程。<br/>
每一层合并了两个较短区间的最值记录。<br/><br/><font color="#0000ff">Sparse Table的查询：</font><br/><br/>
对于查询rmq[i,j]<br/>
把该区间分成两段：<br/>
[i , i + 2<sup>k</sup> - 1]和[j - 2<sup>k</sup> + 1 , j]<br/>
则可以导出：<br/>
rmq[i,j] = max{ M[i][k] , M[j-2<sup>k+1][k]</sup> }<br/><br/>
然后就是要确定k值。标准就是使得分成的两个区间能覆盖原来的区间[i,j]即可。<br/>
于是 j - 2<sup>k</sup> + 1 &lt;= i + 2 ^k - 1 + 1<br/>
最终：k&gt;=log2(j-i+1)-1<br/><br/><font color="#0000ff">POJ3368：</font><br/><br/>
有了上面这个数据结构，刷这个题就先转化一下就行了。<br/><br/>
由于数据是有序的，<br/>
那么在读入的过程中就可以统计出一个频率来。<br/><br/>
比如：<br/>
-1 -1 1 1 1 1 3 10 10 10<br/>
统计为freq[]：<br/>
2 4 1 3<br/><br/>
要记录的信息是，这个数字的频率freq[]，左端left[]，右端right[]，<br/>
由于预处理后，数字本身是多少并不关心，所以其实可以不用记录数字num[]。<br/><br/>
给出统计[a,b]之间的频率后。<br/>
先要得到a,b对应的数字在freq[]里面的位置l,r。<br/>
可以用二分来完成。<br/><br/>
于是最终要输出的结果是<br/>
max{<br/>
right[l] - a + 1 ,<br/>
rmq(l+1 , r-1) ,<br/>
b - left[r] + 1,<br/>
}<br/><br/>
当然，对于l和r的差值要讨论相等，刚好等于1，以及其他这三种情况。<br/><br/><font color="#0000ff">POJ3368代码：</font><br/><font color="#ff0000"><br/>
关于排版，只能深表遗憾。<br/>
其实是有缩进的，粘上来就成这样了。<br/>
可以在VC中用全选，alt+f8解决。</font><br/><br/></p>

<h1>include &lt;stdio.h&gt;<br/></h1>

<h1>include &lt;string.h&gt;<br/></h1>

<h1>include &lt;math.h&gt;<br/><br/></h1>

<p>const int MAXN = 100010 ;<br/>
const int MAXLOGN = 17 ;<br/><br/>
int num[MAXN] , left[MAXN] , right[MAXN] , freq[MAXN] ;<br/>
int rmq[MAXN][MAXLOGN] ;<br/>
int power2[MAXLOGN + 1] ;<br/>
int total ; <br/><br/>
void init(){<br/>
int i ;<br/>
power2[0] = 1 ;<br/>
for ( i = 1 ; i &lt;= MAXLOGN ; i ++ ){<br/>
power2[i] = power2[i - 1] * 2 ;<br/>
}<br/>
}<br/><br/>
int max_rmq(int i , int j){<br/>
if ( freq[i] &gt; freq[j] ) return i ;<br/>
else return j ;<br/>
}<br/><br/>
void init_st(){<br/>
int i , j ;<br/>
for ( i = 1 ; i &lt;= total ; i ++ ){<br/>
rmq[i][0] = i ;<br/>
}<br/>
int max_log2 = int (log(double(total)) / log(double(2))) ;<br/>
for ( j = 1 ; j &lt;= max_log2 ; j ++ ){<br/>
for ( i = 1 ; i &lt;= total ; i ++ ){<br/>
rmq[i][j] = max_rmq(rmq[i][j - 1] , rmq[i + power2[j-1]][j - 1]) ;<br/>
}<br/>
}<br/>
}<br/><br/>
int rmq_st(int i , int j){<br/>
int loglen = int(log(double(j - i + 1)) / log(double(2))) ;<br/>
return max_rmq(rmq[i][loglen] , rmq[j - power2[loglen] + 1][loglen]) ;<br/>
}<br/><br/>
int search(int x){<br/>
int l = 1 ;<br/>
int r = total + 1 ;<br/>
while ( l &lt; r ){<br/>
int mid = (l + r) / 2 ;<br/>
if ( x &gt; right[mid] ) l = mid + 1 ;<br/>
else r = mid ;<br/>
}<br/>
return l ;<br/>
}<br/><br/>
int max(int a , int b){<br/>
return a &gt; b ? a : b ;<br/>
}<br/><br/>
int max_freq(int a , int b){<br/>
int l = search(a) ;<br/>
int r = search(b) ;<br/><br/>
if ( l == r ){//same block<br/>
return b - a + 1 ;<br/>
}<br/><br/>
int t ;<br/>
if ( r - l &gt; 1 ){<br/>
t = freq[rmq_st(l + 1 , r - 1)];<br/>
}else t = -1 ;<br/><br/>
t = max(t , right[l] - a + 1) ;<br/>
t = max(t , b - left[r] + 1) ;<br/><br/>
return t ;<br/>
}<br/><br/>
int main(){<br/>
int n , q ;<br/>
int i ;<br/>
int curleft , curnum , tmp , count ;<br/>
init() ;<br/>
while ( 1 ){<br/>
scanf(&#8220;%d&#8221; , &amp;n) ;<br/>
if ( n == 0 ) break ;<br/>
scanf(&#8220;%d&#8221; , &amp;q) ;<br/>
total = 0 ;<br/>
curnum = 10000000 ; <br/>
for ( i = 1 ; i &lt;= n ; i ++ ){<br/>
scanf(&#8220;%d&#8221; , &amp;tmp) ;<br/>
if ( tmp != curnum ) {<br/>
left[total] = curleft ;<br/>
right[total] = i - 1 ;<br/>
num[total] = curnum ;<br/>
freq[total] = count ;<br/>
curleft = i ;<br/>
curnum = tmp ;<br/>
count = 1 ;<br/>
total ++ ;<br/>
}else count ++ ;<br/>
}<br/>
left[total] = curleft ;<br/>
right[total] = i - 1 ;<br/>
num[total] = curnum ;<br/>
freq[total] = count ;<br/><br/>
init_st() ;<br/>
for ( i = 0 ; i &lt; q ; i ++ ){<br/>
int a , b ;<br/>
scanf(&#8220;%d%d&#8221; , &amp;a , &amp;b) ;<br/>
printf(&#8220;%d\n&#8221; , max_freq(a , b)) ;<br/>
}<br/>
}<br/>
return 0 ;<br/>
}<br/><br/><font color="#0000ff">其他问题：</font><br/><br/>
1.<font color="#ff0000">在算2的方幂的时候，使用移位比预计算后寻址来得更快。</font><br/>
这点在以前弄有关线段树的东西的时候也发现过类似情况。<br/><br/>
2.最初加外挂的时候，写了这样一句：<br/>
putint(max_freq(getint() , getint())) ;<br/><br/>
交WA了若干次，才反映过来，<font color="#ff0000">默认函数传参是从右边开始的</font>。<br/>
于是给max_freq的两个数刚好打颠倒了。<br/>
这个要严重的注意。。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/08/06/%E4%B8%80%E7%B1%BB%E8%BF%9E%E7%BB%AD%E6%9C%80%E5%A4%A7%E5%8C%BA%E5%9F%9F%E9%97%AE%E9%A2%98%EF%BC%88fzu1801%2CPOJ3494%2C2559%2C2796%2C3250%29/">一类连续最大区域问题（fzu1801,POJ3494,2559,2796,3250)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-08-06T22:45:00+08:00" pubdate data-updated="true">Aug 6<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.8.6<br/><br/>
故事是从<a href="http://acm.fzu.edu.cn/problem.php?pid=1801" target="_blank">fzu1801</a>开始的。<br/>
因为有小朋友问了一个我也不会的问题，<br/>
为了搞定这个问题，挖出了一堆矿来。<br/>
于是现在就递归地把这些问题看回去。<br/><br/><font color="#0000ff">FZU1801:</font><br/><br/>
题目中给出了几种字符，和他们的变换规则。<br/>
简单的来说，就是，最后剩下的肯定是abc这几个。<br/>
abc这些字符本身是不可变动的，<br/>
而wxyz是可以变换成他们的。<br/><br/>
于是我们把所有能变成a的字符都变成a，<br/>
可以求出由a组成的最大子矩阵是多大。<br/>
同理，求出由b、c组成的，就是变换后能取得的最大子矩阵了。<br/><br/>
对于上面的，把变换后为a的地方都用1替换，<br/>
其他地方都用0替换，这个问题就转化成了POJ3494了。<br/><br/>
这个问题就是平面上的最大连续区域问题了。<br/><br/><font color="#0000ff">POJ3494:</font><br/><br/>
假设现在要解决的是行1..i中最大子矩阵是多少，记为<font color="#ff9900">子问题Pi</font>。<br/>
定义h[j]为j列中，从第i行开始向第1行的方向，最多连续多少个1。<br/><br/>
比如下面的case：<br/>
00100<br/>
10110<br/>
11111<br/><br/>
h[]：<br/>
2 1 3 2 1<br/><br/>
于是Pi可以重述如下：<br/><br/><font color="#ff9900">max(x,y) {(y - x + 1) * min{h[k]}}<br/>
x&lt;=k&lt;=y<br/>
1&lt;=x&lt;=y&lt;=n<br/></font><br/>
这样Pi就转化成了POJ2559。<br/>
从后面可以得知，解决他的复杂度为O(n)，<br/>
只要枚举各个Pi，选择其中最大值即可，<br/>
而枚举i的复杂度为O(m)，总的复杂度为O(m<em>n)。<br/><br/><font color="#0000ff">POJ2559:</font><br/><br/>
首先，要达到最大矩形，显然该矩形的高度会恰好等于某个柱的高度。<br/>
否则，该矩形还可以继续提高。<br/><br/>
所以，只需要枚举选第i个柱作为矩形的高度。<br/>
从该柱向左扩展尽量远，向右也扩展尽量远，得到以该柱为高度的最大矩形。<br/>
这个过程是O(n）的。<br/><br/>
要向两边扩展尽量远。<br/>
设left[i]表示：<br/>
从left[i]到i的所有柱的高度都不小于h[i]，<br/>
同时，h[left[i]-1]&lt;h[i]。<br/>
这样left[i]标记的位置就是上面提到的可以向左走的最远距离了。<br/><br/>
对right[i]也做类似定义。<br/>
则以h[i]为高度的矩形的最大面积为<br/>
area[i]=h[i]</em>(right[i]-left[i]+1)<br/><br/>
ans = max{area[i]}<br/><br/>
最后的问题就是在O(n)的时间内求出left[]和right[]<br/><br/>
这里又用到了栈的思维，见POJ3250。<br/><br/>
以left[]的求法为例：<br/><br/>
维护一个栈，使得：<br/>
h[stack[0]] &lt; h[stack[1]] &lt; h[stack[2]] &lt; &#8230; &lt; h[stack[top]]<br/><br/>
先在h[]的两端加上哨兵，h[0] = -1 , h[n+1] = -1。<br/>
初始时,stack[0] = 0 , top = 0 。<br/><br/>
当计算第i个柱子的left值时，<br/>
先从栈顶依次弹出比h[i]高或等于的柱子。<br/>
此时，满足：（从栈的维护过程可以得知）<br/>
h[stack[top]]&lt;h[i]<br/>
h[stack[top + 1]]&gt;=h[i]<br/>
并且：<br/>
h[(stack[top]+1)&#8230;(stack[top + 1])]均&gt;=h[i]<br/>
也就是left[i] = stack[top]+1<br/><br/>
继续维护这个栈的结构，把i入栈。<br/><br/>
核心代码：<br/><font color="#ff9900">        stack[0] = 0 ;<br/>
top = 0 ;<br/></font><font color="#ff9900">        for ( i = 1 ; i &lt;= n ; i ++ ){<br/>
while ( h[i] &lt;= h[stack[top]] ) top &#8211; ;<br/>
left[i] = stack[top] + 1 ;<br/>
stack[++ top] = i ;<br/>
}</font><br/><br/>
对right的处理也是类似。<br/><font color="#0000ff"><br/>
POJ2796:</font><br/><br/>
跟POJ2559非常相近了。<br/>
问题可以描述为：<br/><br/><font color="#ff9900">max(x,y) {(sum[x,y]) * min{h[k]}}<br/>
x&lt;=k&lt;=y<br/>
1&lt;=x&lt;=y&lt;=n<br/></font><br/>
其中sum[x,y]为快乐值从x天到y天的加和。<br/>
这个处理是O(n)时间可以完成的。<br/><br/>
而问题的关键还是在于，选定一天作为快乐值最小的一天后。<br/>
要向两端寻找一个尽可能大的区域，使得这个区域中的快乐值都不低于这天。<br/><br/>
在构造left[],right[]的时候用到的递减栈和递增栈的思维同POJ3250。<br/><br/><font color="#0000ff">POJ3250:</font><br/><br/>
首先是个思路的转换，<br/>
题目中直接指出的是每个牛能看到的牛的个数ci，<br/>
要求ci的累加。<br/>
这样做起来不太方便 。<br/><br/>
重新定义一个对每个牛，能看到他的牛的个数为di，<br/>
那么对di求和就行了。这两个值是相等的，不多说了。<br/><br/>
这个时候，维护一个递减栈就可办到了：<br/>
h[stack[0]] &gt; h[stack[1]] &gt; h[stack[2]] &gt; &#8230; &gt; h[stack[top]]<br/>
其中stack[top] = i <br/>
在这个情况下，显然栈中的牛就是能看到该牛的个数。<br/>
即di = top。把他们累加起来就对了。<br/><br/>
核心代码：（实现中的栈的底的序号和上面描述的不一致，意思一样）<br/><font color="#ff9900"><br/>
for ( i = 0 ; i &lt; n ; i ++ ){<br/>
int t = 0 ;<br/>
char ch ;<br/>
while ( (ch = getchar()) &gt;= &#8216;0&#8217; ){<br/>
t = t * 10 + ch - &#8216;0&#8217; ;<br/>
}<br/>
while ( tp &gt; 0 &amp;&amp; t &gt;= s[tp] ) tp &#8211; ;<br/>
ans += tp ;<br/>
s[++ tp] = t ;<br/>
}</font><br/><font color="#0000ff"><br/>
总结：</font><br/><br/>
解决一维的连续区间问题，可以用O(n)的扫描得到。<br/>
而通过适当的转化，把以为的连续区域问题，转化为一维的，确实很巧妙。<br/><br/>
在看discuss前，我的简单想法是：<br/>
枚举每个子矩形，判断是否里面只有同一种符号。<br/>
经过适当的预处理，判断，这一步可以在O(1)完成。<br/>
如用sum[i][j]记录(1,1)到(i,j)组成的子矩形中为1元素的个数。<br/>
那么可以算出枚举的矩形的面积和这个和是否相等，来决定是否只有一种符号。<br/>
而枚举子矩形最简单的是四重循环，枚举两个角的两个坐标。<br/>
改进是，枚举两个x的值，二分在y方向的长度，枚举y值之一。<br/>
这样做起来也是O(n<em>n</em>m*log(m))，或者m，n互换，但大同小异。<br/>
其复杂度是相当高的。<br/><br/>
然后就是那种用递减栈来计算出可行区间的思路，<br/>
也是很巧妙的，写起来很短，但老是想不到。。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/08/05/BrainFuck%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E3%80%90%E6%84%8F%E8%AF%91%E3%80%91%28%E4%B8%8B%EF%BC%89/">BrainFuck（四）基本操作【意译】(下）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-08-05T09:59:00+08:00" pubdate data-updated="true">Aug 5<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 18pt; "><font size="3">(hplonline)2009.8.5</font><br/></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><strong><span style="font-size: 18pt; ">逻辑操作<span/></span></strong></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; ">首先，作逻辑真值的定义，非<span>0</span>为真，<span>0</span>为假。<span/></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "> </span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; ">或运算，把两个操作数都移动到同一格即可<span>: </span></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "><span>  </span><em>or(s1,s2,d)</em> <strong>=</strong> <em>move(s1,d) move(s2,d)</em></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; ">与运算要依靠<span>if</span>分支结构<span>: </span></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "><span>  </span><em>and(s1,s2,d)</em> <strong>=</strong> <em>if(s1) move(s2,d) endif(s1) zero(s2) </em></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; ">zero(s2)</span></em><span style="font-size: 12pt; "> </span><span style="font-size: 12pt; ">用来当<span>s1</span>为<span>0</span>的时候对<span>s2</span>清零<span>.</span></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; ">（这个清零也是这些宏的默认特性，即在操作之后源格清零）<span> </span></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; ">非操作<span>: </span></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "><span>  </span><em>not(s,d)</em> <strong>=</strong> <em>inc(d) if(s) dec(d) endif(s)</em></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><strong><span style="font-size: 18pt; ">比较<span/></span></strong></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; ">首先实现一个宏，他把<span>x1,x2</span>中的小者减到<span>0</span>，另一个减到<span>|x1-x2|: </span></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "><span>  </span></span><em><span style="font-size: 12pt; ">subtractMinimum(x1,x2,t1,t2,t3)</span></em><span style="font-size: 12pt; "> <strong>=</strong></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "><span>      </span><em>copy(x1,t1,t3) copy(x2,t2,t3) and(t1,t2,t3)</em></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>      </span>to(t3)</span></em><span style="font-size: 12pt; "> [</span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "><span>        </span><em>zero(t3)</em></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>        </span>dec(x1) dec(x2)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>        </span>copy(x1,t1,t3) copy(x2,t2,t3) and(t1,t2,t3)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>      </span></span></em><em><span style="font-size: 12pt; ">to(t3)</span></em><span style="font-size: 12pt; "> ]</span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; ">(</span><span style="font-size: 12pt; ">这个定义的源格也就是目的格，结果返回在<span>x1</span>和<span>x2</span>里面<span>) </span></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "> </span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; ">使用这个宏，可以定义各种比较<span>: </span></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "><span>  </span></span><em><span style="font-size: 12pt; ">notEqual(x1,x2,d,t1,t2)</span></em><span style="font-size: 12pt; "> <strong>=</strong> <em>subtractMinimum(x1,x2,d,t1,t2) or(x1,x2,d)</em></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "><span>  </span><em>Equal(x1,x2,d,t1,t2)</em> <strong>=</strong> <em>NotEqual(x1,x2,t1,d,t2) not(t1,d)</em></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "><span>  </span><em>Greater(x1,x2,d,t1,t2)</em> <strong>=</strong> <em>subtractMinimum(x1,x2,d,t1,t2) zero(x2) move(x1,d)</em></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "><span>  </span><em>Less(x1,x2,d,t1,t2)</em> <strong>=</strong> <em>subtractMinimum(x1,x2,d,t1,t2) zero(x1) move(x2,d)</em></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "><span>  </span><em>GreaterOrEqual(x1,x2,d,t1,t2)</em> <strong>=</strong> <em>inc(x1) Greater(x1,x2,d,t1,t2)</em></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "><span>  </span><em>LessOrEqual(x1,x2,d,t1,t2)</em> <strong>=</strong> <em>inc(x2) Less(x1,x2,d,t1,t2)</em></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "> </span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; ">上面的<em><span>subtractMinimum</span></em><span> </span>阅读起来很短，但展开后很长。展开后更短的版本如下<span>: </span></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "><span>  </span><em>subtractMinimum(x1,x2,t1,t2,t3)</em> <strong>=</strong></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "><span>      </span></span><em><span style="font-size: 12pt; ">for(x1)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>         </span>copy(x2,t1,t2)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>         </span>ifelse(t1,t2)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>           </span>dec(x2)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>         </span>else(t1,t2)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>          </span><span> </span>inc(t3)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>         </span></span></em><em><span style="font-size: 12pt; ">endelse(t2)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>      </span>next(x1)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>      </span>move(t3,x1)</span></em><span style="font-size: 12pt; "/></p>


<p align="left" style="text-align: left;" class="MsoNormal"><strong><span style="font-size: 18pt; ">和小常数比较<span/></span></strong></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; ">使用逻辑运算和<span>if</span>结构，递归定义<span>: </span></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "><span>  </span><em>isZero(s,d)</em> <strong>=</strong> <em>not(s,d)</em></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "><span>  </span><em>isOne(s,d)</em> <strong>=</strong> <em>if(s) dec(s) isZero(s,d) endif(s)</em></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "><span>  </span><em>isTwo(s,d)</em> <strong>=</strong> <em>if(s) dec(s) isOne(s,d) endif(s)</em></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "><span>  </span><em>isThree(s,d)</em> <strong>=</strong> <em>if(s) dec(s) isTwo(s,d) endif(s)</em></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "><span>  </span>&#8230;.</span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; ">（<span>hplonline</span>：其实可以牺牲一个临时格，先用来生成常数，然后使用上一节的比较，可避免递归）<span/></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><strong><span style="font-size: 18pt; ">常数<span/></span></strong></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; ">给一个格加上特定的常数，可以直接使用需要数量的<span>’+’</span>，也可以参考作者的大数生成：<span><a href="http://www.iwriteiam.nl/Ha_bf_numb.html">Big numbers in BF</a>. </span></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><strong><span style="font-size: 18pt; ">数组<span/></span></strong></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; ">这里的数组为一系列无穷长度的数组，一开始应该确定下需要多少数组（<span>n</span>）和这些数组开始的地方（<span>b</span>），实现数组即实现获取（<span>get</span>）和存储（<span>set</span>）<span/></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; ">为了实现先作如下定义<span>: </span></span></p>


<ul type="disc"><li style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; ">b</span></em><span style="font-size: 12pt; ">: </span><span style="font-size: 12pt; ">数组区域的开始<span>. </span></span></li>
    <li style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; ">n</span></em><span style="font-size: 12pt; ">: </span><span style="font-size: 12pt; ">数组的个数<span>. </span></span></li>
    <li style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; ">a</span></em><span style="font-size: 12pt; ">: </span><span style="font-size: 12pt; ">指出使用的数组是哪个（<span>0</span>开始）<span> </span></span></li>
    <li style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; ">i</span></em><span style="font-size: 12pt; ">: </span><span style="font-size: 12pt; ">指出该数组中的下标（<span>0</span>开始）<span> </span></span></li>
    <li style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; ">v</span></em><span style="font-size: 12pt; ">: get</span><span style="font-size: 12pt; ">方法中，代表把值放入的格，<span>set</span>方法中，代表把待放入的值所在的格<span>. </span></span></li>
</ul>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; ">Set</span><span style="font-size: 12pt; ">和<span>get</span>方法的定义如下<span>: </span></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "><span>  </span><em>setarray(b,n,a,i,v)</em></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "><span>  </span>= <em>copy(i,b+1,b)</em></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>     </span>copy(v,b+2,b)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>     </span>for(b+1)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>        </span>move(b,b+n+3)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>        </span>move(b+1,b+n+4)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>        </span>move(b+2,b+n+5)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>        </span>right(n+3)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>        </span>inc(b)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>     </span>next(b+1)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>     </span>zero(a)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>     </span>move(b+2,a)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>     </span>for(b)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>        </span>left(n+3)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>        </span>move(b+n+3,b)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>     </span>next(b)</span></em><span style="font-size: 12pt; "/></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "> </span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "><span>  </span><em>getarray(b,n,a,i,v)</em></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "><span>  </span>= <em>copy(i,b+1,b)</em></span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>     </span>for(b+1)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>        </span>move(b,b+n+3)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>        </span>move(b+1,b+n+4)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>        </span>right(n+3)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>        </span>inc(b)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>     </span>next(b+1)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>     </span>copy(a,b+1,b+2)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>     </span>for(b)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>        </span>left(n+3)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>        </span>move(b+n+3,b)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>        </span>move(b+n+4,b+1)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>     </span>next(b)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><em><span style="font-size: 12pt; "><span>     </span>move(b+1,v,b)</span></em></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="font-size: 12pt; "> </span></p>


<p class="MsoNormal"><span style="font-size: 12pt; ">其中 <em><span>right(n)</span></em><span> </span>代表<em><span>n</span></em><span> </span>个<span>&#8216;&gt;&#8217;</span>符号， <em><span>left(n)</span></em><span> </span>代表 <em><span>n</span></em><span> </span>个<span>&#8216;&lt;&#8217;</span>符号。<span/></span></p>


<p class="MsoNormal"><span style="font-size: 12pt; "> </span></p>


<p class="MsoNormal"><span style="font-size: 12pt; ">（<span>hplonline</span>：<span/></span></p>


<p class="MsoNormal"><span style="font-size: 12pt; ">这里数组的结构是这样的：<span/></span></p>


<p class="MsoNormal"><span style="font-size: 12pt; ">b b+1 b+2 b+3 b+4 … b+n+2 b+n+3 b+n+4 b+n+5 b+n+6 b+n+7 … </span></p>


<p class="MsoNormal"><span style="font-size: 12pt; ">t1 t2<span>  </span>t<chmetcnv tcsc="0" numbertype="1" negative="False" hasspace="True" sourcevalue="3" unitname="a">3 a</chmetcnv><chmetcnv tcsc="0" numbertype="1" negative="False" hasspace="True" sourcevalue="11" unitname="a">11 a</chmetcnv>21<span>      </span>an1<span>    </span>t1<span>      </span>t2<span>     </span>t<chmetcnv tcsc="0" numbertype="1" negative="False" hasspace="True" sourcevalue="3" unitname="a">3<span>    </span>a</chmetcnv><chmetcnv tcsc="0" numbertype="1" negative="False" hasspace="True" sourcevalue="12" unitname="a">12<span>  </span>a</chmetcnv>22</span></p>


<p class="MsoNormal"><span style="font-size: 12pt; "> </span></p>


<p class="MsoNormal"><span>aij</span><span>代表的是第</span><span>i</span><span>个数组的第</span><span>j</span><span>个元素。</span><span>t</span><span>代表的是临时单元。</span><span/></p>


<p class="MsoNormal"><span>即先排上所有数组的第一个元素，再排上所有数组的第二个元素，再是所有数组的第三个元素。。。</span><span/></p>


<p class="MsoNormal"><span> </span></p>


<p class="MsoNormal"><span>这个设计确实很巧妙，以</span><span>set</span><span>方法来说。先把待存入数值放入</span><span>t3</span><span>，把下标放入</span><span>t2</span><span>。</span><span/></p>


<p class="MsoNormal"><span>然后不断循环，每次把</span><span>t3</span><span>，</span><span>t2</span><span>，</span><span>t1</span><span>搬移</span><span>n</span><span>位，并且把</span><span>t2</span><span>减</span><span>1</span><span>，</span><span>t1</span><span>加</span><span>1</span><span>。</span><span/></p>


<p class="MsoNormal"><span>这样，到</span><span>t2</span><span>为</span><span>0</span><span>的时候就是该元素应该存放的段了，然后加上数组的偏移即可。</span><span/></p>


<p class="MsoNormal"><span>退回来的时候，只要找到</span><span>t1</span><span>为</span><span>0</span><span>的地方就行了。</span><span/></p>


<p class="MsoNormal"><span>为什么要退回来，也是这套宏的一致性定义，</span><span/></p>


<p class="MsoNormal"><span>要保证操作之后，除了指定的格的值被改变外，指针不动，</span><span/></p>


<p class="MsoNormal"><span>这样才能在更大的程序段中调用他们而不出错。</span><span/></p>


<p><span>）</span></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/08/05/BrainFuck%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E3%80%90%E6%84%8F%E8%AF%91%E3%80%91%28%E4%B8%8A%EF%BC%89/">BrainFuck（四）基本操作【意译】(上）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-08-05T09:58:00+08:00" pubdate data-updated="true">Aug 5<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p class="MsoNormal"><span>(hplonline)2009.8.4<br/><br/></span><span>原文：</span><span><br/><a href="http://www.iwriteiam.nl/Ha_bf_intro.html" target="_blank">http://www.iwriteiam.nl/Ha_bf_intro.html</a><br/><br/></span><span>（意译的标准在于本人能理解，</span><span><br/></span><span>知道大意后，详细内容还是要参考原文，</span><span><br/></span><span>这篇更类似摘要或者笔记）</span></p>


<p class="MsoNormal"><span> </span></p>


<p class="MsoNormal"><span>这篇的内容涉及到很多宏的定义，需要从头按顺序看，才能理解，要记住各个宏定义的时候的参数是什么意义。这篇在于给出一个功能上的完整集合，所以并非里面的宏是在具体使用时候的最优解决方案，很多时候，可以针对特殊情况进行改进的。但是通过这篇给出的宏的方式，比较容易构建程序，并且展开方便。</span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><strong><span style="font-size: 18pt;"> </span></strong></p>


<p align="left" class="MsoNormal" style="text-align: left;"><strong><span style="font-size: 18pt;">移动，复制，加法</span></strong></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;">最简单的程序，清零当前所指的格<span>: </span></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>  </span>[-]</span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;">把当前格的数字移动到右边一格<span>: </span></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>  </span>[ &gt; + &lt; - ]</span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;">通用的移动数字的框架为<span>: </span></span></p>


<ul type="disc"><li class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;">把指针移动到源点</span></li>
    <li class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;">&#8221;[&#8221;      command </span></li>
    <li class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;">把指针移动到目的点<span> </span></span></li>
    <li class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;">&#8221;+&#8221;      command </span></li>
    <li class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;">（这一步可能对多个目的点相加）</span></li>
    <li class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;">把指针移动到源点</span></li>
    <li class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;">&#8221;-&#8221;      command </span></li>
    <li class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;">&#8221;]&#8221;      command </span></li>
</ul>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;">定义 <em><span>to(m)</span></em><span> </span>为把指针移动到<em><span>m</span></em></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><em><span style="font-size: 12pt;">move(s,d)</span></em><span style="font-size: 12pt;"> </span><span style="font-size: 12pt;">表示移动<span>s</span>的数字到<span>d, </span>可以写作<span>: </span></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>  </span><em>move(s,d)</em> <strong>=</strong> <em>to(s)</em> [ <em>to(d)</em> + <em>to(s) </em>- ]</span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"> </span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;">定义 <em><span>for(a)</span></em><span> </span>和 <em><span>next(a)</span></em><span>: </span></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>  </span><em>for(a)</em> <strong>=</strong> <em>to(a)</em>[</span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>  </span><em>next(a)</em> <strong>=</strong> <em>to(a)</em>-]</span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>  </span><em>move(s,d)</em></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>  </span><strong>=</strong> <em>for(s)</em></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>        </span><em>to(d)</em> +</span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>      </span><em>next(s)</em></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"> </span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;">把一个源点移动到两个目的点<span>: </span></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>  </span><em>move2(s,d1,d2)</em></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>  </span><strong>=</strong> <em>for(s)</em></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>        </span><em>to(d1)</em> +</span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>        </span><em>to(d2)</em> +</span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>      </span><em>next(s)</em>-]</span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"> </span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;">把<span>s</span>复制到<span>t</span>需要用到一个临时单元<span>t: </span></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>  </span><em>copy(s,d,t)</em> <strong>=</strong> <em>move2(s,d,t) move(t,s)</em></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;">以上的操作都默认了各个格子在操作之前是空的。</span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><strong><span style="font-size: 18pt;">乘法和幂</span></strong></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;">把一个数变成两倍<span>: </span></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>  </span><em>double(s,d)</em> <strong>=</strong> <em>move2(s,d,d)</em></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;">用 <em><span>constant(n)</span></em><span> </span>表示在当前格设置常数<span>n</span></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;">那么<span>s</span>乘以常数<span>n</span>可以写作<span>: </span></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>  </span><em>multiplyconst(s,d,n)</em></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>  </span><strong>=</strong> <em>for(s)</em></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>        </span><em>to(d) constant(n)</em></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>      </span><em>next(s)</em></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"> </span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;">两个数相乘：<span> </span></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>  </span><em>times(s1,s2,d,t)</em></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>  </span><strong>=</strong> <em>for(s1)</em></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>        </span><em>copy(s2,d,t)</em></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>      </span><em>next(s1)</em></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>      </span><em>zero(s2)</em></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"> </span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;">注意，在以上以及以后的定义中，都认为一个操作完成后源格被置零。</span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"> </span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;">乘幂，就是重复乘法就行了<span>:</span></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"> </span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>  </span><em>power(x,p,d,t1,t2,t3)</em></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>  </span></span><strong><span style="font-size: 12pt;">=</span></strong><span style="font-size: 12pt;"> <em>to(d)</em> +</span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>      </span><em>for(p)</em></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><em><span style="font-size: 12pt;"><span>          </span>copy(x,t1,<span style="color: red;">t2</span>)</span></em></p>


<p align="left" class="MsoNormal" style="text-align: left;"><em><span style="font-size: 12pt;"><span>          </span></span></em><em><span style="font-size: 12pt;">times(d,t1,t2,t3)</span></em></p>


<p align="left" class="MsoNormal" style="text-align: left;"><em><span style="font-size: 12pt;"><span>          </span>move(t2,d)</span></em></p>


<p align="left" class="MsoNormal" style="text-align: left;"><em><span style="font-size: 12pt;"><span>      </span></span></em><em><span style="font-size: 12pt;">next(p)</span></em></p>


<p align="left" class="MsoNormal" style="text-align: left;"><em><span style="font-size: 12pt;"><span>      </span>zero(x)</span></em></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;">（红色部分为<span>hplonline</span>更正，因为<span>copy</span>宏的定义要用到一个临时格）</span></p>


<p align="left" class="MsoNormal" style="text-align: left;"> </p>


<p align="left" class="MsoNormal" style="text-align: left;"><strong><span style="font-size: 18pt;">If-then-else</span></strong><strong><span style="font-size: 18pt;">分支结构</span></strong></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;">之前实现了循环，<span>[]</span>可以进行判断，而分支可以视作只执行一次的循环，所以按照循环的结构，在分支内部把控制循环真值的格清零即可。定义如下符号<span>: </span></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>  </span><em>zero(a)</em> <strong>=</strong> <em>to(a)</em> [-]</span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>  </span><em>if(a)</em> <strong>=</strong> <em>to(a)</em> [</span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>  </span><em>endif(a)</em> <strong>=</strong> <em>zero(a)</em> ]</span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"> </span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;">实现<span>else</span>结构，只需增加一个临时变量，首先置<span>1</span>，进入<span>if</span>分支的时候清零，则在下一次判断不进入<span>else</span>分枝<span>: </span></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>  </span><em>ifelse(a,t)</em> <strong>=</strong> <em>inc(t) if(a) dec(t)</em></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>  </span><em>else(a,t)</em> <strong>=</strong> <em>endif(a) if(t)</em></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>  </span><em>endelse(t)</em> <strong>=</strong> <em>endif(t)</em></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;">最后一个宏也可写作<span>: </span></span></p>


<p align="left" class="MsoNormal" style="text-align: left;"><span style="font-size: 12pt;"><span>  </span><em>endelse(t)</em> <strong>=</strong> <em>dec(t)</em> ]</span></p>


<p>(百度说我太长了。。。只有分成两篇。。）<br/><p class="MsoNormal"> </p></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/07/29/BrainFuck%EF%BC%88%E4%B8%80%EF%BC%89%E8%A7%A3%E9%87%8A%E5%99%A8/">BrainFuck（一）解释器</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-07-29T12:05:00+08:00" pubdate data-updated="true">Jul 29<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.7.29<br/><br/>
前天听说了brainfuck这种强大的语言，<br/>
在fuck自己brain的同时也fuck别人的brain。<br/><font color="#0000ff"><br/>
从网上摘抄一段描述：</font><br/><em><br/>
这种语言基于一个简单的机器模型，除了指令，这个机器还包括：一个以字节为单位、被初始化为零的数组、一个指向该数组的指针(初始时指向数组的第一个字节)、以及用于输入输出的两个字节流。<br/>
下面是这八种状态的描述，其中每个状态由一个字符标识：<br/>
字符 含义 <br/>
＞ 指针加一 <br/>
＜; 指针减一 <br/>
+ 指针指向的字节的值加一 <br/>
- 指针指向的字节的值减一 <br/>
. 输出指针指向的单元内容(ASCII码) <br/>
, 输入内容到指针指向的单元(ASCII码) <br/>
[ 如果指针指向的单元值为零，向前跳转到对应的]指令的次一指令处 <br/>
] 如果指针指向的单元值不为零，向后跳转到对应的[指令的次一指令处 </em>          <br/><br/>
规则简单，则变化更为灵活多样，就像围棋一样。<br/><br/>
前面若干条都很好理解，<br/>
最后两条的话，用C的循环去对应，就能想通了：<br/><br/><font color="#ff6600">[</font> while (*ptr) {<br/><font color="#ff6600">] </font>} <br/><br/>
在以上指令的基础上，为了能够进行调试，<br/>
我自己加一个&#8217;@&#8217;，用来输出当前整个数组的情况。<br/><font color="#0000ff"><br/>
我的解释器：</font><br/><br/>
网上有不少地方提到编译器，总觉得听上去有点别扭，<br/>
看他们所干的事情实际上就是解释的功能，<br/>
甚至连函数名都是interpret之类的。<br/><br/>
我这个解释器的一个特点是用STL实现，<br/>
所以那个数组可以是任意伸缩的。<br/>
但是由于在语言的定义里面没有规范数组下标为负的情况，<br/>
所以遇到的时候，仅仅是简单报告错误。<br/><br/>
第二个特点就是没有用递归实现[]。<br/>
由于[]在逻辑行为上很像while循环，<br/>
我在网上看到过的一份代码就是采用每次找到一对括号，<br/>
把这段截取成一个新的字符串，然后递归调用执行。<br/>
我是直接从上面的定义出发，让程序按照那样的规定跳转。<br/>
在实际操作上，先用map&lt;string::iterator , string::iterator&gt;<br/>
的结构把匹配的括号保存下来，即可实现高速查找配对括号的位置。<br/>
而这个预处理只占用一次线性的时间。<br/><br/>
第三个也将就算个特点，就是忽略空格、tab、换行这些字符。<br/>
于是可以把程序写得更有结构一点。。<br/><br/><font color="#0000ff">代码：</font><br/><br/></p>

<h1>pragma warning(disable:4786)<br/><br/></h1>

<h1>include &lt;iostream&gt;<br/></h1>

<h1>include &lt;fstream&gt;<br/></h1>

<h1>include &lt;stdio.h&gt;<br/></h1>

<h1>include &lt;stack&gt;<br/></h1>

<h1>include &lt;list&gt;<br/></h1>

<h1>include &lt;string&gt;<br/></h1>

<h1>include &lt;map&gt;<br/><br/></h1>

<p>using namespace std ;<br/><br/>
bool work_brackets(string &amp;code , map&lt;string::iterator , string::iterator&gt; &amp;brackets){<br/>
       stack&lt;string::iterator&gt; st ;<br/>
       string::iterator it ;<br/><br/>
       brackets.clear() ;<br/>
       while ( !st.empty() ) st.pop() ;<br/>
       for ( it = code.begin() ; it != code.end() ; it ++ ){<br/>
              if ( <em>it == &#8216;[&#8217; ){<br/>
                     st.push(it) ;       <br/>
              }<br/>
              if ( </em>it == &#8216;]&#8217; ){<br/>
                     if ( st.empty() ) return false ;//brackets unbalanced<br/>
                     brackets[it] = st.top() ;<br/>
                     brackets[st.top()] = it ;<br/>
                     st.pop() ;<br/>
              }<br/>
       }<br/><br/>
       if ( st.empty() ) return true ;<br/>
       else return false ;<br/>
}<br/><br/>
void interpret(string &amp;code){<br/>
       list&lt;char&gt;::iterator pointer ;<br/>
       list&lt;char&gt;::iterator tmpit ;<br/>
       list&lt;char&gt; array ;<br/>
       map&lt;string::iterator , string::iterator&gt; brackets ;<br/><br/>
       if ( !work_brackets(code , brackets) ){<br/>
              cerr&lt;&lt;&#8221;brackets is unbalanced&#8221;&lt;&lt;endl ;<br/>
              return ;<br/>
       }<br/><br/>
       array.clear() ;<br/>
       array.push_back(char(0)) ;<br/>
       pointer = array.begin() ;<br/>
       string::iterator it = code.begin();<br/><br/>
       while ( it != code.end() ){<br/>
              switch(<em>it){<br/>
              case &#8216;+&#8217;: <br/>
                     ++ </em>pointer ;<br/>
                     break ;<br/>
              case &#8216;-&#8216;:<br/>
                     &#8211; <em>pointer ;<br/>
                     break ;<br/>
              case &#8216;&lt;&#8217;: <br/>
                     if ( pointer != array.begin() ) {<br/>
                            &#8211; pointer ;<br/>
                     }else{<br/>
                            cerr&lt;&lt;&#8221;pointer down overflow&#8221;&lt;&lt;endl ;<br/>
                     }<br/>
                     break ;<br/>
              case &#8216;&gt;&#8217;: <br/>
                     tmpit = pointer ;<br/>
                     ++ tmpit ;<br/>
                     if ( tmpit == array.end() ){<br/>
                            array.push_back(char(0)) ;<br/>
                     }<br/>
                     ++pointer ;<br/>
                     break ;<br/>
              case &#8216;[&#8216;: <br/>
                     if ( </em>pointer == 0 ) {<br/>
                            it = brackets[it] ;<br/>
                     }<br/>
                     break ;<br/>
              case &#8216;]&#8217;: <br/>
                     if ( <em>pointer != 0 ) {<br/>
                            it = brackets[it] ;<br/>
                     }<br/>
                     break ;<br/>
              case &#8216;.&#8217;: <br/>
                     cout.put(</em>pointer) ;<br/>
                     break ;<br/>
              case &#8216;,&#8217;: <br/>
                     <em>pointer = cin.get() ;<br/>
                     break ;<br/>
              case &#8216;@&#8217;:<br/>
                     cout&lt;&lt;endl&lt;&lt;&#8221;&#8212;&#8212;&#8212;&#8211;memory:&#8221;&lt;&lt;endl ;<br/>
                     for ( tmpit = array.begin() ; tmpit != array.end() ; tmpit ++ ){<br/>
                            if ( tmpit == pointer ){<br/>
                                   cout&lt;&lt;&#8217;(&#8216;&lt;&lt;int(</em>tmpit)&lt;&lt;&#8221;) &#8221; ;<br/>
                            }else{<br/>
                                   cout&lt;&lt;int(<em>tmpit)&lt;&lt;&#8217; &#8217; ;<br/>
                            }<br/>
                     }<br/>
                     cout&lt;&lt;endl&lt;&lt;&#8221;&#8212;&#8212;&#8212;&#8211;end of memory&#8221;&lt;&lt;endl ;<br/>
                     break ;<br/>
              default:<br/>
                     if ( strchr(&#8221;        \r\n&#8221; , </em>it) ){<br/>
                            //ignore blanks<br/>
                     }else{<br/>
                            cerr&lt;&lt;endl&lt;&lt;&#8221;bad charactor (&#8220;&lt;&lt;<em>it&lt;&lt;&#8221;) in file&#8221;&lt;&lt;endl; <br/>
                     }<br/>
                     break ;<br/>
              }<br/>
              it ++ ;<br/>
       }<br/>
       cout&lt;&lt;endl&lt;&lt;&#8221;program end.&#8221;&lt;&lt;endl;<br/>
}<br/><br/><br/>
int main(int argc , char</em> argv[]){<br/>
       string code ;<br/>
       string tmp ;<br/>
       ifstream fin(argv[1]) ;<br/><br/>
       if ( fin.is_open() ){<br/>
              code = &#8220;&#8221; ;<br/>
              while ( !fin.eof() ){<br/>
                     fin&gt;&gt;tmp ;<br/>
                     code += tmp ;<br/>
              }<br/>
              interpret(code) ;<br/>
       }else{<br/>
              cout&lt;&lt;&#8221;file open error&#8221;&lt;&lt;endl; <br/>
       }<br/>
       return 0 ;<br/>
}<br/><br/><font color="#0000ff">一个样例：</font><br/><br/>
&gt;+++++++<font color="#ff0000">@</font>++[&lt;++++++++&gt;-]&lt;.&gt;++++<br/>
+++[&lt;++++&gt;-]&lt;+.+++++++..+++.[-]&gt;++++++++[&lt;++++&gt;-]&lt;.<br/>
&gt;+++++++++++[&lt;+++++&gt;-]&lt;.&gt;++++++++[&lt;+++&gt;-]&lt;.+++.&#8212;&#8212;.&#8212;&#8212;&#8211;.[-]<br/>
&gt;++++++++[&lt;++++&gt;-]&lt;+.[-]++++++++++.<br/><br/>
保存成一个文件，把文件名用第一参数传给上面的解释器就行了。<br/>
如：bf 1.txt<br/><br/>
结果：<br/><br/>
&#8212;&#8212;&#8212;&#8211;memory:<br/>
0 (7)<br/>
&#8212;&#8212;&#8212;&#8211;end of memory<br/>
Hello World!<br/><br/>
program end.<br/><br/>
除了标红的@是我自己加进去的便于调试的东西外，<br/>
这段程序就是网上很流行的那个hello world。<br/>
其中每一段调试信息输出都由&#8212;&#8212;-分节。<br/><br/>
数组是从左到右输出，带有括号的表示当前指针所指向的单元。<br/><br/>
这下把这个小东西做好了<img src="http://img.baidu.com/hi/jx/j_0015.gif"/>，就可以耍一耍这种哦哦那个语言了。。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/07/28/assert%E7%94%A8%E6%B3%95%EF%BC%8C%E5%8E%9F%E7%90%86%EF%BC%8C%E6%94%B9%E7%BC%96%EF%BC%88C%2B%2B%29/">assert用法，原理，改编（C++)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-07-28T16:51:00+08:00" pubdate data-updated="true">Jul 28<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.7.28<br/><br/><img src="http://img.baidu.com/hi/jx/j_0003.gif"/>最近才发现，原来assert这么好用啊。。。<br/>
再看看是怎么实现的，又找到了些有趣的东西。<br/><br/><font color="#0000ff">用法：<br/></font><br/>
先包含<br/></p>

<h1>inlcude &lt;assert.h&gt;<br/><br/></h1>

<p>在想用的地方给一句：<br/>
assert(expression)就可以了。<br/>
expression是任意有效的逻辑表达式。<br/>
比如：<br/><font color="#ff6600"><br/>
FILE <em>fp = fopen(&#8220;in.txt&#8221;,&#8221;r&#8221;) ;<br/>
if ( ! fp ){<br/>
     exit(0) ;<br/>
}<br/>
assert(fp != NULL) ;</font><br/><br/>
当expression不满足时，就会报出一个很丑陋的框框，<br/>
然后向控制台输出assert不满足的文件和行号。<br/><br/>
具体到debug的时候，<br/>
可以撒网式地在各个地方放上认为应该为真的表达式的assert，<br/>
说不定哪个就爆了，于是趁机发现了问题。<br/><br/><font color="#0000ff">原理：</font><br/><br/>
只要有源码就没有秘密，<br/>
所以打开assert.h，看看里面是怎么写的。<br/><br/>
主要的就这两句：<br/><font color="#ff6600"><em>CRTIMP void __cdecl </em>assert(void </em>, void *, unsigned);<br/></p>

<h1>define assert(exp) (void)( (exp) || (_assert(#exp, <strong>FILE</strong>, <strong>LINE</strong>), 0) )</font><br/><br/></h1>

<p>第一句就干的就是输出一些信息，然后弹出个框框，<br/>
顺便结束程序这些勾当。<br/>
他被调用的时候，是类似于：<br/>
_assert(&#8220;false&#8221; , &#8220;c:\1.cpp&#8221; , 15)<br/>
这样。<br/><br/>
第二句的构造可谓精简啊，小小一句话还包含了挺多以前没注意到的事情。<br/><br/><font color="#ff6600">1.短路求值</font><br/><br/>
这个是c的重要特性，在处理&amp;&amp;的时候前面为假则不用继续，<br/>
在处理|| 的时候，前面为真则不用继续。<br/>
形象地说把后面的表达式短路了。<br/><br/><font color="#ff6600">2.单行宏</font><br/><br/></p>

<h1>exp 生成&#8221;exp&#8221;这样的字符串<br/></h1>

<h1>@a 生成&#8217;a&#8217;这样的字符<br/></h1>

<p>a##b 把a和b连接起来<br/><br/>
第一个用法在这里见到了，第二个暂时还没见到用的实例。<br/>
第三个在a和b是宏的参数的时候有用。否则直接的ab会被当作一个东西。<br/><br/><font color="#ff6600">3.特殊的预定义宏</font><br/><br/>
<strong>FILE</strong> 会被替换成所在的文件，字符串形式<br/>
<strong>LINE</strong> 会被替换成行号，unsigned类型<br/>
<strong>DATE</strong> 会被替换成日期<br/>
<strong>TIME</strong> 会被替换成时间<br/><br/>
其实之前翻过的跟C有关的书应该都讲了这些的。<br/>
不过拿着一个列表，又不给出真正实用的例子，<br/>
当然不知道这些东西是怎么回事，<br/>
久了自然也就忘了。<br/><br/><font color="#ff6600">4.逗号表达式</font><br/><br/>
感觉实在是一个用的很少的事情，<br/>
毕竟有多句话的时候，完全可以用分号就行了。<br/>
虽然有好多地方在if之类的里面很压缩的用逗号表达式写好几句话，<br/>
其实都可以改得不用逗号表达式的。<br/><br/>
其一是逗号表达式的优先级很低，所以后面那对括号实在是不可缺少。<br/><br/>
其二是逗号表达式的值为最右边式子的值。<br/>
这个估计很多人都记过，但不见得有啥重大意义。<br/>
这里，倒确实是发挥了他的意义。<br/>
因为<em>asert这个函数是void型的，<br/>
如果不使用逗号表达式在右边补个0的话，<br/>
会报告：（VC6)<br/>
error C2297: &#8216;||&#8217; : illegal, right operand has type &#8216;void&#8217;<br/><br/><font color="#0000ff">改编：</font><br/><br/>
知道是怎么回事，当然可以很容易做出自己想要的东西。<br/>
再说还有asert.h里面的参照呢。<br/><br/>
比如，我嫌默认的</em>assert弹出的东西看着太压抑了。。。<br/>
就自己写个就行了。<br/><br/></p>

<h1>include &lt;windows.h&gt;<br/></h1>

<h1>include &lt;stdio.h&gt;<br/></h1>

<h1>include &lt;stdlib.h&gt;<br/><br/></h1>

<h1>define MAX_BUFFER 200 <br/></h1>

<p>void _assert(char <em>msg , char </em>file , unsigned line){<br/>
     char buf[MAX_BUFFER] ;<br/>
     sprintf(buf , &#8220;assertion fail:\n%s\nin file:\n%s\non line:\n%d&#8221; , msg , file , line) ;<br/>
     ::MessageBox(NULL , buf , &#8220;assertion failure&#8221; , MB_OK) ;<br/>
     exit(0) ;<br/>
}<br/><br/></p>

<h1>define assert(exp) ((exp) || (_assert(#exp , <strong>FILE</strong> , <strong>LINE</strong>) , 0) )<br/><br/></h1>

<p>int main(){<br/>
     assert(1 == 1 &amp;&amp; 3 == 4) ;<br/>
     return 0 ;<br/>
}<br/><br/>
效果：<br/><br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/42a9f1f226242c3bb17ec52c.jpg" small="0" class="blogimg"/></div></p>

<br/>


<p>至于我的这个是不是更压抑。。那不属于这里讨论的问题了。<br/><br/>
反正通过简单变更_assert函数，可以把相关情况输出到文件，<br/>
或者选择另外的方式表达出来，能想到的都可以。<br/><br/>
至于assert这个宏，也有可以动手脚的地方。<br/>
自带的是assert一个为真的表达式。<br/>
有的时候就想assert一个为假的表达式，当他为真的时候发出警告。<br/><br/>
比如：<br/><br/><font color="#ff6600">FILE *fp = fopen(&#8220;in.txt&#8221;,&#8221;r&#8221;) ;<br/>
if ( ! fp ){<br/>
     exit(0) ;<br/>
}<br/>
warn(fp == NULL)</font><br/><br/>
套用上面的写法，既然是为真发警告，那么用&amp;&amp;去换||就行了。<br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/07/26/find%E5%AF%B9%E8%B1%A1%EF%BC%88word.vba%EF%BC%89/">find对象（word.vba）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-07-26T12:02:00+08:00" pubdate data-updated="true">Jul 26<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.7.26<br/><br/><font color="#0000ff">起因：</font><br/><br/>
看到王老师的这篇<a href="http://www.wangxiaofeng.net/?p=3537" target="_blank">日志</a>。<br/>
里面加粗了125的“的”字。<br/>
好家伙，这工作量可不小啊，很难想象人工操作要费多久。<br/><br/>
于是把word的宏搞出来用用，<br/><font color="#ff6600"><br/>
     n = Selection.Characters.Count<br/>
     For i = 1 To n<br/>
         If Selection.Characters(i) = &#8220;的&#8221; Then<br/>
             Selection.Characters(i).Bold = True &#8216;wdToggle<br/>
         End If<br/>
     Next i</font><br/><br/>
这不就可以了嘛。<br/><br/>
可是一执行就傻了，卡了好几十秒钟才做完。。<br/>
可见vb那个慢啊。。。<br/><font color="#0000ff"><br/>
经过：</font><br/><br/>
仔细想了一下，就没见王老师发过正儿八经的技术文章，<br/>
应该不至于沦落到写宏这步田地。。<br/><br/>
于是跑去问人了，发现原来word自己就有这个功能，囧啊。<br/>
就在平常经常用的替换功能里面，是可以设置格式的。。。<img src="http://img.baidu.com/hi/jx/j_0012.gif"/><br/><br/>
这不就结了嘛，比起写宏来说，<br/>
显然是老少皆宜啊。<br/><br/><img src="http://img.baidu.com/hi/jx/j_0025.gif"/>所以软件这东西啊，会用的人跟熟练工毕竟是有差别的。。。<br/><br/><font color="#0000ff">结果：</font><br/><br/>
其实写个宏到真没啥，不过没想到那么慢啊。。<br/>
Characters又是集合类型，还用for来一个一个地访问。。<br/><br/>
于是我猜有其他的办法，比如啥find方法之类的。<br/>
打开帮助，找find，没有find方法，倒是有<font color="#ff0000">find属性和find对象</font>。<br/><br/>
再一看，下面有几个例子，好强大的样子，可以设置的东西挺多的。<br/><br/>
正准备写，突然发现有点傻，<br/>
既然word自己就可以完成这个，那录制一下宏不就有了。<br/><br/>
把“的”字都替换成粗体的代码段：<br/><br/>
     Selection.Find.ClearFormatting<br/>
     Selection.Find.Replacement.ClearFormatting<br/>
     With Selection.Find<br/>
         .Text = &#8220;的&#8221;<br/>
         .Replacement.Text = &#8220;的&#8221;<br/>
       <font color="#ff0000"> .Replacement.Font.Bold = True</font><br/>
         .Forward = True<br/>
         .Wrap = wdFindContinue<br/>
         .Format = True<br/>
         .MatchCase = False<br/>
         .MatchWholeWord = False<br/>
         .MatchByte = True<br/>
         .MatchAllWordForms = False<br/>
         .MatchSoundsLike = False<br/>
         .MatchWildcards = False<br/>
         .MatchFuzzy = False<br/>
     End With<br/>
     Selection.Find.Execute Replace:=wdReplaceAll<br/><br/>
中间那句红色的在录制出来的时候是没有的，<br/>
不知道是什么原因，试了若干次都是如此。。。<br/>
于是自己加上去。。<br/><br/>
至于为什么要这么加，我也不知道。。<br/>
今天之前我不知道有find对象，更不所里面还含一个replacement对象，<br/>
而replacement对象还有个font对象，font对象还有bold属性。<br/><br/>
唯一知道的就是先打一个点出来，然后后面会跟一个列表，<br/>
看谁顺眼就选谁，继续点下去。。<br/>
看来vba是相当意识流的一个玩意儿。。。<br/><br/>
再加上详细的帮助，偶尔蛋疼一下是完全足够了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/07/23/%E4%B8%80%E4%B8%AA%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0%E7%9A%84%E5%9B%BE%E5%BD%A2%E6%BC%94%E7%A4%BA%28matlab%29/">一个线性筛素数的图形演示(matlab)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-07-23T11:30:00+08:00" pubdate data-updated="true">Jul 23<span>rd</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.7.23<br/><br/>
做完了之后，发现其实也并不直观到哪里去，<br/>
而且由于matlab绘图的原因，演示的范围很有限。<br/>
所以估计一下，知道的同学看了知道是啥意思，<br/>
不知道的同学也不用期望看这个就彻底理解了，<br/>
还是得去找找其他的详细解释来看看。<br/><br/><font color="#0000ff">matlab实现的线性筛素数：<br/></font><br/>
clear ;<br/>
N = 20 ;<br/>
marks = zeros(1,N) ;<br/>
primes = [] ;<br/>
for i = 2:N<br/>
     if ~marks(i)<br/>
         primes = [primes , i] ;<br/>
     end<br/>
     for j = 1:length(primes)<br/>
         if i * primes(j) &gt; N <br/>
             break ;<br/>
         end<br/>
         marks(i * primes(j)) = 1 ;<br/>
         if mod(i , primes(j)) == 0 <br/>
             break ;     <br/>
         end<br/>
     end<br/>
end<br/>
primes<br/><br/><font color="#0000ff">在各个步骤中加入绘图演示的程序：</font><br/><br/>
clear ;<br/>
T = 1 ;%单步间隔时间<br/>
N = 20 ;%演示到的点数<br/>
marks = zeros(1,N) ;<br/>
plot(1:N , ones(1,N) , &#8216;o&#8217;) ;<br/>
for i = 1:N<br/>
     text(i,0.9,int2str(i)) ;<br/>
end<br/>
axis([0 N+1 0 2]) ;<br/>
hold on ;<br/>
primes = [] ;<br/>
for i = 2:N<br/>
     quiver(i - 0.2 ,1.2 , 0.1 , -0.15 , 0) ;pause(T) ;<br/>
     if ~marks(i)<br/>
         primes = [primes , i] ;<br/>
         plot(i,1,&#8217;<em>&#8217;) ;pause(T) ;<br/>
         text(length(primes) , 1.5 , int2str(i)) ;<br/>
     end<br/>
     plot(1:length(primes) , 1.4 , &#8216;og&#8217;) ;pause(T) ;<br/>
     for j = 1:length(primes)<br/>
         if i * primes(j) &gt; N <br/>
             break ;<br/>
         end<br/>
         plot(j , 1.4 , &#8216;or&#8217;) ;pause(T) ;<br/>
         marks(i * primes(j)) = 1 ;<br/>
         plot(i * primes(j) , 1 , &#8216;xr&#8217;) ;<br/>
         plot(i * primes(j) , 1 , &#8216;or&#8217;) ;<br/>
         pause(T) ;<br/>
         if mod(i , primes(j)) == 0 <br/>
             break ;     <br/>
         end<br/>
     end<br/>
end<br/>
primes<br/><br/><font color="#0000ff">效果：</font><br/><br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/96aee1f8fa9b0a27d8f9fd8e.jpg" small="0" class="blogimg"/><br/>
最下面一行就是带筛选的数字。空圈表示还没被筛掉的。<br/>
蓝色</em>号是确定为素数的，红色X号是被筛掉的。<br/><br/>
上面的蓝色箭头指向当前正在考察的数字。<br/><br/>
上面的数字是当前得到的素数表。<br/>
数字下面的圆圈，为红的表示，考察过的。（即筛掉primes(j) * i)</div></p>

<br/>


<p>下面箭头的走势对应的是最外层i的循环，<br/>
上面的红圈表达的是对应j的循环。<br/><br/></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/backup-hplonline/blog/page/13/">&larr; Older</a>
    
    <a href="/backup-hplonline/blog/archives">Blog Archives</a>
    
    <a class="next" href="/backup-hplonline/blog/page/11/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/backup-hplonline/blog/2013/05/04/test/">Test</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/04/09/%E5%86%8D%E8%B0%88stl%E7%9A%84rotate/">再谈stl的rotate</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%BA%8C%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、二）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%89%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、三）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%80%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、一）</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - hplonline -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
