
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>hplonline</title>
  <meta name="author" content="hplonline">

  
  <meta name="description" content="(hplonline)2009.7.21
完全就是意思一下，
看起来有点假啊。。。
自己造个东西自己来玩。。
原理在上一篇的虚函数的底层机制
于是就可以通过改写虚函数表指针来达到执行其他代码的目的。
下面的shellcode先占够了24个位置，
然后在程序里面， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hupili.github.io/backup-hplonline/blog/page/13">
  <link href="/backup-hplonline/favicon.png" rel="icon">
  <link href="/backup-hplonline/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/backup-hplonline/atom.xml" rel="alternate" title="hplonline" type="application/atom+xml">
  <script src="/backup-hplonline/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/backup-hplonline/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/backup-hplonline/">hplonline</a></h1>
  
    <h2>backup from 2006 to 2012 (original hi.baidu.com/hplonline/)</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/backup-hplonline/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hupili.github.io/backup-hplonline" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/backup-hplonline/">Blog</a></li>
  <li><a href="/backup-hplonline/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/07/21/%E6%94%BB%E5%87%BB%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%88%E6%84%8F%E6%80%9D%E4%B8%80%E4%B8%8B%EF%BC%89/">攻击虚函数（意思一下）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-07-21T16:44:00+08:00" pubdate data-updated="true">Jul 21<span>st</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.7.21<br/><br/>
完全就是意思一下<img src="http://img.baidu.com/hi/jx/j_0016.gif"/>，<br/>
看起来有点假啊。。。<br/>
自己造个东西自己来玩。。<br/><br/>
原理在上一篇的<a href="http://hi.baidu.com/hplonline/blog/item/1bacf81f75e4026af724e485.html" target="_blank">虚函数的底层机制</a><br/><br/>
于是就可以通过改写虚函数表指针来达到执行其他代码的目的。<font color="#0000ff"><br/></font><br/>
下面的shellcode先占够了24个位置，<br/>
然后在程序里面，我们把20开始的双字设置成新的虚函数表的地址。<br/>
因为表项只有1个，所以就用一个int型的变量来假装个表了。<br/><font color="#0000ff"><br/>
程序：</font><br/><br/></p>

<h1>include &lt;iostream&gt;<br/><br/></h1>

<p>using namespace std ; <br/><br/>
char shellcode[] = {<br/>
0x90 , 0x90 , 0x90 , 0x90 , <br/>
0x90 , 0x90 , 0x90 , 0x90 , <br/>
0x90 , 0x90 , 0x90 , 0x90 , <br/>
0x90 , 0x90 , 0x90 , 0x90 , <br/>
0x90 , 0x90 , 0x90 , 0x90 , <br/>
0x90 , 0x90 , 0x90 , 0x90 , <br/>
0x00<br/>
} ; <br/><br/>
class mycls{<br/>
public:<br/>
     int other_member ;<br/>
     virtual fun(char <em>s){<br/>
          cout&lt;&lt;&#8221;I&#8217;m fun&#8221;&lt;&lt;endl ;<br/>
          cout&lt;&lt;s&lt;&lt;endl ;<br/>
     }<br/>
} ;<br/><br/>
void f(){<br/>
     cout&lt;&lt;&#8221;I&#8217;m f&#8221;&lt;&lt;endl ;<br/>
}<br/><br/>
int main(){<br/>
     mycls c ;<br/>
     char buf[20] ;<br/>
     mycls </em>p ;<br/>
     int pf ;<br/>
     pf = (int)f ;//<em>(int</em>)<em>(int</em>)&amp;c ;<br/>
     <em>(int</em>)(shellcode + 20) = (int)&amp;pf ;<br/>
     shellcode[24] = 0 ;<br/>
     strcpy(buf , shellcode) ;<br/>
     p = &amp;c ;<br/>
     p-&gt;fun(buf) ;<br/>
     return 0 ;<br/>
}<br/><br/>
结果：<br/><br/>
I&#8217;m f<br/>
（外加一个报错框）<br/><br/><font color="#0000ff">实际上的安排：</font><br/><br/>
上面借助了其他一些地方，而实际上整个内存可以这么安排：<br/><br/>
&lt;shellcode + 4&gt;&lt;nop&gt;&lt;nop&gt;&lt;nop&gt;&#8230;&#8230;&lt;nop&gt;&lt;real code&gt;&lt;nop&gt;&#8230;&lt;nop&gt;&lt;shellcode&gt;<br/><br/>
shellcode只开始的地址。于是最后一个&lt;shellcode&gt;作为数据淹没虚函数表的地址。<br/>
执行的时候，会把shellcode开始的地方当作是虚函数表。<br/>
然后查这个表的第一项，得到 shellcode+4 ， <br/>
把这个作为虚函数的实际地址调用，然后就进入到真正的代码段里面了。<br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/07/21/%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6/">虚函数的底层机制</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-07-21T13:58:00+08:00" pubdate data-updated="true">Jul 21<span>st</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.7.21<br/><br/><font color="#0000ff">环境：</font>VISTA+VC6+OD<br/><br/><font color="#0000ff">一。普通的类成员函数调用观察：</font><br/><br/>
先做一个最基本的<br/><br/></p>

<h1>include &lt;iostream&gt;<br/><br/></h1>

<p>using namespace std ;<br/><br/>
class mycls{<br/>
public:<br/>
     int member ;<br/>
     void output(){<br/>
          cout&lt;&lt;&#8221;I&#8217;m output&#8221;&lt;&lt;endl ;<br/>
     }<br/>
     void vf1(){<br/>
          cout&lt;&lt;&#8221;I&#8217;m vf1&#8221;&lt;&lt;endl ; <br/>
     }<br/>
     void vf2(){<br/>
          cout&lt;&lt;&#8221;I&#8217;m vf2&#8221;&lt;&lt;endl ;<br/>
     }<br/>
};<br/><br/>
int main(){<br/>
     mycls c ;<br/>
     mycls *p ;<br/><br/>
     cout&lt;&lt;sizeof(c)&lt;&lt;endl;<br/><br/>
     c.output() ;//.调用方式<br/><br/>
     p = &amp;c ;<br/>
     p-&gt;output() ;//-&gt;调用方式<br/>
     <br/>
     return 0 ;<br/>
}<br/><br/>
运行结果中，只有打出的sizeof是要看的，结果是4，为int member的空间。<br/><br/>
然后在OD里面看相应的调用代码：<br/><br/><font color="#ff6600">c.output() ;//.调用方式</font><br/>
004015B0    .  8D4D FC        lea      ecx, dword ptr [ebp-4]<br/>
004015B3    .  E8 01FBFFFF    call     <font color="#ff0000">004010B9</font><br/><br/><font color="#ff6600">p-&gt;output() ;//-&gt;调用方式</font><br/>
004015B8    .  8D45 FC        lea      eax, dword ptr [ebp-4]<br/>
004015BB    .  8945 F8        mov      dword ptr [ebp-8], eax<br/>
004015BE    .  8B4D F8        mov      ecx, dword ptr [ebp-8]<br/>
004015C1    .  E8 F3FAFFFF    call     004010B9<br/><br/>
这里看得出来-&gt;调用比.调用就是多了一点指针赋值而已。<br/>
而调用的类的地址放在ECX中，这是__thiscall的约定。<br/>
004010B9是output函数的地址，<br/>
作为普通成员函数，这里直接给出了一个固定的地址。<br/><br/>
跟到这个地址里面去看下：<br/>
004010B9    $ /E9 32050000    jmp      mycls::output<br/><br/>
这种造型的跳转很常见，就这句话的前后就有很多。<br/>
因为编译的时候不确定函数的地址，所以编译器只有留出个空位。<br/>
这里的空位就是连接器填上的。<br/><br/><font color="#0000ff">二。虚函数调用观察：</font><br/><br/>
把上前面那个程序中的函数都加上virtual来修饰：<br/><br/></p>

<h1>include &lt;iostream&gt;<br/><br/></h1>

<p>using namespace std ;<br/><br/>
class mycls{<br/>
public:<br/>
     int member ;<br/>
     <font color="#ff0000">virtual </font>void output(){<br/>
          cout&lt;&lt;&#8221;I&#8217;m output&#8221;&lt;&lt;endl ;<br/>
     }<br/>
   <font color="#ff0000"> virtual </font>void vf1(){<br/>
          cout&lt;&lt;&#8221;I&#8217;m vf1&#8221;&lt;&lt;endl ; <br/>
     }<br/>
     <font color="#ff0000">virtual </font>void vf2(){<br/>
          cout&lt;&lt;&#8221;I&#8217;m vf2&#8221;&lt;&lt;endl ;<br/>
     }<br/>
};<br/><br/>
int main(){<br/>
     mycls c ;<br/>
     mycls <em>p ;<br/><br/>
     cout&lt;&lt;sizeof(c)&lt;&lt;endl;<br/><br/>
     c.output() ;//.调用方式<br/><br/>
     p = &amp;c ;<br/>
     p-&gt;output() ;//-&gt;调用方式<br/>
     p-&gt;vf1() ;<br/>
     p-&gt;vf2() ;<br/>
     return 0 ;<br/>
}<br/><br/>
首先观察到的是sizeof出的数据为8。<br/>
原因是加入了虚函数后，在该类中要额外保存一个虚函数表的指针。<br/><br/>
对应的汇编代码如下：<br/>
（去掉了一些检查堆栈平衡之类的与这里研究无关的部分）<br/><br/><font color="#ff6600">     c.output() ;//.调用方式</font><br/>
004015D8    .  8D4D F8             lea      ecx, dword ptr [ebp-8]<br/>
004015DB    .  E8 F7FAFFFF         call     004010D7<br/><br/><font color="#ff6600">     p = &amp;c ;</font><br/>
004015E0    .  8D45 F8             lea      eax, dword ptr [ebp-8]<br/>
004015E3    .  8945 F4             mov      dword ptr [ebp-C], eax<br/><br/><font color="#ff6600">     p-&gt;output() ;//-&gt;调用方式</font><br/>
004015E6    .  8B4D F4             mov      ecx, dword ptr [ebp-C]<br/>
004015E9    .  8B11                mov      edx, dword ptr [ecx]<br/>
004015ED    .  8B4D F4             mov      ecx, dword ptr [ebp-C]<br/>
004015F0    .  FF12                call     dword ptr <font color="#ff0000">[edx]      </font>         <br/>
                             <br/><font color="#ff6600">     p-&gt;vf1() ;</font><br/>
004015F9    .  8B45 F4             mov      eax, dword ptr [ebp-C]<br/>
004015FC    .  8B10                mov      edx, dword ptr [eax]<br/>
00401600    .  8B4D F4             mov      ecx, dword ptr [ebp-C]<br/>
00401603    .  FF52 04             call     dword ptr <font color="#ff0000">[edx+4]</font><br/><br/><font color="#ff6600">     p-&gt;vf2() ;</font><br/>
0040160D    .  8B45 F4             mov      eax, dword ptr [ebp-C]<br/>
00401610    .  8B10                mov      edx, dword ptr [eax]<br/>
00401614    .  8B4D F4             mov      ecx, dword ptr [ebp-C]<br/>
00401617    .  FF52 08             call     dword ptr <font color="#ff0000">[edx+8]</font><br/><br/><font color="#ff0000">重要结论：.调用方式的虚函数在处理上和普通函数相同</font><br/>
这点很重要，在溢出攻击虚函数的时候，<br/>
如果该函数是用.方式调用，则随便怎么覆盖虚函数表的指针都没有意义。<br/><br/>
下面的三组指针方式调用在形式上都是差不多的。<br/>
看到最后对是对edx指向的地方加一个偏移处的值作为函数入口地址调用。<br/><br/>
用OD跟踪进去。发现EDX为0046F02C。<br/>
再到这个地址去看一下有什么内容：<br/>
[edx]<br/>
004010D7<br/>
[edx+4]<br/>
0040119A<br/>
[edx+8]<br/>
004012A3<br/>
（在OD中看到的这三个地址比较乱，<br/>
因为OD会当作代码的方式来组合排列，需要自己按四字节整理一下）<br/><br/>
所以对三个函数的调用最后会变成：<br/>
call 004010D7<br/>
call  0040119A<br/>
call 004012A3<br/><br/>
再分别到这三个地址去逛一圈，OD已经把符号名称标好了。<br/><br/>
004010D7    $ /E9 84050000         jmp      mycls::output<br/>
0040119A    . /E9 61050000         jmp      mycls::vf1<br/>
004012A3    . /E9 B8040000         jmp      mycls::vf2<br/><br/>
刚好就是要调用的三个函数。<br/><br/>
所以<font color="#ff0000">EDX可以视作是虚函数表的指针</font>，虚函数表给出了各个函数的入口地址。<br/>
（尽管真实的地址还是由链接器填上的jmp xxxx)<br/><br/>
再看下面的两句：<br/>
0040160D    .  8B45 F4             mov      eax, dword ptr [ebp-C]<br/>
00401610    .  8B10                mov      edx, dword ptr [eax]<br/><br/>
[ebp-C]就是指针p。<br/>
等于说edx = </em>(DWORD *)p ;<br/><font color="#ff0000"><br/>
再换句话，就是这里的虚函数表的入口地址放在了类的开头处，<br/>
在所有成员变量之前。</font><br/><br/><font color="#0000ff">三。虚函数表（VTABLE)地址的填入</font><br/><br/>
程序还是第二节的程序：<br/><br/>
在main函数开头的地方找到<br/>
004015B8    .  8D4D F8             lea      ecx, dword ptr [ebp-8]<br/>
004015BB    .  E8 D9FCFFFF         call     00401299<br/><br/>
进入00401299：<br/>
00401299    $ /E9 22040000         jmp      mycls::mycls<br/><br/>
根据名称来看，是构造函数， 继续进去。<br/>
004016DA  |.  894D FC             mov      dword ptr [ebp-4], ecx<br/>
004016DD  |.  8B45 FC             mov      eax, dword ptr [ebp-4]<br/>
004016E0  |.  C700 2CF04600       <font color="#ff0000">mov      dword ptr [eax], offset mycls::<code>vftable'&lt;/font&gt;&lt;br/&gt;&lt;br/&gt;
这几句在人看起来确实有点废话。。。不过能够表达那个意思就行了。&lt;br/&gt;
从最后一句看得出来，VTABLE的地址就是在这里填入的。&lt;br/&gt;&lt;br/&gt;
这里我们没有写构造函数，编译器自己加上的，&lt;br/&gt;
那如果给出一个什么都不干的构造函数，这个地址又怎么办了？&lt;br/&gt;&lt;br/&gt;
该前面的类加一个函数：&lt;br/&gt;
     mycls(){&lt;br/&gt;
          member = 1 ;&lt;br/&gt;
     }&lt;br/&gt;&lt;br/&gt;
跟踪到构造函数里面的代码：&lt;br/&gt;
0040167A  |.  894D FC             mov      &lt;font color="#ff6600"&gt;dword ptr [ebp-4]&lt;/font&gt;, ecx&lt;br/&gt;
0040167D  |.  8B45 FC             mov      eax, dword ptr [ebp-4]&lt;br/&gt;
00401680  |.  C700 1CF04600       mov      dword ptr [eax], offset mycls::</code>vftable&#8217;<br/>
00401686  |.  8B4D FC             mov      ecx, dword ptr [ebp-4]<br/>
00401689  |.  C741 04 01000000  <font color="#ff0000"> mov      dword ptr [ecx+4], 1</font><br/>
00401690  |.  8B45 FC             mov      eax, <font color="#ff6600">dword ptr [ebp-4]</font><br/><br/>
红色的是我们的标志语句，可见编译器是直接把相关代码给放在了我们的代码前面。<br/>
最后一句是个题外话，EAX里面放的值的根本来源是ECX，<br/>
即该对象的指针，<font color="#ff0000">这同时印证了构造函数不是没有返回，是返回该类的引用。</font><br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/07/20/%E6%8A%8Aqq%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E8%BD%AC%E5%8C%96%E6%88%90%E6%AF%94%E8%BE%83%E5%AE%B9%E6%98%93%E6%93%8D%E4%BD%9C%E7%9A%84%E6%A0%BC%E5%BC%8F/">把qq聊天记录转化成比较容易操作的格式</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-07-20T22:36:00+08:00" pubdate data-updated="true">Jul 20<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.7.20<br/><br/><font color="#0000ff">起因：</font><br/><br/>
有个群的管理员提出要踢人的需求。<br/>
那么踢谁留谁总得找点数据说话。<br/>
把qq2009翻了一遍，找到的唯一可以看的信息是，<br/>
某个人最后发言的时间。<br/><br/>
在普通活跃度的群当然，<br/>
凭个最后发言时间，或者发言条数，<br/>
都可以大致觉得这个人的参与程度。<br/><br/>
对于特别活跃的群，就不好说了。<br/>
可能大家都经常发言。<br/>
但是有的人往往是“啊”“哦”“嗯”，<br/>
或者是些乱七八糟的表情。<br/>
另外一些人可能很认真，<br/>
说得虽少，但每次都很有信息量。<br/>
这显然是要区别对待的。<br/><br/>
至于怎么给出这个所谓“参与程度”的标准，<br/>
那是后话了，<br/>
现在首先要解决的就是先把聊天记录整理出来，<br/>
便于实现任何需求的统计。<br/><br/><font color="#0000ff">分析：</font><br/><br/>
qq2009目前支持导出为三种格式：<br/><br/>
.bak，据说是加密的，除了导回之外，没办法提取里面的信息<br/>
（当然，高手来破解除外，即使破解了还要去迁就他的数据编排方式，麻烦）<br/><br/>
.mht，信息是完全保留了的，图片颜色具备<br/>
但是操作起来又麻烦，熟悉mht的格式倒是不很难，<br/>
况且有很多已经做好的库可以使用。<br/>
问题在于整理里面的信息，毕竟含量实在是太丰富了。<br/><br/>
.txt，很直观，编排大致上是有规律的，操作起来比较简单，<br/>
可以依赖现有知识解决，不用去学新的东西。<br/><br/>
所以这里就导出为.txt，然后对这个文件进行操作。<br/><br/><font color="#0000ff">格式上的问题：</font><br/><br/>
导出一个群的记录，<br/>
开头部分基本上是这样的：<br/><br/>
消息记录<br/><br/>
================================================================<br/>
消息分组:群列表<br/>
================================================================<br/>
消息对象:Hello qsh！<br/>
================================================================<br/><br/>
毕竟跟我们后面的消息条目没啥关系，<br/><font color="#ff6600">于是直接手动删掉。</font><br/>
（<font color="#ff0000">用后面给出的程序来提取的话，<br/>
最好是从消息开始的地方，手动复制到结尾，<br/>
重新存个文件。。。我也不知道为什么，<br/>
在原导出的文件上删掉前面的内容，<br/>
虽然视觉一样，读出的东西却有问题。。。。</font>）<br/><br/>
再观察每条消息的格式。<br/><br/>
发现聊天时的回车都被去掉了，自成一行。<br/>
所以大致是下面的样子：<br/><font color="#ff6600"><br/>
2009/1/20 21:00:38 [昵称[&lt;邮箱&gt;]][(qq号)]<br/>
消息<br/><br/>
2009/1/20 21:01:13 [昵称[&lt;邮箱&gt;]][(qq号)]<br/>
消息<br/></font><br/>
装怪就怪在。。有的地方只有qq号，有的地方只有昵称。<br/>
当然有的地方两个都有，还有地方都没有。。。。<br/>
而有昵称的地方，有的有绑定邮箱，有的没有。。。<br/><br/>
当然，这些并不是一开始就观察完全的。。<br/>
所以反复写了好久，RE过多次。<br/><br/>
然后就是结构设计上的问题。<br/>
由于昵称和qq号的不完备性，<br/>
只有额外引入一个本记录中的ID号，作为主键<br/>
用来标识一个用户。<br/><br/>
通过这个ID，来关联一个用户类型的结构体，<br/>
里面存放qq号，昵称，和以后可以添加的各种统计信息。<br/><br/>
另外一个关联类型，就是消息结构。<br/>
其中ID作为外键，另外记录时间和内容。<br/><br/>
最初统计的时候，分别用map来关联昵称或qq号 对应的ID。<br/>
由于之后要求按照ID对用户类型做操作，所以用vector来存放。<br/>
至于消息类型，统计的时候显然是顺次操作，<br/>
读入也是顺次的，于是就直接放list了。<br/><br/><font color="#0000ff">没意思的代码：</font><br/><br/>
下面的代码只对发言条数做过统计，<br/>
仅仅是用来验证读取模块是否正确。<br/>
在这个基础上，可以方便地加入其他的统计，获取感兴趣的方面。<br/><br/>
后来看到其他人用perl和python写的。。。。那真是一个短啊。。囧。。<br/>
于是有时间还是得学一学了，要不显得太土鳖了。。<br/>
不过定位不一样，仅仅做上面提到的按发言排序，就很简洁。<br/>
要多加点其他的东西还是挺费力的。<br/><br/></p>

<h1>pragma warning(disable:4786) <br/><br/></h1>

<h1>include &lt;iostream&gt;<br/></h1>

<h1>include &lt;stdio.h&gt;<br/></h1>

<h1>include &lt;list&gt;<br/></h1>

<h1>include &lt;map&gt;<br/></h1>

<h1>include &lt;string&gt;<br/></h1>

<h1>include &lt;vector&gt;<br/></h1>

<h1>include &lt;algorithm&gt;<br/><br/></h1>

<p>using namespace std ; <br/><br/>
const int MAX_MSG_LENGTH = 10000 ;<br/><br/>
typedef int ID ;<br/><br/>
typedef struct time_type{<br/>
     short year ;<br/>
     char month ;<br/>
     char day ;<br/>
     char hour ;<br/>
     char minute ;<br/>
     char second ;<br/>
}TIME ;<br/><br/>
typedef struct message_type{<br/>
     ID identifier ;<br/>
     TIME time;<br/>
     string content ;<br/>
}MESSAGE ;<br/><br/>
typedef struct user_type{<br/>
     string name ;<br/>
     string num ;<br/>
     int cnt_msg ;<br/>
}USER ;<br/><br/>
class qqmsg{<br/>
public:<br/>
     map&lt;string , int&gt; map_name2id ;<br/>
     map&lt;string , int&gt; map_num2id ;<br/>
     list&lt;MESSAGE&gt; list_msg ;<br/>
     vector&lt;USER&gt; vector_user ;<br/>
     void init() ;<br/>
     ID qqmsg::getid(char <em>str) ;<br/>
     bool read(char </em>filename) ;<br/>
     void statistics() ;<br/>
     void output() ;<br/>
} ;<br/><br/>
void qqmsg::init(){<br/>
     map_name2id.clear() ;<br/>
     map_num2id.clear() ;<br/>
     list_msg.clear() ;<br/>
     vector_user.clear() ;<br/>
}<br/><br/>
//标准化名称：<br/>
//name&lt;email@email.com&gt;<br/>
//name<br/>
//所以去掉含有&lt;&gt;的部分<br/>
void std_name(char <em>s){<br/>
     char </em>p = strstr(s , &#8220;&lt;&#8221;) ;<br/>
     if ( p != NULL ) {<br/>
          if ( strstr(p , &#8220;&gt;&#8221;)){<br/>
               <em>p = &#8216;\0&#8217; ;<br/>
          }<br/>
     }<br/>
}<br/><br/>
ID qqmsg::getid(char </em>str){<br/>
     char name[50] , blankspace , num[50] ;     <br/>
     USER tmp ;<br/>
     tmp.name = &#8220;&#8221; ;<br/>
     tmp.num = &#8220;&#8221; ;<br/>
     int ret = sscanf(str , &#8220;%<a href="%[^">^(\012</a>])&#8221; , &amp;name[-1] , num) ; //前面的一个空格读掉name[-1]<br/>
     std_name(name) ;<br/>
     if ( ret == 0 ) {<br/>
          //发生错误,什么都没有？<br/>
          return -1 ;<br/>
     }<br/>
     if ( ret == 2 ){<br/>
          tmp.name = name ;<br/>
          tmp.num = num ; <br/>
          if ( name[0] == &#8216;\0&#8217; ) {<br/>
               //只有qq号<br/>
               if ( map_num2id.count(tmp.num) ){<br/>
                    return map_num2id[tmp.num] ;     <br/>
               }else{<br/>
                    map_num2id[tmp.num] = vector_user.size() ;<br/>
                    vector_user.push_back(tmp) ;<br/>
                    return vector_user.size() ;<br/>
               }<br/><br/>
          }else{<br/>
               //qq号和昵称都有<br/>
               if ( map_num2id.count(tmp.num)){<br/>
                    int i = map_num2id[tmp.num] ;<br/>
                    map_name2id[tmp.name] = i ;<br/>
                    vector_user[i].name = tmp.name ;<br/>
                    return i ;<br/>
               }<br/>
               if ( map_name2id.count(tmp.name)){<br/>
                    int i = map_name2id[tmp.name] ;<br/>
                    map_num2id[tmp.num] = i ;<br/>
                    vector_user[i].num = tmp.num ;<br/>
                    return i ;<br/>
               }<br/>
               map_num2id[tmp.num] = vector_user.size() ;<br/>
               map_name2id[tmp.name] = vector_user.size() ;<br/>
               vector_user.push_back(tmp) ;<br/>
               return vector_user.size() - 1 ;<br/>
          }<br/>
     }else{<br/>
          //只有昵称<br/>
          tmp.name = name ;<br/>
          if ( map_name2id.count(tmp.name) ){<br/>
               return map_name2id[tmp.name] ;     <br/>
          }else{<br/>
               map_name2id[tmp.name] = vector_user.size() ;<br/>
               vector_user.push_back(tmp) ;<br/>
               return vector_user.size() ;<br/>
          }<br/>
     }<br/>
}<br/><br/>
bool qqmsg::read(char <em>filename){<br/>
     FILE </em>fp = fopen(filename , &#8220;r&#8221;) ;<br/>
     if ( fp == NULL ) return false ;<br/>
     <br/>
     char <em>buffer = new char[MAX_MSG_LENGTH] ;<br/>
     int n ;<br/><br/>
     MESSAGE tmp ;<br/>
     try{<br/>
          while ( 1 ){<br/>
               bool over = false ;<br/>
               while ( 1 ){<br/>
                    if ( !fgets(buffer , MAX_MSG_LENGTH , fp) ){<br/>
                         //读到文件的尾部了<br/>
                         over = true ;<br/>
                         break ;<br/>
                    }<br/>
                    //尝试按照消息头来读取，如果不正常，则忽略掉后面的内容，<br/>
                    //继续把下一行按照消息头来解析<br/>
                    if ( buffer[0] != &#8216;\012&#8217; ) {<br/>
                         int ret = sscanf(buffer , &#8220;%d/%d/%d %d:%d:%d%n&#8221; ,<br/>
                              &amp;tmp.time.year , &amp;tmp.time.month , &amp;tmp.time.day ,<br/>
                              &amp;tmp.time.hour , &amp;tmp.time.minute , &amp;tmp.time.second , &amp;n) ;          <br/>
                         if ( ret == 6 ) break ;<br/>
                    }               <br/>
               }<br/>
               if ( over ) break ;     <br/><br/>
               tmp.identifier = getid(buffer + n) ;<br/><br/>
               fgets(buffer , MAX_MSG_LENGTH , fp) ;<br/>
               tmp.content = buffer ;<br/>
               list_msg.push_back(tmp); <br/>
          }<br/>
     }catch(&#8230;){<br/>
          puts(buffer) ;<br/>
     }<br/><br/>
     delete buffer ;<br/>
     fclose(fp) ;<br/>
     return true ;<br/>
}<br/><br/>
void qqmsg::statistics(){<br/>
     vector&lt;USER&gt;::iterator vit ;<br/>
     for ( vit = vector_user.begin() ; vit != vector_user.end() ; vit ++ ){<br/>
          (</em>vit).cnt_msg = 0 ;<br/>
     }     <br/><br/>
     list&lt;MESSAGE&gt;::iterator lit ;<br/>
     for ( lit = list_msg.begin() ; lit != list_msg.end() ; lit ++ ){<br/>
          vector_user[(<em>lit).identifier].cnt_msg ++ ;<br/>
     }<br/>
}<br/><br/>
bool operator&lt;(const USER &amp;u1 , const USER &amp;u2){<br/>
     return u1.cnt_msg &gt; u2.cnt_msg ;<br/>
}<br/><br/>
void qqmsg::output(){<br/>
     vector&lt;USER&gt;::iterator it ;<br/>
     sort(vector_user.begin() , vector_user.end()) ;<br/>
     for ( it = vector_user.begin() ; it != vector_user.end() ; it ++ ){<br/>
          printf(&#8220;%40s %10s %d\n&#8221; , (</em>it).name.c_str() , (<em>it).num.c_str() , (</em>it).cnt_msg ) ;<br/>
     }<br/>
}<br/><br/>
int main(){<br/>
     qqmsg msg ;<br/>
     msg.init() ;<br/>
     msg.read(&#8220;3.txt&#8221;) ;<br/>
     msg.statistics() ;<br/>
     msg.output() ;<br/>
     return 0 ;<br/>
}</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/07/19/scanf%E7%9A%84%E4%B8%89%E7%82%B9%E4%B8%8D%E5%B8%B8%E8%A7%81%E4%BD%86%E5%BE%88%E5%AE%9E%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E5%BF%BD%E7%95%A5%E5%8F%98%E9%87%8F%EF%BC%8C%E6%89%AB%E6%8F%8F%E5%AD%97%E7%AC%A6%EF%BC%8C%E8%AF%BB%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%AA%E6%95%B0%EF%BC%89/">Scanf的三点不常见但很实用的方法（忽略变量，扫描字符，读入字符个数）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-07-19T01:10:00+08:00" pubdate data-updated="true">Jul 19<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.7.19<br/><br/>
一直学得很囫囵吞枣，<br/>
拿到问题的时候，总是很暴力地用已有的知识去解决，<br/>
很少去了解一些新的东西。<br/><br/>
而往往的经验是，<font color="#ff0000">终日而思，不如须臾之所学</font>。<br/><br/>
下面的内容都有相关的实例支撑，<br/>
不使用这些手段也可以解决，<br/>
但是可能稍微费事一点。<br/><font color="#0000ff"><br/></font><font color="#0000ff">一。忽略变量(%<em>?)</font><br/><br/>
这个还算容易见到一点：<br/><font color="#ff6600"><br/>
      int i ;<br/>
      scanf(&#8220;%</em>d %d&#8221; , &amp;i) ;<br/>
      printf(&#8220;%d&#8221; , i) ;</font><br/><br/>
输入：<br/>
1 2<br/>
输出：<br/>
2<br/><br/>
不用他当然也可以，定义一个废的变量，<br/>
在实参的地方占个位置，往里面读就行了。<br/><br/>
但是用*的好处在于，减少传参。<br/><br/><font color="#0000ff">二。扫描字符(%[<sup>?])</font><br/><br/></sup>
这个问题比较实际，如果要读入形如下面的数据：<br/>
(123)  (456)<br/>
要的是括号里面的东西，但是不含括号。也就是123和456。<br/><br/>
如果确定了里面都是是数字，当然很好写：<br/><font color="#ff6600"><br/>
      int i1 , i2 ;<br/>
      scanf(&#8220;(%d) (%d)&#8221; , &amp;i1 , &amp;i2) ;<br/>
      printf(&#8220;%d %d&#8221; , i1 , i2) ;</font><br/><br/>
如果告诉你要读入的是串字符呢：<br/>
(aaa) (bbb)<br/><br/>
难道是这样？<br/>
scanf(&#8220;(%s) (%s)&#8221; , s1 , s2) ;<br/><br/>
显然不行。%s会一直读到空格符。<br/><br/>
解决方法：<br/><br/><font color="#ff6600">      char s1[100] , s2[100] ;<br/>
      scanf(&#8220;(%[<sup>)])</sup> (%[<sup>)])&#8221;</sup> , s1 , s2 ) ;<br/>
      puts(s1) ;<br/>
      puts(s2) ;<br/></font><br/>
在[<sup>&#8230;]里面指定字符串的截止符。<br/><br/></sup>
输入：<br/>
(aaa) (bbb)<br/><br/>
输出：<br/>
aaa<br/>
bbb<br/><br/>
看来是达到效果了。<br/><br/><font color="#0000ff">三。读入字符个数(%n)</font><br/><br/>
这个问题也比较实在。<br/>
比如，有这样一个题。<br/><br/>
给一组整数，每行有多少个无法确定。<br/>
要求给出每行的和。<br/>
数据以end结束。<br/><br/>
比如：<br/><br/>
1 2 3 <br/>
4 5<br/>
6 7 8 9 10<br/>
11 <br/>
end<br/><br/>
题目的意思是相当直观的，<br/>
主要的问题就在于编码上面。<br/><br/>
不妨先动手试做一个，然后看看下面这段：<br/><br/><font color="#ff6600">int main(){<br/>
      char tmp[100] ;<br/>
      int sum , n , base , t;<br/>
      while ( gets(tmp) ){<br/>
            if ( strcmp(tmp , &#8220;end&#8221;) == 0 ) break ;<br/>
            sum = 0 ;<br/>
            base = 0 ;<br/>
            while ( sscanf(tmp + base, &#8220;%d%n&#8221; , &amp;t , &amp;n) == 1 ){<br/>
                  base += n ;<br/>
                  sum += t ;<br/>
            } <br/>
            printf(&#8220;%d\n&#8221; , sum) ;<br/>
      }<br/>
      return 0 ;<br/>
}</font><br/><br/>
控制台情况：（输入输出均在内）<br/><br/>
1 2 3<br/>
6<br/>
4 5<br/>
9<br/>
6 7 8 9 10<br/>
40<br/>
11<br/>
11<br/>
end<br/>
Press any key to continue<br/><br/>
首先，每一行打头的要么是个整数要么是“end”。<br/>
这就与一般ACM那些以-1结尾的不同了。<br/><br/>
为了检验，只有先按照字符串全部读入。<br/>
就是外层循环的gets。<br/><br/>
之后做个比较，是很普通的一件事。<br/>
如果是end那么退出。<br/><br/>
关键就在于，如果不是end。而一行的数字有多少个没法确定。<br/>
每个数字有多少个位数也不好确定。<br/><br/>
这里，既然数据都到了一个tmp的字符数组里面，<br/>
当然要用sscanf来搞定后面的操作了。<br/><br/>
读入了前面的字符后，通过对tmp加上一定的偏移，<br/>
就可以实现继续读后面的数字，<br/>
而sscanf返回成功读入的变量的个数，<br/>
通过这个可以判断是否读完了。<br/><br/>
最后的问题就在于，怎么得到偏移了多少。<br/>
这时%n就帮上忙了，通过他，可以得知已经读过了多少字符。<br/><br/>
另外，printf的返回值就是打印的字符数，<br/>
有的时候，在向一个缓冲区输出的时，可以直接用他的返回值来偏移。<br/>
而scanf的返回值是成功读入的变量数，<br/>
于是只有把%n利用起来。<br/><br/><font color="#0000ff">总结：</font><br/><br/>
这些内容当然可以用其他的办法解决。<br/>
第一个的已经说了。<br/>
至于后两个，可以用getchar，边读边判断。<br/>
这一定是可行的，因为给你getchar，你可以做出scanf等等。。。<br/><br/>
但有的时候，只要充分了解一点现有的东西，<br/>
就可以少费很多事。<br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/07/17/%E7%AC%AC%E4%B8%80%E4%B8%AADirectX%E7%A8%8B%E5%BA%8F/">第一个DirectX程序</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-07-17T17:55:00+08:00" pubdate data-updated="true">Jul 17<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.7.17<br/><br/>
其实几年前就找过相关的东西看了。<br/>
楞是看不懂啊。。<br/>
不过倒是一直对一些词汇有点映象，<br/>
什么表面啊，翻转啊。。。<br/>
也不算坏。<br/><br/>
今天终于憋出来了第一个DirectDraw的练习。<br/>
做的就是一堆“hplonline”，有不同的颜色，<br/>
以不同的方向和速度，从屏幕左上角的点往其他方向跑。<br/>
这个东西我试了下没法截图，囧。<br/>
貌似听说有可以搞定的软件，不过难得去找了。<br/><br/><font color="#0000ff">流程：</font><br/><br/>
网上有个被转载了好多份的代码，<br/>
大致上是看得很清楚的了。<br/><br/><font color="#ff6600">前期准备：</font><br/>
创建DirectDraw对象<br/>
设置合作模式<br/>
设置显示模式<br/>
创建主DirectSurface<br/>
取得关联的从DirectSurface（后台表面）<br/><br/><font color="#ff6600">刷新：</font><br/>
在后台表面上绘图<br/>
翻转直到成功<br/><br/>
通过Surface 的GetDC方法，<br/>
可以取得一个与之相关的DC。<br/>
就可以用通常用的GDI函数来绘制了。<br/><br/><font color="#0000ff">几点很重要的小事：</font><br/><br/>
刚开始，以为把DX SDK下下来，安好，就万事大吉。<br/>
于是去找些别人写好的源码，发现不能编译啊。。囧。。<br/><br/>
首先tool-&gt;options-&gt;directories里面，<br/>
设置好相关的include和lib文件夹的位置。<br/><br/>
然后，包含相关的头文件，<br/>
这个一般找到的源码都是做了的。<br/><br/>
最后就是把lib添加进去，<br/>
可以用#pragma comment，<br/>
也可以在<br/>
project-&gt;settings-&gt;link<br/>
的object/library里面添加上。<br/><br/>
个人倾向的还是用#pragma的方式。<br/>
这样，当发出去的源码被copy到了N多地方之后，<br/>
还可以直接编译，不用去改工程的设置。<br/><br/>
还有个注意的就是，创建窗口的时候。<br/>
至少给dwStyle指定一个WS_POPUP。<br/>
如果是NULL的话，创建出来的默认造型里面，<br/>
又有边框，又有标题栏。<br/>
于是画图的时候闪烁很厉害。<br/><br/><font color="#0000ff">代码：</font><br/><br/></p>

<h1>include &lt;stdio.h&gt;<br/></h1>

<h1>include &lt;windows.h&gt;<br/><font color="#ff0000">#include &lt;ddraw.h&gt;</font><br/></h1>

<h1>include &lt;list&gt;<br/></h1>

<h1>include &lt;stdlib.h&gt;<br/></h1>

<h1>include &lt;time.h&gt;<br/><br/></h1>

<p>using namespace std ;<br/><br/><font color="#ff0000">#pragma comment(lib , &#8220;ddraw.lib&#8221;)</font><br/><br/>
const int wndWidth = 640 ;<br/>
const int wndHeight = 480 ;<br/><br/>
typedef struct label_type{<br/>
     int x , y ;<br/>
     int dx , dy ;<br/>
     COLORREF color ;<br/>
     HFONT hfont ;<br/>
}LABEL ;<br/><br/>
HWND g_hWnd ;<br/>
LPDIRECTDRAW g_lpDD ;<br/>
LPDIRECTDRAWSURFACE g_lpDDSPrimary ;<br/>
LPDIRECTDRAWSURFACE g_lpDDSBack ;<br/>
RECT scrRect ;<br/><br/>
BOOL g_bActive = TRUE;<br/><br/>
list&lt;LABEL&gt; lLabel ;<br/><br/>
//here:sample of message handling function<br/>
LRESULT OnKeyDown(WPARAM wParam , LPARAM lParam){<br/>
     if ( wParam == VK_ESCAPE ) PostQuitMessage(0) ;<br/>
     return 0 ;//An application should return zero if it processes this message<br/>
}<br/><br/>
LRESULT OnQuit(WPARAM wParam ,LPARAM lParam){<br/>
     if ( g_lpDDSPrimary != NULL ) {<br/>
          g_lpDDSPrimary-&gt;Release() ;<br/>
          g_lpDDSPrimary = NULL ;<br/>
     }<br/>
     if ( g_lpDD != NULL ){<br/>
          g_lpDD-&gt;Release() ;<br/>
          g_lpDD = NULL ;<br/>
     } <br/>
     return 0 ;//<br/>
}<br/><br/>
LRESULT OnActivate(WPARAM wParam ,LPARAM lParam){<br/>
     g_bActive = LOWORD(wParam) ;<br/>
     return 0 ;//<br/>
}<br/><br/>
LRESULT OnSetCursor(WPARAM wParam ,LPARAM lParam){<br/>
     SetCursor(NULL) ;<br/>
     return 0 ;//<br/>
}<br/><br/>
LRESULT CALLBACK myWindowProc(<br/>
  HWND hwnd,       // handle to window<br/>
  UINT uMsg,       // message identifier<br/>
  WPARAM wParam,  // first message parameter<br/>
  LPARAM lParam    // second message parameter<br/>
  ){<br/>
     switch(uMsg){<br/>
     case WM_KEYDOWN : return OnKeyDown(wParam , lParam) ; break ;<br/>
     case WM_QUIT: return OnQuit(wParam , lParam) ; break ;<br/>
     case WM_ACTIVATE: return OnActivate(wParam , lParam) ; break ;<br/>
     case WM_SETCURSOR:return OnSetCursor(wParam , lParam) ;break ;<br/>
          //here:add more message routing<br/>
     default:return DefWindowProc(hwnd , uMsg , wParam , lParam) ;     <br/>
     }<br/>
}<br/><br/>
BOOL myCreateWindow(HINSTANCE hInstance){<br/>
     //here:design your window<br/>
     WNDCLASS myCls ;<br/>
     myCls.cbClsExtra = NULL ;<br/>
     myCls.cbWndExtra = NULL ;<br/>
     myCls.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH) ;<br/>
     myCls.hCursor = LoadCursor(NULL , IDC_ARROW) ;<br/>
     myCls.hIcon = LoadIcon(NULL , IDI_APPLICATION) ;<br/>
     myCls.hInstance = hInstance ;<br/>
     myCls.lpfnWndProc = myWindowProc ;<br/>
     myCls.lpszClassName = &#8220;mywndclass&#8221; ;<br/>
     myCls.lpszMenuName = NULL ;<br/>
     myCls.style = NULL ; //CS_HREDRAW | CS_VREDRAW ;<br/><br/>
     RegisterClass(&amp;myCls) ;<br/><br/>
     int scrWidth = GetSystemMetrics(SM_CXSCREEN) ;<br/>
     int scrHeight = GetSystemMetrics(SM_CYSCREEN) ;<br/><br/>
     //WS_POPUP的指定十分有必要，否则会创建出普通窗体，<br/>
     //即含有边框和标题栏。<br/>
     g_hWnd = CreateWindow(&#8220;mywndclass&#8221; , &#8220;my window(esc for quit)&#8221; ,<font color="#ff0000"> WS_POPUP , </font><br/>
          (scrWidth - wndWidth) / 2 , (scrHeight - wndHeight) / 2 , <br/>
          wndWidth , wndHeight , NULL , NULL , hInstance , NULL) ;<br/><br/>
     ShowWindow(g_hWnd , SW_SHOW) ;<br/><br/>
     return TRUE ;<br/>
}<br/><br/>
void ReportError(char <em>msg){<br/>
     MessageBox(NULL , msg , &#8220;error&#8221; , MB_OK) ;<br/>
}<br/><br/>
void InitLabel(){<br/>
     lLabel.clear() ;<br/>
}<br/><br/>
void RefreshLabel(){<br/>
     list&lt;LABEL&gt;::iterator it ;<br/>
     for ( it = lLabel.begin() ; it != lLabel.end() ; ){<br/>
          LABEL &amp;tmpl = </em>it ;<br/>
          tmpl.x += tmpl.dx ;<br/>
          tmpl.y += tmpl.dy ;<br/>
          if ( tmpl.x &gt; wndWidth || tmpl.y &gt; wndHeight ) {<br/>
               DeleteObject((<em>it).hfont) ;<br/>
               it = lLabel.erase(it) ;<br/>
          }else {<br/>
               ++ it ;<br/>
          }<br/>
     }<br/><br/>
}<br/><br/>
//CALLBACK of timer<br/>
VOID CALLBACK AddLabel(HWND hwnd, UINT a, UINT b, DWORD c){<br/>
     LABEL tmpl ;<br/>
     tmpl.x = 0 ;<br/>
     tmpl.y = 0 ;<br/>
     tmpl.color = RGB(rand() % 200 + 56 , rand() % 200 + 56 , rand() % 200 + 56) ;<br/>
     tmpl.dx = rand() % 40 ;<br/>
     tmpl.dy = rand() % 40 ;<br/>
     LOGFONT logfont ;<br/>
     memset(&amp;logfont , 0 , sizeof(logfont)) ;<br/>
     logfont.lfHeight = rand() % 30 + 10 ;<br/>
     logfont.lfWidth = rand() % 30 + 10 ;<br/>
     tmpl.hfont = CreateFontIndirect(&amp;logfont) ;<br/>
     lLabel.push_back(tmpl) ;<br/>
}<br/><br/>
BOOL myDraw(){<br/>
     HDC hdc ;<br/><br/>
     if ( g_lpDDSBack-&gt;GetDC(&amp;hdc) != DD_OK ){<br/>
     //     ReportError(&#8220;get dc error&#8221;) ;<br/>
          return FALSE ;<br/>
     }<br/><br/>
     FillRect(hdc , &amp;scrRect , (HBRUSH)GetStockObject(BLACK_BRUSH)) ;<br/><br/>
     RefreshLabel() ;<br/>
     list&lt;LABEL&gt;::iterator it ;<br/>
     SetBkMode(hdc , TRANSPARENT) ;<br/>
     for ( it = lLabel.begin() ; it != lLabel.end() ; it ++ ){<br/>
          SetTextColor(hdc , (</em>it).color) ;<br/>
          SelectObject(hdc , (<em>it).hfont) ;<br/>
          TextOut(hdc , (</em>it).x , (*it).y , &#8220;hplonline&#8221; , 9) ;<br/>
     }<br/><br/>
     g_lpDDSBack-&gt;ReleaseDC(hdc) ;<br/><br/>
     while ( g_lpDDSPrimary-&gt;Flip(NULL , 0 ) == DDERR_WASSTILLDRAWING ){<br/>
          Sleep(10) ;<br/>
     }<br/><br/>
     return TRUE ;<br/>
}<br/><br/>
BOOL myInitDX(){<br/>
     HRESULT ret ;<br/>
     <br/>
     ret = DirectDrawCreate(NULL , &amp;g_lpDD , NULL) ;<br/>
     if ( ret != DD_OK ) {<br/>
          ReportError(&#8220;can&#8217;t create directdraw object&#8221;) ;<br/>
          return FALSE ;<br/>
     }<br/><br/>
     ret = g_lpDD-&gt;SetCooperativeLevel(g_hWnd , DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN ) ;<br/>
     if ( ret != DD_OK ){<br/>
          ReportError(&#8220;set cooperative failed!&#8221;) ;<br/>
          return FALSE ;<br/>
     }<br/><br/>
     ret = g_lpDD-&gt;SetDisplayMode(640 , 480 , 8) ;<br/>
     scrRect.left = 0 ;<br/>
     scrRect.right = wndWidth ;<br/>
     scrRect.top = 0 ;<br/>
     scrRect.bottom = wndHeight ;<br/>
     if ( ret != DD_OK ){<br/>
          ReportError(&#8220;set display mode failed!&#8221;) ;<br/>
          return FALSE ;<br/>
     }<br/>
     <br/>
     DDSURFACEDESC ddsd ;<br/>
     ddsd.dwSize = sizeof(ddsd) ;<br/>
     ddsd.dwFlags = DDSD_BACKBUFFERCOUNT ;<br/>
     ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | DDSCAPS_FLIP | DDSCAPS_COMPLEX ;<br/>
     ddsd.dwBackBufferCount = 1 ;<br/>
     ret = g_lpDD-&gt;CreateSurface(&amp;ddsd , &amp;g_lpDDSPrimary , NULL) ;<br/>
     if ( ret != DD_OK ){<br/>
          ReportError(&#8220;create primary surface failed&#8221;) ;<br/>
          return FALSE ;<br/>
     }<br/><br/>
     DDSCAPS ddscaps ;<br/>
     ddscaps.dwCaps = DDSCAPS_BACKBUFFER ;<br/>
     ret = g_lpDDSPrimary-&gt;GetAttachedSurface(&amp;ddscaps , &amp;g_lpDDSBack) ;<br/>
     if ( ret != DD_OK ){<br/>
          ReportError(&#8220;create back surface failed&#8221;) ;<br/>
          return FALSE ;<br/>
     }<br/><br/>
     return TRUE ;<br/>
}<br/><br/>
int WINAPI WinMain(<br/>
  HINSTANCE hInstance,  // handle to current instance<br/>
  HINSTANCE hPrevInstance,  // handle to previous instance<br/>
  LPSTR lpCmdLine,       // pointer to command line<br/>
  int nCmdShow           // show state of window<br/>
  ){     <br/>
     MSG msg ;<br/>
     <br/>
     myCreateWindow(hInstance) ;<br/>
     <br/>
     srand(time(NULL)) ;<br/><br/>
     if ( !myInitDX()){<br/>
          ReportError(&#8220;failed init DX&#8221;) ;<br/>
          return -1 ;<br/>
     }<br/><br/>
     InitLabel() ;<br/>
     SetTimer(g_hWnd , 0 , 500 , AddLabel) ;<br/><br/>
     while (1){<br/>
          if ( PeekMessage(&amp;msg , NULL , NULL , NULL , PM_NOREMOVE)){<br/>
               if ( !GetMessage(&amp;msg , NULL , NULL , NULL) ) {<br/>
                    return msg.wParam ;<br/>
               }<br/>
               TranslateMessage(&amp;msg) ;<br/>
               DispatchMessage(&amp;msg) ;<br/>
          }else{<br/>
               if ( g_bActive ){<br/>
                    myDraw() ;<br/>
                    Sleep(100) ;<br/>
               }<br/>
          }<br/>
     }<br/><br/>
     KillTimer(g_hWnd , 0) ;<br/><br/>
     return msg.wParam ;<br/>
}</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/07/17/%E8%B4%B4%E4%B8%AAwin32%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%80%E5%B0%8F%E6%A1%86%E6%9E%B6%EF%BC%88VC6%29/">贴个win32程序的最小框架（VC6)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-07-17T13:38:00+08:00" pubdate data-updated="true">Jul 17<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.7.17<br/><br/>
记得两年前，刚开始看孙鑫老师的书时，<br/>
对老师那熟练的打字佩服得五体投地。<br/><br/>
当时完全没法理解，<br/>
后来也在不同的时间又多少做过一些练习。<br/>
昨天突然想起准备玩下DX，<br/>
还是先做个应用程序的框架出来好用。<br/><br/>
没想到那么一拍就出来了。。<br/>
具体的过程居然也貌似可以正背如流了：<br/><br/><font color="#ff6600">设计窗口过程<br/><br/>
设计窗口类<br/>
注册窗口类<br/>
创建窗口<br/><br/>
消息循环</font><br/><br/>
还是卖油翁的那句话：但手熟尔。<br/>
老师其实也是如此。。<br/><br/>
倒是消息循环的设计有一点讲究，<br/>
如果要充分利用计算资源的话，<br/>
可以用PeekMessage。这个函数不会阻塞，<br/>
可以在没有消息处理的时候干点别的事情。<br/><br/>
不过也完全可以就用一般的GetMessage的框架，<br/>
反正要大量计算的时候再开个线程就是了。<br/><br/><font color="#0000ff">代码：</font><br/><br/></p>

<h1>include &lt;stdio.h&gt;<br/></h1>

<h1>include &lt;windows.h&gt;<br/><br/></h1>

<p>//here:sample of message handling function<br/>
LRESULT OnKeyDown(WPARAM wParam , LPARAM lParam){<br/>
     if ( wParam == VK_ESCAPE ) PostQuitMessage(0) ;<br/>
     return 0 ;//An application should return zero if it processes this message<br/>
}<br/><br/>
LRESULT CALLBACK myWindowProc(<br/>
  HWND hwnd,       // handle to window<br/>
  UINT uMsg,       // message identifier<br/>
  WPARAM wParam,  // first message parameter<br/>
  LPARAM lParam    // second message parameter<br/>
  ){<br/>
     switch(uMsg){<br/>
     case WM_KEYDOWN : return OnKeyDown(wParam , lParam) ; break ;<br/>
          //here:add more message routing<br/>
     default:return DefWindowProc(hwnd , uMsg , wParam , lParam) ;     <br/>
     }<br/>
}<br/><br/>
BOOL myCreateWindow(HINSTANCE hInstance){<br/>
     //here:design your window<br/>
     WNDCLASS myCls ;<br/>
     myCls.cbClsExtra = NULL ;<br/>
     myCls.cbWndExtra = NULL ;<br/>
     myCls.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH) ;<br/>
     myCls.hCursor = LoadCursor(NULL , IDC_ARROW) ;<br/>
     myCls.hIcon = LoadIcon(NULL , IDI_APPLICATION) ;<br/>
     myCls.hInstance = hInstance ;<br/>
     myCls.lpfnWndProc = myWindowProc ;<br/>
     myCls.lpszClassName = &#8220;mywndclass&#8221; ;<br/>
     myCls.lpszMenuName = NULL ;<br/>
     myCls.style = CS_HREDRAW | CS_VREDRAW ;<br/><br/>
     RegisterClass(&amp;myCls) ;<br/><br/>
     int scrWidth = GetSystemMetrics(SM_CXSCREEN) ;<br/>
     int scrHeight = GetSystemMetrics(SM_CYSCREEN) ;<br/>
     const int wndWidth = 640 ;<br/>
     const int wndHeight = 480 ;<br/><br/>
     HWND hWnd = CreateWindow(&#8220;mywndclass&#8221; , &#8220;my window(esc for quit)&#8221; , NULL , <br/>
          (scrWidth - wndWidth) / 2 , (scrHeight - wndHeight) / 2 , <br/>
          wndWidth , wndHeight , NULL , NULL , hInstance , NULL) ;<br/><br/>
     ShowWindow(hWnd , SW_SHOW) ;<br/><br/>
     return TRUE ;<br/>
}<br/><br/>
int WINAPI WinMain(<br/>
  HINSTANCE hInstance,  // handle to current instance<br/>
  HINSTANCE hPrevInstance,  // handle to previous instance<br/>
  LPSTR lpCmdLine,       // pointer to command line<br/>
  int nCmdShow           // show state of window<br/>
  ){<br/>
     MSG msg ;<br/>
     <br/>
     myCreateWindow(hInstance) ;<br/>
     <br/>
     while ( GetMessage(&amp;msg , NULL , NULL , NULL) ){<br/>
          TranslateMessage(&amp;msg) ;<br/>
          DispatchMessage(&amp;msg) ;<br/>
     }<br/><br/>
     return msg.wParam ;<br/>
}<br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/07/15/switch..case..%E6%A0%87%E7%AD%BE..%E6%8E%92%E7%89%88/">switch..case..标签..排版</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-07-15T14:34:00+08:00" pubdate data-updated="true">Jul 15<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.7.15<br/><br/>
上一篇不知道怎么提到排版的问题了。<br/>
当然就说到了强大的alt+f8。<br/>
于是又想到了跟switch有关的一点猥琐事情。<br/><br/><font color="#0000ff">例一：</font><br/><br/>
下面的程序的输出是？<br/><br/><font color="#339966">#include &lt;stdio.h&gt;</font><br/><font color="#0000ff">int</font> main(){<br/>
   <font color="#0000ff"> int </font>a = 0 ;<br/>
      <font color="#0000ff">switch</font>(a){<br/>
      <font color="#0000ff">case</font> 1:puts(&#8220;aaaa&#8221;) ;<font color="#0000ff">break</font> ;<br/>
      <font color="#0000ff">defau1t</font>:puts(&#8220;bbbb&#8221;) ;<font color="#0000ff">break</font> ;<br/>
      } ;<br/>
  <font color="#0000ff">  return</font> 0 ;<br/>
}<br/><br/>
其实就是什么都不输出。。<br/>
虽然default打错了，<br/>
但是他的欺骗性在于defau1t会被认为是标签，<br/>
于是这段是符合语法的。<br/><br/>
至少有三个办法看出这个问题。<br/>
1.放到IDE里面去，没有被标注高亮的颜色。<br/>
2.特明显的就是VC6的alt+f8。<br/>
被排过后，标签始终是顶到行首的，一眼就看出来了。<br/>
3.编译器要给出一个：<br/>
warning C4102: &#8216;defau1t&#8217; : unreferenced label<br/><br/><br/><font color="#0000ff">例二：</font><br/><br/>
在河畔上遇到有人问的。<br/>
帮忙改下面的程序，他得不到期望的结果：<br/><br/></p>

<h1>include&lt;iostream&gt;<br/></h1>

<h1>include&lt;iomanip&gt;<br/></h1>

<p>using namespace std;<br/>
int main()<br/>
{<br/>
      enum color{red,yellow,blue,white,black};<br/>
      color pri;<br/>
      int i,j,k,n=0,loop;<br/>
      for(i=red;i&lt;=black;i++)<br/>
          for(j=red;j&lt;=black;j++)<br/>
          if(i!=j)<br/>
          {for(k=red;k&lt;=black;k++)<br/>
          if((k!=i)&amp;&amp;(k!=j))<br/>
          {<br/>
          n=n+1;<br/>
          cout&lt;&lt;setw(3)&lt;&lt;n;<br/>
          for(loop=1;loop&lt;=3;loop++)<br/>
          {switch(loop){<br/>
          case1:pri=color(i);break;<br/>
          case2:pri=color(j);break;<br/>
          case3:pri=color(k);break;<br/>
          default:break;<br/>
          }<br/>
          switch(pri)<br/>
          {<br/>
          case red:cout&lt;&lt;setw(8)&lt;&lt;&#8221;red&#8221;;break;<br/>
          case yellow:cout&lt;&lt;setw(8)&lt;&lt;&#8221;yellow&#8221;;break;<br/>
          case blue:cout&lt;&lt;setw(8)&lt;&lt;&#8221;blue&#8221;;break;<br/>
          case white:cout&lt;&lt;setw(8)&lt;&lt;&#8221;white&#8221;;break;<br/>
          case black:cout&lt;&lt;setw(8)&lt;&lt;&#8221;black&#8221;;break;<br/>
          default:break;<br/>
          }<br/>
          }<br/>
          cout&lt;&lt;endl;}}<br/>
cout&lt;&lt;&#8221;total:&#8221;&lt;&lt;n&lt;&lt;endl;<br/>
return 0;<br/>
}<br/><br/>
不用管他实现的是啥功能，和分析其他逻辑，<br/>
这个事情可以仅仅从<font color="#ff0000">排版技术</font>上解决。<br/><br/>
比如拿到后往VC里一放，ctrl+a，alt+f8。<br/><br/></p>

<h1>include&lt;iostream&gt;<br/></h1>

<h1>include&lt;iomanip&gt;<br/></h1>

<p>using namespace std;<br/>
int main()<br/>
{<br/>
      enum color{red,yellow,blue,white,black};<br/>
      color pri;<br/>
      int i,j,k,n=0,loop;<br/>
      for(i=red;i&lt;=black;i++)<br/>
          for(j=red;j&lt;=black;j++)<br/>
                  if(i!=j)<br/>
                  {for(k=red;k&lt;=black;k++)<br/>
                  if((k!=i)&amp;&amp;(k!=j))<br/>
                  {<br/>
                        n=n+1;<br/>
                        cout&lt;&lt;setw(3)&lt;&lt;n;<br/>
                        for(loop=1;loop&lt;=3;loop++)<br/>
                        {switch(loop){<br/><font color="#ff0000">case1:pri=color(i);break;<br/>
case2:pri=color(j);break;<br/>
case3:pri=color(k);break;</font><br/>
          default:break;<br/>
                        }<br/>
                        switch(pri)<br/>
                        {<br/>
                        case red:cout&lt;&lt;setw(8)&lt;&lt;&#8221;red&#8221;;break;<br/>
                        case yellow:cout&lt;&lt;setw(8)&lt;&lt;&#8221;yellow&#8221;;break;<br/>
                        case blue:cout&lt;&lt;setw(8)&lt;&lt;&#8221;blue&#8221;;break;<br/>
                        case white:cout&lt;&lt;setw(8)&lt;&lt;&#8221;white&#8221;;break;<br/>
                        case black:cout&lt;&lt;setw(8)&lt;&lt;&#8221;black&#8221;;break;<br/>
                        default:break;<br/>
                        }<br/>
                        }<br/>
                        cout&lt;&lt;endl;}}<br/>
                  cout&lt;&lt;&#8221;total:&#8221;&lt;&lt;n&lt;&lt;endl;<br/>
                  return 0;<br/>
}<br/><br/>
显然，中间标红的三行会格外的扯人眼球啊。<br/>
标签的这种性质使得我们很容易发现他。<br/><br/>
于是可以很容易的想到，作者是想做<br/>
case 1:<br/>
case 2:<br/>
case 3:<br/>
把空格给打掉了。。。<br/>
这一掉就成了普通的标签了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/07/11/%E5%B1%8F%E5%B9%95DC%EF%BC%8C%E5%86%85%E5%AD%98DC/">屏幕DC，内存DC</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-07-11T20:38:00+08:00" pubdate data-updated="true">Jul 11<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.7.11<br/><br/>
今天某人说google map没有测距尺用。。。<br/>
要自己把图截下来，根据比例尺来量确实有点麻烦。<br/>
那就整个戳瓢程序来辅助。<br/><br/>
首先就是把屏幕保存下来。<br/>
这里只要创建一个屏幕DC，就可以把里面的图像弄出来了。<br/><br/>
下面这几句，就可以把屏幕的内容复制到自己的窗口上。<br/><br/>
     CDC scrdc ;<br/>
     scrdc.CreateDC(&#8220;DISPLAY&#8221; , NULL , NULL , NULL) ;<br/>
     CClientDC(this).BitBlt(0 , 0 , m_xscr , m_yscr , &amp;scrdc , 0 , 0 , SRCCOPY) ;<br/><br/>
在自己的窗口上，就可以很方便地捕捉鼠标位置等等，<br/>
然后根据输入的比例尺，给出量出的距离。<br/><br/>
像去掉标题栏，全屏化窗口都是基本操作。<br/><br/>
碰到一个问题，就是开始一直没有把图存进内存DC里面。<br/>
在网上逛了一圈，发现了是怎么回事。<br/>
原来初始化的内存DC，没地方绘图，<br/>
要先创建一个兼容的屏幕大小的位图，然后选进这个DC才行。<br/><br/>
大概就是这样。<br/><br/>
     CDC scrdc ;<br/>
     scrdc.CreateDC(&#8220;DISPLAY&#8221; , NULL , NULL , NULL) ;<br/>
     m_xscr = GetSystemMetrics(SM_CXSCREEN) ;<br/>
     m_yscr = GetSystemMetrics(SM_CYSCREEN) ;<br/>
     memdc.CreateCompatibleDC(NULL) ;<br/>
     membitmap.CreateCompatibleBitmap(<font color="#ff0000">&amp;scrdc</font> , m_xscr , m_yscr) ;<br/>
     memdc.SelectObject(&amp;membitmap) ;<br/><br/>
最后一个问题就是，刚开始截出来的图显示不正常。<br/>
才发现是创建兼容位图的时候，应该用屏幕DC，而不是内存DC，<br/>
把上面相应的那句换成：<br/><br/>
membitmap.CreateCompatibleBitmap(<font color="#ff0000">&amp;memdc</font> , m_xscr , m_yscr) ;<br/><br/>
就会发现截出来的图变成黑白的一坨。。。<br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/07/10/%E5%87%A0%E7%A7%8D%E5%90%8C%E6%AD%A5%E6%89%8B%E6%AE%B5%EF%BC%88%E4%BA%92%E6%96%A5%E9%87%8F%EF%BC%8C%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%8C%E4%BA%8B%E4%BB%B6%EF%BC%8C%E4%B8%B4%E7%95%8C%E5%8C%BA%EF%BC%89/">几种同步手段（互斥量，信号量，事件，临界区）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-07-10T19:19:00+08:00" pubdate data-updated="true">Jul 10<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.7.10<br/><br/><font color="#0000ff">环境：</font><br/><br/>
VISTA+VC6<br/>
双核<br/><br/>
这个环境对于下面的有些效果来说，十分关键。<br/>
在我下面的练习中，如果是单核，那么两个线程无法真正的同时执行，<br/>
而单个操作的耗时也并不长，可能看不到互斥访问中的一些问题。<br/>
在VISTA之前的一些系统，时间片比较大，也不容易看到。。<br/><font color="#0000ff"><br/>
设计目标：</font><br/><br/>
模拟一个售票系统，有两个线程可以出售，总共100张票。<br/>
中间打印出出售的信息。<br/>
这里的票是一个临界资源，<br/>
同时，控制台也是个临界资源。（如果同时输出会造成屏幕的混乱）<br/><br/><font color="#0000ff">原始程序：</font><br/><br/></p>

<h1>include &lt;stdio.h&gt;<br/></h1>

<h1>include &lt;iostream&gt;<br/></h1>

<h1>include &lt;windows.h&gt;<br/><br/></h1>

<p>using namespace std;<br/><br/>
int total=100;<br/><br/>
DWORD WINAPI proc1(<br/>
  LPVOID lpParameter    // thread data<br/>
  ){<br/>
     while (1){<br/>
          if ( total == 0 ) break ;<br/>
          <font color="#ff0000">Sleep(rand()%30) ;</font><br/>
          cout&lt;&lt;&#8221;thread1 sold:&#8221;&lt;&lt;total&#8211;&lt;&lt;endl;<br/>
     }<br/>
     return 0;<br/>
};<br/><br/>
DWORD WINAPI proc2(<br/>
  LPVOID lpParameter    // thread data<br/>
  ){<br/>
     while (1){<br/>
          if ( total == 0 ) break ;<br/>
          Sleep(rand()%30) ;<br/>
          cout&lt;&lt;&#8221;thread2 sold:&#8221;&lt;&lt;total&#8211;&lt;&lt;endl;<br/>
     }<br/>
     return 0;<br/>
};<br/><br/>
int main(){<br/>
     HANDLE thread1,thread2;<br/>
     thread1=CreateThread(NULL,0,proc1,NULL,0,NULL);<br/>
     thread2=CreateThread(NULL,0,proc2,NULL,0,NULL);<br/>
     Sleep(4000);<br/>
     CloseHandle(thread1);<br/>
     CloseHandle(thread2);<br/>
     return 0;<br/>
}<br/><br/>
程序的意思很直观，就是开了两个线程。<br/>
在里面分别判断票数是否到0，<br/>
如果不是的话，那么模拟售出了一张票，并且打印出售出的票号。<br/><br/>
中间标红的随机延迟是一个关键点。<br/>
把他去掉的话，一般就看不到效果了。<br/>
因为电脑实在太快了，if的判断和下面的输出，<br/>
几乎是在同一时间完成的。<br/>
从时间片的意义上来说，大部分时候可以看做原子操作。<br/>
于是减到0之后，线程正常结束就停下了。<br/>
所以给个随机延迟，强迫if的判断和total&#8211;的分离，<br/>
这样就可以看到由于没有做好同步造成的问题了。<br/><br/>
这个程序的输出，有的地方会有字符交叉，很混乱。<br/>
最明显的是，减到0之后，还会不断地向下面减。<br/><br/><font color="#0000ff">同步的框架：</font><br/><br/>
下面几个方法，大同小异，<br/>
基本上的过程就是：<br/><br/>
1.定义相关的变量<br/>
2.创建相关的变量<br/>
3.进去临界区前等待相关的信号<br/>
4.退出的时候<font color="#ff6600">清除</font>相关的信号<br/>
（信号有的时候可以进入临界区，还是信号无的时候可以进入，<br/>
在几个实现手段里面有不同的叙述，所以清除是个泛化的说法）<br/><br/><font color="#0000ff">互斥量：</font><br/><br/></p>

<h1>include &lt;stdio.h&gt;<br/></h1>

<h1>include &lt;iostream&gt;<br/></h1>

<h1>include &lt;windows.h&gt;<br/><br/></h1>

<p>using namespace std;<br/><br/>
int total=100;<br/><font color="#ff0000">HANDLE mutex;</font><br/><br/>
DWORD WINAPI proc1(<br/>
  LPVOID lpParameter    // thread data<br/>
  ){<br/>
     while (1){<br/><font color="#ff0000">         WaitForSingleObject(mutex,INFINITE);</font><br/>
          if ( total == 0 ) break ;<br/>
          Sleep(rand()%30) ;<br/>
          cout&lt;&lt;&#8221;thread1 sold:&#8221;&lt;&lt;total&#8211;&lt;&lt;endl;<br/><font color="#ff0000">          ReleaseMutex(mutex);</font><br/>
     }<br/>
     return 0;<br/>
};<br/><br/>
DWORD WINAPI proc2(<br/>
  LPVOID lpParameter    // thread data<br/>
  ){<br/>
     while (1){<br/>
          WaitForSingleObject(mutex,INFINITE);<br/>
          if ( total == 0 ) break ;<br/>
          Sleep(rand()%30) ;<br/>
          cout&lt;&lt;&#8221;thread2 sold:&#8221;&lt;&lt;total&#8211;&lt;&lt;endl;<br/>
          ReleaseMutex(mutex);<br/>
     }<br/>
     return 0;<br/>
};<br/><br/>
int main(){<br/>
     HANDLE thread1,thread2;<br/><font color="#ff0000">     mutex=CreateMutex(NULL,false,NULL);</font><br/>
     thread1=CreateThread(NULL,0,proc1,NULL,0,NULL);<br/>
     thread2=CreateThread(NULL,0,proc2,NULL,0,NULL);<br/>
     Sleep(4000);<br/>
     CloseHandle(thread1);<br/>
     CloseHandle(thread2);<br/><font color="#ff0000">     CloseHandle(mutex);</font><br/>
     return 0;<br/>
}<br/><br/>
这是最基本的，和框架非常吻合，<br/>
知道标红的几个函数就按照这种方式写就行了。<br/><br/><font color="#0000ff">信号量：</font><br/><br/></p>

<h1>include &lt;stdio.h&gt;<br/></h1>

<h1>include &lt;iostream&gt;<br/></h1>

<h1>include &lt;windows.h&gt;<br/><br/></h1>

<p>using namespace std;<br/><br/>
int total=100;<br/><font color="#ff0000"><br/>
HANDLE semaphore ;</font><br/><br/>
DWORD WINAPI proc1(<br/>
  LPVOID lpParameter    // thread data<br/>
  ){<br/>
     while (1){<br/>
        <font color="#ff0000"> WaitForSingleObject(semaphore,INFINITE);</font><br/>
          if ( total == 0 ) break ;<br/>
          Sleep(rand()%30) ;<br/>
          cout&lt;&lt;&#8221;thread1 sold:&#8221;&lt;&lt;total&#8211;&lt;&lt;endl;<br/>
        <font color="#ff0000"> ReleaseSemaphore(semaphore , 1 , NULL) ;</font><br/>
     }<br/>
     return 0;<br/>
};<br/><br/>
DWORD WINAPI proc2(<br/>
  LPVOID lpParameter    // thread data<br/>
  ){<br/>
     while (total&gt;0){<br/>
          WaitForSingleObject(semaphore,INFINITE);<br/>
          if ( total == 0 ) break ;<br/>
          Sleep(rand()%30) ;<br/>
          cout&lt;&lt;&#8221;thread2 sold:&#8221;&lt;&lt;total&#8211;&lt;&lt;endl;<br/>
          ReleaseSemaphore(semaphore , 1 , NULL) ;<br/>
     }<br/>
     return 0;<br/>
};<br/><br/>
int main(){<br/>
     HANDLE thread1,thread2;<br/>
   <font color="#ff0000"> semaphore = CreateSemaphore(NULL , 1 , 1 , NULL) ;</font><br/><br/>
     thread1=CreateThread(NULL,0,proc1,NULL,0,NULL);<br/>
     thread2=CreateThread(NULL,0,proc2,NULL,0,NULL);<br/><br/>
     Sleep(4000);<br/>
     CloseHandle(thread1);<br/>
     CloseHandle(thread2);<br/>
     <font color="#ff0000">CloseHandle(semaphore) ;</font><br/><br/>
     return 0;<br/>
}<br/><br/>
和互斥量不同的地方在于，信号量可以允许多个线程同时访问。<br/>
比如writer/reader模型中，多个reader同时访问是允许的。<br/>
在创建的时候，可以指定最大的数目和初始化时候的数目。<br/>
如果指定为1，也就是这里用的情况，相当于就和前面的互斥量方式一样了。<br/><br/><font color="#0000ff">事件：</font><br/><br/></p>

<h1>include &lt;stdio.h&gt;<br/></h1>

<h1>include &lt;iostream&gt;<br/></h1>

<h1>include &lt;windows.h&gt;<br/><br/></h1>

<p>using namespace std;<br/><br/>
int total=100;<br/><br/><font color="#ff0000">HANDLE event;</font><br/><br/>
DWORD WINAPI proc1(<br/>
  LPVOID lpParameter    // thread data<br/>
  ){<br/>
     while (1){<br/>
        <font color="#ff0000"> WaitForSingleObject(event,INFINITE);</font><br/>
          if ( total == 0 ) break ;<br/>
          Sleep(rand()%30) ;<br/>
          cout&lt;&lt;&#8221;thread1 sold:&#8221;&lt;&lt;total&#8211;&lt;&lt;endl;<br/>
          <font color="#ff0000">SetEvent(event) ;</font><br/>
     }<br/>
     return 0;<br/>
};<br/><br/>
DWORD WINAPI proc2(<br/>
  LPVOID lpParameter    // thread data<br/>
  ){<br/>
     while (total&gt;0){<br/>
          WaitForSingleObject(event,INFINITE);<br/>
          if ( total == 0 ) break ;<br/>
          Sleep(rand()%30) ;<br/>
          cout&lt;&lt;&#8221;thread2 sold:&#8221;&lt;&lt;total&#8211;&lt;&lt;endl;<br/>
          SetEvent(event) ;<br/>
     }<br/>
     return 0;<br/>
};<br/><br/>
int main(){<br/>
     HANDLE thread1,thread2;<br/>
   <font color="#ff0000"> event = CreateEvent(NULL , FALSE , TRUE , NULL) ;</font><br/>
     thread1=CreateThread(NULL,0,proc1,NULL,0,NULL);<br/>
     thread2=CreateThread(NULL,0,proc2,NULL,0,NULL);<br/>
     Sleep(4000);<br/>
     CloseHandle(thread1);<br/>
     CloseHandle(thread2);<br/>
   <font color="#ff0000"> CloseHandle(event);</font><br/>
     return 0;<br/>
}<br/><br/>
CreateEvent的第二个参数是设置是否为手动事件。<br/>
如果是手动的话，当用WaitForSingleObject等到事件的时候，<br/>
系统并不清除掉该事件已发生的信号，<br/>
于是要自己调用ResetEvent来清除。<br/>
这两个函数之间的空隙将造成潜在的同步问题。<br/>
于是设置生FALSE，表示自动事件。<br/>
在等到该事件的时候，同时把该事件置为无效，防止其他地方进入临界段。<br/><br/><font color="#0000ff">临界区：</font><br/><br/></p>

<h1>include &lt;stdio.h&gt;<br/></h1>

<h1>include &lt;iostream&gt;<br/></h1>

<h1>include &lt;windows.h&gt;<br/><br/></h1>

<p>using namespace std;<br/><br/>
int total=100;<br/><br/><font color="#ff0000">CRITICAL_SECTION <em>cs;</font><br/><br/>
DWORD WINAPI proc1(<br/>
  LPVOID lpParameter    // thread data<br/>
  ){<br/>
     while (1){<br/>
       <font color="#ff0000">  EnterCriticalSection(&amp;</em>cs);</font><br/>
          if ( total == 0 ) break ;<br/><font color="#ff0000">     //     Sleep(rand()%30) ;</font><br/>
          cout&lt;&lt;&#8221;thread1 sold:&#8221;&lt;&lt;total&#8211;&lt;&lt;endl;<br/>
     <font color="#ff0000">     LeaveCriticalSection(&amp;<em>cs);</font><br/>
     }<br/>
     return 0;<br/>
};<br/><br/>
DWORD WINAPI proc2(<br/>
  LPVOID lpParameter    // thread data<br/>
  ){<br/>
     while (1){<br/>
          EnterCriticalSection(&amp;</em>cs);<br/>
          if ( total == 0 ) break ;<br/>
     //     Sleep(rand()%30) ;<br/>
          cout&lt;&lt;&#8221;thread2 sold:&#8221;&lt;&lt;total&#8211;&lt;&lt;endl;<br/>
          LeaveCriticalSection(&amp;<em>cs);<br/>
     }<br/>
     return 0;<br/>
};<br/><br/>
int main(){<br/>
     HANDLE thread1,thread2;<br/>
  <font color="#ff0000">  InitializeCriticalSection(&amp;</em>cs);</font><br/>
     thread1=CreateThread(NULL,0,proc1,NULL,0,NULL);<br/>
     thread2=CreateThread(NULL,0,proc2,NULL,0,NULL);<br/>
     Sleep(4000);<br/>
     CloseHandle(thread1);<br/>
     CloseHandle(thread2);<br/>
     return 0;<br/>
}<br/><br/>
与前面的相比，这种方式在最后不用类似CloseHandle之类的操作。<br/><br/>
还有注意到我把上面的Sleep注释掉了。<br/>
因为<font color="#ff0000">使用临界区来同步，速度非常快，消耗资源比前几种都小</font><br/>
加上随机延迟后，可能一个线程直接就把票给售完了。。<br/><br/>
即使在现在这种写法下，可能运行好几次，<br/>
能够找到一下若干thread1信息之内夹杂几个thread2的信息，或者反之。<br/><br/>
但观察前三种，基本上的效果是一个线程输出一下，交织频繁。<br/><br/><font color="#0000ff">总结：</font><br/><br/>
前三种方式，依赖一个句柄，<br/>
他们都可以指定一个名字，成为全局的对象，<br/>
可以完成进程间的同步。<br/>
在不用的时候要，销毁相关的句柄。<br/>
消耗资源比较大。<br/><br/>
最后一种临界区，消耗资源非常少，速度快。<br/>
但是只能解决线程间的同步。<br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/07/09/%E4%BD%BF%E7%94%A8unrarlib%E8%A7%A3%E5%8E%8Brar%E6%A1%A3%E6%A1%88--%E5%8C%85%E8%A3%85%E4%B8%80%E4%B8%AA%E2%80%9C%E8%A7%A3%E5%8E%8B%E5%88%B0XX%E6%96%87%E4%BB%B6%E5%A4%B9%E2%80%9D%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%88VC6%29/">使用unrarlib解压rar档案&#8211;包装一个“解压到XX文件夹”的函数（VC6)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-07-09T14:21:00+08:00" pubdate data-updated="true">Jul 9<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.7.9<br/><br/>
今天早上看到的个贴子提到解压rar的问题。<br/>
说了三种方法：<br/><font color="#ff6600"><br/>
1.调用rar的命令行<br/>
2.使用rar相关的dll，unrar.dll</font><br/><font color="#ff6600">3.unrarlib</font><br/><br/>
法1，要求用户装有rar，虽然现在不装rar的电脑几乎没有，<br/>
但是总的说来显得不是很好。<br/><br/>
法2，据说自己的程序走到哪里都要拖着dll，不好看。<br/><br/>
法3，有相应的源码，可以直接放在自己的工程中使用，很方便。<br/><br/>
工程网站：<br/><a href="http://www.unrarlib.org/" target="_blank">http://www.unrarlib.org/</a><br/><br/>
去上面把源码下下来，把<br/>
unrarlib.h<br/>
unrarlib.c<br/>
包含在自己的工程里面就可以用了。<br/><br/>
\samples\很不错，里面有三个例子，基本上一看就明白的。<br/><br/><font color="#0000ff">完整程序：</font><br/><br/>
实现一个把指定档案解压到指定文件夹的函数UnComp<br/><br/></p>

<h1>include &lt;windows.h&gt;<br/></h1>

<h1>include &#8220;unrarlib.h&#8221;<br/></h1>

<h1>include &lt;stdio.h&gt;<br/></h1>

<h1>include &lt;stdlib.h&gt;<br/></h1>

<h1>include &lt;string.h&gt;<br/></h1>

<h1>include &lt;set&gt;<br/></h1>

<h1>include &lt;string&gt;<br/><br/></h1>

<h1>pragma warning(disable:4786)<br/><br/></h1>

<p>std::set&lt;std::string&gt; PathSet ;<br/><br/>
BOOL OutputFile(char <em>buffer , DWORD size , char </em>path) ;<br/>
BOOL CreateDir(char <em>path) ;<br/>
BOOL UnComp(char </em>rarfile , char <em>dir , char </em>password) ;<br/><br/>
int main(){<br/><br/>
     if ( UnComp(&#8220;1.rar&#8221; , &#8220;1&#8221; , &#8220;password&#8221;) == TRUE ){<br/>
          printf(&#8220;\nsuccessfully done.\n&#8221;) ;<br/>
     }else{<br/>
          printf(&#8220;\nfail to uncompress it . \n&#8221;) ;<br/>
          printf(&#8220;be sure your archive is created by rar2.0\n&#8221;) ;<br/>
          printf(&#8220;and expected directory does not exist\n&#8221;) ;<br/>
     }<br/><br/>
     return 0 ;<br/>
}<br/><br/>
BOOL OutputFile(char <em>buffer , DWORD size , char </em>path){<br/>
     FILE <em>fp = fopen(path , &#8220;wb&#8221;) ;<br/>
     if ( !fp ){<br/>
          printf(&#8220;error opening file&#8221;) ;<br/>
          return FALSE ;<br/>
     }<br/>
     fwrite(buffer , size , 1 , fp) ;<br/>
     fclose(fp) ;<br/>
     return TRUE ;<br/>
}<br/><br/>
BOOL CreateDir(char </em>path){<br/>
     char temppath[MAX_PATH] ;<br/>
     int l = strlen(path) ;<br/>
     int i ;<br/>
     for ( i = l - 1 ; i &gt;= 0 ; i &#8211; ) if (path[i] == &#8216;&#39;) break ;<br/>
     <br/>
     //base directory reached<br/>
     if (i &lt; 0) return TRUE ;<br/><br/>
     //create parent directory<br/>
     memcpy(temppath , path , i) ;<br/>
     temppath[i] = &#8216;\0&#8217; ;<br/><br/>
     //already created<br/>
     if (PathSet.count(temppath)){<br/>
          return TRUE ;<br/>
     }     <br/><br/>
     if ( CreateDir(temppath) == FALSE ){<br/>
          return FALSE ;<br/>
     }else{<br/>
          if ( CreateDirectory(temppath , NULL) == FALSE){<br/>
               return FALSE ;<br/>
          }else{<br/>
               PathSet.insert(temppath) ;<br/>
               return TRUE ;<br/>
          }<br/>
     }<br/>
}<br/><br/>
BOOL UnComp(char <em>rarfile , char </em>dir , char <em>password){<br/>
     PathSet.clear() ;<br/>
     ArchiveList_struct </em>list ;<br/>
     urarlib_list(rarfile , (ArchiveList_struct<em>) &amp;list) ;<br/>
     ArchiveList_struct </em>p = list ;<br/>
     while ( p ){<br/>
          //extract only when not directory<br/>
          if (p-&gt;item.FileAttr != 16){<br/>
               printf(&#8220;now extracting %s &#8230;&#8221;,p-&gt;item.Name) ;<br/><br/>
               char <em>buffer ;<br/>
               DWORD size ;<br/>
               char path[MAX_PATH] ;<br/><br/>
               int ret = urarlib_get(&amp;buffer , &amp;size , p-&gt;item.Name , rarfile , password) ;<br/>
               if ( ret == FALSE ) {<br/>
                    printf(&#8220;error getting file\n&#8221;) ;<br/>
                    return FALSE ;<br/>
               }<br/>
               sprintf(path , &#8220;%s\%s&#8221; , dir , p-&gt;item.Name) ;<br/>
               if ( CreateDir(path) == FALSE ){<br/>
                    printf(&#8220;error creating path&#8221;) ;<br/>
                    return FALSE ;<br/>
               }<br/>
               OutputFile(buffer , size , path) ;<br/>
               free(buffer) ;<br/><br/>
               printf(&#8220;done!.\n&#8221;) ;<br/>
          }<br/>
          p = p-&gt;next ;<br/>
     }<br/><br/>
     urarlib_freelist(list) ;<br/><br/>
     return TRUE ;<br/>
}<br/><br/><font color="#0000ff">提要：</font><br/><br/>
关于这套lib，就三个函数<img src="http://img.baidu.com/hi/jx/j_0011.gif"/>，所以说很容易使用嘛。<br/><br/>
urarlib_list<br/>
用来得到一个链表，存放了rar档案的所有文件的信息。<br/><br/>
urarlib_freelist<br/>
用来释放上面得到的链表。<br/><br/>
urarlib_get<br/>
用来得到档案中的某个文件。<br/><br/>
大体上的流程就是，得到文件链表，然后一个一个地提取出来，fwrite到该放他的地方。<br/><br/><font color="#0000ff">建立目录：</font><br/><br/>
整个提取流程很直观，唯一要考虑的就是建立目录的问题。<br/>
win32api的CreateDirectory只能在已经存在的目录下创建新的目录，<br/>
当目录存在的时候，就自动忽略。<br/><br/>
而观察过urarlib返回的list就知道，里面的文件并不一定是按照目录从浅到深排序的。<br/>
所以可能第一个文件的路径就是1\2\3\4.txt。<br/>
那么为了他，要先创建1，再创建1\2，然后是1\2\3，最后才能写入文件4.txt。<br/><br/>
这个任务就放在自己的<br/>
CreateDir<br/>
函数里面完成了。<br/><br/>
这个函数递归处理传进去的路径字符串，于是可以从浅到深地创建目录。<br/><br/>
其中用到了个stl里的PathSet，用来判断是否已经创建过该目录了，<br/>
是的话，就直接返回，避免重复创建。<br/>
(虽然重复调用CreateDirectory可以自动忽略存在的目录，<br/>
毕竟效率上会吃亏）<br/><br/><font color="#0000ff">用处：</font><br/><br/>
有的时候，想给自己的程序一起带上一些数据，<br/>
直接放在资源里面，消耗空间确实不少，<br/>
这下有了这套装备，就可以先压缩起来，<br/>
然后随时解压出来，由于是unrarlib是源码形式发布，<br/>
不用带上其他的东西，很清爽。<br/><br/><font color="#0000ff">缺点：</font><br/><br/><font color="#ff0000">由于这套库实在是比较老了，只支持到rar2.0</font>。。。<br/>
这就是个问题了，先不说压缩质量肯定不如后面的版本。<br/>
关键在于要找到rar2.0都是一个麻烦的事情。。<br/><br/>
还好，在<a href="http://hi.baidu.com/hplonline/blog/item/28f8b91b0207bf108718bf2e.html" target="_blank">上一篇</a>介绍的网站中，搜集到了。。<br/><br/>
另外一个就是函数的参数设计上，有点令人费解的地方：<br/><br/>
先看下声明：<br/>
extern int urarlib_list(void </em>rarfile, ArchiveList_struct <em>list);<br/><br/>
再看下调用：<br/>
     ArchiveList_struct </em>list ;<br/>
     urarlib_list(rarfile , (ArchiveList_struct<em>) &amp;list) ;<br/><br/>
是个人都会觉得很奇怪。。<br/>
首先，ArchiveList_struct是链表的节点。<br/>
在没有头节点的时候，要用一个头指针来维护，就是这里的list。<br/><br/>
这个list定义出来时，显然是随机值，<br/>
要依赖urarlib_list把他的值改成生成的链表的头指针。<br/><br/>
出于这个目的，于是应该传的不是指向ArchiveList_struct的指针，<br/>
而是一个指向指针的指针，从后面的&amp;list的位置也看得出来。<br/><br/>
而根据函数的参数列表，却还要先强制转换成ArchiveList_struct的指针。。。<br/><br/>
从这个函数的源码可以看到，里面有：<br/>
(</em>(DWORD*)list) = (DWORD)NULL;     <br/><br/>
也就是在里面，list还是先被转化成指向指针（DWORD）的指针，再赋值。。。<br/><br/>
嗯，很绕口。。这个设计确实不好看，不过由于这套库的配套sample很不错，能够看懂怎么用。<br/></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/backup-hplonline/blog/page/14/">&larr; Older</a>
    
    <a href="/backup-hplonline/blog/archives">Blog Archives</a>
    
    <a class="next" href="/backup-hplonline/blog/page/12/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/backup-hplonline/blog/2013/05/04/test/">Test</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/04/09/%E5%86%8D%E8%B0%88stl%E7%9A%84rotate/">再谈stl的rotate</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%BA%8C%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、二）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%89%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、三）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%80%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、一）</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - hplonline -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
