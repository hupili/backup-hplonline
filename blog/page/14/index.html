
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>hplonline</title>
  <meta name="author" content="hplonline">

  
  <meta name="description" content="(hplonline)2009.7.5目标：
用四位二进制加法器74x283设计四位二进制加法/减法器 线索式思维：
已经有了实现加法器的功能
==》把减法转化成加法
==》补码
==》实现~x+1
==》已有非门，要实现加1的功能
==》嗯，再来一片283
加法和减法
==》 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hupili.github.io/backup-hplonline/blog/page/14">
  <link href="/backup-hplonline/favicon.png" rel="icon">
  <link href="/backup-hplonline/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/backup-hplonline/atom.xml" rel="alternate" title="hplonline" type="application/atom+xml">
  <script src="/backup-hplonline/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/backup-hplonline/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/backup-hplonline/">hplonline</a></h1>
  
    <h2>backup from 2006 to 2012 (original hi.baidu.com/hplonline/)</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/backup-hplonline/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hupili.github.io/backup-hplonline" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/backup-hplonline/">Blog</a></li>
  <li><a href="/backup-hplonline/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/07/05/74LS283%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%A0%E5%87%8F%E5%99%A8%EF%BC%88%E5%8F%8D%E8%A7%82%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%80%9D%E7%BB%B4%E6%82%B2%E5%89%A7%EF%BC%89/">74LS283实现的加减器（反观程序员的思维悲剧）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-07-05T15:06:00+08:00" pubdate data-updated="true">Jul 5<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.7.5<font color="#0000ff"><span style="background-color: rgb(0, 0, 255);"><br/><br/></span>目标：</font><br/>
用四位二进制加法器74x283设计四位二进制加法/减法器 <br/><br/><font color="#0000ff">线索式思维：</font><br/><br/>
已经有了实现加法器的功能<br/>
==》把减法转化成加法<br/>
==》补码<br/>
==》实现~x+1<br/>
==》已有非门，要实现加1的功能<br/>
==》嗯，再来一片283<br/><br/>
加法和减法<br/>
==》被加数和被减数都直接接到283的A端<br/>
==》如果是减数，要求补<br/>
==》使用数据选择器<br/><font color="#0000ff"><br/>
电路图：</font><br/><br/>
开关的上面四个表示被加（减）数，下面四个表示加（减）数<br/>
最下面一个0表示做加法，1表示做减法。<br/><br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/1bacf81fb19a4e44f724e4c0.jpg" small="0" class="blogimg"/></div></p>

<div forimg="1"><br/>
这个图演示了一个3-2的计算。<br/>
至于最后的进位输出是1，那是补码运算的自然结果。<br/><br/>
这个设计用了两片283，一片157.。。<br/><br/><font color="#0000ff">精简方案：</font><br/><br/><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/a0df39faf8188339a9d311c0.jpg" small="0" class="blogimg"/></div>


<br/>


<p>这个是直接从老师课件上拷下来的。。<br/>
当我看到他的时候，简直震精了。<br/><br/>
用M为0表示做加法，1表示减法。<br/>
那么直接异或，如果是0的话，那么原样传进去。<br/>
如果是1的话，正好是对B的每一位都取反。<br/>
但是这里要加的是补码，取反加1，这个1正好传给CI。<br/>
而当M为0的时候，传给CI的也是0，太合适了。。。<br/><br/><font color="#0000ff">反思：</font><br/><br/>
前一种思维，非常直观，属于快餐式构思，能够在短时间内给出解决方案。<br/>
这种解决方案的重点在于逻辑可行，而往往可能在设计上并不精简。<br/><br/>
就像有人问用J-K触发器实现状态机的那些题怎么做。<br/>
我说，我也不知道，但是你知道如果用D触发器的话怎么做吧？<br/>
那就没问题了，你在J-K触发器前面加点货，先把他搞成D触发器吧。<br/>
我相信这么做的话，老师不敢咬你的。。。<br/><br/>
这种就是典型的<font color="#ff0000">逻辑可行</font>式的思维。<br/>
你知道了A，又知道了用B怎么搞出A的功能。<br/>
那么用A来完成的东西你都可以用B来代替了。<br/><br/>
做程序员做久了就有这样一种毛病，<br/><font color="#ff0000">过于注重以前的经验，而把所有新的东西都向旧的经验上归结。</font><br/><br/>
比如最开始看汇编的时候，看到了比较指令，条件跳转指令，<br/>
于是很兴奋，感到自己会用汇编写循环了。。<br/>
（这种组合的思维也是程序员的特点之一，<br/>
只要新的东西能够向旧的经验上归结，<br/>
那么不需要更多的提点，就可以做出同样的功能了）<br/>
再看到后面，才发现，原来还有loop可以用，还有loopz，loopnz。。。。<br/>
用他们的话，虽然效率上吃亏，但是真的可以简化设计。。<br/><br/>
而这里的这个加减器的实现也是如此，<br/>
拿到他，并不是先去关注283能提供给我们的一系列功能。<br/>
直接就开始构思了，正如前面说的，这种构思，步步都很严密，<br/>
全部是建立在已经很熟悉的知识或者器件之上，<br/>
最后来说，功能也是能够实现的。。。<br/><br/>
但是相比认真分析过后的精简设计，真的是相形见绌。。。<br/><br/>
另外一个，就是<font color="#ff0000">泛型的毛病</font>。。<br/>
做程序做多了，往往会倾向于写通用的东西。<br/>
比如有个题要做1加到100，于是先做一个a加到b的模块，<br/>
然后传给1和100进去。。<br/><br/>
而当一个月前，发现了ROM这个<a href="http://hi.baidu.com/hplonline/blog/item/d916c9ce0ae70d0b93457e69.html" target="_blank">通用的解决方案</a>时。。。。<br/>
看到啥问题都会想到这个东西了。。。囧。。。<br/><br/>
所以作为程序员，我们没法抢电子工程师的饭碗，这是有道理的。。<br/>
主要这思维充满了太多戏剧性的东西，有点囧。。。<br/><div class="O"></p>

<div/>
<span style="Times New Roman&quot;; font-size: 178%; visibility: hidden;"><span style="color: red; position: absolute; left: -4.13%;  font-size: 75%;">Ø，了<br/><br/>
这种<br/></span></span></div>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/06/29/%E6%9E%9A%E4%B8%BE%E5%9E%8B%EF%BC%8C%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%8C%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4%EF%BC%8C%E9%9D%99%E6%80%81%E8%BD%AC%E6%8D%A2%EF%BC%8C%E4%B9%A0%E6%83%AF%E9%97%AE%E9%A2%98/">枚举型，结构体，名字空间，静态转换，习惯问题</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-06-29T19:09:00+08:00" pubdate data-updated="true">Jun 29<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.6.29<br/><br/><font color="#ff0000">（环境为VC6.0)</font><br/><br/><font color="#0000ff">例一：</font><br/><br/>
定义如下结构。<br/><br/><font color="#ff6600">struct sa{<br/>
     enum {<br/>
          e1,e2,e3 <br/>
     }val ;<br/>
}a ;<br/><br/>
struct sb{<br/>
     sa a ;<br/>
}b ;</font><br/><br/>
做赋值：<br/><font color="#ff6600">a.val = e1 ;</font><br/><br/>
编译器会报错，说e1没有定义。<br/><br/>
办法：<br/><font color="#ff6600">     a.val = sa.e1 ;<br/>
     a.val = a.e1 ;<br/>
     a.val = sa::e1 ;</font><br/><br/>
最后一个比较好理解，就是指定名字空间，<br/>
一个结构体，一个类，都相当于一个独立的名字空间。<br/>
第二个，引用方式很像成员变量。不管他。。<br/>
语言这东西本来就没为什么的，能用就行。<br/>
第一个看起来就更别扭了。。<br/>
如果说第二个是实例化的a，把e1当作成员变量的低位，<br/>
那么第一个用法，在.前面放的是结构体名（类名）。。。<br/>
暂且记下这个用法，能用就行了。<br/><br/>
那么对b.a.val赋值呢。其实就差不多了：<br/><font color="#ff6600">     b.a.val = sa::e1 ;<br/>
     b.a.val = b.a.e1 ;<br/>
     b.a.val = sa.e1 ;</font><br/><br/>
第二个用法因为是实例化的对象名，所以要从b开始跟着走。<br/>
如果发现用b.a.val = a.e1 ;也是可以的，<br/>
是因为最开头我定义了一个叫a的这个东西。<br/><br/><font color="#0000ff">例二：</font><br/><br/>
就是一个嵌套。<br/>
反正编译过了，说明可以这样用而已。<br/><br/><font color="#ff6600">struct sb{<br/>
     struct sa{<br/>
          enum {<br/>
               e1,e2,e3 <br/>
          }val ;<br/>
     } a;<br/>
}b ;<br/><br/>
int main(){<br/>
     b.a.val = sb::sa.e1 ;<br/>
     b.a.val = b.a.e1 ;<br/>
     b.a.val = sb::sa::e1 ;<br/>
     return 0 ;<br/>
}</font><br/><br/><font color="#0000ff">例三：</font><br/><br/>
前面提到过，名字空间方式引用很好理解，<br/>
但形如成员变量的引用，总觉得有点别扭。<br/>
但这种引用方式是有意义的。比如：<br/><font color="#ff6600"><br/>
struct {<br/>
     struct {<br/>
          enum {<br/>
               e1,e2,e3 <br/>
          }val ;<br/>
     }a ;<br/>
}b ;<br/><br/>
int main(){     <br/>
     b.a.val = b.a.e1 ;<br/>
     return 0 ;<br/>
}</font><br/><br/>
这种不先定义类型，<font color="#ff0000">直接用结构体定义变量的习惯</font>在老点的代码里面有不少。<br/>
这个时候没有结构体的名字，只有通过实例化的变量去索引到相关的没举行的值了。<br/><br/><font color="#0000ff">例四：</font><br/><br/>
这下来个静态转换，上面的这种定义习惯就出现尴尬了。<br/><br/>
在例三的代码上做一句：<br/><font color="#ff6600">b.a.val = 1 ;</font><br/><br/>
会有报错：<br/>
error C2440: &#8216;=&#8217; : cannot convert from &#8216;const int&#8217; to &#8216;enum sb::sa::ee&#8217;<br/>
         <font color="#ff0000">Conversion to enumeration type requires an explicit cast</font> (static_cast, C-style cast or function-style cast)<br/><br/>
说明了，从其他类型到枚举型要用显示转换。<br/><br/>
但是根据例三的定义，各个类型都没有名字，这下就相当尴尬了。<br/><br/>
虽然c里面有sizeof，却没有个typeof来用。<br/><br/>
所以，<font color="#ff0000">好的习惯还是把该有的东西都带上名字，少用直接定义</font>。<br/><br/><font color="#ff6600">struct sb{<br/>
     struct sa{<br/>
          enum ee{<br/>
               e1,e2,e3 <br/>
          }val ;<br/>
     }a ;<br/>
}b ;<br/><br/>
int main(){     <br/>
     b.a.val = </font><font color="#ff6600"><font color="#ff0000">static_cast&lt;sb::sa::ee&gt;(</font>1) ;<br/>
     return 0 ;<br/>
}</font><br/><br/>
关于static_cast，可以参考我前面关于<a href="http://hi.baidu.com/hplonline/blog/item/a8f8c2fc9100a4f5fd037fa4.html" target="_blank">C++类型转换</a>的笔记</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/06/27/%E7%BB%91%E5%AE%9Acmd%E5%88%B0%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3/">绑定cmd到指定端口</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-06-27T16:23:00+08:00" pubdate data-updated="true">Jun 27<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.6.27<br/><br/>
例子来自《0day》5.6.3节。<br/>
由于原书直接上汇编，并且缩减得实在是太厉害，<br/>
不容易抓住主要脉络，所以自己想先用C实现一个再体会。<br/><br/>
绑定后在客户端用telnet软件就可以连接了。<br/><br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/de161417c0da1e274b90a70d.jpg" small="0" class="blogimg"/></div></p>

<br/>


<p>由于破vista把telnet.exe给阉割了。于是用这款SecureCRT。<br/>
可以管理多个会话，非常方便。<br/><br/><font color="#0000ff">代码（含详细注释）：</font><br/><br/></p>

<h1>include &lt;winsock2.h&gt;<br/></h1>

<h1>include &lt;windows.h&gt;<br/></h1>

<h1>include &lt;stdio.h&gt;<br/></h1>

<h1>pragma comment(lib,&#8221;ws2_32.lib&#8221;)<br/><br/></h1>

<p>char <em>app_name = &#8220;cmd.exe&#8221; ;<br/><br/>
int main(){<br/>
     WORD wVersionRequested;<br/>
     WSADATA wsaData;<br/>
     int err;<br/><br/>
     wVersionRequested = MAKEWORD( 1, 1 );<br/><br/>
     err = WSAStartup( wVersionRequested, &amp;wsaData);<br/>
     if (err!=0){<br/>
          return err;<br/>
     }<br/>
     <br/>
     if (LOBYTE ( wsaData.wVersion) != 1 ||<br/>
          HIBYTE ( wsaData.wVersion) != 1){<br/>
          WSACleanup();<br/>
          return 0;<br/>
     }<br/><br/>
     //以上部分属于“八股”的范畴，各种资料有讲相关的意思。<br/>
     //这里直接用了，很多时候做Socket编程都会写上这些话。<br/><br/>
     //得到服务端的socket<br/><font color="#ff0000">     SOCKET mySocket = WSASocketA(AF_INET , SOCK_STREAM , 0 , 0 , 0  , 0) ;<br/>
//     SOCKET mySocket = socket(AF_INET , SOCK_STREAM , 0 ) ;</font><br/>
     <br/>
     //生成地址结构，这里主要关注的是协议和端口<br/>
     //要注意的是htonx系列函数的使用否则得不到预期效果<br/>
     SOCKADDR_IN sa ;<br/>
     sa.sin_family = AF_INET ;<br/>
     sa.sin_addr.S_un.S_addr = htonl(ADDR_ANY) ;<br/>
     sa.sin_port = htons(6000) ;<br/>
     <br/>
     //绑定到端口<br/>
     bind(mySocket , (SOCKADDR</em>)&amp;sa , sizeof(sa)) ;<br/>
     <br/>
     //监听端口<br/>
     listen(mySocket , 5) ;<br/><br/>
     SOCKADDR_IN otherAddr ; //用来接收客户端地址<br/>
     int len ; //。。由于accept最后一个参数要传指针。。。。<br/>
     SOCKET otherSocket ;<br/>
     len = sizeof(otherAddr) ;<br/><br/>
     otherSocket = accept(mySocket , (SOCKADDR<em>)&amp;otherAddr , &amp;len) ;<br/><br/>
     //用于进程启动的信息<br/>
     STARTUPINFO si ;<br/>
     memset(&amp;si , 0 , sizeof(si)) ;<br/>
     //长度信息，很重要，否则结构里的内容会全部忽视<br/>
     si.cb = sizeof(STARTUPINFO) ;<br/>
     //这里设置三个标准句柄<br/>
     si.hStdError = (void</em>)otherSocket ;<br/>
     si.hStdInput = (void<em>)otherSocket ;<br/>
     si.hStdOutput = (void</em>)otherSocket ;<br/>
     //如果没有这个标志的话，以上指定的句柄会被忽略<br/>
     si.dwFlags = STARTF_USESTDHANDLES ;<br/><br/>
     //用来接收进程信息<br/>
     PROCESS_INFORMATION pi ;<br/><br/>
     //创建进程<br/>
     CreateProcess(NULL , app_name , NULL , NULL , TRUE , NULL , NULL , NULL , &amp;si , &amp;pi) ;<br/><br/>
     //这节用来隐藏窗口<br/>
     SetConsoleTitle(&#8220;hplonline&#8221;) ;<br/>
     HWND hWnd = FindWindow(NULL , &#8220;hplonline&#8221;) ;<br/>
     ShowWindow(hWnd , SW_HIDE);<br/><br/>
     //用来等待直到创建的cmd结束为止<br/>
     WaitForSingleObject( pi.hProcess, INFINITE );<br/>
     CloseHandle(pi.hProcess) ;<br/>
     CloseHandle(pi.hThread) ;<br/><br/>
     //这个也是“八股”的范畴<br/>
     WSACleanup();<br/>
     return 0 ;<br/>
}<br/><br/><font color="#0000ff">很诡异的问题：</font><br/><br/>
下面这句换成后面注释过的，就没有任何效果了。<br/>
     SOCKET mySocket = WSASocketA(AF_INET , SOCK_STREAM , 0 , 0 , 0  , 0) ;<br/>
//     SOCKET mySocket = socket(AF_INET , SOCK_STREAM , 0 ) ;<br/><br/>
MSDN上给WSASocket的解释中有一句：<br/>
If<em> lpProtocolInfo</em> is NULL, the WS2_32.DLL uses the first three parameters  (<em>af, type, protocol</em>) to determine ……<br/><br/>
就是说，按照这样样的参数传进去，后面的都会忽略。<br/>
相当于给socket传了同样的内容过去。<br/>
但用socket却没有任何效果。<br/><br/>
网上搜了不少地方，只看到有的说：<br/>
socket符合unix标准，用于同步传输<br/>
WSASocket指定更多的，如IO重叠等特性<br/><br/>
但不管怎么说，这里并没有给WSASocket指定更多的信息啊。。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/06/26/volatile%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%BB%93%E5%90%88%E6%80%A7%E9%97%AE%E9%A2%98/">Volatile的修饰结合性问题</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-06-26T19:52:00+08:00" pubdate data-updated="true">Jun 26<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.6.26<br/><br/>
（实验在VC6下完成）<br/><br/>
若干天前，研究了下<a href="http://hi.baidu.com/hplonline/blog/item/baf29d2bb27a5ff2e7cd400b.html" target="_blank">volatile</a>的作用，没有太深入。<br/>
前些天，做了跟<a href="http://hi.baidu.com/hplonline/blog/item/e936db001972dd18738b65a2.html" target="_blank">函数指针的调用约定修饰</a>有关的工作，<br/>
当时也提到了结合性，提到了const之类的。<br/><br/>
今天在看到一群人讨论的时候，才反映过来volatile的修饰也有结合性的问题。<br/><br/>
而同时发现的就是，之前对<a href="http://hi.baidu.com/hplonline/blog/item/baf29d2bb27a5ff2e7cd400b.html" target="_blank">volatile的讨论</a>并不完全。<br/>
这里从当时的最后一个实验开始继续研究。<br/><br/><font color="#0000ff">程序如下：</font><br/><br/></p>

<h1>include &lt;iostream&gt;<br/></h1>

<h1>include &lt;windows.h&gt;<br/><br/></h1>

<p>using namespace std;<br/><br/>
DWORD v_esp ;<br/><br/>
int one = 1 ;<br/><br/>
DWORD WINAPI ThreadProc(<br/>
LPVOID lpParameter    // thread data<br/>
){<br/>
     Sleep(3000) ;<br/>
     <strong>asm{<br/>
         mov ebx , v_esp ;<br/>
         sub ebx , 4 ;<br/>
         mov eax , OFFSET one ;<br/>
         mov [ebx] , eax ;<br/>
     }<br/>
     return 0 ;<br/>
}<br/><br/>
void wait( int * <font color="#ff0000">volatile</font> p){<br/>
     while ( *p == 0 ) ;<br/>
}<br/><br/>
int main(){<br/>
     int n = 0 ;<br/>
     cout&lt;&lt;&#8221;begin&#8221;&lt;&lt;endl;<br/>
     CreateThread(NULL , 0 , ThreadProc , &amp;n , NULL , NULL ) ;<br/>
     cout&lt;&lt;&#8221;end&#8221;&lt;&lt;endl;<br/>
     </strong>asm{<br/>
         mov v_esp , esp ;<br/>
     }<br/>
     wait(&amp;n) ;<br/>
     cout&lt;&lt;&#8221;terminated normally&#8221;&lt;&lt;endl;<br/>
     return 0 ;<br/>
}<br/><br/><font color="#ff6600">这个程序在release下也可以正常结束了。</font><br/><br/>
而当时的程序在release下就会不停地执行。<br/>
比较一下改动的地方，非常微妙：<br/><br/>
旧：<br/>
void wait(<font color="#ff0000">volatile</font> int <em>p){<br/><br/>
新：<br/>
void wait( int </em><font color="#ff0000"> volatile</font> p){<br/><br/>
第一个volatile是和int结合的，表示指向的int是“<font color="#ff0000">易变的</font>”。<br/>
换言之，在最快速度优化下，会认为p本身是不变的。<br/>
于是每次从p指向的位置读出数据来判断是否为0。<br/>
而p指向的是什么，由于认为不变，可以直接保存在一个寄存器中。<br/><br/>
第二个volatile是和p结合的。意思就是这个指针变量是“<font color="#ff0000">易变的</font>”。<br/>
于是，即使在最快速度优化下，首先要先从放p变量的内存处取得p本身的值。<br/>
然后再从这个地址去读取数据。<br/><br/><font color="#0000ff">wait函数的汇编：</font><br/><br/>
旧：<br/>
00401030  mov      eax, dword ptr [esp+4]<br/>
00401034  cmp      dword ptr [eax], 0<br/>
00401037  jnz      short 0040103E<br/>
00401039  cmp      dword ptr [eax], 0<br/>
0040103C  je       short 00401039<br/>
0040103E  retn<br/><br/>
[esp+4]就是p的位置。很明显编译器把p放在了eax里面。<br/>
即假设了p本身的值在运行过程中不变。<br/><br/>
新：<br/>
00401030  mov      eax, dword ptr [esp+4]<br/>
00401034  mov      ecx, dword ptr [eax]<br/>
00401036  test     ecx, ecx<br/>
00401038  jnz      short 00401044<br/>
0040103A  mov      ecx, dword ptr [esp+4]<br/>
0040103E  mov      eax, dword ptr [ecx]<br/>
00401040  test     eax, eax<br/>
00401042  je       short 0040103A<br/>
00401044  retn<br/><br/>
这个代码就老实到家了，每次都从p处取得一个地址，<br/>
又从这个地址取得一个值，判断是否为0。<br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/06/19/%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%AA%97%E5%8F%A3%E7%BB%98%E5%9B%BE%28dev-c%2B%2B%29/">控制台窗口绘图(dev-c++)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-06-19T17:33:00+08:00" pubdate data-updated="true">Jun 19<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.6.19<br/><br/>
C有一套图形接口函数在graphics.h里面定义。<br/>
而C++的编译器一般都没有带上这套库了。<br/><br/>
不管怎么说，控制台窗口虽然长得黑不溜秋的，<br/>
本质上也是个窗口，那么就可以用win32的GDI来完成。<br/><br/>
下面就画这样一个矩形出来。<br/><br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/89c8780e083ffcec7acbe1b8.jpg" small="0" class="blogimg"/></div></p>

<br/><font color="#0000ff">原理：</font><br/><br/>


<p>和一般的GDI绘图步骤一样。<br/>
得到窗口句柄，创建DC，绘图，释放DC<br/><br/><font color="#0000ff">程序：</font><br/><br/>
看到下面注释掉的东西，就知道经过了不少梗塞的尝试。<br/>
先把代码拿出来，然后说说实现上的问题。<br/><br/></p>

<h1>include &lt;iostream&gt;<br/></h1>

<h1>include &lt;windows.h&gt;<br/></h1>

<p>using namespace std ; <br/><font color="#339966">//#pragma comment(lib , &#8220;gdi32.lib&#8221;)</font><br/><br/>
typedef BOOL (<em>func_rectangle)(<br/>
  HDC hdc,          // handle to device context<br/>
  int nLeftRect,    // x-coord of bounding rectangle&#8217;s upper-left corner<br/>
  int nTopRect,     // y-coord of bounding rectangle&#8217;s upper-left corner<br/>
  int nRightRect,  // x-coord of bounding rectangle&#8217;s lower-right corner<br/>
  int nBottomRect  // y-coord of bounding rectangle&#8217;s lower-right corner<br/>
)<font color="#ff0000"><strong>attribute</strong>((stdcall));</font><br/><br/>
int main(){<br/>
     SetConsoleTitle(&#8220;hplonline&#8221;) ;<br/>
     HWND hWnd = FindWindow(NULL , &#8220;hplonline&#8221;) ;<br/>
     HDC hDC = GetDC(hWnd) ;<br/>
     HMODULE hLib = LoadLibrary(&#8220;gdi32.dll&#8221;) ;<br/><font color="#339966">     //printf(&#8220;%x\n&#8221;,hLib);</font><br/>
     func_rectangle pRectangle = (func_rectangle)GetProcAddress(hLib , &#8220;Rectangle&#8221;) ;<br/><font color="#339966">     //printf(&#8220;%x\n&#8221;,pRectangle);</font><br/>
     (</em>pRectangle)(hDC , 100 , 100 , 200 , 200 ) ;<br/><font color="#339966">     //Rectangle(hDC , 100 , 100 , 200 , 200 ) ;</font><br/>
     getchar();<br/>
     ReleaseDC(hWnd , hDC) ;  <br/><font color="#339966">     //system(&#8220;pause&#8221;) ;</font><br/>
     return 0 ;     <br/>
}<br/><br/><font color="#0000ff">1。得到窗口句柄<br/><br/></font>GetStdHandle函数得到的是控制台的<font color="#ff0000">输入输出句柄</font>，<br/>
这里要绘图，应该先得到<font color="#ff0000">窗口句柄</font>。<br/><br/>
由于没有直接的函数来完成这个事情。<br/>
M$给了一套用FindWindow的<a href="http://support.microsoft.com/kb/124103/zh-cn" target="_blank">解决方案</a>。<br/>
讲解很详细，而且考虑很周全，<br/>
比如先把窗口标题改为唯一的，再查找窗口，然后又改回来。<br/><br/><font color="#0000ff">2。取得相关的函数</font><br/><br/>
根据我的注释就看得出来，其实本来想直接写<br/>
Rectangle函数调用的。<br/><br/>
结果出来个错误：<br/><font color="#ff0000">  [Linker error] undefined reference to `Rectangle@20&#8217; </font><br/><br/>
连接器没有找到Rectangle的实现。<br/>
从函数的名字来看，知道要传入20字节的参数，是<strong>stdcall约定的。<br/><br/>
在VC6下，IDE默认给连接器设置了如下库的：<br/>
kernel32.lib user32.lib winspool.lib comdlg32.lib advapi32.lib <font color="#ff0000">gdi32.lib</font><br/>
shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib <br/>
可以在project-&gt;settings-&gt;link  .. Object/Library modules 看到他们。<br/><br/>
当然，我所想到的第二点就是用#pragma comment把库添加进去，<br/><font color="#339966">#pragma comment(lib , &#8220;gdi32.lib&#8221;)</font><br/>
在VC下经常这样搞，但是这回还是报错依然。<br/><br/>
于是去VC下面试了一下，手动把gdi32.lib从链接选项中去掉。<br/>
错误出来了：<br/><font color="#ff0000">error LNK2001: unresolved external symbol </strong>imp<strong>Rectangle@20</font><br/>
多个</strong>imp<strong>前缀，表示导入函数。<br/>
加上<font color="#339966">pragma comment(lib , &#8220;gdi32.lib&#8221;)<br/></font>结果可以用了。<br/><br/>
看来在DEV下要找点其他的方法。<br/>
这里仅仅缺GDI32.DLL的函数，<br/>
但像 LoadLIbrary,GetProcAddress之类的都是有的。<br/>
于是就用他们两来取得任何想要的函数了。<br/><br/><font color="#0000ff">3。函数指针，调用约定</font><br/><br/>
用GetProcAddress得到的仅仅是一个地址，<br/>
要自己指定函数指针的类型。<br/><br/>
typedef BOOL (*func_rectangle)(<br/>
  HDC hdc,          // handle to device context<br/>
  int nLeftRect,    // x-coord of bounding rectangle&#8217;s upper-left corner<br/>
  int nTopRect,     // y-coord of bounding rectangle&#8217;s upper-left corner<br/>
  int nRightRect,  // x-coord of bounding rectangle&#8217;s lower-right corner<br/>
  int nBottomRect  // y-coord of bounding rectangle&#8217;s lower-right corner<br/>
)<font color="#ff0000"></strong>attribute__((stdcall));</font><br/><br/>
上午在VC6中试的时候，由于对结合规则不清楚搞了很久。<a href="http://hi.baidu.com/hplonline/blog/item/e936db001972dd18738b65a2.html" target="_blank">参考这个</a>。<br/>
用DEV的话，就像下面标红的地方一样，比较容易写。<br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/06/19/%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%8B%E6%94%B9%E5%8F%98%E6%96%87%E5%AD%97%E9%A2%9C%E8%89%B2/">控制台下改变文字颜色</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-06-19T13:23:00+08:00" pubdate data-updated="true">Jun 19<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.6.19<br/><br/>
用MFC的类或者GDI做图形编程的时候。<br/>
要改变下文字的颜色比较容易，有若干直观的函数可以调用。<br/>
比如SetBkColor之类的。<br/><br/>
在控制台下，还有一套古老的API可以用。<br/>
虽然不是很直观，也能达到一定效果。<br/><br/><font color="#0000ff">效果：</font><br/><div forimg="1"><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/b0aea7346dea9b91d1a2d31c.jpg"/></div></p>

<br/><br/><font color="#0000ff">代码：</font><br/><br/>


<h1>include &lt;windows.h&gt;<br/><br/></h1>

<p>int main(){<br/>
      HANDLE h ;<br/>
      int len ;<br/>
      COORD coord ;<br/>
      WORD att ;<br/>
      h = GetStdHandle(STD_OUTPUT_HANDLE) ;<br/>
      len = lstrlen(&#8220;hplonline&#8221;) ;<br/>
      WriteConsole(h , &#8220;hplonline&#8221; , len , &amp;len , NULL) ;<br/><br/>
      coord.X = 0 ;<br/>
      coord.Y = 0 ;<br/>
      att =  BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED | FOREGROUND_RED | FOREGROUND_BLUE;<br/>
      FillConsoleOutputAttribute(h , att , len , coord , &amp;len) ;<br/>
      <br/>
      getchar();<br/>
      return 0 ;<br/>
}<br/><br/><font color="#0000ff">说明：</font><br/><br/>
这套函数的名字里面一般都有Console字样。<br/>
GetStdHandle用来取得当前的标准输入，输出，或错误输出的句柄。<br/>
在调用其他函数的时候，一般都要求传入这个句柄。<br/><br/>
att比较有意思，是个WORD型的，定义的常量中只有RED GREEN BLUE 这几个，<br/>
但是可以用 | 把他们连接起来，组成其他的颜色。一共有8种。<br/><br/>
屏幕坐标按照惯例，也是向右为x的正方向，向下为y的正方向。<br/><br/>
其他的在MSDN里面说明很详尽了。<br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/06/18/windows%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E7%9A%84%E5%87%A0%E4%B8%AA%E7%AE%80%E5%8D%95%E5%AE%9E%E9%AA%8C%EF%BC%88__try%2C__finally%2C__except%29%EF%BC%88VC6%29/">Windows异常处理机制的几个简单实验（__try , __finally , __except)（VC6)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-06-18T11:57:00+08:00" pubdate data-updated="true">Jun 18<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.6.18<br/><br/>
C++有标准的try,catch,throw，还没来得及深入体会。<br/>
先试试M$的windows异常处理机制<strong>try , </strong>finally , __except。<br/><font color="#0000ff"><br/>
一。观察时序</font><br/><br/>
这个例子是从MSDN里面抄下来的，只改了一小点地方<br/><br/>
// Example of try-except and try-finally statements<br/></p>

<h1>include &#8220;stdio.h&#8221;<br/></h1>

<h1>include &lt;windows.h&gt;<br/></h1>

<h1>include &lt;excpt.h&gt;<br/><br/></h1>

<p>void main()<br/>
{<br/>
    int<em> p = 0x00000000;    // pointer to NULL<br/>
    puts(&#8220;hello&#8221;);<br/>
    <strong>try{<br/>
       puts(&#8220;in try1&#8221;);<br/>
       </strong>try{<br/>
          puts(&#8220;in try2&#8221;);<br/>
          </em>p = 13;     // causes an access violation exception;<br/>
       }<strong>finally{<br/>
          puts(&#8220;in finally&#8221;);<br/>
       }<br/>
    }</strong>except(puts(&#8220;in filter&#8221;), 1){<br/>
       puts(&#8220;in except&#8221;);<br/>
    }<br/>
    puts(&#8220;world&#8221;);<br/>
}<br/><br/><font color="#ff6600">输出：</font><br/><br/>
hello<br/>
in try1<br/>
in try2<br/>
in filter<br/>
in finally<br/>
in except<br/>
world<br/><br/><font color="#ff6600">结论：</font><br/><br/>
根据输出的字符串，各个语句块的执行顺序一目了然。<br/>
要注意的就是finally是在对应的try块执行完之后（不管是正常还是异常结束）。<br/><br/>
__except(XXX){<br/>
       YYY<br/>
    }<br/>
其中XX部分M$叫他filter，在捕获到异常的时候执行。<br/>
YYY部分叫except 。在异常位置对应的finally之后执行。<br/><br/>
设置finally这一机制的目的在于，异常处理完之后，还有机会去释放一些资源等等。<br/><br/><font color="#0000ff">二。异常处理相关的结构</font><br/><br/><br/></p>

<h1>include &lt;stdio.h&gt;<br/></h1>

<h1>include &lt;EXCPT.H&gt;<br/></h1>

<h1>include &lt;windows.h&gt;<br/></h1>

<h1>include &lt;winnt.h&gt;<br/><br/></h1>

<p>int myhandler(int code , PEXCEPTION_POINTERS p){<br/>
     printf(&#8220;error but corrected %x\n&#8221; , code) ;<br/>
     printf(&#8220;%x,%x\n&#8221; , p-&gt;ContextRecord , p-&gt;ExceptionRecord) ;<br/>
     CONTEXT <em>c = p-&gt;ContextRecord  ;<br/>
     printf(&#8220;%x,%x,%x,%x\n&#8221;,c-&gt;Eax , c-&gt;Ebx , c-&gt;Ecx , c-&gt;Edx ) ;<br/>
     printf(&#8220;%x\n&#8221;,&amp;c);<br/>
     return 1;<br/>
}<br/><br/>
int main(){<br/>
     <strong>try{<br/>
          </strong>asm{<br/>
               mov eax , 1 ;<br/>
               mov ebx , 2 ;<br/>
               mov ecx , 3 ;<br/>
               mov edx , 4 ;<br/>
               mov [eax] , 1 ; cause exception <br/>
          }<br/>
     }<strong>except(myhandler(<em>exception_code() , (PEXCEPTION_POINTERS)</em>exception_info())){} ;<br/>
     return 0 ;<br/>
}<br/><br/><font color="#ff6600"></strong>except()</font><br/><br/>
其中如果要执行复杂的操作，可以封装一个函数完成。<br/>
这个函数应该返回如下值：<br/><strong>EXCEPTION_CONTINUE_EXECUTION (–1)</strong>  <br/>
表示异常已经消除，从异常地址处<font color="#ff0000">继续执行</font><br/><strong>EXCEPTION_CONTINUE_SEARCH (0)</strong> <br/>
表示无法处理这个异常，叫给后一级处理<br/><strong>EXCEPTION_EXECUTE_HANDLER (1)</strong> <br/>
表示异常数理完，<font color="#ff0000">结束程序</font><br/><br/>
在int myhandler(函数中，把 return 1;<br/>
改为 <font color="#ff0000">return -1</font>，可以看到不断打印出信息，<br/>
因为还没有消除这个异常，于是返回执行时马上又进入异常处理函数<br/>
改为 <font color="#ff0000">return 0</font>，可以看到windows的报错框，然后程序结束了。<br/>
因为表示没法处理这个异常，而之后我们又没有其他的处理函数了，<br/>
于是交给了系统，系统一般都是弹个出错框，然后结束程序。<br/><br/><font color="#ff6600"><em>exception_code()，</em>exception_info()</font><br/><br/>
前者返回错误代码，后者返回EXCEPTION_POINTERS结构的一个指针，<br/>
只能在<font color="#ff0000">filter</font>的位置使用这个函数。<br/>
定义如下：<br/>
typedef struct _EXCEPTION_POINTERS {<br/>
     PEXCEPTION_RECORD ExceptionRecord;<br/>
     PCONTEXT ContextRecord;<br/>
} EXCEPTION_POINTERS, </em>PEXCEPTION_POINTERS;<br/>
这个结构里面包含两个指针。<br/>
他们的定义都可以在 <font color="#ff0000">winnt.h</font>中看到，比较长，就不抄出来的了。<br/><br/>
通过ExceptionRecord可以取得比如异常地址，异常代码，之类的信息。<br/>
通过ContextRecord可以取得异常时的CPU现场。<br/>
（示例中打印出了几个寄存器的值供观察）<br/><font color="#ff6600"><br/>
ExceptionRecord，ContextRecord指向的地址</font><br/><br/>
他们都是放在栈区的，<br/>
根据打印出的地址和局部变量的地址比较可得，<br/>
printf(&#8220;%x\n&#8221;,&amp;c);<br/><br/><font color="#0000ff">三。修正现场继续执行</font><br/><br/></p>

<h1>include &lt;stdio.h&gt;<br/></h1>

<h1>include &lt;EXCPT.H&gt;<br/></h1>

<h1>include &lt;windows.h&gt;<br/></h1>

<h1>include &lt;winnt.h&gt;<br/><br/></h1>

<p>int myerror(int code , PEXCEPTION_POINTERS p){<br/>
     printf(&#8220;error but corrected %x\n&#8221; , code) ;<br/>
     CONTEXT *c = p-&gt;ContextRecord ;<br/>
     c-&gt;Ebx = 1 ;<br/>
     return -1;<br/>
}<br/><br/>
int main(){<br/>
     <strong>try{<br/>
          </strong>asm{<br/>
               mov ebx , 0 ;<br/>
               mov eax , 0 ;<br/>
               cdq ;<br/>
               div ebx ;<br/>
          }<br/>
     }<em><em>except(myerror(</em>exception_code() , (PEXCEPTION_POINTERS)</em>exception_info())){<br/>
     <br/>
     }<br/>
     return 0 ;<br/>
}<br/><br/>
这里制造了一个除0的异常。<br/>
在异常处理中，把EBX的值修改过后，返回-1，<br/>
告知继续执行，可以看到程序正常结束。<br/><br/>
如果把  c-&gt;Ebx = 1 ;注释掉，就像前面例子中一样，<br/>
异常不断地被触发，导致不停地打印信息。。<br/><br/><font color="#0000ff">其他:</font><br/><br/>
EXCPT.H这个头文件名让我觉得很梗塞。。。<br/>
这是哪门子的缩写啊。。。那个E很有必要省略吗。。<br/><br/>
windows异常处理机制的详细资料（看0day推荐的）：<br/><a href="http://www.microsoft.com/msj/0197/exception/exception.aspx" target="_blank"><font face="verdana, arial, helvetica" color="#000080" size="3">A Crash Course on the Depths of Win32™ Structured Exception Handling</font></a><br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/06/17/%E8%B4%B9%E9%A9%AC%E7%82%B9%EF%BC%88%E5%88%9D%E8%AF%95%E5%87%A0%E4%BD%95%E7%94%BB%E6%9D%BF%EF%BC%89/">费马点（初试几何画板）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-06-17T19:32:00+08:00" pubdate data-updated="true">Jun 17<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.6.17<br/><br/><font color="#0000ff">起因：</font><br/><br/>
看一篇paper的时候看到了这个<br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/f6fb9aef1ee6b5c9cf1b3e54.jpg" small="0" class="blogimg"/><br/>
表达的是平面三点的Steiner tree的构造方法。<br/>
中间那个黑点就是传说中的费马点。<br/><br/>
于是在以前的note里面翻箱倒柜一番，<br/>
居然发现还收藏了百度百科的那个词条，<br/>
那为什么当时没有细看呢。<br/><br/>
观察了一下，原因太简单了，只能怪<a href="http://baike.baidu.com/view/184329.htm" target="_blank">那图</a>太丑了，估计以后会被补充好一点吧。<br/><br/>
由于经常依赖电脑做事情，用纸总觉得不爽。<br/>
突然很火星地发现了<font color="#ff0000">几何画板</font>这个软件。<br/><br/>
用了下，果然很方便，比起CAD来说，足够轻量级了，容易上手。<br/>
而且他是基于元素之间的生成关系的，<br/>
比如我下面画好的那个图，拖动其中的线段，其他部分会跟着变形，<br/>
对于直观观察一些结论来说很好用。<br/><br/>
一边画一边看，就很容易理解了，以后就拿这个当草稿纸了<img src="http://img.baidu.com/hi/jx/j_0015.gif"/><br/><br/><font color="#ff0000">下面证明的文字部分是从百科copy过来的。</font><br/><font color="#0000ff"><br/>
证明：</font><br/><br/><font color="#ff6600">(1)费马点对边的张角为120度。</font></div></p>

<div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/ec10a5519dfea6a98d543054.jpg" small="0" class="blogimg"/><br/>
△CC&#8217;B和△AA’B中,BC=BA&#8217;,BA=BC&#8217;,∠CBC&#8217;=∠B+60度=∠ABA&#8217;,<br/>
△CC&#8217;B和△AA&#8217;B是全等三角形,得到∠PCB=∠PA&#8217;B<br/>
同理可得∠CBP=∠CA&#8217;P<br/>
由∠PA&#8217;B+∠CA&#8217;P=60度，得∠PCB+∠CBP=60度,所以∠CPB=120度<br/>
同理,∠APB=120度，∠APC=120度<br/><br/><font color="#ff6600">(2)PA+PB+PC=AA&#8217;</font><br/><br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/ec10a5519dfea6a98d543054.jpg" small="0" class="blogimg"/></div>
<br/>
将△BPC以点B为旋转中心旋转60度与△BDA&#8217;重合，连结PD，则△PDB为等边三角形，所以∠BPD=60度<br/>
又∠BPA=120度，因此A、P、D三点在同一直线上，<br/>
又∠CPB=∠A&#8217;DB=120度，∠PDB=60度，∠PDA&#8217;=&#8217;80度，所以A、P、D、A&#8217;四点在同一直线上，故PA+PB+PC=AA&#8217;。</div>


<div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/e1f5302959d5f2d898250a54.jpg" small="0" class="blogimg"/><br/><br/><font color="#ff6600">(3)PA+PB+PC最短</font><br/><br/>
在△ABC内任意取一点M（不与点P重合），连结AM、BM、CM，将△BMC以点B为旋转中心旋转60度与△BGA&#8217;重合，连结AM、GM、A&#8217;G(同上)，则AA&#8217;&lt;A&#8217;G+GM+MA=AM+BM+CM.所以费马点到三个顶点A、B、C的距离最短。</div>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/06/14/Nelder-Mead%E5%8D%95%E7%BA%AF%E5%BD%A2%E6%B3%95%E6%B1%82%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E6%9E%81%E5%80%BC%EF%BC%88MATLAB%EF%BC%89/">Nelder-Mead单纯形法求多元函数极值（MATLAB）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-06-14T19:34:00+08:00" pubdate data-updated="true">Jun 14<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.6.14<br/><br/><font color="#0000ff">简介：</font><br/><br/>
n维空间中，由n+1个顶点，可以组成“最简单”的图形，叫单纯形。<br/>
NM法就是先构造一个初始的，包含给定点的单纯形。<br/>
然后使用可能的三种手段（<font color="#ff0000">反射，扩展，压缩</font>）去替换函数值最差的顶点。<br/>
在以上三种手段失效的时候，使用<font color="#ff0000">收缩</font>。<br/>
直到该单纯形的半径足够的小。<br/>
（半径的定义可以有很多，比如两两点的距离，<br/>
两两点构成的向量中最大的维度的值，<br/>
只要当“半径”趋于0的时候，该单纯形趋于一个点即可）<br/><br/><font color="#0000ff">相关资料：</font><br/><br/><a href="http://www.box.net/shared/14o1dy0f5d" target="_blank">NelderMeadProof.pdf</a><br/>
这篇文章讲解比较详细。<br/>
虽然只提到二维的情况，不过可以推广到n维。<br/>
主要通过上面的几个图例，知道四种手段即可：<br/><font color="#ff0000">反射(reflection)，扩展(expasion)，压缩(contraction)，</font><font color="#ff0000">收缩(shrink)</font><br/><br/>
看懂了这四个基本手段后，就不用去搜其他资料了。<br/>
感觉网上很多写得十分别扭。<br/>
最好的方法就是直接找matlab里面的fminsearch函数。<br/>
写得漂亮而且通用。<br/>
这套代码里面，允许对以上四种操作的尺寸做定制。<br/>
（比如一般的文献讲的扩展是从反射点再走一倍反射点到中心的距离，<br/>
这个距离在fminsearch里面可以手工定制：<br/>
% Initialize parameters<br/>
rho = 1;<font color="#ff0000"> chi = 2;</font> psi = 0.5; sigma = 0.5;<br/>
同理还可以改变其他几个代码)<br/><font color="#0000ff"><br/>
单纯形变换流程：</font><br/><br/>
看流程之前，先确保一提到上面四个操作，就能反映出相关的点之间的关系。<br/><br/>
最好点：best<br/>
次差点：soso<br/>
最差点：worst<br/>
反射点：r<br/>
扩展点：e<br/>
内压缩点：c1(center和worst之间）<br/>
外压缩点：c2(center和r之间）<br/><br/>
1。如果反射点值小于best，那么考虑扩展点e，选r和e中小者去替换worst<br/>
2。如果反射点值小于soso，用r如替换worst<br/>
3。非以上两种情况，考虑压缩点<br/>
3.1。worst比r小，那么考虑c1，如果c1比worst小，选c1替换，否则考虑收缩<br/>
3.2。r比worst小，那么考虑c2，如果c2比r小，选c2替换，否则考虑收缩<br/>
4。如果在第3步中确定需要收缩，那么将所有点向best方向按比例收缩<br/><br/>
剩下的内容代码里面比较详细了。<br/><br/><font color="#0000ff">代码：</font><br/><br/>
下面这个就是看了matlab实现的fminsearch之后，稍加改写的一个版本。<br/>
去掉了一些通用性的定制变量，一些繁琐的参数判断，尽量写了详细的注释。<br/><br/>
function [x , fval , flag] = nm_min(fun , x0 , max_time , eps)<br/>
%realization of Nelder-Mead Simplex<br/>
%[x fval flag] = nm_min(f , x0 , max_time , eps)<br/>
%max_time:最大迭代次数，默认10000<br/>
%eps:精度，默认1e-5<br/><br/>
%参数检查<br/>
if nargin &lt; 2, <br/>
       error(&#8216;请至少传入函数和初始点&#8217;); <br/>
end<br/><br/>
%默认值设置<br/>
if nargin &lt; 3<br/>
        max_time = 10000 ;<br/>
end<br/>
if nargin &lt; 4<br/>
        eps = 1e-5 ;        <br/>
end<br/><br/>
n = length(x0) ;%变量个数<br/>
x0 = x0(:) ;%把x0变成列向量<br/><br/>
%vx是单纯形矩阵，n行n+1列<br/>
%即n维空间中的n+1个点<br/>
vx = x0 ;<br/>
%vf是函数值，对应每个列向量<br/>
vf = feval(fun , x0) ;<br/><br/>
%构造初始单纯形<br/>
%分别对每个维度按一定比例扩张，以形成一个高维体<br/>
for i = 1:n         <br/>
        x = x0 ;<br/>
        if abs(x(i)) &lt; eps<br/>
            x(i) = x(i) + 0.005 ;%该维度上为0时，人工指定加上一定值<br/>
        else<br/>
            x(i) = x(i) * 1.05 ;<br/>
        end<br/>
        vx = [vx , x] ;<br/>
        vf = [vf , feval(fun , x)] ;<br/>
end<br/><br/>
%排序，做迭代准备<br/>
[vf index] = sort(vf) ;<br/>
vx = vx(:,index) ;<br/><br/>
%开始迭代<br/>
while max_time &gt; 0 <br/>
        %各个点在各维度上的差值足够小<br/>
        if max(max(abs(vx(:,2:n+1)-vx(:,1:n)))) &lt; eps <br/>
            break<br/>
        end<br/>
        %三个考察点，最优，次差，最差<br/>
        best = vx(: , 1) ;<br/>
        fbest = vf(1) ;<br/>
        soso = vx(: , n) ;<br/>
        fsoso = vf(n) ;<br/>
        worst = vx(: , n+1) ;<br/>
        fworst = vf(n+1) ;            <br/>
        center = sum(vx(: , 1:n) , 2) ./ n ;<br/>
        r = 2 * center - worst ;%反射点<br/>
        fr = feval(fun , r) ;<br/>
        if fr &lt; fbest<br/>
            %比最好的结果还好，说明方向正确，考察扩展点，以期望更多的下降<br/>
            e = 2 * r - center ; %扩展点<br/>
            fe = feval(fun , e) ;<br/>
            %在扩展点和反射点中选择较优者去替换最差点<br/>
            if fe &lt; fr<br/>
                vx(: , n+1) = e ;<br/>
                f(: , n+1) = fe ;<br/>
            else<br/>
                vx(: , n+1) = r ;<br/>
                vf(: , n+1) = fr ;<br/>
            end<br/>
        else<br/>
            if fr &lt; fsoso<br/>
                %比次差结果好，能够改进<br/>
                vx(: , n+1) = r ;<br/>
                vf(: , n+1) = fr ;                <br/>
            else<br/>
                %比次差结果坏，应该考察压缩点<br/>
                %当压缩点无法得到更优值的时候，考虑收缩<br/>
                shrink = 0 ;<br/>
                if fr &lt; fworst<br/>
                    %由于r点更优所以<br/>
                    %向r点的方向找压缩点 <br/>
                    c = ( r + center ) ./ 2 ;<br/>
                    fc = feval(fun , c) ;<br/>
                    if fc &lt; fr<br/>
                        %确定从r压缩向c可以改进 <br/>
                        vx(: , n+1) = c ;<br/>
                        vf(: , n+1) = fc ;<br/>
                    else<br/>
                        %否则的话，准备进行收缩<br/>
                        shrink = true ;<br/>
                    end<br/>
                else<br/>
                    c = (worst + center) ./ 2 ;<br/>
                    fc = feval(fun , c) ;<br/>
                    if fc &lt; fr<br/>
                        %确定从r压缩向c可以改进 <br/><font color="#ff0000">%（2009.7.22标注，这里应该是搞错了，回去再认真看一下）</font><br/>
                        vx(: , n+1) = c ;<br/>
                        vf(: , n+1) = fc ;<br/>
                    else<br/>
                        %否则的话，准备进行收缩<br/>
                        shrink = 1 ;<br/>
                    end                    <br/>
                end%fr &lt; fworst<br/>
                if shrink<br/>
                    %压缩点并非更优，考虑所有点向best收缩<br/>
                    for i = 2:n+1<br/>
                        vx(: , i) = ( vx(i) + best ) ./ 2 ;<br/>
                        vf(: , i) = feval(fun , vx(: , i)) ;<br/>
                    end<br/>
                end%shrink<br/>
            end%fr &lt; fsoso<br/>
        end%fr &lt; fbest<br/>
        [vf index] = sort(vf) ;<br/>
        vx = vx(:,index) ;        <br/>
        max_time = max_time - 1 ;<br/>
end%while max_time &gt; 0 <br/><br/>
x = vx(: , 1) ;<br/>
fval = vf(: , 1);<br/><br/>
if max_time &gt; 0<br/>
        flag = 1 ;<br/>
else <br/>
        flag = 0 ;<br/>
end<br/><font color="#0000ff"><br/>
示例：</font><br/><br/>
f = inline(&#8216;x(1).<sup>2+(x(2)-2).<sup>2&#8217;)<br/></sup></sup>
[x fval flag] = nm_min(f , [0;0])<br/><br/>
x =<br/>
           0<br/>
      2.0000<br/>
fval =<br/>
8.0779e-028<br/>
flag =<br/>
       1<br/><br/>
flag=1表示找到解，[0;2.0000]，相应的函数值为8.0779e-028(即0）<br/>
和解析计算吻合。<br/><br/><font color="#0000ff">图形化演示：</font><br/><br/>
对于上面的示例，修改一下程序，画出先10次迭代的轨迹如下：<br/><br/><div forimg="1"><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/2210888b1e1140f6fc1f107b.jpg"/></div>
此方法的精髓在于不断向最优点进发。<br/>
而在最优点附近的时候，围绕最优点旋转，并不断收缩，<br/>
直到所掌握的单纯形近似收缩到一个点为止。<br/><br/><font color="#0000ff">关于matlab的一点事：</font><br/><br/>
在看fminsearch时才发现<br/>
x(:)这个表达式，无论x是列向量还是行向量，都会返回列向量<br/><br/>
维度的指定相当重要 。<br/>
%排序，做迭代准备<br/>
[vf index] = sort(vf) ;<br/>
vx =<font color="#ff0000"> vx(:,index) ;</font><br/><br/>
最初写的是vx = vx(index)<br/>
直接导致vx中不是按照列提取的结果。。。<br/><br/>
还有<br/>
max(max(abs(vx(:,2:n+1)-vx(:,1:n))))<br/><font color="#ff0000">vx(:,2:n+1)</font>里面的冒号开始也写掉了。<br/>
当达到极值的时候，反而搞得分量间可能相差较大。<br/>
所以每次都跑慢max_time。。。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/06/07/%E7%94%A8ROM%E8%87%AA%E5%88%B6ALU%EF%BC%88proteus%EF%BC%8Cvc%EF%BC%8C27c512%29/">用ROM自制ALU（proteus，vc，27c512)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-06-07T12:56:00+08:00" pubdate data-updated="true">Jun 7<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.6.7<br/><br/>
完整作品下载：<a href="http://www.box.net/shared/1ogxc1lnyx" target="_blank">rom_caculator</a><br/><br/>
前些时候，学习数电，听说了74X181这个东西，<br/>
感觉功能还挺多的，结果在proteus里面仿真的时候，<br/>
只有一个空壳在那里，没有相关的模型，无法使用。（我是7.12版）<br/><br/>
这周数电结课，听到了一句近乎哲学的话（至少是相对这个学科而言），<br/>
一语惊醒梦中人啊：<br/><br/><font color="#ff0000">rom的本质就是一个n输入m输出组合逻辑电路。</font><br/>
（地址线有n位，数据线有m位）<br/>
在课上苦苦耗了一学期，听到的最有用的一句莫过于此<img src="http://img.baidu.com/hi/jx/j_0015.gif"/>。<br/>
我很喜欢这种，说出来地球人都知道，但是不说，大部分地球人都不知道的东西。。。<br/><br/>
那么接上面，比如这里选用的27c512就可以看作16输入，8输出的组合逻辑电路了。<br/><br/><font color="#0000ff">电路：</font><br/><br/><div forimg="1"><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/1f1e11d5e16ba4e150da4b70.jpg"/></div></p>

<br/>


<p>a和b是4bit的数据输入，上面为低位，直接接到了0&#8211;7的地址线上。<br/>
下面是运算符选择。四种运算符，用编码器编码后送到8，9两位。<br/><br/>
右边的D[0..7]就是数据输出，也是上面为低位。<br/><br/>
上图演示的就是a/b的结果（即：7/2=3）<br/><br/><font color="#0000ff">程序：</font><br/><br/>
程序就很简单了，随便拿个在pc上写c的工具就可以了。<br/><br/></p>

<h1>include &lt;stdio.h&gt;<br/><br/></h1>

<p>int main(){<br/>
      FILE *fp = fopen(&#8220;data_rom.bin&#8221; , &#8220;wb&#8221;) ;<br/>
      unsigned int i , j ;<br/>
      unsigned char ch ;<br/><br/>
      for ( i = 0 ; i &lt; 16 ; i ++ ) {<br/>
            for ( j = 0 ; j &lt; 16 ; j ++ ){<br/>
                  ch = i + j ;<br/>
                  fwrite(&amp;ch , 1 , 1 , fp) ;<br/>
            }<br/>
      }<br/><br/>
      for ( i = 0 ; i &lt; 16 ; i ++ ) {<br/>
            for ( j = 0 ; j &lt; 16 ; j ++ ){<br/>
                  ch = (unsigned char)(j - i) ;<br/>
                  fwrite(&amp;ch , 1 , 1 , fp) ;<br/>
            }<br/>
      }<br/><br/>
      for ( i = 0 ; i &lt; 16 ; i ++ ) {<br/>
            for ( j = 0 ; j &lt; 16 ; j ++ ){<br/>
                  ch = i * j ;<br/>
                  fwrite(&amp;ch , 1 , 1 , fp) ;<br/>
            }<br/>
      }      <br/><br/>
      for ( i = 0 ; i &lt; 16 ; i ++ ) {<br/>
            for ( j = 0 ; j &lt; 16 ; j ++ ){<br/>
                  if ( i == 0 ) ch = 0xff ;<br/>
                  else ch = j / i ;<br/>
                  fwrite(&amp;ch , 1 , 1 , fp) ;<br/>
            }<br/>
      }<br/><br/>
      fclose(fp) ;<br/>
      return 0 ;<br/>
}<br/><br/><font color="#0000ff">加载：</font><br/><br/>
在proteus里面，为27c512指定数据文件，就选择上面生成的data_rom.bin。<br/>
然后就可以使用了。<br/><br/><font color="#0000ff">总结：</font><br/><br/>
一旦得知到rom的本质之后，可以用其来实现的逻辑即可获得大幅增长。<br/><br/>
一般的数电，微机原理之类的课程都会提到相应的<font color="#ff0000">字扩展，位扩展</font>的事情。<br/>
这样，就可以得到<font color="#ff0000">任意想要的输入个数和输出个数</font>。<br/><br/>
剩下的事情就是生成相应的数据，下载到rom里面这么简单。<br/><br/>
个把月前，当初次听说181，但又没找到相应的模型的时候，<br/>
真的是很纠结，当时想了两种：<br/><font color="#ff6600">1。用其他MSI来搭建。。。其复杂程度无法想象，作罢。<br/>
2。自己做个元件。。在网上找了很久的资料。。没找着有用的，也罢。。</font><br/><br/>
而现在，任何的组合逻辑都可以用一个小小的rom来实现，<br/>
可谓强大啊。。虽然上面只给了几个简单的四则运算。<br/>
但是，各位看官必然想到，用他来开方，求幂，控制数码管显示，等等，<br/>
都完全不在话下。。<br/><br/>
用C语言写段程序，生成相应的数据显然比用若干器件来搭建一个庞大的电路简单。<br/><font color="#ff0000">另外，对应于任何输入，获得稳定输出的时间都是一样的。</font><br/>
（这点是其他器件搭建出来的不容易做到的，<br/>
因为不同的输入途经的线路会不同，<br/>
比较典型的就是像ripple adder这种，<br/>
最小和最大延迟之间成倍数关系）<br/>
再换句话说，这种搞法有点<font color="#ff0000">打表</font>的味道。<img src="http://img.baidu.com/hi/jx/j_0015.gif"/><br/>
可见一个通用的思想，可以用在不同的地方。<br/>
（可参考：<a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/8fbb05b30fb894a0d8335ae9.html">编译器打表（MASM)</a>）<br/><br/>
rom。。。很邪恶，很暴力的通用解决方案。<img src="http://img.baidu.com/hi/jx/j_0003.gif"/></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/backup-hplonline/blog/page/15/">&larr; Older</a>
    
    <a href="/backup-hplonline/blog/archives">Blog Archives</a>
    
    <a class="next" href="/backup-hplonline/blog/page/13/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/backup-hplonline/blog/2013/05/04/test/">Test</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/04/09/%E5%86%8D%E8%B0%88stl%E7%9A%84rotate/">再谈stl的rotate</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%BA%8C%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、二）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%89%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、三）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%80%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、一）</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - hplonline -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
