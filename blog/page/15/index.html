
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>hplonline</title>
  <meta name="author" content="hplonline">

  
  <meta name="description" content="(hplonline)2009.6.6
我的参考代码和详细的资料在这里下载。
其中写了导读了，于是我就不在这里说了。上一篇中也有简单的提要，可以在最后看下。
HDU1512，这个在前面的左偏树里面提到过了。
因为当时刷了下不是很快，于是想到有斐波那契堆这个东西，
结果用好不容易搞了个斐波那契堆出来 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hupili.github.io/backup-hplonline/blog/page/15">
  <link href="/backup-hplonline/favicon.png" rel="icon">
  <link href="/backup-hplonline/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/backup-hplonline/atom.xml" rel="alternate" title="hplonline" type="application/atom+xml">
  <script src="/backup-hplonline/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/backup-hplonline/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/backup-hplonline/">hplonline</a></h1>
  
    <h2>backup from 2006 to 2012 (original hi.baidu.com/hplonline/)</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/backup-hplonline/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hupili.github.io/backup-hplonline" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/backup-hplonline/">Blog</a></li>
  <li><a href="/backup-hplonline/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/06/06/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86%28fibonacciheap%29%28poj2253%29%28hdu1512%29/">斐波那契堆(fibonacci Heap)(poj2253)(hdu1512)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-06-06T10:59:00+08:00" pubdate data-updated="true">Jun 6<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.6.6<br/><br/>
我的参考代码和详细的资料在<a href="http://www.box.net/shared/mvvr4h2cyq" target="_blank">这里下载</a>。<br/>
其中写了导读了，于是我就不在这里说了。<br/><a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/c62071cb4d9b1917bf09e6b4.html">上一篇</a>中也有简单的提要，可以在最后看下。<br/><br/>
HDU1512，这个在前面的<a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/7a8a0633d33d0ef01b4cff08.html">左偏树</a>里面提到过了。<br/>
因为当时刷了下不是很快，于是想到有斐波那契堆这个东西，<br/>
结果用好不容易搞了个斐波那契堆出来，反而更慢，太失望了。<br/><br/><a href="http://www.box.net/shared/tyanmpcxiz" target="_blank">HDU1512.TXT</a><br/><br/>
POJ2253，求的是 Min Max路径，就是经过的边中最大值最小的路。<br/>
随便上一种最短路的算法就可以了。<br/>
刷这个题，只是为了测试一下用斐波那契堆实现可改点堆的正确性。<br/><br/><a href="http://www.box.net/shared/slixsfievu" target="_blank">POJ2253.TXT</a><br/><br/><font color="#0000ff">我的终极bug：</font><br/><br/>
1.bug版<br/>
//将l2放到l1的断开处<br/>
PFNode <em>list_merge(PFNode l1 , PFNode l2){<br/>
      if ( l1 == NULL ) return l2 ;<br/>
      if ( l2 == NULL ) return l1 ;<br/>
      PFNode l1_right = l1-&gt;right ;<br/>
      PFNode l2_right = l2-&gt;right ;<br/><font color="#ff0000">      l1-&gt;right = l2 ;<br/>
      l2-&gt;left = l1 ;<br/>
      l2_right-&gt;right = l1_right ;<br/>
      l1_right-&gt;left = l2_right ;</font><br/>
      return l1 ;<br/>
}<br/><br/>
2.正常版<br/>
//将l2放到l1的断开处<br/>
PFNode </em>list_merge(PFNode l1 , PFNode l2){<br/>
      if ( l1 == NULL ) return l2 ;<br/>
      if ( l2 == NULL ) return l1 ;<br/>
      PFNode l1_right = l1-&gt;right ;<br/>
      PFNode l2_right = l2-&gt;right ;<br/><font color="#ff0000">      l1-&gt;right = l2_right ;<br/>
      l2-&gt;right = l1_right ;<br/>
      l2_right-&gt;left = l1 ;<br/>
      l1_right-&gt;left = l2 ;/<em>here &#8230;</em>/</font><br/>
      return l1 ;<br/>
}<br/><br/>
这就是我调了三天的最大的一个bug（当然期间也有不少小的bug）<br/>
仔细一看。。。其实就是把双向链表的合并写错了<img src="http://img.baidu.com/hi/jx/j_0012.gif"/>。<br/>
可见基础的数据结构都没过关，太浮躁了<img src="http://img.baidu.com/hi/jx/j_0004.gif"/>。。。。<br/><br/><font color="#0000ff">一点感想:</font><br/><br/>
有时候，花多少时间仅仅取决于对于一件事情的较真程度。<br/><br/>
写出第一版，仅花了两个小时。<br/>
随便写几个插入删除，看结果都很正常。<br/>
于是我身边的80%的人，会就此停住了。<br/>
（常年在纸上写程序，连能否编译通过都不知道，<br/>
还期望他们有闲心去测试什么吗？<br/>
对于他们来说，老师的红勾就是正确的代名词）<br/><br/>
接着我用大数据进行排序的测试。<br/>
发现了一些问题，调了之后，对于20000的数据排序都正常了。<br/>
这时候，不说别人了，连我自己都心满意足了。<br/>
直到这个时候，也才花了三小时左右。<br/><br/>
本来当天就想把我的东西发出来的，<br/>
又想了一下，还是去把HDU1512给刷了再说。<br/>
改了一下，把样例过了，交上去，TLE了。。。。。<br/><br/>
第二天又来搞，发现了TLE所在，一改，结果WA了。。<br/>
很想不通，于是自己生成了数据，跟前面用左偏树写一起测，<br/>
发现果然答案不同。。。<br/><br/>
第三天又找啊找。。才发现了原来是上面提到的链表操作失误。。<br/>
当时那个郁闷啊。。。因为这几天一直在想是不是对斐波那契堆的理解有误。<br/>
根本没有怀疑过会在这种基础结构上出问题。。。。<img src="http://img.baidu.com/hi/jx/j_0012.gif"/><br/><br/>
于是昨晚把HDU1512刷了，刚想发，想起减值操作还没测试。。。<br/>
于是又在POJ上找了道很水的最短路，来整个改点堆。。。<br/><br/>
好不容易。。终于可以放心地发了。。。<img src="http://img.baidu.com/hi/jx/j_0009.gif"/>。<br/>
（不过各位发现bug了，记得要跟我说哈）</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/06/05/4%E7%A7%8D%E5%8F%AF%E5%B9%B6%E5%A0%86/">4种可并堆</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-06-05T15:10:00+08:00" pubdate data-updated="true">Jun 5<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.6.5<br/>
今天比较失败，搞忘带实验室钥匙了<img src="http://img.baidu.com/hi/jx/j_0009.gif"/>。<br/>
被卡在门外，于是去参观了下新图书馆。<br/><br/>
本来是要去找找斐波那契堆(fibonacci heap)的资料，<br/>
主要是搞这个玩意搞了两天了，还是有点问题，都不好意思拿出来。。。<br/>
翻了好多地方还是没有翻到，倒是乱七八糟地看了一堆还没来得及实践的结构。<br/><br/><font color="#0000ff">可并堆：</font><br/><br/>
一般谈到的二项堆，关注其根有序的特性。<br/>
支持插入，弹出最小，等操作。<br/>
用来局部排序的效果很好(比如STL里面的partial_sort)<br/><br/>
不足在于，没有给出具体的合并方式。<br/><br/>
合并的基本思想：<br/>
h1，h2的根节点中小者显然为合并后的根节点，假设是h1。<br/>
那么就要将h1的<font color="#ff0000">某个子树</font>和h2，合并。<br/>
这个过程一直递归到，h1和h2中有一个为空的时候，返回另一个即可。<br/><font color="#0000ff"><br/>
1。非对称堆</font><br/><br/>
根据上面叙述的合并思想，唯一的歧义在于，某个子树应该怎么选取？<br/>
非对称堆的结构中，不增加额外信息。<br/>
办法是，交换一下左右枝，然后选择右枝（左枝）合并。<br/>
这样就不至于出现，每次都选右枝，导致右边明显臃肿的现象。<br/>
但是这种不至于只是个期望。<br/><br/>
而从期望的角度，貌似每次合并的时候，<font color="#ff0000">随机</font>选取左右枝也是不错的方案。<br/><br/><font color="#0000ff">2。左偏树</font><br/><br/>
上面看到的非对称堆，发现选取合并枝的关键在于：<br/><font color="#ff0000">尽量使合并用枝更短。<br/></font><br/>
左偏树的节点中<font color="#ff0000">保留了到外节点的距离</font>。<br/>
（由于限制了右边的距离一定比左边的距离小或等，<br/>
所以当合并到达外节点的时候，右子树一定为空，这时合并操作就结束了）<br/>
这个距离相当于就是沿着这个分支合并下去还要的次数。<br/>
既然右边的距离小，那么每次就拿右边来合并。<br/>
而每递归完一层后，检查左右的距离，把小的放到右边。<br/><br/>
我的代码可以<a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/7a8a0633d33d0ef01b4cff08.html">参考这个</a>。<br/><br/><font color="#0000ff">3。对称堆</font><br/><br/>
这个描述更有“堆”的感觉。<br/>
（和前面认识的二项堆在结构上很不相同）<br/>
每一层都是若干个堆拉成的链表。（而不仅仅是两个孩子的左右堆）<br/><br/>
保有一个根节点，使得可以对整个堆进行访问。<br/><br/>
插入操作，因为单节点也是个堆，于是使用合并来实现。<br/><br/>
合并的时候，比较两个堆的元素，小的作为新的根。比如h1，<br/>
那么h2直接放到h1的孩子链表里面就行了。<br/><br/>
降值操作。把相关节点降值后，拿来和原来的堆合并即可。<br/><br/>
由于合并的复杂度是O(1)，导致上面的几个操作都很快。<br/><br/>
麻烦之处在于删除最小元素。<br/>
由于删除了原来的根，该根的孩子都跑到同一层了，<br/>
并且是散的，所以执行c-1次合并把他们弄成一个堆（c是原来根的孩子数）<br/><br/>
这个复杂度就是O(c)的。<br/><br/>
c是个啥玩意喃？？比较囧，<br/>
多的时候，可以到n<br/>
（比如这个堆除根外的左右元素都是根的孩子，<br/>
那么一删，相当于是n-1个散点在一层了）<br/>
少的时候，也可能就是1<br/>
（比如每个节点都只有一个孩子，拉成一个有序的链表）<br/><br/><font color="#0000ff">4。斐波那契堆</font><br/><br/>
跟3号叙述的对称堆比较相似，有几点不同：<br/>
1。保留的是一个根的链表，而不是一个单根。<br/>
（对整个堆的访问，从一个指向根链表的最小元素的指针开始。）<br/>
2。增加了孩子数的记录（一般资料叫这个为度数）<br/>
3。增加了一个标记<br/>
（很诡异的想法，还没想透他的意义；<br/>
这个标记跟减值操作有关，跟可并堆的实现没有直接关系）<br/><br/>
插入，直接放到根链表中。<br/><br/>
合并，比较一下，把大点的树并到小点的树的孩子链表里面。<br/><br/>
删除，把根节点删了，其孩子全部放到根链表里面。<br/>
此时的根链表可能很臃肿了，于是进行至多c-1次合并(c是孩子数)<br/>
合并的规则是，选取度数（就是前面定义的孩子数）相同的节点合并。<br/>
合并到没有两个节点的度数相同就可以了。<br/><br/>
科学家有严密的推算，说在均摊意义下，<br/>
插入合并减值为O(1)<br/>
删除是O(logn)<br/><br/><a href="http://hi.baidu.com/hplonline/blog/item/c0f979f073fcb7a7a50f5295.html" target="_blank">相关资料</a><br/><br/><font color="#0000ff">小结：<br/></font><br/>
2和4感觉分别是在1和3的基础上增加了一定的信息。<br/>
并且更加充分地利用这些信息，来达到某种效果。<br/><img src="http://img.baidu.com/hi/jx/j_0016.gif"/>不过我的斐波那契堆都还没写出来。。<br/>
就在这里说了一大堆。。。跟放屁似的。。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/06/02/%E5%B7%A6%E5%81%8F%E6%A0%91%EF%BC%88%E9%A1%BA%E4%BE%BF%E5%88%B7%E4%B8%AAHDU1512%EF%BC%89/">左偏树（顺便刷个HDU1512）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-06-02T22:10:00+08:00" pubdate data-updated="true">Jun 2<span>nd</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.6.2<br/><br/>
关于左偏树的资料，<br/>
网上到处转载的大多是05年黄源河的论文<br/><a href="http://www.box.net/shared/01tp7616qx" target="_blank">《左偏树》</a><br/>
应该说从理论到实现讲解得很清楚了，分享出来。<br/><br/>
主要在网上搜的时候，很多地方提到HDU1512<br/>
（其实就是一个人提到，到家转出来的）<br/>
于是顺便去刷了下。<br/><br/>
处理猴子认识与否，是典型的<a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/bd4524dd0463bcd18c1029c6.html">并查集</a>擅长解决的。<br/>
每次要得到<font color="#ff0000">strongness</font>最大的。<br/>
（<img src="http://img.baidu.com/hi/jx/j_0016.gif"/>个人认为应该是<font color="#ff0000">strength</font>。。。）<br/>
且打完一架之后要合并，于是需要可并堆来支持。<br/>
左偏树是性价比很高的可并堆的实现方案。<br/><br/>
写法上，和下面的左偏树的实现有点出入：<a href="http://www.box.net/shared/h82h087lxs" target="_blank">HDU1512</a>.txt<br/>
意思上是一样的。<br/><br/><font color="#0000ff">个人的理解：</font><br/><br/>
merge操作作为左偏树的基础。<br/>
按照堆的性质，取出待合并的树中最小的作为根即可。<br/>
由于限制了右树的“距离”更小。<br/>
所以确定根之后，把另一棵树和根的右枝合并。<br/>
可以尽可能地减少合并的次数。<br/><br/>
距离为0的点的右树是空的，这时候merge可以结束。<br/>
而从某节点走到距离为0的节点，只需要他的距离步。<br/>
这样可以保证很高的效率。<br/><br/><font color="#0000ff">我的左偏树代码：</font><br/><br/></p>

<h1>include &lt;stdio.h&gt;<br/></h1>

<h1>include &lt;stdlib.h&gt;<br/></h1>

<h1>include &lt;iostream&gt;<br/><br/></h1>

<p>typedef int ElemType ;<br/><br/>
typedef struct leftistnode_type{<br/>
       ElemType data ;<br/>
       int dis ;<br/>
       leftistnode_type <em>left , </em>right ;<br/>
}LNode ;<br/><br/>
typedef LNode* PLNode ;<br/><br/>
//空间分配宏，便于实现其他配置方式<br/></p>

<h1>define _L_initspace <br/></h1>

<h1>define _L_allocate() (LNode *)malloc(sizeof(LNode))<br/></h1>

<h1>define _L_deallocate(p) free(p) <br/></h1>

<p>//ANode space[1000] , *spacehead ;<br/>
//#define <em>L_initspace spacehead = space <br/>
//#define </em>L_allocate() spacehead++ ;<br/>
//#define <em>L_deallocate(p) <br/><br/>
class LeftistTree{<br/>
private:<br/>
       PLNode root ;<br/>
       LNode nil_node ;<br/>
       PLNode nil ;<br/>
       PLNode </em>merge(PLNode t1 , PLNode t2) ;<br/>
       void <em>delete_node(PLNode p) ;<br/>
public:<br/>
       LeftistTree() ;<br/>
       ~LeftistTree() ;<br/>
       ElemType Root() ;//获得根节点<br/>
       void Join(LeftistTree &amp;t) ;//合并另一个树到该树上<br/>
       void Insert(ElemType d) ;//插入<br/>
       void DeleteRoot() ;//删除<br/>
       void Clear() ;//清空树<br/>
       bool Empty() ;//判空<br/>
       friend LeftistTree ;<br/>
} ;<br/><br/>
PLNode LeftistTree::</em>merge(PLNode t1 , PLNode t2){<br/>
       if ( t1 == nil ) return t2 ;<br/>
       if ( t2 == nil ) return t1 ;<br/>
       PLNode t ;<br/>
       if ( t1-&gt;data &gt; t2-&gt;data ) {<br/>
              t = t1 ; t1 = t2 ; t2 = t ;<br/>
       }<br/>
       t = <em>merge(t1-&gt;right , t2) ;<br/>
       if ( t-&gt;dis &gt; t1-&gt;left-&gt;dis ) {<br/>
              t1-&gt;right = t1-&gt;left ;<br/>
              t1-&gt;left = t ;<br/>
       }else{<br/>
              t1-&gt;right = t ;<br/>
       }<br/>
       t1-&gt;dis = t1-&gt;right-&gt;dis + 1 ;<br/>
       return t1 ;<br/>
}<br/><br/>
LeftistTree::LeftistTree(){<br/>
       nil = &amp;nil_node ;<br/>
       nil-&gt;left = nil ;<br/>
       nil-&gt;right = nil ;<br/>
       nil-&gt;dis = -1 ;//为维护左偏性质而规定<br/>
       root = nil ;<br/>
}<br/><br/>
LeftistTree::~LeftistTree(){<br/>
       Clear() ;<br/>
}<br/><br/>
void LeftistTree::</em>delete_node(PLNode p){<br/>
       if ( p != nil ){<br/>
              <em>delete_node(p-&gt;left) ;<br/>
              </em>delete_node(p-&gt;right) ;<br/>
              <em>L_deallocate(p) ;<br/>
       }<br/>
}<br/><br/>
void LeftistTree::Clear(){<br/>
       </em>delete_node(root) ;<br/>
}<br/><br/>
ElemType LeftistTree::Root(){<br/>
       return root-&gt;data ;<br/>
}<br/><br/>
void LeftistTree::Insert(ElemType d){<br/>
       PLNode p = <em>L_allocate() ;<br/>
       p-&gt;data = d ;<br/>
       p-&gt;left = nil ;<br/>
       p-&gt;right = nil ;<br/>
       p-&gt;dis = 0 ;<br/>
       root = </em>merge(root , p) ;<br/>
}<br/><br/>
void LeftistTree::DeleteRoot(){<br/>
       PLNode p = root ;<br/>
       root = <em>merge(root-&gt;left , root-&gt;right) ;<br/>
       </em>L_deallocate(p) ;<br/>
}<br/><br/>
void LeftistTree::Join(LeftistTree &amp;t){<br/>
       root = _merge(root , t.root) ;<br/>
       t.root = t.nil ;<br/>
}<br/><br/>
bool LeftistTree::Empty(){<br/>
       return root == nil ;<br/>
}<br/><br/>
using namespace std ;<br/><br/>
int main(){<br/>
       int a[] = {3 , 2 , 9 , 10 , 5 , 4 , 6 , 7} ;<br/>
       int sz = sizeof(a) / sizeof(a[0]) ;<br/>
       LeftistTree lt ;<br/>
       int i ;<br/>
       for ( i = 0 ; i &lt; sz ; i ++ )<br/>
              lt.Insert(a[i]) ;<br/>
       for ( i = 0 ; i &lt; sz ; i ++ ){<br/>
              cout&lt;&lt;lt.Root() &lt;&lt;endl;<br/>
              lt.DeleteRoot() ;<br/>
       }<br/>
       return 0 ;<br/>
}</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/06/02/%E5%85%B3%E4%BA%8E%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%80%E7%82%B9%E4%BA%8B%E6%83%85/">关于排序的一点事情</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-06-02T14:35:00+08:00" pubdate data-updated="true">Jun 2<span>nd</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.5.31<br/><br/>
被有道的一道题囧起了。<br/><br/>
=====group8的500。<br/><br/>
双倍超立方数是指一个正整数可以正好被拆分为两种不同的a<sup>3+b<sup>3的方式，其中a,b均为整数且0&lt;a&lt;=b。对于任何一个指定的</sup></sup> int n, 返回所有的小于等于n的双倍超立方数的个数。 <br/><br/>
=====<br/><br/>
开始想了想这东西难道有啥公式，于是推啊推。。但是完全没有头绪。<br/><br/>
再一想，a,b最大就1000，于是可以暴力a，b，求出所以的组合。<br/>
最多10<sup>6个数，然后统计这些数里面出现刚好两次的数。<br/><br/></sup>
问题在于统计这里，我的第一反映就是map。<br/>
于是拿map去记某个数出现的次数。<br/>
最后在map里面扫一遍，找个数为2的。<br/><br/>
这个办法在本机上跑了下最大的数据。<br/>
居然要3s的样子。。看来不行。<br/><br/>
只有拿hash去处理某个数和组成他的次数之间的关系。<br/>
发现很快，最大的数据也可以秒过。。<br/><br/>
下来一交流。。才意识到这个题可以排序的。。<br/>
把不超过10<sup>6个数都算出来后，排一下，<br/></sup>
然后顺次检验就可以得到出现次数为2的数的个数了。。<br/><br/>
囧，为啥老是想不到排序呢。。<br/><br/>
同理的还有另外一道题。<br/><br/>
去年暑假刚开始训练的时候，那个POJ3630。<br/>
就是给一堆电话号码，判断有没有出现前缀的情况。<br/><br/>
我当时第一反映居然是TRIE，但是又写不来TRIE。结果纠结了一下午没搞出来。<br/><br/>
而当天的很多人都是拿到排序一下，于是只用检验相邻的两个是否为前缀就可以了。<br/><br/>
虽然从速度上说，排序可能不能刷到最快。<br/>
但是从编码上来说，有完全的优势。。<br/><br/>
再早一点，到去年暑假前校内赛的某题。<br/>
就是一堆数里面找出出现了奇数次次的那个。<br/><br/>
后来倒是知道了，可以用XOR来完成，简洁高效。<br/><br/>
出于通用的考虑，比如出现k次的数有哪些？用XOR就不行了。<br/><br/>
这个时候，依然可以用排序！排好后顺次检查就可以。<br/><br/>
当时比较雷人，没想到排序，又写不来hash，<br/>
而32bit-signed int范围的数据又不可能直接开数组统计。。<br/>
于是同样在那纠结了一下午。<br/><br/>
排序真的是个好东西啊，但是想不到呢。。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/06/01/SplayTree%28%E4%BC%B8%E5%B1%95%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%80%E4%B8%AA%E6%BC%94%E7%A4%BA%EF%BC%89/">SplayTree(伸展操作的一个演示）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-06-01T16:55:00+08:00" pubdate data-updated="true">Jun 1<span>st</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.6.1<br/><br/>
上篇给出了一个SplayTree的完整实现。<br/>
可以看到，一旦有了splay操作，那么其他的事情就很好办了。<br/><br/>
不过我看到的这份splay操作实在是很费解。<br/>
于是一边看一边拿visio画图。<br/>
其实我也不杂理解，拿出来大家一起看一下玩。<br/><br/><font color="#0000ff">伸展代码如下：</font><br/><br/>
PSNode SplayTree::<em>splay(ElemType d , PSNode p){<br/>
      //(1)left:待完成的树左子树，他的右子树为空<br/>
      //(2)通过移动，可以把left视为右子树为空的树串成的链表<br/>
      //left为左子树中的最大值（因为右子树为空）<br/>
      PSNode left , right ;<br/>
      //为了满足(1)，设置一个header，他初始的时候左右均空<br/>
      SNode header ;<br/>
      header.left = nil ;<br/>
      header.right = nil ;<br/>
      //而left和right均从header开始出发<br/>
      //(3)当left离开header的时候，left的右端挂上的肯定是当前树的左端<br/>
      left = &amp;header ;<br/>
      right = &amp;header ;<br/><br/>
      nil-&gt;data = d ;//(4)避免在空节点处发生双旋<br/><br/>
      while ( p-&gt;data != d ){<br/>
            if ( d &lt; p-&gt;data ){<br/>
                  if ( d &lt; p-&gt;left-&gt;data ) { // 当p-&gt;left为nil时，条件自动不成立，见(4)<br/>
                        p = </em>rotate_right(p) ; //同个方向前进，应该双旋<br/>
                  }<br/>
                  if ( p-&gt;left == nil ) break ;//节点查找失败，但p已经为新节点应当的插入点了。<br/>
                  right-&gt;left = p ;<br/>
                  right = p ;<br/>
                  p = p-&gt;left ;<br/>
            }else{<br/>
                  if ( p-&gt;right-&gt;data &lt; d ) {<br/>
                        p = _rotate_left(p) ;<br/>
                  }<br/>
                  if ( p-&gt;right == nil ) break ;<br/>
                  left-&gt;right = p ;<br/>
                  left = p ;<br/>
                  p = p-&gt;right ;<br/>
            }<br/>
      }<br/><br/>
      //p已经是我们要的节点了。他为新的根<br/>
      left-&gt;right = p-&gt;left ;//left的右端是空的,见(1)<br/>
      right-&gt;left = p-&gt;right ;<br/>
      //将header左右子树链接到p上面<br/>
      p-&gt;left = header.right ;//head的右端是新根的左端，见(3)<br/>
      p-&gt;right = header.left ;<br/>
      return p ;<br/>
}<br/><br/><font color="#0000ff">下图是关于双旋的演示：</font><br/><div forimg="1"><br/><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/c0f979f03064768aa50f5211.jpg"/><br/><br/>
下面的这个可以看作是中间状态。<br/><br/><br/><font color="#0000ff">1。初始的时候，令空节点的值为splay操作的值。</font><br/>
把header做成一个左右均空的节点。<br/>
让left和right都指向header</div></p>

<div forimg="1"><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/a2f3e1c477236f8c8326ac12.jpg"/><br/><br/><br/><font color="#0000ff">2。第一次比较，应该向左移动两次。</font></div>


<div forimg="1"><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/a2f1ba51367faa3d377abe12.jpg"/><br/><br/><br/><font color="#0000ff">3。先对X右旋一次。</font></div>


<div forimg="1"><br/><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/cb5e40edfd15a7f1b21cb112.jpg"/><br/><br/><br/><br/><font color="#0000ff">4。将X的右枝挂到right的左枝，同时移动right向新的左枝<br/><br/></font></div>


<div forimg="1"><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/8fc50d08f45e3315e8248812.jpg"/><br/><br/><font color="#0000ff">5。应该向X的右端插入，但已经为空，于是停止。</font><br/><br/>
将X的左枝挂到left的右枝上。<br/>
将X的右枝挂到right的左枝上。</div>


<div forimg="1"><br/><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/7fec1795ee1d2e2d7af48012.jpg"/><br/><br/><font color="#0000ff">6。最后一步合并操作。</font><br/><br/>
将header的右枝挂给X的左枝<br/>
将header的左枝挂给X的右枝</div>


<div forimg="1"><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/612531c71b5ad4f9d0006012.jpg"/></div>


<div forimg="1"><br/><font color="#0000ff">7。将元素4在树根的位置插入</font><br/><br/><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/c0eab0a145765eae46106412.jpg"/></div>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/06/01/SplayTree%28%E4%BC%B8%E5%B1%95%E6%A0%91%EF%BC%8C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%89/">SplayTree(伸展树，自顶向下的实现）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-06-01T15:59:00+08:00" pubdate data-updated="true">Jun 1<span>st</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.6.1<br/><br/>
代码基本上是照着别人的写出来的。<br/><br/>
主要还是自顶向下的伸展过程，在实现上真有点纠结。<br/>
现在假设已经有了splay(d , p)的过程。<br/>
表示把值为d的元素伸展到以p为根的树根处。<br/>
那么基于这个操作，可以很方便完成以下内容：<br/><br/><font color="#0000ff">insert:</font><br/>
先把对待插元素d做一个splay。<br/>
这时如果根的值和d相等，那么说明d在树里了。<br/>
否则的话，建立新根，令其值为d。<br/>
如果d小于旧根的值，<br/>
把旧根的左枝给新根做左枝，旧根的左枝为空，<br/>
把旧根作为新根的右枝。<br/>
另一种情况同理。<br/><br/><font color="#0000ff">delete:</font><br/>
先对待删元素d做一个splay。<br/>
如果根的值不为d，那么啥都不做。<br/>
如果根的两端均为空，那么直接删除，令新根为空。<br/>
如果只有一端为空，那么把根移向不为空的子树，删除原来的。<br/>
如果两端都有内容，那么在根的左边对值d做一次splay，<br/>
做完后，得到的p是原来左枝上最大的值，他的右端肯定为空。<br/>
于是把旧根的右枝挂到p的右枝上，删除旧根，p为新根。<br/><font color="#0000ff"><br/>
nextnode:</font><br/>
&#8212;&#8212;<br/>
这个函数要完成的是找根节点的下一节点。<br/>
找任意节点的下一节点的话，只需要先对“任意节点”进行一次查找，<br/>
则“任意节点”会位于根的位置，那么调用该函数即可。<br/>
&#8212;&#8212;&#8212;-<br/>
对根的右枝，按照根的值做一次splay。<br/>
这样得到的p为右枝上最小的，他没有左枝，<br/>
把旧根挂到p的左枝上，旧根的右枝令为空。<br/>
把新根令为p，即完成。<br/><br/>
剩下的就看代码吧，顺便找找bug<img src="http://img.baidu.com/hi/jx/j_0019.gif"/>。<br/>
随便跑了下，感觉不是很快的样子喃。。<img src="http://img.baidu.com/hi/jx/j_0016.gif"/>有待进一步测试。<br/><br/><font color="#0000ff">代码：</font><br/><br/></p>

<h1>include &lt;iostream&gt;<br/></h1>

<h1>include &lt;stdlib.h&gt;<br/><br/></h1>

<p>//元素类型<br/>
typedef int ElemType ;<br/><br/>
//树的节点<br/>
struct SNode{<br/>
      ElemType data ;<br/>
      SNode <em>left , </em>right ;<br/>
};<br/>
typedef SNode *PSNode ;<br/><br/>
//空间分配宏，便于实现其他配置方式<br/></p>

<h1>define _S_initspace <br/></h1>

<h1>define _S_allocate() (SNode *)malloc(sizeof(SNode))<br/></h1>

<h1>define _S_deallocate(p) free(p) <br/></h1>

<p>//SNode space[200000] , <em>spacehead ;<br/>
//#define <em>S_initspace spacehead = space <br/>
//#define </em>S_allocate() spacehead++ ;<br/>
//#define <em>S_deallocate(p) <br/><br/>
//S<br/>
class SplayTree{<br/>
private:<br/>
      ElemType INFINITE , NEG_INFINITE ;<br/>
      PSNode root ;<br/>
      SNode nil_node ; //空节点<br/>
      PSNode nil ;<br/>
      void </em>delete_node(PSNode p) ;<br/>
      PSNode <em>rotate_left(PSNode p) ;//左旋<br/>
      PSNode </em>rotate_right(PSNode p) ;//右旋<br/>
      PSNode <em>splay(ElemType d , PSNode p) ;//伸展<br/>
      void </em>in_order(PSNode p) ;//p节点的中序遍历<br/>
      void _pre_order(PSNode p) ;//p节点的前序遍历<br/>
public:      <br/>
      SplayTree() ;//构造空树<br/>
      ~SplayTree() ;//销毁树<br/>
      PSNode Find(ElemType d) ;//查找元素，<br/>
      PSNode FindMax() ;//查找最大元素，<br/>
      PSNode FindMin() ;//查找最小元素，<br/>
      ElemType&amp; Retrieve(PSNode p) ;//获取元素<br/>
      PSNode Insert(ElemType d) ;//插入元素<br/>
      void Delete(ElemType d) ;//按元素删除<br/>
      void Erase(PSNode p) ;//按节点位置删除<br/>
      void Clear() ;//清除整棵树<br/>
      void InOrder() ; //中序遍历<br/>
      void PreOrder() ; //前序遍历<br/>
      PSNode Nil() ;//返回空节点，便于调用端判断边界条件<br/>
      static void Sort(ElemType a[] , int n , int d = 1) ;//利用S进行排序，静态函数<br/>
      void SetInfinite(ElemType inf , ElemType ninf) ;//设置极值<br/>
      bool NextNode() ;//根的后继节点，返回是否存在后继<br/>
      bool PrevNode() ;//根的前驱节点<br/>
      PSNode Root() ;//返回根<br/>
} ;<br/><br/>
PSNode SplayTree::Nil(){<br/>
      return nil ;<br/>
}<br/><br/>
PSNode SplayTree::Root(){<br/>
      return root ;<br/>
}<br/><br/>
//d：1，从小到大，0，从大到小<br/>
void SplayTree::Sort(ElemType a[] , int n , int d){<br/>
      SplayTree tree ;<br/>
      int i ;<br/>
      for ( i = 0 ; i &lt; n ; i ++ ){<br/>
            tree.Insert(a[i]) ;<br/>
      //      tree.InOrder() ;<br/>
      //      tree.PreOrder() ;<br/>
      }<br/>
//      tree.InOrder() ;<br/>
//      tree.PreOrder() ;<br/>
      for ( i = 0 ; i &lt; n ; i ++ ){<br/>
            PSNode p ;<br/>
            if ( d ) {<br/>
                  p = tree.FindMin() ;<br/>
            }else{<br/>
                  p = tree.FindMax() ;      <br/>
            }<br/>
            a[i] = tree.Retrieve(p) ;<br/>
            tree.Erase(p) ;<br/>
      }<br/>
}<br/><br/>
SplayTree::SplayTree(){<br/>
      nil = &amp;nil_node ;<br/>
      root = nil ;<br/>
      nil_node.left = nil ;<br/>
      nil_node.right = nil ;<br/>
      //利用ElemType的默认构造函数创建极值<br/>
      ElemType </em>p = new ElemType ;<br/>
      INFINITE = <em>p ;<br/>
      NEG_INFINITE = </em>p ;<br/>
      delete p ;<br/>
}<br/><br/>
void SplayTree::SetInfinite(ElemType inf , ElemType ninf){<br/>
      INFINITE = inf ;<br/>
      NEG_INFINITE = ninf ;<br/>
}<br/><br/>
SplayTree::~SplayTree(){<br/>
      Clear() ;<br/>
}<br/><br/>
void SplayTree::<em>in_order(PSNode p){<br/>
      if ( p != nil ) {<br/>
            </em>in_order(p-&gt;left) ;<br/>
            std::cout&lt;&lt;p-&gt;data&lt;&lt;&#8217; &#8217; ;<br/>
            <em>in_order(p-&gt;right) ;<br/>
      }<br/>
}<br/><br/>
void SplayTree::</em>pre_order(PSNode p){<br/>
      if ( p != nil ) {<br/>
            std::cout&lt;&lt;p-&gt;data&lt;&lt;&#8217; &#8217; ;<br/>
            <em>pre_order(p-&gt;left) ;<br/>
            </em>pre_order(p-&gt;right) ;<br/>
      }      <br/>
}<br/><br/>
void SplayTree::InOrder(){<br/>
      <em>in_order(root) ;<br/>
      std::cout&lt;&lt;std::endl;<br/>
}<br/><br/>
void SplayTree::PreOrder(){<br/>
      </em>pre_order(root) ;<br/>
      std::cout&lt;&lt;std::endl;<br/>
}<br/><br/>
bool SplayTree::NextNode(){<br/>
      PSNode newroot = root-&gt;right ;<br/>
      if ( newroot != nil ){<br/>
            newroot = <em>splay(root-&gt;data , newroot) ;<br/>
            newroot-&gt;left = root ;<br/>
            root-&gt;right = nil ;<br/>
            root = newroot ;<br/>
            return true ;<br/>
      }<br/>
      return false ;<br/>
}<br/><br/>
bool SplayTree::PrevNode(){<br/>
      PSNode newroot = root-&gt;left ;<br/>
      if ( newroot != nil ){<br/>
            newroot = </em>splay(root-&gt;data , newroot) ;<br/>
            newroot-&gt;right = root ;<br/>
            root-&gt;left = nil ;<br/>
            root = newroot ;<br/>
            return true ;<br/>
      }<br/>
      return false ;      <br/>
}<br/><br/>
PSNode SplayTree::Find(ElemType d){      <br/>
      return root = <em>splay(d , root) ;<br/>
}<br/><br/>
PSNode SplayTree::FindMax(){<br/>
      return root = </em>splay(INFINITE , root) ;<br/>
}<br/><br/>
PSNode SplayTree::FindMin(){<br/>
      return root = <em>splay(NEG_INFINITE , root) ;<br/>
}<br/><br/>
ElemType&amp; SplayTree::Retrieve(PSNode p){<br/>
      if ( p != nil ) <br/>
            return p-&gt;data ;<br/>
      else return nil-&gt;data ;<br/>
}<br/><br/>
//左旋<br/>
PSNode SplayTree::</em>rotate_left(PSNode p){<br/>
      PSNode child = p-&gt;right ;<br/>
      p-&gt;right = child-&gt;left ;<br/>
      child-&gt;left = p ;<br/>
      return child ;<br/>
}<br/><br/>
//右旋<br/>
PSNode SplayTree::<em>rotate_right(PSNode p){<br/>
      PSNode child = p-&gt;left ;<br/>
      p-&gt;left = child-&gt;right ;<br/>
      child-&gt;right = p ;<br/>
      return child ;<br/>
}<br/><br/>
PSNode SplayTree::</em>splay(ElemType d , PSNode p){<br/>
      //(1)left:待完成的树左子树，他的右子树为空<br/>
      //(2)通过移动，可以把left视为右子树为空的树串成的链表<br/>
      //left为左子树中的最大值（因为右子树为空）<br/>
      PSNode left , right ;<br/>
      //为了满足(1)，设置一个header，他初始的时候左右均空<br/>
      SNode header ;<br/>
      header.left = nil ;<br/>
      header.right = nil ;<br/>
      //而left和right均从header开始出发<br/>
      //(3)当left离开header的时候，left的右端挂上的肯定是当前树的左端<br/>
      left = &amp;header ;<br/>
      right = &amp;header ;<br/><br/>
      nil-&gt;data = d ;//(4)避免在空节点处发生双旋<br/><br/>
      while ( p-&gt;data != d ){<br/>
            if ( d &lt; p-&gt;data ){<br/>
                  if ( d &lt; p-&gt;left-&gt;data ) { // 当p-&gt;left为nil时，条件自动不成立，见(4)<br/>
                        p = <em>rotate_right(p) ; //同个方向前进，应该双旋<br/>
                  }<br/>
                  if ( p-&gt;left == nil ) break ;//节点查找失败，但p已经为新节点应当的插入点了。<br/>
                  right-&gt;left = p ;<br/>
                  right = p ;<br/>
                  p = p-&gt;left ;<br/>
            }else{<br/>
                  if ( p-&gt;right-&gt;data &lt; d ) {<br/>
                        p = </em>rotate_left(p) ;<br/>
                  }<br/>
                  if ( p-&gt;right == nil ) break ;<br/>
                  left-&gt;right = p ;<br/>
                  left = p ;<br/>
                  p = p-&gt;right ;<br/>
            }<br/>
      }<br/><br/>
      //p已经是我们要的节点了。他为新的根<br/>
      left-&gt;right = p-&gt;left ;//left的右端是空的,见(1)<br/>
      right-&gt;left = p-&gt;right ;<br/>
      //将header左右子树链接到p上面<br/>
      p-&gt;left = header.right ;//head的右端是新根的左端，见(3)<br/>
      p-&gt;right = header.left ;<br/>
      return p ;<br/>
}<br/><br/>
PSNode SplayTree::Insert(ElemType d){      <br/>
      //根为空<br/>
      if ( root == nil ) {<br/>
            root = <em>S_allocate() ;<br/>
            root-&gt;left = nil ;<br/>
            root-&gt;right = nil ;<br/>
            root-&gt;data = d ;<br/>
            return root ;<br/>
      }<br/>
      root = </em>splay(d , root) ;<br/>
      //已经存在<br/>
      if ( d == root-&gt;data ) return root ;<br/>
      PSNode p = <em>S_allocate() ;<br/>
      p-&gt;data = d ;<br/>
      if ( d &lt; root-&gt;data ){<br/>
            p-&gt;right = root ;<br/>
            p-&gt;left = root-&gt;left ;<br/>
            root-&gt;left =nil ;<br/>
      }else{<br/>
            p-&gt;left = root ;<br/>
            p-&gt;right = root-&gt;right ;<br/>
            root-&gt;right = nil ;<br/>
      }<br/>
      return root = p ;<br/>
}<br/><br/>
void SplayTree::Erase(PSNode pos){<br/>
      Delete(pos-&gt;data) ;<br/>
}<br/><br/>
void SplayTree::Delete(ElemType d){<br/>
      root = </em>splay(d , root) ;<br/>
      if ( root-&gt;data == d ){<br/>
            PSNode tmp = root ;<br/>
            if ( root-&gt;left == nil ){//有可能无左子树<br/>
                  root = root-&gt;right ;<br/>
            }else{<br/>
                  //伸展得到的是左树的最大节点，他无右子树<br/>
                  PSNode newroot = root-&gt;left ;<br/>
                  newroot = <em>splay(d , newroot) ;<br/>
                  newroot-&gt;right = root-&gt;right ;<br/>
                  root =newroot ;<br/>
            }<br/>
            </em>S_deallocate(tmp) ;<br/>
      }<br/>
}<br/><br/>
//容易栈溢<br/>
void SplayTree::<em>delete_node(PSNode p){<br/>
      if ( p != nil ){<br/>
            </em>delete_node(p-&gt;left) ;<br/>
            <em>delete_node(p-&gt;right) ;<br/>
            </em>S_deallocate(p) ;<br/>
      }<br/>
}<br/><br/>
void SplayTree::Clear(){<br/>
//      <em>delete_node(root) ;<br/>
      if ( root == nil ) return ;<br/>
      FindMin() ;<br/>
      while ( root-&gt;right != nil ){<br/>
            PSNode tmp = root ;<br/>
            root = root-&gt;right ;<br/>
            </em>S_deallocate(tmp) ;<br/>
      }<br/>
      _S_deallocate(root) ;<br/>
      root = nil ;<br/>
}<br/><br/><br/>
//测试代码<br/>
using namespace std;<br/></p>

<h1>include &lt;algorithm&gt;<br/></h1>

<h1>include &lt;time.h&gt;<br/><br/></h1>

<p>const TOTAL = 200000 ;<br/>
int c[TOTAL] ;<br/><br/>
int main(){<br/><br/>
      int a[] = {3,2,9,7,5,8,6} ;<br/>
//      int a[] = {5 , 2 , 3} ;<br/>
      int b[10] ;<br/>
      int sz = sizeof(a) / sizeof(int)  ;<br/>
      int i;<br/><br/>
      //初始化空间<br/>
       <em>S_initspace ;<br/><br/>
      for ( i = 0 ; i &lt; sz ; i ++ ) b[i] = a[i] ;<br/><br/>
      //排序测试<br/>
      SplayTree::Sort(a , sz , 1) ;<br/>
      for ( i = 0 ; i &lt; sz ; i ++ )cout&lt;&lt;a[i]&lt;&lt;&#8217; &#8216;;<br/>
      cout&lt;&lt;endl;<br/>
      <br/>
      SplayTree tree ;<br/>
      tree.SetInfinite(1000000000 , -1000000000) ;//重要，在查找最值时用到<br/><br/>
      //插入，删除，中序遍历，空树测试<br/>
/<em>      tree.Insert(1) ;<br/>
      tree.InOrder() ;<br/>
      tree.Insert(1) ;<br/>
      tree.InOrder() ;<br/>
      tree.Delete(1) ;<br/>
      tree.InOrder() ;<br/>
</em>/<br/>
      //插入测试，根据中序和前序，可以构造出整树，来检验插入是否正确<br/>
      for ( i = 0 ; i &lt; sz ; i ++ ){<br/>
            tree.Insert(a[i]) ;<br/>
            tree.InOrder() ;<br/>
            tree.PreOrder() ;<br/>
      }<br/>
      cout&lt;&lt;endl;<br/><br/>
//      return 0 ;<br/><br/>
      //查找测试<br/>
      //不存在元素<br/>
      cout&lt;&lt;tree.Find(4)&lt;&lt;endl;<br/>
      cout&lt;&lt;endl;<br/>
      //存在的元素<br/>
      cout&lt;&lt;tree.Find(9)&lt;&lt;endl;<br/>
      cout&lt;&lt;tree.Find(9)-&gt;data&lt;&lt;endl;<br/>
      //删除元素<br/>
      tree.Delete(9) ;<br/>
      cout&lt;&lt;tree.Find(9)&lt;&lt;endl;<br/><br/>
      tree.InOrder() ;<br/>
      tree.PreOrder() ;<br/><br/>
      //清除测试<br/>
      cout&lt;&lt;endl;<br/>
      cout&lt;&lt;tree.Find(3)&lt;&lt;endl;<br/>
      cout&lt;&lt;tree.Retrieve(tree.Find(3))&lt;&lt;endl;<br/>
      tree.Clear() ;<br/>
      cout&lt;&lt;tree.Find(3)&lt;&lt;endl;      <br/>
      tree.PreOrder() ;<br/><br/>
//大数据测试<br/>
      for ( i = 0 ; i &lt; TOTAL ; i ++ ) c[i] = i ; <br/>
      random_shuffle(c , c + TOTAL) ;<br/>
//      可选择输出数据检验      <br/>
//      for ( i = 0 ; i &lt; TOTAL ; i ++ ) cout&lt;&lt;c[i]&lt;&lt;&#8217; &#8217; ;<br/>
//      cout&lt;&lt;endl;<br/>
//      return 0 ;<br/>
      clock_t tt = clock() ;<br/>
//      </em>S_initspace ;<br/>
//      SplayTree::Sort(c , TOTAL , 1) ;<br/>
      tree.Clear() ;<br/>
      for ( i = 0 ; i &lt; TOTAL ; i ++ ){<br/>
            tree.Insert(c[i]) ;<br/>
      }<br/>
      tree.FindMin() ;<br/>
      for ( i = 0 ; i &lt; TOTAL ; i ++ ){<br/>
            c[i] = tree.Root()-&gt;data ;<br/>
            tree.NextNode() ;<br/>
      }<br/>
      printf(&#8220;time: %d\n&#8221; , clock() - tt) ;<br/>
      for ( i = 0 ; i &lt; TOTAL ; i ++ ) if ( c[i] != i ) break; <br/>
      if ( i == TOTAL ) cout&lt;&lt;&#8221;ok&#8221;&lt;&lt;endl;<br/>
      else cout&lt;&lt;&#8221;bad alg!&#8221;&lt;&lt;endl;<br/><br/>
      return 0 ;<br/>
}</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/05/31/%E5%B8%B8%E9%87%8F%E5%8C%BA%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88VC6.DEBUG%2CVC6.RELEASE%29/">常量区的问题（VC6.DEBUG , VC6.RELEASE)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-05-31T12:15:00+08:00" pubdate data-updated="true">May 31<span>st</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.5.31<br/><br/>
发现这个问题其实是在今年考二级前，<br/>
当时一哥们写了一个很逼真的程序，<br/>
最后调了一个晚上，我也去找了很久，<br/>
才发现关键所在，可见总有点东西忽略。<br/><br/>
后来一忙又搞忘记了，直到今天又看到类似的<font color="#0000ff">例子：</font><br/><br/>
int main(){<br/>
     char <em>p = &#8220;aaa&#8221; ;<br/>
     char q[] = &#8220;bbb&#8221; ;<br/>
     <br/>
     cout&lt;&lt;p[0]&lt;&lt;endl;<br/>
     cout&lt;&lt;q[0]&lt;&lt;endl;<br/>
   <font color="#339966"> //p[0] = &#8216;1&#8217; ;//这里要挂</font><br/>
     q[0] = &#8216;1&#8217; ;<br/><br/>
     return 0 ;<br/>
}<br/><br/>
可以试试注释掉的一句。<br/>
执行到那里程序就挂掉了。<br/><br/>
在VISTA下好像直接出关闭程序的框框，<br/>
在XP下好像有Access Violation。<br/><br/><font color="#0000ff">究其原因：</font><br/><br/>
     char q[] = &#8220;bbb&#8221; ;<br/>
这个是放在栈里面的。<br/>
所以可以随便读取修改。<br/><br/>
     char </em>p = &#8220;aaa&#8221; ;<br/>
这个的&#8221;aaa&#8221; 是放在常量区里面。<br/>
p只是个指针，存放了&#8221;aaa&#8221; 的地址。<br/><br/>
p[0]这种表达式，如果用于右值的话，是没有问题的。<br/>
但是用于左值，由于那块内存是只读的，于是就出问题了。<br/><br/>
但是注意到现在是在debug下玩的。<br/>
所以换到release下试试。<br/><br/><font color="#339966"><font color="#000000">p[0] = &#8216;1&#8217;<br/>
就可以不报错执行了</font><br/></font><br/>
可见，这种常量读写的检查是debug方式提供的特殊功能。<br/>
有助于排除此类改写常量导致的错误。<br/><font color="#0000ff"><br/>
其他关于Access Violation的琐碎：</font><br/><br/>
一般发生这种错误的时候，直接F5运行，<br/>
弹出的框里面确定，IDE会自动停到Access Violation的句子上。<br/>
这个时候往往要检查的都是指针，数组下标一类的问题。<br/>
比如指针为空，数组下标越界等等。<br/><br/>
有个特点就是，往往越界出去的位置既不能读，也不能写。<br/><br/>
而上面的这个问题，可以看到指针指向的是有效的数据区，<br/>
并没有越界，明明是可以读取的，于是当他写入出错时，<br/>
就有点摸不着头脑了。。。<br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/05/30/Treap%EF%BC%88%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%89/">Treap（随机化的二叉搜索树）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-05-30T09:11:00+08:00" pubdate data-updated="true">May 30<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.5.29<br/><br/>
据说Treap就是Tree + Heap的意思。<br/><br/><font color="#ff0000">NOCOW</font>上有很详细的解释：<br/>
http://www.nocow.cn/index.php/Treap<br/><br/><font color="#ff0000">强烈推荐这个网站</font>，有很多关于数据结构和算法方面的详细资料。<br/>
而且到目前为止<font color="#ff0000">非常绿色</font>！非常希望能坚持久点。<br/><br/><font color="#0000ff">核心思想：</font><br/><br/>
BST在<font color="#ff0000">极端情况</font>下的效率差的原因在于数据<font color="#ff0000">有序</font>。<br/>
而在<font color="#ff0000">随机插入</font>下BST仍然是高效的。<br/>
于是通过给每个元素加入<font color="#ff0000">随机产生的优先级</font>，<br/>
并维护整棵树在优先级上的堆性质则可。<br/><br/>
考虑将一组数据插入Treap完成后。<br/><br/>
如果将这时的所有元素按照优先级排序。<br/>
按照排后的顺序将这些元素插入一个普通BST。<br/>
得到的将和插入Treap的一样。<br/><br/>
而优先级是随机给定的，相当于将原来的元素随机排序后插入。<br/>
于是可以保证BST在平均情况下的效率。<br/><br/><font color="#0000ff">写法：<br/></font><br/>
我还是在前面写过的搜索树类框架上改的。<br/>
要重新写的也就是插入和删除两个过程。<br/>
我对优先级维护的是大顶堆，给空节点的优先级赋值为-1。<br/>
随机产生的优先级是直接调用rand()，在0..32767之间。<br/><br/><font color="#0000ff">插入：</font><br/>
按照BST的办法找到插入点。插入。<br/>
从插入点开始对优先级向上调整成堆。<br/>
在堆里面，调整的时候是直接交换节点和他父亲来实现的。<br/>
在这里，通过旋转实现，因为旋转可以保证BST的性质不受改变。<br/><br/><font color="#0000ff">删除：</font><br/>
把删除点的优先级视作-1。（这时他的优先级肯定是最小的了）<br/>
从删除点对优先级向下调整成堆。<br/>
在堆里，调整是通过交换实现。这里依然通过旋转实现“交换”。<br/>
调整好后，待删除节点一定是处于叶子的位置了。<br/>
于是直接将该节点删除即可。<br/><br/><font color="#0000ff">一点benchmark：</font><br/><br/>
为了测试Treap和普通BST的性能，<br/>
选择了20000个已排序点的benchmark。<br/>
空间分配用的自己写的space[]的方式。（见下面的空间分配宏处）<br/>
先就按照下面的代码跑，<font color="#ff0000">9ms</font><br/>
然后做点改动：<br/><br/>
//随机宏，便于实现其他随机数产生方式<br/></p>

<h1>define _T_rand()<font color="#ff0000"> rand()</font><br/></h1>

<h1>define _T_initseed() srand(time(NULL))<br/><br/></h1>

<p>中间换个#define _T_rand()<font color="#ff0000"> 1</font><br/>
这样所有节点的优先级都一样，相当于按照BST方式来搞。<br/><br/>
结果为：<font color="#ff0000">1735ms</font><br/><br/>
可见引入随机的Treap还是有点用。<br/><br/>
测试的时候，<font color="#ff0000">如果数据已经洗牌过。则BST比Treap还快。</font><br/>
毕竟BST在实现上少调用了若干rand()，也比较可观。<br/><font color="#0000ff"><br/>
代码：</font><br/><br/></p>

<h1>include &lt;stdio.h&gt;<br/></h1>

<h1>include &lt;stdlib.h&gt;<br/></h1>

<h1>include &lt;iostream&gt;<br/></h1>

<h1>include &lt;time.h&gt;<br/><br/></h1>

<p>typedef int ElemType ; <br/><br/>
//随机宏，便于实现其他随机数产生方式<br/></p>

<h1>define _T_rand() rand()<br/></h1>

<h1>define _T_initseed() srand(time(NULL))<br/><br/></h1>

<p>//树的节点<br/>
struct TNode{<br/>
     ElemType data ;<br/>
     TNode <em>left , </em>right , <em>parent ;<br/>
     int prior ;<br/>
};<br/>
typedef TNode </em>PTNode ;<br/><br/>
//空间分配宏，便于实现其他配置方式<br/></p>

<h1>define _T_initspace() <br/></h1>

<h1>define _T_allocate() (TNode *)malloc(sizeof(TNode))<br/></h1>

<h1>define _T_deallocate(p) free(p) <br/></h1>

<p>//TNode space[200000] , *spacehead ;<br/>
//#define <em>T_initspace() spacehead = space <br/>
//#define </em>T_allocate() spacehead++ ;<br/>
//#define <em>T_deallocate(p) <br/><br/>
//Treap<br/>
//prior成大顶堆<br/>
class Treap{<br/>
private:<br/>
     PTNode root ;<br/>
     TNode nil_node ; //空节点<br/>
     PTNode nil ;//空节点指针<br/><br/>
     void </em>delete_node(PTNode p) ;<br/>
     PTNode <em>next_node(PTNode p) ;//中继前驱<br/>
     PTNode </em>prev_node(PTNode p) ;//中继后继<br/>
     PTNode <em>rotate_left(PTNode p ) ;//以p为轴左旋<br/>
     PTNode </em>rotate_right(PTNode p ) ;//以p为轴右旋<br/>
     PTNode <em>find_node(PTNode p , ElemType d ) ;//从p开始的位置寻找节点<br/>
     PTNode </em>find_parent(ElemType d ) ;//寻找d的父节点<br/>
     void <em>in_order(PTNode p) ;//p节点的中序遍历<br/>
     void </em>pre_order(PTNode p) ;//p节点的前序遍历<br/>
public:<br/>
     <br/>
     Treap() ;//构造空树<br/>
     ~Treap() ;//销毁树<br/>
     PTNode Find(ElemType d) ;//查找元素，<br/>
     PTNode FindMax() ;//查找最大元素，<br/>
     PTNode FindMin() ;//查找最小元素，<br/>
     ElemType&amp; Retrieve(PTNode p) ;//获取元素<br/>
     PTNode Insert(ElemType d) ;//插入元素<br/>
     void Delete(ElemType d) ;//按元素删除<br/>
     void Erase(PTNode p) ;//按节点位置删除<br/>
     void Clear() ;//清除整棵树<br/>
     void InOrder() ; //中序遍历<br/>
     void PreOrder() ; //前序遍历<br/>
     PTNode Nil() ;//返回空节点，便于调用端判断边界条件<br/>
     static void Sort(ElemType a[] , int n , int d = 1) ;//利用T进行排序，静态函数<br/>
} ;<br/><br/><br/>
//d：1，从小到大，0，从大到小<br/>
void Treap::Sort(ElemType a[] , int n , int d){<br/>
     Treap tree ;<br/>
     int i ;<br/>
     for ( i = 0 ; i &lt; n ; i ++ ){<br/>
          tree.Insert(a[i]) ;<br/>
     //     tree.InOrder() ;<br/>
     //     tree.PreOrder() ;<br/>
     }<br/>
//     tree.InOrder() ;<br/>
//     tree.PreOrder() ;<br/>
     for ( i = 0 ; i &lt; n ; i ++ ){<br/>
          PTNode p ;<br/>
          if ( d ) {<br/>
               p = tree.FindMin() ;<br/>
          }else{<br/>
               p = tree.FindMax() ;     <br/>
          }<br/>
          a[i] = tree.Retrieve(p) ;<br/>
          tree.Erase(p) ;<br/>
     }<br/>
}<br/><br/>
Treap::Treap(){<br/>
     nil = &amp;nil_node ;<br/>
     root = nil ;<br/>
     nil_node.left = nil ;<br/>
     nil_node.right = nil ;<br/>
     nil_node.parent = nil ;<br/>
     nil_node.prior = -1 ; //设置为最小，空节点只能在叶子处<br/>
}<br/><br/>
Treap::~Treap(){<br/>
     Clear() ;<br/>
}<br/><br/>
void Treap::<em>in_order(PTNode p){<br/>
     if ( p != nil ) {<br/>
          </em>in_order(p-&gt;left) ;<br/>
          std::cout&lt;&lt;p-&gt;data&lt;&lt;&#8217; &#8216;;<br/>
          <em>in_order(p-&gt;right) ;<br/>
     }<br/>
}<br/><br/>
void Treap::</em>pre_order(PTNode p){<br/>
     if ( p != nil ) {<br/>
          std::cout&lt;&lt;p-&gt;data&lt;&lt;&#8217; &#8217; ;<br/>
          <em>pre_order(p-&gt;left) ;<br/>
          </em>pre_order(p-&gt;right) ;<br/>
     }     <br/>
}<br/><br/>
void Treap::InOrder(){<br/>
     <em>in_order(root) ;<br/>
     std::cout&lt;&lt;std::endl;<br/>
}<br/><br/>
void Treap::PreOrder(){<br/>
     </em>pre_order(root) ;<br/>
     std::cout&lt;&lt;std::endl;<br/>
}<br/><br/>
PTNode Treap::<em>next_node(PTNode p){<br/>
     if ( p == nil ) return nil ;<br/>
     if ( p-&gt;right != nil ){<br/>
          p = p-&gt;right ;<br/>
          while ( p-&gt;left != nil ) p = p-&gt;left ;<br/>
     }else{<br/>
          while ( p-&gt;parent &amp;&amp; p-&gt;parent-&gt;right == p ) p = p-&gt;parent ;<br/>
          p = p-&gt;parent ;<br/>
     }<br/>
     return p ;<br/>
}<br/><br/>
PTNode Treap::</em>prev_node(PTNode p){<br/>
     if ( p == nil ) return nil ;<br/>
     if ( p-&gt;left != nil ){<br/>
          p = p-&gt;left ;<br/>
          while ( p-&gt;right != nil ) p = p-&gt;right ;<br/>
     }else{<br/>
          while ( p-&gt;parent &amp;&amp; p-&gt;parent-&gt;left == p ) p = p-&gt;parent ;<br/>
          p = p-&gt;parent ;<br/>
     }<br/>
     return p ;     <br/>
}<br/><br/>
PTNode Treap::Find(ElemType d){     <br/>
     return <em>find_node(root , d) ;<br/>
}<br/><br/>
PTNode Treap::FindMax(){<br/>
     if ( root == nil ) return nil ;<br/>
     PTNode p = root ;<br/>
     while ( p-&gt;right != nil ){<br/>
          p = p-&gt;right ;<br/>
     }<br/>
     return p ;<br/>
}<br/><br/>
PTNode Treap::FindMin(){<br/>
     if ( root == nil ) return nil ;<br/>
     PTNode p = root ;<br/>
     while ( p-&gt;left != nil ){<br/>
          p = p-&gt;left ;<br/>
     }<br/>
     return p ;<br/>
}<br/><br/>
ElemType&amp; Treap::Retrieve(PTNode p){<br/>
     if ( p != nil ) <br/>
          return p-&gt;data ;<br/>
     else return nil-&gt;data ;<br/>
}<br/><br/>
//左旋<br/>
PTNode Treap::</em>rotate_left(PTNode p ){<br/>
     PTNode child = p-&gt;right ;<br/>
     p-&gt;right = child-&gt;left ;<br/>
     if ( child-&gt;left != nil ) child-&gt;left-&gt;parent = p ;<br/>
     child-&gt;left = p ;<br/>
     PTNode ancestor = p-&gt;parent ;<br/>
     if ( ancestor != nil ) {<br/>
          if ( ancestor-&gt;left == p ) ancestor-&gt;left = child ;<br/>
          else ancestor-&gt;right = child ;<br/>
     }else{<br/>
          root = child ;<br/>
     }<br/>
     child-&gt;parent = ancestor ;<br/>
     p-&gt;parent = child ;<br/>
     return child ;<br/>
}<br/><br/>
//右旋<br/>
PTNode Treap::<em>rotate_right(PTNode p ){<br/>
     PTNode child = p-&gt;left ;<br/>
     p-&gt;left = child-&gt;right ;<br/>
     if ( child-&gt;right != nil ) child-&gt;right-&gt;parent = p ;<br/>
     child-&gt;right = p ;<br/>
     PTNode ancestor = p-&gt;parent ;<br/>
     if ( ancestor != nil ) {<br/>
          if ( ancestor-&gt;left == p ) ancestor-&gt;left = child ;<br/>
          else ancestor-&gt;right = child ;<br/>
     }else{<br/>
          root = child ;<br/>
     }<br/>
     child-&gt;parent = ancestor ;<br/>
     p-&gt;parent = child ;<br/>
     return child ;<br/>
}<br/><br/>
PTNode Treap::</em>find_node(PTNode p , ElemType d ){<br/>
     if ( p == nil ) return root ;//说明p是根节点的父节点<br/>
     while ( p != nil &amp;&amp; p-&gt;data != d ){<br/>
          if ( d &lt; p-&gt;data ) p = p-&gt;left ;<br/>
          else p = p-&gt;right ;<br/>
     }     <br/>
     return p ;<br/>
}<br/><br/>
PTNode Treap::<em>find_parent(ElemType d ){<br/>
     if ( root == nil ) return nil ;<br/>
     PTNode p = nil ;<br/>
     PTNode q = root ;<br/>
     do{<br/>
          if ( q-&gt;data == d ) return p ;<br/>
          p = q ;<br/>
          if ( d &lt; q-&gt;data ) q = q-&gt;left ;<br/>
          else q = q-&gt;right ;<br/>
     }while (q != nil ) ;<br/>
     return p ;<br/>
}<br/><br/>
PTNode Treap::Insert(ElemType d){     <br/>
     PTNode parent = </em>find_parent(d) ;<br/>
     PTNode child = <em>find_node(parent , d) ;<br/><br/>
     if ( child != nil ) return child ;<br/>
     child = </em>T_allocate() ;<br/>
     child-&gt;data = d ;<br/>
     child-&gt;left = nil ;<br/>
     child-&gt;right = nil ;<br/>
     child-&gt;parent = parent ;<br/>
     child-&gt;prior = <em>T_rand() ;<br/><br/>
     //root为空<br/>
     if ( root == nil ) {<br/>
          root = child ;<br/>
          return root ;<br/>
     }<br/><br/>
     //将child挂到parent上<br/>
     if ( d &lt; parent-&gt;data ) parent-&gt;left = child ;<br/>
     else parent-&gt;right = child ;<br/><br/>
     //开始按照堆性质调整<br/>
     while ( parent != nil &amp;&amp; child-&gt;prior &gt; parent-&gt;prior ){<br/>
          if ( child == parent-&gt;left )<br/>
               child = </em>rotate_right(parent) ;<br/>
          else <br/>
               child = <em>rotate_left(parent) ;<br/>
          parent = child-&gt;parent ;<br/>
     }<br/><br/>
     return child ;<br/>
}<br/><br/>
void Treap::Erase(PTNode pos){<br/>
     PTNode left = pos-&gt;left ;<br/>
     PTNode right = pos-&gt;right ;<br/>
     while ( left != nil || right != nil ){<br/>
          if ( left-&gt;prior &lt; right-&gt;prior ){<br/>
               </em>rotate_left(pos) ;<br/>
          }else{<br/>
               <em>rotate_right(pos) ;<br/>
          }<br/>
          left = pos-&gt;left ;<br/>
          right = pos-&gt;right ;<br/>
     }<br/>
     if ( pos == root ){<br/>
          root = nil ;<br/>
     }else{<br/>
          PTNode parent = pos-&gt;parent ;<br/>
          if ( pos == parent-&gt;left ) parent-&gt;left = nil ;<br/>
          else parent-&gt;right = nil ;<br/>
     }<br/>
     </em>T_deallocate(pos) ;<br/>
}<br/><br/>
void Treap::Delete(ElemType d){<br/>
     PTNode p = Find(d) ;<br/>
     if ( p != nil ) {<br/>
          Erase(p) ;<br/>
     }<br/>
}<br/><br/>
void Treap::<em>delete_node(PTNode p){<br/>
     if ( p != nil ){<br/>
          </em>delete_node(p-&gt;left) ;<br/>
          <em>delete_node(p-&gt;right) ;<br/>
          </em>T_deallocate(p) ;<br/>
     }<br/>
}<br/><br/>
void Treap::Clear(){<br/>
     _delete_node(root) ;<br/>
     root = nil ;<br/>
}<br/><br/>
//测试代码<br/>
using namespace std;<br/></p>

<h1>include &lt;algorithm&gt;<br/></h1>

<h1>include &lt;time.h&gt;<br/><br/></h1>

<p>const TOTAL = 200000 ;<br/>
int c[TOTAL] ;<br/><br/>
int main(){<br/><br/>
     int a[] = {3,2,9,7,5,8,6} ;<br/>
//     int a[] = {5 , 2 , 3} ;<br/>
     int b[10] ;<br/>
     int sz = sizeof(a) / sizeof(int)  ;<br/>
     int i;<br/>
     Treap tree ;<br/><br/>
     //初始化数据<br/>
     <em>T_initseed() ;<br/><br/>
     //初始化空间<br/>
      </em>T_initspace() ;<br/><br/>
     for ( i = 0 ; i &lt; sz ; i ++ ) b[i] = a[i] ;<br/><br/>
     //排序测试<br/>
     Treap::Sort(a , sz , 1) ;<br/>
     for ( i = 0 ; i &lt; sz ; i ++ )cout&lt;&lt;a[i]&lt;&lt;&#8217; &#8216;;<br/>
     cout&lt;&lt;endl;<br/><br/>
     <br/><br/>
     //插入，删除，中序遍历，空树测试<br/>
     tree.Insert(1) ;<br/>
     tree.InOrder() ;<br/>
     tree.Insert(1) ;<br/>
     tree.InOrder() ;<br/>
     tree.Delete(1) ;<br/>
     tree.InOrder() ;<br/><br/>
     //插入测试，根据中序和前序，可以构造出整树，来检验插入是否正确<br/>
     for ( i = 0 ; i &lt; sz ; i ++ ){<br/>
          tree.Insert(a[i]) ;<br/>
          tree.InOrder() ;<br/>
          tree.PreOrder() ;<br/>
     }<br/>
     cout&lt;&lt;endl;<br/><br/>
//     return 0 ;<br/><br/>
     //查找测试<br/>
     //不存在元素<br/>
     cout&lt;&lt;tree.Find(4)&lt;&lt;endl;<br/>
     cout&lt;&lt;endl;<br/>
     //存在的元素<br/>
     cout&lt;&lt;tree.Find(9)&lt;&lt;endl;<br/>
     cout&lt;&lt;tree.Find(9)-&gt;data&lt;&lt;endl;<br/>
     //删除元素<br/>
     tree.Delete(9) ;<br/>
     cout&lt;&lt;tree.Find(9)&lt;&lt;endl;<br/><br/>
     tree.InOrder() ;<br/>
     tree.PreOrder() ;<br/><br/>
     //清除测试<br/>
     cout&lt;&lt;endl;<br/>
     cout&lt;&lt;tree.Find(3)&lt;&lt;endl;<br/>
     cout&lt;&lt;tree.Retrieve(tree.Find(3))&lt;&lt;endl;<br/>
     tree.Clear() ;<br/>
     cout&lt;&lt;tree.Find(3)&lt;&lt;endl;     <br/>
     tree.PreOrder() ;<br/><br/>
//大数据测试<br/>
     for ( i = 0 ; i &lt; TOTAL ; i ++ ) c[i] = i ; <br/>
     random_shuffle(c , c + TOTAL) ;<br/>
//     可选择输出数据检验     <br/>
//     for ( i = 0 ; i &lt; TOTAL ; i ++ ) cout&lt;&lt;c[i]&lt;&lt;&#8217; &#8217; ;<br/>
//     cout&lt;&lt;endl;<br/>
//     return 0 ;<br/>
     clock_t tt = clock() ;<br/>
     _T_initspace() ;<br/>
     Treap::Sort(c , TOTAL , 1) ;<br/>
     printf(&#8220;time: %d\n&#8221; , clock() - tt) ;<br/>
     for ( i = 0 ; i &lt; TOTAL ; i ++ ) if ( c[i] != i ) break; <br/>
     if ( i == TOTAL ) cout&lt;&lt;&#8221;ok&#8221;&lt;&lt;endl;<br/>
     else cout&lt;&lt;&#8221;bad alg!&#8221;&lt;&lt;endl;<br/><br/>
     return 0 ;<br/>
}</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/05/27/%E7%A8%8B%E5%BA%8F%E5%88%A4%E6%96%AD%E9%80%BB%E8%BE%91%E9%97%AE%E9%A2%98%EF%BC%8C%E8%95%B4%E5%90%AB%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%AD%89%E4%BB%B7%E8%BD%AC%E6%8D%A2%EF%BC%88MATLAB%29/">程序判断逻辑问题，蕴含表达式的等价转换（MATLAB)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-05-27T22:39:00+08:00" pubdate data-updated="true">May 27<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.5.27<br/><br/>
昨天在河畔上碰到有人问一个送200水的题，<br/>
题虽然很水，看在200水的份上，还是决定去刷掉。<br/><br/>
==========================<br/>
如果A参加比赛，那么B、C、D也将参加比赛。如果上述断定为真，那么下述哪项断定 <br/>
必定为真（　　） <br/>
A.如果A没参加比赛，那么B、C、D都参加比赛 <br/>
B.如果B、C、D都参加比赛，那么A也参加比赛 <br/>
C.如果D没参加比赛，那么B、C不会都参加比赛 <br/>
D.如果C没参加比赛，那么A、D不会都参加比赛 <br/>
==========================<br/><br/>
由于题目过于水。。好几个人抢在我前面就把答案给出来了。<br/>
而且有很啰嗦的证明。<br/>
看来只有另辟蹊径。。其实就是搞点花样好赚水。。<br/><br/><font color="#0000ff">打开MATLAB，写一个程序：</font><br/><pre class="prettyprint"><span class="kwd">for</span><span class="pln"> a </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">:</span><span class="lit">1</span><span class="pln"><br/></span><span class="kwd">for</span><span class="pln"> b </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">:</span><span class="lit">1</span><span class="pln"><br/></span><span class="kwd">for</span><span class="pln"> c </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">:</span><span class="lit">1</span><span class="pln"><br/></span><span class="kwd">for</span><span class="pln"> d </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">:</span><span class="lit">1</span><span class="pln"><br/></span><span class="pun">%</span><span class="pln">p</span><span class="pun">-&gt;</span><span class="pln">q  </span><span class="pun">==&gt;</span><span class="pln"> </span><span class="pun">~</span><span class="pln">p</span><span class="pun">|</span><span class="pln">q<br/></span><span class="kwd">if</span><span class="pln">  </span><span class="pun">~</span><span class="pln">a </span><span class="pun">|</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> b </span><span class="pun">&amp;</span><span class="pln"> c </span><span class="pun">&amp;</span><span class="pln"> d </span><span class="pun">)</span><span class="pln"> <br/></span><span class="kwd">if</span><span class="pln"> </span><span class="pun">~(</span><span class="pln">a </span><span class="pun">|</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> b </span><span class="pun">&amp;</span><span class="pln"> c </span><span class="pun">&amp;</span><span class="pln"> d </span><span class="pun">))</span><span class="pln"> <br/>                        disp</span><span class="pun">(</span><span class="str">'A false'</span><span class="pun">)</span><span class="pln"><br/></span><span class="kwd">end</span><span class="pln"><br/></span><span class="kwd">if</span><span class="pln"> </span><span class="pun">~(~(</span><span class="pln">b </span><span class="pun">&amp;</span><span class="pln"> c </span><span class="pun">&amp;</span><span class="pln"> <font color="#ff0000">d</font></span><span class="pun">)</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> a </span><span class="pun">)</span><span class="pln"> <br/>                        disp</span><span class="pun">(</span><span class="str">'B false'</span><span class="pun">)</span><span class="pln"><br/></span><span class="kwd">end</span><span class="pln"><br/></span><span class="kwd">if</span><span class="pln"> </span><span class="pun">~(</span><span class="pln">d </span><span class="pun">|</span><span class="pln"> </span><span class="pun">~(</span><span class="pln">b </span><span class="pun">&amp;</span><span class="pln"> c</span><span class="pun">))</span><span class="pln"><br/>                        disp</span><span class="pun">(</span><span class="str">'C false'</span><span class="pun">)</span><span class="pln">    <br/></span><span class="kwd">end</span><span class="pln"><br/></span><span class="kwd">if</span><span class="pln"> </span><span class="pun">~(</span><span class="pln">c </span><span class="pun">|</span><span class="pln"> </span><span class="pun">~(</span><span class="pln">a </span><span class="pun">&amp;</span><span class="pln"> d</span><span class="pun">))</span><span class="pln"><br/>                        disp</span><span class="pun">(</span><span class="str">'D false'</span><span class="pun">)</span><span class="pln">    <br/></span><span class="kwd">end</span><span class="pln"><br/></span><span class="kwd">end</span><span class="pln"><br/></span><span class="kwd">end</span><span class="pln"><br/></span><span class="kwd">end</span><span class="pln"><br/></span><span class="kwd">end</span><span class="pln"><br/></span><span class="kwd">end</span><span class="pln"><br/></span></pre>
<font color="#0000ff">结果：</font><br/>
A false<br/>
A false<br/>
A false<br/>
A false<br/>
A false<br/>
A false<br/>
A false<br/>
B false<br/>
C false<br/>
B false<br/><br/>
程序的原理是枚举所有合理情况。一旦有某个选项在某个情况下为假，就打出false。<br/><br/>
实践证明，只有D没有被打出。也就是满足所有情况的。为全真式。<br/><br/>
记得第一次看到用程序来解决逻辑问题，<br/>
还是那本讲QB的教材，举了几个基本的例子。<br/>
看了觉得很搞笑的，<br/>
首先，这么简单的东西还写个程序干嘛。<br/>
其次，一直没细致地想过，只是直观上觉得构造逻辑式子很容易。<br/><br/>
比如，A为1，B为1：<br/>
A&amp;B<br/><br/>
A和B至少有一个为真：<br/>
A|B<br/><br/>
还能举出很多，让人觉得很简单的式子。<br/>
归结了一下，这类式子用到的都是基本的逻辑描述：<br/><font color="#ff0000">与，或，非，异或。。。等等</font><br/><br/>
而这些东西，中学的数序会提到，概率的前几章也会再讲，数字电路也会涉及。<br/>
所以，一看就觉得很眼熟，很快就构造出来了。<br/><br/>
而原题中全部都是“XXX,那么YYY的形式”，<br/>
如果没有<font color="#ff0000">蕴含</font>这个概念，就会感觉在转化上困难。<br/>
因为那几个选项在我们读来就像是一个句子。<br/>
到程序里面就有点：<br/>
IF &#8230; THEN &#8230;<br/>
的这种感觉。<br/><br/>
而知道了蕴含这个概念后，可以把他们整体作为一个式子来考虑。<br/><br/><font color="#ff0000">p蕴含q：p-&gt;q。<br/>
对应的文字描述就是“如果p，那么q”</font><br/><br/><font color="#ff0000">蕴含关系的典型转换：<br/>
p-&gt;q  ==&gt; (~p)|q</font><br/>
也就是上面程序里面大量出现的结构。<br/><br/>
比如来翻译这句话：<br/>
如果D没参加比赛，那么B、C不会都参加比赛 <br/>
==&gt;<br/>
D没参加比赛-&gt;B、C不会都参加比赛<br/><br/>
B、C不会都参加比赛<br/>
==&gt;<br/>
~(B&amp;C)<br/><br/>
D没参加比赛<br/>
==&gt;<br/>
~D<br/><br/>
那么整合起来，运用蕴含的转化式：<br/>
D|~(B&amp;C)<br/><br/>
也就是说“如果D没参加比赛，那么B、C不会都参加比赛&#8221;<br/>
这句话和D|~(B&amp;C)是等价的。<br/><br/>
第一次接触到“蕴含”的时候感觉很神奇的。。<br/>
很方便就把“一句话”表达的意思，翻译成一个逻辑式子了。。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/05/25/%E7%94%BB%E5%BF%83%EF%BC%88MATLAB%EF%BC%8Cfill%EF%BC%8C%E3%80%8A%E9%AD%94%E6%9C%AF%E5%B8%88%E3%80%8B%EF%BC%89/">画心（MATLAB，fill，《魔术师》）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-05-25T13:56:00+08:00" pubdate data-updated="true">May 25<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.5.25<br/><br/>
记得微积分的最后有个讲心形线的东西。<br/>
看了那个图，只能觉得，大致上算吧，总体上看去还是很别扭。<br/><br/>
今天看到用旋转的椭圆来拼成一个心，感觉很逼真。<br/><br/>
matlab的eaplot真的是很easy，表达式一上去就出来了。<br/><font color="#ff6600">ezplot(&#8216;24<em>x</em>x-20<em>abs(x)</em>y+15<em>y</em>y=225&#8217;) ;</font><br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/c0b2c6bfb8c8452e18d81f3c.jpg" small="0" class="blogimg"/><br/><br/>
貌似也没看到有啥好方法，据说还在百度知道上搜到这种“<a href="http://zhidao.baidu.com/question/52524620.html" target="_blank">不会</a>”为最佳答案的东西。。</div></p>

<br/>


<p>瞟了一下，matlab里面有fill和fill3两个函数。<br/>
fill是对给出的点的序列描出的多边形画图。<br/>
于是就想把这个心上的点顺次生成，用fill画出来。<br/><br/>
因为表达式：24<em>x</em>x-20<em>abs(x)</em>y+15<em>y</em>y=225<br/>
的长相问题，在直角坐标下，很难找到一个办法来描述“顺次”这个意思。<br/><br/>
故转化到极坐标下。<br/>
当然，算出theta对应的r后，plot画图前还是得转回直角坐标来的。<br/><br/>
这里由于图像左右对称，所以theta只取[-0.5pi,0.5pi]。<br/>
把得到的点翻转一下就是了：<br/><br/><font color="#ff6600">theta = -pi/2:0.01:pi/2 ;<br/>
r = (225 ./ (24 .<em> cos(theta).<sup>2</sup> - 20 .</em> cos(theta).<em>sin(theta) + 15 .</em> sin(theta).<sup>2</sup> )) ;<br/>
x = r .<em> cos(theta) ;<br/>
y = r .</em> sin(theta) ;<br/>
fill([x -fliplr(x)] , [y fliplr(y)] , &#8216;r&#8217;) ;</font><br/><br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/f11493257878994435a80f3c.jpg" small="0" class="blogimg"/></div></p>

<br/>


<p>不过有个问题，貌似和上面的函数式ezplot出来的轮廓不一样。<br/>
从某种意义上来说，这个图还是很像心的。但为啥不一样呢。。囧。。<br/><br/>
yhsa678同学用他那犀利的眼神发现了问题所在：<br/><font color="#ff0000">r = sqrt(225 ./ (24 .<em> cos(theta).<sup>2</sup> - 20 .</em> cos(theta).<em>sin(theta) + 15 .</em> sin(theta).<sup>2</sup> )) ;</font><br/>
就是推极坐标表达的时候搞忘对r开方了。<br/>
这下弄出来就是这个样子了。<br/><br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/b605c41b255f38deae51333c.jpg" small="0" class="blogimg"/></div></p>

<br/>


<p>关于上面提到的fill要顺次连接的问题，可以改一点来观察。<br/><div forimg="1"><font color="#ff6600">theta = -pi/2:0.01:pi/2 ;<br/>
r = sqrt(225 ./ (24 .<em> cos(theta).<sup>2</sup> - 20 .</em> cos(theta).<em>sin(theta) + 15 .</em> sin(theta).<sup>2</sup> )) ;<br/>
x = r .<em> cos(theta) ;<br/>
y = r .</em> sin(theta) ;<br/>
%fill([x -fliplr(x)] , [y fliplr(y)] , &#8216;r&#8217;) ;</font><br/><font color="#ff0000">fill([x -x] , [y y] , &#8216;r&#8217;) ;</font></div></p>

<div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/450d3cd183677c1c9a50273c.jpg" small="0" class="blogimg"/></div>


<div forimg="1"><br/>
这两句：</div>


<div forimg="1">fill([x -fliplr(x)] , [y fliplr(y)] , &#8216;r&#8217;) ;<br/>
fill([x -x] , [y y] , &#8216;r&#8217;) ;</div>


<div forimg="1"><br/>
区别就在第一个先把相关序列翻转了，画出来的就没有中间的黑线。<br/>
第二个的话，fill从最下面延逆时针画到上方x=0处，<br/>
然后瞬间跑到最下方，延顺时针画，这就导致图形有问题。<br/><br/>
所以<font color="#ff0000">fill对点的顺次连接有要求</font></div>


<br/>


<p>不知道那个24<em>x</em>x-20<em>abs(x)</em>y+15<em>y</em>y=225的式子是哪来的。。<br/><br/>
想了一下，可以看成是一个椭圆，先做旋转，然后取正半截，再翻转。见下图：<br/><br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/6a1e00d12d9037f7562c843c.jpg" small="0" class="blogimg"/></div></p>

<br/>


<p>关于向量的旋转，可以参考：<a href="http://www.box.net/shared/casqylxr01" target="_blank">向量的旋转</a><br/><br/>
这样的话，就可以改变长轴a，短轴b，和转角phi来完成各种参数的心形。<br/><br/><font color="#ff6600"><font color="#ff0000">a = 3 ;<br/>
b = 3 ;<br/>
phi = 20 * pi / 180 ;</font><br/>
rotate = [cos(phi) -sin(phi) ; sin(phi) -cos(phi)] ;%旋转矩阵<br/>
theta = -pi:0.01:pi ;<br/>
x0 = a * cos(theta) ;<br/>
y0 = b * sin(theta) ;%标准椭圆的点序列<br/>
pt = rotate * [x0 ; y0] ;<br/>
x1 = pt(1,:) ;<br/>
y1 = pt(2,:) ;%旋转后的序列<br/>
pos = ( x1 &gt;= 0 ) ;<br/>
x = x1(pos) ;<br/>
y = y1(pos) ;%提取正半截<br/>
axis equal<br/>
hold on<br/>
fill([x -fliplr(x)] , [y fliplr(y)] , &#8216;r&#8217;) ;%翻转加绘图<br/>
plot(x0,y0,x1,y1) ;%打印出参考线</font><br/><br/>
那这个旋转椭圆画心又是怎么想到的呢。。<br/>
我也不知道，不过电影《魔术师》里面有类似的情节：<br/><br/>
（男主送给女主的礼物）<br/><br/>
1.看起来虽然不是很椭圆，也有那个意思<br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/c8d9c295c489686fd0135ebc.jpg" small="0" class="blogimg"/><br/><br/>
2.好家伙，可以掰开的。。</div></p>

<div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/0ba65b0fa133120e6159f3bd.jpg" small="0" class="blogimg"/><br/><br/>
3.哇，转一圈过来是个心哦。。</div>


<div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/04243cd351f373243bf3cfbd.jpg" small="0" class="blogimg"/><br/><br/>
4.还可以这样。。。<img src="http://img.baidu.com/hi/jx/j_0016.gif"/>。。？？</div>


<div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/42a9f1f23cdb5637b17ec5bd.jpg" small="0" class="blogimg"/></div>


<br/>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/backup-hplonline/blog/page/16/">&larr; Older</a>
    
    <a href="/backup-hplonline/blog/archives">Blog Archives</a>
    
    <a class="next" href="/backup-hplonline/blog/page/14/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/backup-hplonline/blog/2013/05/04/test/">Test</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/04/09/%E5%86%8D%E8%B0%88stl%E7%9A%84rotate/">再谈stl的rotate</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%BA%8C%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、二）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%89%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、三）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%80%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、一）</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - hplonline -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
