
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>hplonline</title>
  <meta name="author" content="hplonline">

  
  <meta name="description" content="(hplonline)2009.5.24
这里有份资料，可谓写得相当详细了，于是我都不好意思来描述了：
http://imlazy.ycool.com/post.1104022.html
我的代码的框架基本上是从前面写的AVL搬过来的。
因为不同的地方就是插入和删除，搜索树的其他操作是一样的。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hupili.github.io/backup-hplonline/blog/page/16">
  <link href="/backup-hplonline/favicon.png" rel="icon">
  <link href="/backup-hplonline/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/backup-hplonline/atom.xml" rel="alternate" title="hplonline" type="application/atom+xml">
  <script src="/backup-hplonline/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/backup-hplonline/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/backup-hplonline/">hplonline</a></h1>
  
    <h2>backup from 2006 to 2012 (original hi.baidu.com/hplonline/)</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/backup-hplonline/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hupili.github.io/backup-hplonline" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/backup-hplonline/">Blog</a></li>
  <li><a href="/backup-hplonline/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/05/24/%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%88RBTree%EF%BC%89%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%8E%B0/">红黑树（RBTree）的一个实现</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-05-24T19:38:00+08:00" pubdate data-updated="true">May 24<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.5.24<br/><br/>
这里有份资料，可谓写得相当详细了，于是我都不好意思来描述了：<br/>
http://imlazy.ycool.com/post.1104022.html<br/><br/>
我的代码的框架基本上是从前面写的AVL搬过来的。<br/>
因为不同的地方就是<font color="#ff0000">插入和删除</font>，搜索树的其他操作是一样的。<br/>
写的时候，也是照着上面的讲解来的，<br/>
但是调了很久，最后只得对着上面的程序来调，搞得大体上也长得差不多了。<br/><br/>
做了下200000个点排序的<font color="#ff0000">benchmark</font>。<br/>
如果用直接的malloc和free搞，要1300ms的样子。<br/>
用静态分配空间的办法，大概130ms的样子。<br/>
还是比较显著。<br/><br/><font color="#ff0000">有一个教训，就是以后千万不要在NULL上捡懒了。</font><br/>
因为实现红黑树的时候，自己做了个nil节点。<br/>
于是，如果以前AVL的框架中，用到NULL的地方，我都改成nil就对了。<br/>
这个操作用个替换就完成了，很方便。<br/>
但是前面的写法中，有很多if ( p ) {&#8230;}这种。<br/>
这就麻烦了，没改到的话，运行就出问题。<br/><br/>
还有在看那位强人的代码时，才意识到搜索树还有一极大的功能：<br/><font color="#ff0000">获取第k大节点，获取x节点排序后的位置。</font><br/>
这两个操作都是对数级的，而我们平时谈到搜索树时，<br/>
往往关注插入，判重等，很少提到这点。<br/>
其实取最小和取最大都是这两个操作的特化。<br/><br/>
具体实现就是对每个节点增加左右子树节点的记数就可以了。<br/>
下面的代码没有实现这两个操作，准备在把搜索树做得差不多时一起加上。<br/><br/><font color="#0000ff">代码如下：</font><br/><br/></p>

<h1>include &lt;iostream&gt;<br/></h1>

<h1>include &lt;stdlib.h&gt;<br/><br/></h1>

<p>//元素类型<br/>
typedef int ElemType ;<br/><br/>
typedef bool <em>RB_COLOR ;<br/>
</em>RB_COLOR <em>RB_RED = true ;<br/>
</em>RB_COLOR <em>RB_BLACK = false ;<br/><br/>
//树的节点<br/>
struct RBNode{<br/>
     ElemType data ;<br/>
     RBNode <em>left , </em>right , *parent ;<br/>
     </em>RB_COLOR color ;<br/>
};<br/>
typedef RBNode *PRBNode ;<br/><br/>
//空间分配宏，便于实现其他配置方式<br/></p>

<h1>define _RB_initspace <br/></h1>

<h1>define _RB_allocate() (RBNode *)malloc(sizeof(RBNode))<br/></h1>

<h1>define _RB_deallocate(p) free(p) <br/></h1>

<p>//RBNode space[200000] , *spacehead ;<br/>
//#define <em>RB_initspace spacehead = space <br/>
//#define </em>RB_allocate() spacehead++ ;<br/>
//#define <em>RB_deallocate(p) <br/><br/>
//RB<br/>
class RBTree{<br/>
private:<br/>
     PRBNode root ;<br/>
     RBNode nil_node ; //空节点<br/>
     PRBNode nil ;<br/>
     void </em>delete_node(PRBNode p) ;<br/>
     PRBNode <em>next_node(PRBNode p) ;//中继前驱<br/>
     PRBNode </em>prev_node(PRBNode p) ;//中继后继<br/>
     PRBNode <em>rotate_left(PRBNode p ) ;//以p为轴左旋<br/>
     PRBNode </em>rotate_right(PRBNode p ) ;//以p为轴右旋<br/>
     PRBNode <em>find_node(PRBNode p , ElemType d ) ;//从p开始的位置寻找节点<br/>
     PRBNode </em>find_parent(ElemType d ) ;//寻找d的父节点<br/>
     void <em>in_order(PRBNode p) ;//p节点的中序遍历<br/>
     void </em>pre_order(PRBNode p) ;//p节点的前序遍历<br/>
     void <em>insert_fix(PRBNode child , PRBNode parent) ;<br/>
     void </em>erase_fix(PRBNode child , PRBNode parent) ;<br/>
public:<br/>
     <br/>
     RBTree() ;//构造空树<br/>
     ~RBTree() ;//销毁树<br/>
     PRBNode Find(ElemType d) ;//查找元素，<br/>
     PRBNode FindMax() ;//查找最大元素，<br/>
     PRBNode FindMin() ;//查找最小元素，<br/>
     ElemType&amp; Retrieve(PRBNode p) ;//获取元素<br/>
     PRBNode Insert(ElemType d) ;//插入元素<br/>
     void Delete(ElemType d) ;//按元素删除<br/>
     void Erase(PRBNode p) ;//按节点位置删除<br/>
     void Clear() ;//清除整棵树<br/>
     void InOrder() ; //中序遍历<br/>
     void PreOrder() ; //前序遍历<br/>
     PRBNode Nil() ;//返回空节点，便于调用端判断边界条件<br/>
     static void Sort(ElemType a[] , int n , int d = 1) ;//利用RB进行排序，静态函数<br/>
} ;<br/><br/>
PRBNode RBTree::Nil(){<br/>
     return nil ;<br/>
}<br/><br/>
//d：1，从小到大，0，从大到小<br/>
void RBTree::Sort(ElemType a[] , int n , int d){<br/>
     RBTree tree ;<br/>
     int i ;<br/>
     for ( i = 0 ; i &lt; n ; i ++ ){<br/>
          tree.Insert(a[i]) ;<br/>
     //     tree.InOrder() ;<br/>
     //     tree.PreOrder() ;<br/>
     }<br/>
//     tree.InOrder() ;<br/>
//     tree.PreOrder() ;<br/>
     for ( i = 0 ; i &lt; n ; i ++ ){<br/>
          PRBNode p ;<br/>
          if ( d ) {<br/>
               p = tree.FindMin() ;<br/>
          }else{<br/>
               p = tree.FindMax() ;     <br/>
          }<br/>
          a[i] = tree.Retrieve(p) ;<br/>
          tree.Erase(p) ;<br/>
     }<br/>
}<br/><br/>
RBTree::RBTree(){<br/>
     nil = &amp;nil_node ;<br/>
     root = nil ;<br/>
     nil_node.color = <em>RB_BLACK ;<br/>
     nil_node.left = nil ;<br/>
     nil_node.right = nil ;<br/>
     nil_node.parent = nil ;<br/>
}<br/><br/>
RBTree::~RBTree(){<br/>
     Clear() ;<br/>
}<br/><br/>
void RBTree::</em>in_order(PRBNode p){<br/>
     if ( p != nil ) {<br/>
          <em>in_order(p-&gt;left) ;<br/>
          std::cout&lt;&lt;p-&gt;data&lt;&lt;&#8217; &#8216;&lt;&lt;p-&gt;color&lt;&lt;&#8217;,&#8217; ;<br/>
          </em>in_order(p-&gt;right) ;<br/>
     }<br/>
}<br/><br/>
void RBTree::<em>pre_order(PRBNode p){<br/>
     if ( p != nil ) {<br/>
          std::cout&lt;&lt;p-&gt;data&lt;&lt;&#8217; &#8217; ;<br/>
          </em>pre_order(p-&gt;left) ;<br/>
          <em>pre_order(p-&gt;right) ;<br/>
     }     <br/>
}<br/><br/>
void RBTree::InOrder(){<br/>
     </em>in_order(root) ;<br/>
     std::cout&lt;&lt;std::endl;<br/>
}<br/><br/>
void RBTree::PreOrder(){<br/>
     <em>pre_order(root) ;<br/>
     std::cout&lt;&lt;std::endl;<br/>
}<br/><br/>
PRBNode RBTree::</em>next_node(PRBNode p){<br/>
     if ( p == nil ) return nil ;<br/>
     if ( p-&gt;right != nil ){<br/>
          p = p-&gt;right ;<br/>
          while ( p-&gt;left != nil ) p = p-&gt;left ;<br/>
     }else{<br/>
          while ( p-&gt;parent &amp;&amp; p-&gt;parent-&gt;right == p ) p = p-&gt;parent ;<br/>
          p = p-&gt;parent ;<br/>
     }<br/>
     return p ;<br/>
}<br/><br/>
PRBNode RBTree::<em>prev_node(PRBNode p){<br/>
     if ( p == nil ) return nil ;<br/>
     if ( p-&gt;left != nil ){<br/>
          p = p-&gt;left ;<br/>
          while ( p-&gt;right != nil ) p = p-&gt;right ;<br/>
     }else{<br/>
          while ( p-&gt;parent &amp;&amp; p-&gt;parent-&gt;left == p ) p = p-&gt;parent ;<br/>
          p = p-&gt;parent ;<br/>
     }<br/>
     return p ;     <br/>
}<br/><br/>
PRBNode RBTree::Find(ElemType d){     <br/>
     return </em>find_node(root , d) ;<br/>
}<br/><br/>
PRBNode RBTree::FindMax(){<br/>
     if ( root == nil ) return nil ;<br/>
     PRBNode p = root ;<br/>
     while ( p-&gt;right != nil ){<br/>
          p = p-&gt;right ;<br/>
     }<br/>
     return p ;<br/>
}<br/><br/>
PRBNode RBTree::FindMin(){<br/>
     if ( root == nil ) return nil ;<br/>
     PRBNode p = root ;<br/>
     while ( p-&gt;left != nil ){<br/>
          p = p-&gt;left ;<br/>
     }<br/>
     return p ;<br/>
}<br/><br/>
ElemType&amp; RBTree::Retrieve(PRBNode p){<br/>
     if ( p != nil ) <br/>
          return p-&gt;data ;<br/>
     else return nil-&gt;data ;<br/>
}<br/><br/>
//左旋<br/>
PRBNode RBTree::<em>rotate_left(PRBNode p ){<br/>
     PRBNode child = p-&gt;right ;<br/>
     p-&gt;right = child-&gt;left ;<br/>
     if ( child-&gt;left != nil ) child-&gt;left-&gt;parent = p ;<br/>
     child-&gt;left = p ;<br/>
     PRBNode ancestor = p-&gt;parent ;<br/>
     if ( ancestor != nil ) {<br/>
          if ( ancestor-&gt;left == p ) ancestor-&gt;left = child ;<br/>
          else ancestor-&gt;right = child ;<br/>
     }else{<br/>
          root = child ;<br/>
     }<br/>
     child-&gt;parent = ancestor ;<br/>
     p-&gt;parent = child ;<br/>
     return child ;<br/>
}<br/><br/>
//右旋<br/>
PRBNode RBTree::</em>rotate_right(PRBNode p ){<br/>
     PRBNode child = p-&gt;left ;<br/>
     p-&gt;left = child-&gt;right ;<br/>
     if ( child-&gt;right != nil ) child-&gt;right-&gt;parent = p ;<br/>
     child-&gt;right = p ;<br/>
     PRBNode ancestor = p-&gt;parent ;<br/>
     if ( ancestor != nil ) {<br/>
          if ( ancestor-&gt;left == p ) ancestor-&gt;left = child ;<br/>
          else ancestor-&gt;right = child ;<br/>
     }else{<br/>
          root = child ;<br/>
     }<br/>
     child-&gt;parent = ancestor ;<br/>
     p-&gt;parent = child ;<br/>
     return child ;<br/>
}<br/><br/>
PRBNode RBTree::<em>find_node(PRBNode p , ElemType d ){<br/>
     if ( p == nil ) return root ;//说明p是根节点的父节点<br/>
     while ( p != nil &amp;&amp; p-&gt;data != d ){<br/>
          if ( d &lt; p-&gt;data ) p = p-&gt;left ;<br/>
          else p = p-&gt;right ;<br/>
     }     <br/>
     return p ;<br/>
}<br/><br/>
PRBNode RBTree::</em>find_parent(ElemType d ){<br/>
     if ( root == nil ) return nil ;<br/>
     PRBNode p = nil ;<br/>
     PRBNode q = root ;<br/>
     do{<br/>
          if ( q-&gt;data == d ) return p ;<br/>
          p = q ;<br/>
          if ( d &lt; q-&gt;data ) q = q-&gt;left ;<br/>
          else q = q-&gt;right ;<br/>
     }while (q != nil ) ;<br/>
     return p ;<br/>
}<br/><br/>
//child为红且parent为红时需要调整<br/>
void RBTree::<em>insert_fix(PRBNode child , PRBNode parent){<br/>
     while ( parent-&gt;color == </em>RB_RED ){<br/>
          //由于根节点始终为黑色，所以这时的grand一定不是nil<br/>
          PRBNode grand = parent-&gt;parent ;<br/>
          if ( parent == grand-&gt;left ){<br/>
               PRBNode uncle = grand-&gt;right ;<br/>
               if ( uncle-&gt;color == <em>RB_RED ){<br/>
                    parent-&gt;color = </em>RB_BLACK ;<br/>
                    uncle-&gt;color = <em>RB_BLACK ;<br/>
                    grand-&gt;color = </em>RB_RED ;<br/>
                    child = grand ;<br/>
                    parent = child-&gt;parent ;<br/>
               }else{<br/>
                    if ( child == parent-&gt;right ) {<br/>
                          parent = <em>rotate_left(parent) ;<br/>
                    }<br/>
                    parent-&gt;color = </em>RB_BLACK ;//此时已经调整完毕，下一个循环判断即退出<br/>
                    grand-&gt;color = <em>RB_RED ;<br/>
                    </em>rotate_right(grand) ;<br/>
               }<br/>
          }else{<br/>
               PRBNode uncle = grand-&gt;left ;<br/>
               if ( uncle-&gt;color == <em>RB_RED ){<br/>
                    parent-&gt;color = </em>RB_BLACK ;<br/>
                    uncle-&gt;color = <em>RB_BLACK ;<br/>
                    grand-&gt;color = </em>RB_RED ;<br/>
                    child = grand ;<br/>
                    parent = child-&gt;parent ;<br/>
               }else{<br/>
                    if ( child == parent-&gt;left ){<br/>
                         parent = <em>rotate_right(parent) ;<br/>
                    }<br/>
                    parent-&gt;color = </em>RB_BLACK ;<br/>
                    grand-&gt;color = <em>RB_RED ;<br/>
                    </em>rotate_left(grand) ;<br/>
               }<br/>
          }<br/>
     }<br/>
     root-&gt;color = <em>RB_BLACK ;//根节点始终为黑色<br/>
}<br/><br/>
PRBNode RBTree::Insert(ElemType d){     <br/>
     PRBNode parent = </em>find_parent(d);     <br/>
     PRBNode child = <em>find_node(parent , d) ;<br/><br/>
     //存在的节点<br/>
     if ( child != nil ) return child ;<br/><br/>
     //新建节点<br/>
     child = </em>RB_allocate() ;<br/>
     child-&gt;color = <em>RB_RED ;<br/>
     child-&gt;left = nil ;<br/>
     child-&gt;right = nil ;<br/>
     child-&gt;parent = parent ;<br/>
     child-&gt;data = d ;<br/><br/>
     //为根节点<br/>
     if ( parent == nil ){<br/>
          root = child ;<br/>
          root -&gt;color = </em>RB_BLACK ;<br/>
          return root ;<br/>
     }<br/><br/>
     //将child挂到parent上面<br/>
     if ( d &lt; parent-&gt;data ) parent-&gt;left = child ;<br/>
     else parent-&gt;right = child ;<br/><br/>
     <em>insert_fix(child , parent) ;<br/><br/>
     return child ;<br/>
}<br/><br/>
//child所在路径上的黑色减少，需要增加一个黑色节点<br/>
void RBTree::</em>erase_fix(PRBNode child , PRBNode parent){<br/>
     while ( parent != nil &amp;&amp; child-&gt;color == <em>RB_BLACK ){<br/>
          if ( child == parent-&gt;left ){<br/>
               PRBNode sibling = parent-&gt;right ;<br/>
               if ( sibling-&gt;color == </em>RB_RED ){<br/>
                    sibling-&gt;color = <em>RB_BLACK ;<br/>
                    parent-&gt;color = </em>RB_RED ;<br/>
                    <em>rotate_left(parent) ;<br/>
                    sibling = parent-&gt;right ;<br/>
               }<br/>
               if ( sibling-&gt;left-&gt;color == </em>RB_BLACK <br/>
                    &amp;&amp; sibling-&gt;right-&gt;color == <em>RB_BLACK ){<br/>
                    sibling-&gt;color = </em>RB_RED ;<br/>
                    child = parent ;<br/>
                    parent = parent-&gt;parent ;<br/>
               }else{<br/>
                    if ( sibling-&gt;right-&gt;color == <em>RB_BLACK ){<br/>
                         sibling-&gt;color = </em>RB_RED ;<br/>
                         sibling-&gt;left-&gt;color = <em>RB_BLACK ;<br/>
                         sibling = </em>rotate_right(sibling) ;<br/>
                    }<br/>
                    sibling-&gt;right-&gt;color = <em>RB_BLACK ;<br/>
                    sibling-&gt;color = parent-&gt;color ;<br/>
                    parent-&gt;color = </em>RB_BLACK ;<br/>
                    <em>rotate_left(parent) ;<br/>
                    parent = nil ; //到此已经调整完毕，破坏循环条件跳出<br/>
               }<br/>
          }else{<br/>
               PRBNode sibling = parent-&gt;left ;<br/>
               if ( sibling-&gt;color == </em>RB_RED ){<br/>
                    sibling-&gt;color = <em>RB_BLACK ;<br/>
                    parent-&gt;color = </em>RB_RED ;<br/>
                    <em>rotate_right(parent) ;<br/>
                    sibling = parent-&gt;left ;<br/>
               }<br/>
               if ( sibling-&gt;left-&gt;color == </em>RB_BLACK <br/>
                    &amp;&amp; sibling-&gt;right-&gt;color == <em>RB_RED ){<br/>
                    sibling-&gt;color = </em>RB_RED ;<br/>
                    child = parent ;<br/>
                    parent = parent-&gt;parent ;<br/>
               }else{<br/>
                    if ( sibling-&gt;left-&gt;color == <em>RB_BLACK ){<br/>
                         sibling-&gt;color = </em>RB_RED ;<br/>
                         sibling-&gt;right-&gt;color = <em>RB_BLACK ;<br/>
                         sibling = </em>rotate_left(sibling) ;<br/>
                    }<br/>
                    sibling-&gt;left-&gt;color = <em>RB_BLACK ;<br/>
                    sibling-&gt;color = parent-&gt;color ;<br/>
                    parent-&gt;color = </em>RB_BLACK ;<br/>
                    <em>rotate_right(parent) ;<br/>
                    parent = nil ;<br/>
               }<br/>
          }<br/>
     }<br/>
     child-&gt;color = </em>RB_BLACK ;<br/>
}<br/><br/>
void RBTree::Erase(PRBNode pos){<br/>
     //获得替换节点<br/>
     PRBNode subs = pos ;<br/>
     if ( pos-&gt;left != nil &amp;&amp; pos-&gt;right != nil ){<br/>
          //即右二子的最左枝<br/>
          subs = <em>next_node(pos) ;<br/>
          pos-&gt;data = subs-&gt;data ;<br/>
     }<br/><br/>
     PRBNode child ;<br/>
     if ( subs-&gt;left != nil ) child = subs-&gt;left ;<br/>
     else child = subs-&gt;right ;<br/><br/>
     PRBNode parent = subs-&gt;parent ;<br/>
     //把child挂到parent上去<br/>
     if ( parent == nil ) {<br/>
          root = child ;     <br/>
          child-&gt;parent = nil ;<br/>
     }else{<br/>
          if ( subs == parent-&gt;left ) parent-&gt;left = child ;<br/>
          else parent-&gt;right = child ;<br/>
     }<br/>
     if ( child != nil ) child-&gt;parent = parent ;<br/><br/>
     //若删除的是黑色，会导致路径上的黑色变少，要调整<br/>
     if ( subs-&gt;color == </em>RB_BLACK ) {<br/>
          <em>erase_fix(child , parent) ;<br/>
     }<br/><br/>
     </em>RB_deallocate(subs) ;<br/>
}<br/><br/>
void RBTree::Delete(ElemType d){<br/>
     PRBNode p = Find(d) ;<br/>
     if ( p != nil ) {<br/>
          Erase(p) ;<br/>
     }<br/>
}<br/><br/>
void RBTree::<em>delete_node(PRBNode p){<br/>
     if ( p != nil ){<br/>
          </em>delete_node(p-&gt;left) ;<br/>
          <em>delete_node(p-&gt;right) ;<br/>
          </em>RB_deallocate(p) ;<br/>
     }<br/>
}<br/><br/>
void RBTree::Clear(){<br/>
     _delete_node(root) ;<br/>
     root = nil ;<br/>
}<br/><br/><br/>
//测试代码<br/>
using namespace std;<br/></p>

<h1>include &lt;algorithm&gt;<br/></h1>

<h1>include &lt;time.h&gt;<br/><br/></h1>

<p>const TOTAL = 200000 ;<br/>
int c[TOTAL] ;<br/><br/>
int main(){<br/><br/>
     int a[] = {3,2,9,7,5,8,6} ;<br/>
//     int a[] = {5 , 2 , 3} ;<br/>
     int b[10] ;<br/>
     int sz = sizeof(a) / sizeof(int)  ;<br/>
     int i;<br/><br/>
     //初始化空间<br/>
      <em>RB_initspace ;<br/><br/>
     for ( i = 0 ; i &lt; sz ; i ++ ) b[i] = a[i] ;<br/><br/>
     //排序测试<br/>
//     RBTree::Sort(a , sz , 1) ;<br/>
     for ( i = 0 ; i &lt; sz ; i ++ )cout&lt;&lt;a[i]&lt;&lt;&#8217; &#8216;;<br/>
     cout&lt;&lt;endl;<br/>
     <br/>
     RBTree tree ;<br/><br/>
     //插入，删除，中序遍历，空树测试<br/>
     tree.Insert(1) ;<br/>
     tree.InOrder() ;<br/>
     tree.Insert(1) ;<br/>
     tree.InOrder() ;<br/>
     tree.Delete(1) ;<br/>
     tree.InOrder() ;<br/><br/>
     //插入测试，根据中序和前序，可以构造出整树，来检验插入是否正确<br/>
     for ( i = 0 ; i &lt; sz ; i ++ ){<br/>
          tree.Insert(a[i]) ;<br/>
          tree.InOrder() ;<br/>
          tree.PreOrder() ;<br/>
     }<br/>
     cout&lt;&lt;endl;<br/><br/>
//     return 0 ;<br/><br/>
     //查找测试<br/>
     //不存在元素<br/>
     cout&lt;&lt;tree.Find(4)&lt;&lt;endl;<br/>
     cout&lt;&lt;endl;<br/>
     //存在的元素<br/>
     cout&lt;&lt;tree.Find(9)&lt;&lt;endl;<br/>
     cout&lt;&lt;tree.Find(9)-&gt;data&lt;&lt;endl;<br/>
     //删除元素<br/>
     tree.Delete(9) ;<br/>
     cout&lt;&lt;tree.Find(9)&lt;&lt;endl;<br/><br/>
     tree.InOrder() ;<br/>
     tree.PreOrder() ;<br/><br/>
     //清除测试<br/>
     cout&lt;&lt;endl;<br/>
     cout&lt;&lt;tree.Find(3)&lt;&lt;endl;<br/>
     cout&lt;&lt;tree.Retrieve(tree.Find(3))&lt;&lt;endl;<br/>
     tree.Clear() ;<br/>
     cout&lt;&lt;tree.Find(3)&lt;&lt;endl;     <br/>
     tree.PreOrder() ;<br/><br/>
//大数据测试<br/>
     for ( i = 0 ; i &lt; TOTAL ; i ++ ) c[i] = i ; <br/>
     random_shuffle(c , c + TOTAL) ;<br/>
//     可选择输出数据检验     <br/>
//     for ( i = 0 ; i &lt; TOTAL ; i ++ ) cout&lt;&lt;c[i]&lt;&lt;&#8217; &#8217; ;<br/>
//     cout&lt;&lt;endl;<br/>
//     return 0 ;<br/>
     clock_t tt = clock() ;<br/>
//     </em>RB_initspace ;<br/>
     RBTree::Sort(c , TOTAL , 1) ;<br/>
     printf(&#8220;time: %d\n&#8221; , clock() - tt) ;<br/>
     for ( i = 0 ; i &lt; TOTAL ; i ++ ) if ( c[i] != i ) break; <br/>
     if ( i == TOTAL ) cout&lt;&lt;&#8221;ok&#8221;&lt;&lt;endl;<br/>
     else cout&lt;&lt;&#8221;bad alg!&#8221;&lt;&lt;endl;<br/><br/>
     return 0 ;<br/>
}<br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/05/23/%E4%B8%89%E7%A7%8D%E5%BC%82%E5%89%8D%E7%BD%AE%E7%BC%96%E7%A0%81%EF%BC%88%E9%A6%99%E5%86%9C%E7%BC%96%E7%A0%81%EF%BC%8C%E8%B4%B9%E8%AF%BA%E7%BC%96%E7%A0%81%EF%BC%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%EF%BC%89%EF%BC%88%2BMATLAB%E7%A8%8B%E5%BA%8F%29/">三种异前置编码（香农编码，费诺编码，哈夫曼编码）（+MATLAB程序)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-05-23T15:10:00+08:00" pubdate data-updated="true">May 23<span>rd</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.5.23<br/><br/>
异前置码属于唯一可译的码字。<br/><br/>
比如，对A,B,C三个符号编码。<br/><br/><font color="#0000ff">方案一：</font><br/>
A:0,B:01,C:00<br/><br/>
这就是个典型的不唯一可译。<br/>
比如我们收到序列：<br/>
00001<br/>
可以当成是ACB，也可以当成是AAAB，当然还有其他的。<br/><br/><font color="#0000ff">方案二：</font><br/>
A:1,B:01,C:00<br/><br/>
如果收到：<br/>
0110001<br/><br/>
那么唯一可译出来是BACB。<br/><br/>
观察方案二和一，有个特点，就是方案二的码字都不为其他码字的前缀。<br/>
这个就是异前置码的意思。<br/><br/>
在变长编码中，只要保证这点，就是唯一可译的。<br/><br/><font color="#0000ff">以下共用的符号：</font><br/>
p(i)：概率序列<br/>
c(i)：对应的码字序列<br/>
下标都是从1开始<br/><br/><font color="#0000ff">平均码长：</font><br/><br/><font color="#ff0000">即码字长度的期望。</font><br/><br/>
function f = acl(p , c)<br/>
%f = acl(p,c)<br/>
%p:probability , c:code<br/>
%return : average code length <br/>
f = 0 ;<br/>
for i = 1:length(p)<br/>
          f = f + p(i) * length(c{i}) ;          <br/>
end<br/><br/><font color="#0000ff">熵：</font><br/><br/><font color="#ff0000">熵被证明是acl的下界。</font><br/><br/>
function r = h(x)<br/>
%r = h(x)<br/>
%x为向量<br/>
%返回该向量的熵<br/>
EPS = 0.000001;<br/>
y = x ;<br/>
x(x == 0) = EPS ;<br/>
r = -sum(y .* log2(x)) ;<br/><br/>
为避免x为0导致log2(x)无穷的情况，先做EPS的调整。<br/><br/><font color="#0000ff">香农编码：</font><br/><font color="#ff6600"><br/>
1。将概率序列排序，为方便，还是记作p，在编程时调整一下就行。<br/>
2。算累加概率pa(i) = sum(p(j)) , j = 0..i-1，视p(0) = 0<br/>
3。算码长k(i) = ceil(log2(p(i)))<br/>
4。将pa(i)换成二进制表示，取小数前k(i)位为c(i)</font><br/><br/>
我一直觉得很诡异，不知道香农是怎么想到的。<br/>
去问老师，老师说不用证明。。。。<br/>
所以我还是不知道该怎么说明，这样出来的码就一定是异前置的。<br/><br/>
演示：<br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/fa2ebd4506dc2a02cefca3e0.jpg" small="0" class="blogimg"/></div></p>

<br/><br/>


<p>function c = shannon(p)<br/>
% p = [0.25 0.25 0.20 0.15 0.10 0.05]<br/>
% shannon(p)<br/>
[p , index] = sort(p) ;<br/>
p = fliplr(p) ;%从大到小<br/>
n = length(p) ;<br/>
pa = 0 ;%累加概率<br/>
for i = 2:n<br/>
          pa(i) = pa(i - 1) + p(i - 1) ;         <br/>
end<br/>
k = ceil(-log2(p)) ;%码长计算<br/>
c = cell(1,n) ;%生成元胞数组，存码字，是cell，跟上一行不一样<br/>
for i = 1:n<br/>
          c{i} = &#8221; ;<br/>
          tmp = pa(i) ;<br/>
          for j = 1:k(i)<br/>
              tmp = tmp * 2 ;<br/>
              if tmp &gt;= 1 <br/>
                  tmp = tmp - 1 ;<br/>
                  c{i}(j) = &#8216;1&#8217; ;<br/>
              else<br/>
                  c{i}(j) = &#8216;0&#8217; ;<br/>
              end<br/>
          end<br/>
end<br/>
%p<br/>
%pa<br/>
%交换回原来的顺序<br/>
c = fliplr(c) ;<br/>
c(index) = c ;<br/><br/><font color="#0000ff">费诺编码：</font><br/><br/><font color="#ff6600">1。将概率序列排序，为方便，还是记作p，在编程时调整一下就行。<br/>
2。按编码进制数将概率分组，尽量使每组的概率和接近。<br/>
3。给每组分配一位码元（0，1，。。。）<br/>
4。对每一组按同样地方法划分，直到每个符号有唯一码字。<br/></font><br/>
看下下面的表格演示，就发现这个东西完全不用证了。<br/>
编出来的码显然是异前置的。<br/><br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/c5d58d94bc9ad53ad31b7002.jpg" small="0" class="blogimg"/></div></p>

<br/><br/>


<p>function c = fano(p)<br/>
% p = [0.25 0.25 0.20 0.15 0.10 0.05]<br/>
% c = fano(p)<br/>
n = size(p , 2) ;<br/>
%已经编码完成<br/>
if n == 1 <br/>
          c = cell(1,1);<br/>
          c{1} = &#8221; ;<br/>
          return <br/>
end<br/>
[p , index] = sort(p);%按概率排序<br/>
p = fliplr(p) ;<br/>
total = sum(p) ;%总概率<br/>
acc = 0 ;%累积概率<br/>
flag = 0 ;%是否到达尾部的标志<br/>
for i = 1:n-1<br/>
          newacc = acc + p(i) ;<br/>
          if abs(total - 2 * newacc) &gt;= abs(total - 2 * acc)<br/>
              flag = 1 ;<br/>
              break;          <br/>
          end<br/>
          acc = newacc ;<br/>
end<br/>
if ~flag<br/>
          i = n ;<br/>
end<br/>
split = i ;<br/>
%从分界点对两边的码递归做fano<br/>
c1 = fano(p(1:split-1)) ;<br/>
c2 = fano(p(split:n)) ;<br/>
c = cell(1,n) ;<br/>
%添加前缀0，1<br/>
for i = 1:split-1<br/>
          c{i} = strcat(&#8216;0&#8217; , c1{i}) ;<br/>
end<br/>
for i = split:n<br/>
          c{i} = strcat(&#8216;1&#8217; , c2{i - split + 1} ) ; <br/>
end<br/>
%将顺序调整回去<br/>
c = fliplr(c) ;<br/>
c(index) = c ;<br/><br/><font color="#0000ff">哈夫曼编码：</font><br/><br/>
可以用哈夫曼树的观点来看。<br/><br/><font color="#ff6600">1。选取概率最小的两个节点a，b<br/>
2。将他们合并为c加入原概率序列<br/>
3。从c指向a的边标为0，向b的边标为1<br/>
4。重复到仅有一棵树为止。<br/>
5。每个符号的码字就是从根走到该符号的所有边上的码元连接起来。</font><br/><br/>
function c = huffman(p)<br/>
n = size(p , 2) ;<br/>
if n == 1 %此时已合并到一棵树上了，直接返回<br/>
          c = cell(1,1) ;<br/>
          c{1} = &#8221; ;<br/>
          return           <br/>
end<br/>
%找最小的<br/>
[p1 , i1] = min(p) ;<br/>
index = [(1:i1-1) , (i1+1:n)] ;<br/>
%这里的index是一个trick<br/>
%他跟踪了现在的p的每个分量，在原来的p里面的下标<br/>
%在最后，将依据这个下标来成码<br/>
p = p(index) ;<br/>
n = n - 1 ;<br/>
%找第二小的。<br/>
[p2 , i2] = min(p) ;<br/>
index2 = [(1:i2-1) , (i2+1:n)] ;<br/>
%index2是在上一个p中的下标<br/>
p = p(index2);<br/>
i2 = index(i2) ;%i2变为在原p中次小值的下标<br/>
index = index(index2) ;%继续跟踪现在的p在原p中的下标<br/><br/>
p(n) = p1 + p2 ;%生成一个新节点，即合并的两个最小节点的和<br/>
c = huffman(p) ;%对新的p的序列做huffman编码<br/>
c{n+1} = strcat(c{n} , &#8216;1&#8217;) ;%p(n)是开始合并的节点<br/>
c{n} = strcat(c{n} , &#8216;0&#8217;) ;%这里从c(n)分出两枝，对开始合并的两节点成码<br/><br/>
%恢复原顺序<br/>
index = [index , i1 , i2] ;<br/>
c(index) = c ;<br/><font color="#0000ff"><br/>
调用演示：</font><br/><br/>
clear ;<br/>
p1 =[ 0.2500          0.1500          0.2500          0.2000          0.1000          0.0500 ]<br/>
p2 =[ 0.2500          0.2500          0.2000          0.1500          0.1000          0.0500 ]<br/>
h1 = h(p1) <br/>
h2 = h(p2)<br/>
c1 = shannon(p1)<br/>
c2 = shannon(p2)<br/>
l1 = acl(p1 , c1)<br/>
l2 = acl(p2 , c2)<br/>
c3 = fano(p1)<br/>
l3 = acl(p1 , c3)<br/>
c4 = huffman(p2)<br/>
l4 = acl(p2 , c4)<br/><br/><font color="#0000ff">总结：</font><br/><br/>
1.香农编码的想法真的很诡异。。<br/>
2.在信道被无穷扩展后，这三种码的acl都是趋于下界的<br/>
3.在无扩展或较少扩展的时候，费诺和哈夫曼表现更优<br/>
（从测试程序算的几个l可以看出）<br/>
4.费诺和哈夫曼感觉就是同一个东西，只不过看问题的观点不一样而已。<br/>
（费诺从整个序列开始划分，分配码元；<br/>
哈夫曼从单个符号开始合并，分配码元。）<br/>
5.以上实现都是概念型实现，并没有在效率上考虑</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/05/22/win32%E7%A8%8B%E5%BA%8F%E5%90%AF%E7%94%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%EF%BC%88%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%96%87%E4%BB%B6%E5%90%8D%EF%BC%9Aconout%24%2Cconin%24%2Cconerr%24%29/">Win32程序启用控制台（控制台文件名：conout$,conin$,conerr$)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-05-22T19:07:00+08:00" pubdate data-updated="true">May 22<span>nd</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.5.22<br/><br/>
一个寻找很久，却得来全不费功夫的事情。<br/><br/>
做win32窗口程序的时候，有时还是希望在控制台下输入输出一些信息。<br/>
特别是VC的TRACE()宏虽然不错，但是输出在VC的debug窗口下。<br/>
里面有些杂乱的信息，看起来还是很不爽。<br/><br/><font color="#0000ff">1。最原始的分配控制台，获得句柄，再输出</font><br/><br/>
      AllocConsole() ;<br/>
      HANDLE hd = GetStdHandle(STD_OUTPUT_HANDLE) ;<br/>
      WriteConsole(hd , &#8220;hello hplonline&#8221; , sizeof(&#8220;hello hplonline&#8221;) , NULL , NULL );<br/>
      CloseHandle(hd) ;<br/><br/>
这个方法是我最早知道的，但毕竟不直观。<br/>
每次都要调用一个WriteConsole才搞定。<br/>
自己写个函数来包装他的话，虽然做新的项目可以。<br/>
但是想要利用一些以前已经做好的控制台下的东西就囧了。<br/>
如果有个方法能够让我们还是方便地使用printf这样的函数就完美了。<br/><br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/f114932552aec74435a80fca.jpg" small="0" class="blogimg"/></div></p>

<br/><br/><font color="#0000ff">2。对stdin,stdout,stderr重新打开</font><br/><br/>


<p>      AllocConsole();<br/>
      freopen(&#8220;conout$&#8221;,&#8221;w&#8221;,stdout) ;<br/>
      printf(&#8220;hello hplonline!-_-\n&#8221;) ;<br/>
      std::cout&lt;&lt;&#8221;i&#8217;m cout&#8221;&lt;&lt;std::endl;<br/>
      freopen(&#8220;conout$&#8221;,&#8221;w&#8221;,stderr) ;<br/>
      std::cerr&lt;&lt;&#8221;i&#8217;m cerr&#8221;&lt;&lt;std::endl;<br/><br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/ccbe5c4e6ac74a2db2de05ca.jpg" small="0" class="blogimg"/></div></p>

<br/><br/>


<p>这个用起来就很方便了，昨天在论坛上看到的。<br/>
另外就是三个特殊的文件名：<br/><font color="#ff0000">conout$,conin$,conerr$</font><br/>
我想他们的意思已经在他们的名字里的。结合上面的例子就很显然的。<br/><br/><font color="#0000ff">3。修改subsystem</font><br/><br/>
这个方法我就没试过了。<br/>
上学期做AISnake的时候就在想，选手调试起来很不方便。<br/>
但是不知道怎么把控制台搞出来，只有建议大家用文件输出。<br/><br/>
后来看到xsjs的改造版，问之，说直接改subsystem。<br/>
不过他改的那个版本在我这里也是没法输出东西，不知道怎么回事。<br/>
谁去试一下，记得来说说这方法哈，</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/05/20/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3%EF%BC%88AVLTree%EF%BC%89%EF%BC%88%E4%BA%8C%EF%BC%89%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4/">平衡二叉树实现详解（AVLTree）（二）插入和删除</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-05-20T13:11:00+08:00" pubdate data-updated="true">May 20<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.5.20<br/><br/>
完整的实现，可以<a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/4a5fc3ea9cb588dbd439c90a.html">参考</a>前面，旋转和平衡在上一篇。<br/><br/>
由于AVL首先也就是一个BST，所以：<br/>
查找，找最大，找最小，找前驱，找后继，遍历，清空<br/>
这些算法都是和BST一样，故不用说了。<br/><br/><font color="#0000ff">插入：<br/></font><br/>
该函数接收插入的元素，并返回插入后的节点的地址。<br/><font color="#ff6600">PANode AVLTree::Insert(ElemType d){         </font><br/><br/>
首先要判断是否为空树：<br/><font color="#ff6600">         if ( !root ) {<br/>
                  root = <em>AVL_allocate() ; <br/>
                  root-&gt;init(d) ;<br/>
                  return root ;<br/>
         }</font><br/><br/>
其实写到这里的时候，对我最初的设计还是感觉有点囧。<br/>
如果一来就设一个<font color="#ff0000">根节点</font>的话，显然可以少写很多判根的地方。<br/>
但是这也有个问题，要选一个一定不会在应用中出现的值来作为根。<br/>
刷题的话到没问题，选一个题目外的就行了，在工程中，这个值就不好说了。。<br/><br/>
调用私有函数，获取d插入的位置。<br/><font color="#ff6600">         PANode parent = </em>find_parent(d) ;</font><br/>
<em>find_parent在存在d的时候，返回d的父亲，<br/>
不存在d的时候，返回如果有d，应该作为d父亲的节点。<br/><br/>
判断该节点d存在否。<br/><font color="#ff6600">         PANode child = </em>find_node(parent , d) ;<br/>
         if ( child ){//已经存在该节点<br/>
                  return child ;<br/>
         }<br/></font> <br/>
不存在的话，才进行真正的插入：<br/><font color="#ff6600">         PANode p = <em>AVL_allocate() ;<br/>
         p-&gt;init(d) ;<br/>
         p-&gt;parent = parent ;<br/>
         if ( d &lt; parent-&gt;data ) parent-&gt;left = p ;<br/>
         else parent-&gt;right = p ;</font><br/>
这里新建了节点，并把他挂在parent上。<br/><font color="#ff0000"></em>AVL_allocate()</font>是一个宏，为实现多种空间配置设置。<br/>
在这里即是直接malloc(sizeof(ANode))<br/><br/>
令：<br/><font color="#ff6600">child = p ;</font><br/><br/>
接着，由于parent的孩子child增高了（在插入过程中，等于说是从没有变到有）<br/>
于是我们要逐步向根调整平衡因子，遇到不平衡的时候，做平衡操作。<br/>
下面也是只拿左半截做分析。<br/><br/><font color="#ff6600">while ( parent != NULL ){&#8230;.</font><br/>
这个循环有不变式：<br/>
1.还没处理到根，因为根的parent为NULL<br/>
2.child是parent的子节点，且该子节点有所增高<br/>
（个人感觉用不变式的观点设计循环很方便，<br/>
考虑对应的操作的时候，建立在这些不变式上思考，<br/>
并且让这些操作也同时保证不变式的成立）<br/><br/>
如果child是在parent的左枝上。<br/><font color="#ff6600">if ( child == parent-&gt;left ){</font><br/><br/>
这时要对parent之前的平衡性做讨论：<br/><font color="#ff6600">switch( parent-&gt;balance )</font><br/><br/><font color="#0000ff">如果之前为0</font>，那么child增高了之后，将导致左树变高，b(parent) = 1。<br/>
这时，parent也同时增高，于是继续向根走。<br/><font color="#ff6600">                           case 0:<br/>
                                    parent-&gt;balance = 1 ;<br/>
                                    child = parent ;<br/>
                                    parent = parent-&gt;parent ;<br/>
                                    break;</font><br/><br/><font color="#0000ff">如果之前为1</font>，child增高了之后，将导致平衡因子变为2，要调整。<br/>
调整后的parent将和child增高前的parent一样高，于是这里可以返回了。<br/>
   <font color="#ff6600">                     case 1:<br/>
                                    parent-&gt;balance = 2 ;<br/>
                                    _balance_left(parent) ;<br/>
                                    return p ;<br/>
                                    break;</font><br/><br/>
为什么一样呢，看下面就知道了：<br/><div forimg="1"><img height="415" border="0" width="314" src="http://hiphotos.baidu.com/hplonline/pic/item/18c9d7544edce87cd00906c4.jpg" small="0" class="blogimg"/><br/>
ABCD都是空树，本来cur是空的。这个时候parent的高度为1</div></p>

<div forimg="1"><img height="266" border="0" width="362" src="http://hiphotos.baidu.com/hplonline/pic/item/7a8a063338d591dc1b4cffc4.jpg" small="0" class="blogimg"/><br/>
插入cur后，平衡破坏，但经过旋转，child（也就是现在的父节点）的高度也为1。<br/>
既然调整到这里已经平衡了，自然就不用再继续调整了。<br/><br/><font color="#0000ff">如果之前为-1.</font><br/>
由于现在左枝增高，正好parent的两端平衡了，且parent不增高，自然也就直接返回了。<br/><font color="#ff6600">                           case -1:<br/>
                                    parent-&gt;balance = 0 ;<br/>
                                    return p ;<br/>
                                    break;</font></div>


<br/><font color="#0000ff">删除：</font><br/><br/>


<p>给了两个版本，delete用于对元素的删除，erase用于对指向节点的删除。<br/>
所以delete只是一个简单封装：<br/><br/><font color="#ff6600">void AVLTree::Delete(ElemType d){<br/>
         PANode p = Find(d) ;<br/>
         if ( p ) {<br/>
                  Erase(p) ;<br/>
         }<br/>
}</font><br/><br/>
先找到对应元素的位置，再erase之。<br/><br/>
删除某个节点的过程大致是：<br/><font color="#ff0000">如果该节点不是叶子，那么就用他的前驱或后继替换他，去删除替换的节点。<br/>
（这里和BST也是一个道理的）<br/>
当然被删除的节点如果还不是叶子，那么继续重复。<br/>
删完这个替换节点后，从该节点开始，向根调整平衡因子。</font><br/><br/>
在寻找替换节点的时候，还有一点。<br/>
如果正在考察的节点左树高，那么自然我们去左树上寻找替换点。<br/>
也就是调用<em>prev_node。这样有个好处 ，<br/>
就是如果左树由于删除被降低了，那么要调整的地方可能要少些。<br/>
对右边同理：<br/><br/><font color="#ff6600">PANode AVLTree::</em>find_subs(PANode pos){<br/>
         PANode su = pos;<br/>
         while ( (su-&gt;left != NULL) || (su-&gt;right != NULL) ) {<br/>
                  if ( su-&gt;balance == 1 ) {<br/>
                           su = <em>prev_node(pos) ;<br/>
                  }else{<br/>
                           su = </em>next_node(pos) ;<br/>
                  }<br/>
                  pos-&gt;data = su-&gt;data ;<br/>
                  pos = su ;<br/>
         }<br/>
         return su ;<br/>
}</font><br/><br/>
有了这个过程后，就可以开始erase了。<br/><font color="#ff6600">         PANode su = <em>find_subs(pos) ;//替换节点<br/>
         PANode child = su ;<br/>
         PANode parent = child-&gt;parent ;<br/>
         bool over = false ;</font><br/>
找到替换节点，并做好准备去向根调整。<br/><br/>
over是用来判断是否调整完毕的。<br/>
前面的插入，调整完毕时，直接return出去了，<br/>
但这里是删除，完毕的时候还要把节点的空间收回。<br/><br/>
调整循环：<br/><font color="#ff6600">while ( parent &amp;&amp; !over ) {</font><br/>
不变式：<br/>
1.没有处理到根，还没有处理完<br/>
2.child是parent的一个子树，且该子树降低了。<br/><br/>
依然只看左边，对parent之前的平衡性做讨论：<br/><font color="#ff6600">                  if ( child == parent-&gt;left ){//左枝<br/>
                           switch (parent-&gt;balance){</font><br/><br/>
如果parent之前就是平衡的，那么child的降低，会使parent右边高。<br/>
但这不会导致parent的高度搞边，故可以结束调整过程<br/><font color="#ff6600">                           case 0:<br/>
                                    parent-&gt;balance = -1 ;<br/>
                                    over = true ;<br/>
                                    break;</font><br/><br/>
如果parent本来是左边高的，那么child的降低导致parent平衡了。<br/>
但这时，parent降低了，于是要继续往根部调整。<br/>
  <font color="#ff6600">                      case 1:<br/>
                                    parent-&gt;balance = 0 ;<br/>
                                    child = parent ;<br/>
                                    parent = parent-&gt;parent ;<br/>
                                    break;</font><br/><br/>
如果本来是右边高的。这个情况是最复杂的了。<br/>
首先，因为左边的降低，那么平衡被破坏，要调用 </em>balance_right，以达平衡。<br/><br/>
这个时候再判断，如果调整前，parent的右枝是平衡的，那么就可以结束这个过程了。<br/>
否则还要继续向根走。。<br/>
  <font color="#ff6600">                      case -1:<br/>
                                    parent-&gt;balance = -2 ;<br/>
                                    tmp = parent-&gt;right-&gt;balance ;<br/>
                                    child = _balance_right(parent) ;<br/>
                                    parent = child-&gt;parent ;<br/>
                                    if ( tmp == 0 ) over = true ;<br/>
                                    break;</font><br/>
至于为什么调整前parent的右枝是平衡的就可以停止了呢?<br/>
这个就只好拜托各位看前一篇里面的几幅图了，<br/>
虽然是画的左边，右边也一样。仅有在这个时候，parent的高度才不会降低。<br/>
（很麻烦的一个事情，自己把所有情况画出来就看到了）<br/><br/><font color="#0000ff">后记：</font><br/><br/>
仔细再看，发现代码里面有不少冗余。<br/>
不过这样一五一十地写出来比较把稳一点。<br/>
也更容易看懂一点。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/05/19/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3%EF%BC%88AVLTree%EF%BC%89%EF%BC%88%E4%B8%80%EF%BC%89%E6%97%8B%E8%BD%AC%E5%92%8C%E5%B9%B3%E8%A1%A1/">平衡二叉树实现详解（AVLTree）（一）旋转和平衡</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-05-19T20:56:00+08:00" pubdate data-updated="true">May 19<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.5.19<br/><br/>
完整的实现，可以<a href="http://hi.baidu.com/hplonline/blog/item/4a5fc3ea9cb588dbd439c90a.html" target="_blank">参考</a>前面，这篇将分解各个细节部分。<br/>
一来是最近发现一个画图很好用的软件visio，决定用一下，感觉良好。<br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/c0f979f0e693208ba50f52fb.jpg" small="0" class="blogimg"/></div></p>

<br/>


<p>二是这玩意写起来确实很费事，趁还记忆良好，记着，老了也好翻一翻。<br/><br/><font color="#ff0000">本文的读者应该是看过一定资料，<br/>
对AVL有基本了解，<br/>
但在实现时卡住的同学。<br/>
否则，这篇文章会把人弄昏掉。</font><br/><br/>
由于这个结构是很对称的，所以都只拿一半来讲。<br/><br/><font color="#0000ff">基本记号约定：</font><br/><br/>
方形：表示节点<br/>
三角形：表示树，可能为空树<br/>
h(x)：x节点的高度，即x到最远子孙的路径长度，叶节点为0，空树为-1<br/>
left,right,parent：左，右孩子，父亲，根节点父亲为NULL<br/>
b(x)：x节点的平衡因子，定义为h(x-&gt;left) - h(x-&gt;right)<br/><br/>
AVLTree类的成员函数中，<br/>
对外开放的接口习惯用每个单词大起命名。<br/>
私有函数用下划线起小写命名。<br/><br/><font color="#0000ff">AVL的目标：</font><br/><br/>
取最大，取最小，取前驱，取后继，插入，删除，查找，遍历<br/><br/><font color="#0000ff">总体实施方案：</font><br/><br/>
以上操作为一般搜索树都支持的，<br/>
实现的时候前半截和BST一样，<br/>
核心在于随时保持对每个节点x，b(x) = -1,0,1之一。<br/>
这样就能保证对数级的深度了。 <br/><br/><font color="#0000ff">旋转操作：</font><br/><br/>
向右旋转前：<br/><div forimg="1"><img height="269" border="0" width="285" src="http://hiphotos.baidu.com/hplonline/pic/item/93ccc5fc6886f0a6b801a0c4.jpg" small="0" class="blogimg"/><br/>
向右旋转后：</div></p>

<div forimg="1"><img height="296" border="0" width="281" src="http://hiphotos.baidu.com/hplonline/pic/item/e9f38c18b4eba0904bedbcc4.jpg" small="0" class="blogimg"/><br/>
实现上，主要注意的是父子的关系。<br/>
上图仅表达出了旋转的轴心parent，<br/>
而旋转后要注意维护parent的父节点ancestor和子树的关系。<br/>
同时判断parent为整棵树根的情况。<br/><br/><font color="#ff6600">PANode AVLTree::_rotate_right(PANode p ){<br/>
             PANode child = p-&gt;left ;<br/>
             p-&gt;left = child-&gt;right ;<br/>
             if ( child-&gt;right ) child-&gt;right-&gt;parent = p ;<br/>
             child-&gt;right = p ;<br/>
             PANode ancestor = p-&gt;parent ;<br/>
             if ( ancestor ) {<br/>
                          if ( ancestor-&gt;left == p ) ancestor-&gt;left = child ;<br/>
                          else ancestor-&gt;right = child ;<br/>
             }else{<br/>
                          root = child ;<br/>
             }<br/>
             child-&gt;parent = ancestor ;<br/>
             p-&gt;parent = child ;<br/>
             return child ;<br/>
}</font><br/><br/>
旋转操作是平衡操作的子步骤，<br/>
在该步骤中不用考虑平衡因子的调整。<br/>
把平衡因子的问题交给平衡操作和插入删除操作配合完成。<br/><br/><font color="#0000ff">左平衡操作一。左左型：</font><br/><br/>
parent是第一个失去平衡的节点。<br/>
cur是导致失去平衡的节点。<br/>
在插入操作中，可以理解为是<font color="#ff0000">cur的增高</font>。<br/><br/>
有点绕口。。<br/><br/>
如下：<br/><br/>
实际情况中，其实就是ABCD都为空，而cur是新插入到child的节点。<br/>
这将导致h(parent) = 2，失去平衡。</div>


<div forimg="1"><img height="411" border="0" width="310" src="http://hiphotos.baidu.com/hplonline/pic/item/18c9d7544edce87cd00906c4.jpg" small="0" class="blogimg"/><br/>
在cur改变之前，该树一定是平衡的，而cur的插入导致了该树不平衡。<br/>
此时的b(child) = 1<br/><br/>
旋转后如下，重点就是讨论旋转后的平衡因子的变化。</div>


<div forimg="1"><img height="271" border="0" width="369" src="http://hiphotos.baidu.com/hplonline/pic/item/7a8a063338d591dc1b4cffc4.jpg" small="0" class="blogimg"/><br/>
由于ABCD为空，这时，显然：<br/>
B(parent) = B(child) = B(cur) = 0<br/><br/>
对应的代码就是：<br/><font color="#ff6600">           case 1:<br/>
                      re = _rotate_right(p) ;<br/>
                      re-&gt;balance = 0 ;<br/>
                      re-&gt;right-&gt;balance = 0 ;<br/>
                      break;</font><br/><br/>
当然，左左出现，还有可能是在删除过程中，由于A树的降低导致的。<br/>
那么还是这幅图：<br/><br/><div forimg="1"><img height="437" border="0" width="331" src="http://hiphotos.baidu.com/hplonline/pic/item/18c9d7544edce87cd00906c4.jpg" small="0" class="blogimg"/><br/>
当h(cur) - h(B) = 1的时候，同上面的讨论。<br/>
而当h(cur) - h(B) = 0的时候，<br/>
由于：<br/>
h(child) - h(A) = 2 <br/>
h(cur) + 1 - h(A) = 2<br/>
h(cur) - h(A) = 1</div>
<div forimg="1"><img height="282" border="0" width="384" src="http://hiphotos.baidu.com/hplonline/pic/item/7a8a063338d591dc1b4cffc4.jpg" small="0" class="blogimg"/><br/>
b(child) = h(cur) - h(parent) = h(cur) - (h(B) + 1) = -1 <br/>
b(parent) = h(B) - h(A) = h(cur) - h(A) = 1<br/><br/>
对应的代码就是：<br/><font color="#ff6600">          case 0:<br/>
                    re = _rotate_right(p) ;<br/>
                    re-&gt;balance = -1 ;<br/>
                    re-&gt;right-&gt;balance = 1 ;<br/>
                    break;</font><br/><br/><font color="#0000ff">左平衡操作二。左右：<br/></font></div>
</div>


<div forimg="1"><img height="416" border="0" width="323" src="http://hiphotos.baidu.com/hplonline/pic/item/9a3eb91c0f90dbaf86d6b6c4.jpg" small="0" class="blogimg"/><br/>
既为左右，那么h(cur) - h(B) = 1<br/>
先左旋：</div>


<div forimg="1"><img height="417" border="0" width="338" src="http://hiphotos.baidu.com/hplonline/pic/item/8fc50d08a6a96514e82488c4.jpg" small="0" class="blogimg"/><br/>
再右旋：</div>


<div forimg="1"><img height="277" border="0" width="400" src="http://hiphotos.baidu.com/hplonline/pic/item/46c61bdf377df037622798c4.jpg" small="0" class="blogimg"/><br/>
此时的情况是：<br/>
h(cur) = h(B) + 1;因为是“左右”情况，b(child) = -1<br/>
h(A) = h(child) - 2 = h(cur) - 1 = h(B)<br/>
h(C)&lt;=h(B),h(D)&lt;=h(B);否则child就已经不平衡了<br/>
所以b(parent) = h(child) - h(parent) = max{h(B),h(C)} - max{h(D),h(A)} = 0<br/><br/>
而child和parent的平衡因子将根据C,D的关系调整。<br/><br/>
比如h(C) = h(D)的时候，必有h(C) = h(B)，否则A的降低不足以使parent失衡。<br/>
于是b(child) = b(parent) = 0 ;<br/><br/>
若由于插入失衡，那么设C增高。于是有：<br/>
h(C) = h(B) = h(D) + 1<br/><br/>
对应代码：<br/><font color="#ff6600">         case -1:<br/>
                  _rotate_left(child) ;<br/>
                  re = _rotate_right(p) ;<br/>
                  tmp = re-&gt;balance ;<br/>
                  re-&gt;balance = 0 ;<br/>
                  switch(tmp){<br/>
                  case 0:<br/>
                           re-&gt;left-&gt;balance = 0 ;<br/>
                           re-&gt;right-&gt;balance = 0 ;<br/>
                           break;<br/>
                  case 1:<br/>
                           re-&gt;left-&gt;balance = 0 ;<br/>
                           re-&gt;right-&gt;balance = -1 ;<br/>
                           break;<br/>
                  case -1:<br/>
                           re-&gt;left-&gt;balance = 1 ;<br/>
                           re-&gt;right-&gt;balance = 0 ;<br/>
                           break;<br/>
                  }<br/>
                  break;</font><br/><br/><font color="#0000ff">完整的左平衡代码如下：</font><br/><br/><font color="#ff6600">PANode AVLTree::_balance_left(PANode p ){<br/>
         PANode child = p-&gt;left ;<br/>
         PANode re ;<br/>
         int tmp ;<br/>
         switch ( child-&gt;balance ) {<br/>
         case 1:<br/>
                  re = _rotate_right(p) ;<br/>
                  re-&gt;balance = 0 ;<br/>
                  re-&gt;right-&gt;balance = 0 ;<br/>
                  break;<br/>
         case -1:<br/>
                  _rotate_left(child) ;<br/>
                  re = _rotate_right(p) ;<br/>
                  tmp = re-&gt;balance ;<br/>
                  re-&gt;balance = 0 ;<br/>
                  switch(tmp){<br/>
                  case 0:<br/>
                           re-&gt;left-&gt;balance = 0 ;<br/>
                           re-&gt;right-&gt;balance = 0 ;<br/>
                           break;<br/>
                  case 1:<br/>
                           re-&gt;left-&gt;balance = 0 ;<br/>
                           re-&gt;right-&gt;balance = -1 ;<br/>
                           break;<br/>
                  case -1:<br/>
                           re-&gt;left-&gt;balance = 1 ;<br/>
                           re-&gt;right-&gt;balance = 0 ;<br/>
                           break;<br/>
                  }<br/>
                  break;<br/>
         case 0:<br/>
                  re = _rotate_right(p) ;<br/>
                  re-&gt;balance = -1 ;<br/>
                  re-&gt;right-&gt;balance = 1 ;<br/>
                  break;<br/>
         default:;<br/>
                  //assert(&#8220;false&#8221;) ;<br/>
         }<br/>
         return re ;<br/>
}</font></div>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/05/19/POJ2524%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89/">POJ2524（并查集）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-05-19T12:45:00+08:00" pubdate data-updated="true">May 19<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.5.19<br/><br/>
没事水点题玩玩，题目描述很露骨，直接就看出来是什么东西了。<br/>
不过，为刷这题，有更多的东西值得说说。<br/><br/><font color="#0000ff">先是一组数据</font><br/><table cellspacing="0" cellpadding="0" border="0" width="527" style="border-collapse: collapse; width: 395pt;"><col width="72" span="5" style="width: 54pt;"/><col width="95" style="width: 71pt;"/><col width="72" style="width: 54pt;"/><tbody><tr height="19" style="height: 14.25pt;"><td height="19" width="72" style="height: 14.25pt; width: 54pt;">Accepted</td></p>

<pre><code>        &lt;td width="72" style="width: 54pt;"&gt;620K&lt;/td&gt;
        &lt;td width="72" style="width: 54pt;"&gt;32MS&lt;/td&gt;
        &lt;td width="72" style="width: 54pt;"&gt;G++&lt;/td&gt;
        &lt;td width="72" style="width: 54pt;"&gt;1212B&lt;/td&gt;
        &lt;td align="right" width="95" style="width: 71pt;" class="xl24"&gt;2009/5/19&lt;/td&gt;
        &lt;td align="right" width="72" style="width: 54pt;" class="xl25"&gt;9:55:27&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" style="height: 14.25pt;"&gt;Accepted&lt;/td&gt;
        &lt;td&gt;816K&lt;/td&gt;
        &lt;td&gt;47MS&lt;/td&gt;
        &lt;td&gt;G++&lt;/td&gt;
        &lt;td&gt;1194B&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;2009/5/19&lt;/td&gt;
        &lt;td align="right" class="xl25"&gt;9:54:11&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" style="height: 14.25pt;"&gt;Accepted&lt;/td&gt;
        &lt;td&gt;816K&lt;/td&gt;
        &lt;td&gt;297MS&lt;/td&gt;
        &lt;td&gt;G++&lt;/td&gt;
        &lt;td&gt;994B&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;2009/5/19&lt;/td&gt;
        &lt;td align="right" class="xl25"&gt;9:51:30&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" style="height: 14.25pt;"&gt;Accepted&lt;/td&gt;
        &lt;td&gt;816K&lt;/td&gt;
        &lt;td&gt;297MS&lt;/td&gt;
        &lt;td&gt;G++&lt;/td&gt;
        &lt;td&gt;876B&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;2009/5/19&lt;/td&gt;
        &lt;td align="right" class="xl25"&gt;9:48:48&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" style="height: 14.25pt;"&gt;Accepted&lt;/td&gt;
        &lt;td&gt;816K&lt;/td&gt;
        &lt;td&gt;313MS&lt;/td&gt;
        &lt;td&gt;G++&lt;/td&gt;
        &lt;td&gt;848B&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;2009/5/19&lt;/td&gt;
        &lt;td align="right" class="xl25"&gt;9:46:26&lt;/td&gt;
    &lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;br/&gt;&lt;font color="#0000ff"&gt;看时间吧，从下到上依次是：&lt;/font&gt;&lt;br/&gt;&lt;br/&gt;
</code></pre>

<p>AC1，普通<br/>
AC2，对初始化进行优化，少memset了一些地方，快了10多ms<br/>
AC3，加入启发式合并，没发现变快<br/>
AC4，加入外挂，刷到47ms，已经很快了<br/>
AC5，又去掉启发式合并，32ms，成功刷版<br/><br/><font color="#0000ff">于是得出以下结论：</font><br/><br/>
1.<br/>
memset少一点可以提高效率，<br/>
（估计32ms和后面47ms的就是这里有点差异）<br/>
但要小心，是以可能出错为代价的。。不要写囧。（我曾经在这个问题上<a href="http://hi.baidu.com/hplonline/blog/item/8fbb05b34d84d6afd8335af6.html" target="_blank">囧过多次</a>了）<br/><br/>
2.<br/>
启发式合并是一个<font color="#ff0000">理论上</font>很好的东西，但是可能由于加入过多的<font color="#ff0000">if</font>，<br/>
以及<font color="#ff0000">路径压缩本身就很快</font>的原因，导致没有啥优势。<br/><br/>
3.<br/><a href="http://hi.baidu.com/hplonline/blog/item/68db005503fdd1ccb645aeb3.html" target="_blank">外挂</a>是个很强的东西。<br/><br/><font color="#0000ff">并查集的代码：</font><br/><br/>
以后有的哥们是搜并查集进来的。。<br/>
要是看到我一堆废话肯定会起火的。。<br/>
于是给出一套，写得不好看也不丑，用起来手感很好。<br/><br/>
        const int MAXN = 50010 ;<br/><br/>
        int f[MAXN] ;<br/>
        //int r[MAXN] ;<br/><br/>
        void init_set(int n){<br/>
              memset(f + 1 , 0 , sizeof(f[0]) * n) ;<br/>
        //      memset(r + 1 , 0 , sizeof(f[0]) * n) ;<br/>
        }<br/><br/>
        int find_set(int x){<br/>
              int fa = x , t ;<br/>
              while ( f[fa] ) fa = f[fa] ;<br/>
              while ( f[x] ){<br/>
                    t = x ;<br/>
                    x = f[x] ;<br/>
                    f[t] = fa ;<br/>
              }<br/>
              return fa ;<br/>
        }<br/><br/>
        int union_set(int a , int b){<br/>
              a = find_set(a) ;<br/>
              b = find_set(b) ;<br/>
              if ( a == b ){<br/>
                    return 0 ;<br/>
              }else{<br/>
                 <font color="#ff0000"> f[a] = b ;</font><br/>
        //            if ( r[a] &gt; r[b] ) {<br/>
        //                  f[b] = a ;      <br/>
        //            }else{<br/>
        //                  f[a] = b ;<br/>
        //                  if ( r[a] == r[b] ){<br/>
        //                        r[b] ++ ;<br/>
        //                  }<br/>
        //            }<br/>
                    return 1 ;<br/>
              }<br/>
        }<br/><br/>
其中注释掉的就是启发式合并的地方，<br/>
非要用启发式合并的话，就把红色的注释掉，把注释掉的变有效<br/><font color="#ff0000">点的下标是从1</font>开始的<br/><br/><font color="#0000ff">一个火星发现：</font><br/><br/>
  <font color="#ff0000">      #ifndef ONLINE_JUDGE<br/>
              freopen(&#8220;in.txt&#8221;,&#8221;r&#8221;,stdin) ;<br/>
        #endif</font><br/><br/>
ONLINE_JUDGE是个很好用的宏。。<br/>
这样就不用担心有的时候搞忘把freopen注释掉了。。。。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/05/18/AVLTree%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%B8%A6%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%EF%BC%89/">AVLTree的一个实现（带删除操作）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-05-18T14:14:00+08:00" pubdate data-updated="true">May 18<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.5.18<br/><br/><font color="#0000ff">一。前面的废话<br/></font><br/>
为什么非要在括号里面加个<font color="#ff0000">带删除</font>呢？？<br/>
因为我在网上看到好多放出来的AVL没有删除操作。<br/>
这倒没啥，还有些没有删除操作却在标题里面表明有删除。。<br/>
或者在函数的定义处定义个删除函数却不实现。。囧<br/>
正好也看到网上不少人在寻找这个东西。<br/>
于是憋了一个出来。<br/><br/>
从昨天中午憋到今天中午，终于调好了！<img src="http://img.baidu.com/hi/jx/j_0003.gif"/>。<font color="#ff0000">约500行吧。</font>。。<br/>
基本的情况均有覆盖，最后也有大数据检验。详情见后面的测试代码吧。<br/><font color="#ff0000">(万一谁用的时候发现错误，一定要记载清楚跟我讲啊。。）</font><br/><br/>
听说这个生猛的结构也是有好多年的，一直似是而非地以为自己知道，<br/>
从来没动过手。。两个月前，一个同学问我个问题。。<br/>
我说bfs+hash，他一直说他们老师说的AVLTree。。<br/>
把我吓惨了，大一下，仅有半年C的基础，外加半学期的数据结构基础。。<br/>
能搞出来吗。。？<br/><br/>
于是要是搞不出一个来，我这脸就丢大了啊。。<br/>
真的一搞，发现有些东西还不像以为的那么简单，很多细节容易出错。<br/>
这两天耗费了若干草稿纸：<br/><div forimg="1"><a href="http://hiphotos.baidu.com/hplonline/pic/item/24c0cc5cf6dd3967faf2c090.jpg" target="_blank"><img height="138" border="0" width="200" src="http://hiphotos.baidu.com/hplonline/abpic/item/24c0cc5cf6dd3967faf2c090.jpg" small="1" class="blogimg"/></a></div>
憋出来后觉得神清气爽，发现写AVL的难点其实就在平衡因子的操作上。<br/><font color="#ff0000">要列清楚各种情况，发现其中平衡因子是怎么改变的，就可以搞定了。</font><br/>
这个过程显然是要消耗大量草稿纸的，<br/>
当然，鉴于各位拥有容量更大，运算速度更快的大脑，可以少用一点。<br/><br/>
有一些前导的知识点：<br/><a href="http://hi.baidu.com/hplonline/blog/item/6267a37773b21e13b151b9f7.html" target="_blank">BinarySearchTree</a><br/><br/>
AVL就是在BST的思想上做了一些改进。<br/><br/>
该结构的介绍乃是到处都有，而且往往地球人看了都觉得可以很快写出来。<br/>
所以各位就baidu一下就有了。<br/><br/><font color="#0000ff">二。含一定注释的代码</font><br/><br/></p>

<h1>include &lt;iostream&gt;<br/></h1>

<h1>include &lt;stdlib.h&gt;<br/><br/></h1>

<p>//元素类型<br/>
typedef int ElemType ;<br/><br/>
//树的节点<br/>
struct ANode{<br/>
       ElemType data ;<br/>
       ANode <em>left , </em>right , <em>parent ;<br/>
       int balance ;//height(left) - height(right) <br/>
       ANode(){} ;<br/>
       ANode(ElemType d){<br/>
              data = d ;<br/>
              left = NULL ;<br/>
              right = NULL ; <br/>
              parent = NULL ;<br/>
              balance = 0 ;<br/>
       }<br/>
       void init(ElemType d){<br/>
              data = d ;<br/>
              left = NULL ;<br/>
              right = NULL ; <br/>
              parent = NULL ;              <br/>
              balance = 0 ;<br/>
       }<br/>
};<br/>
typedef ANode </em>PANode ;<br/><br/>
//空间分配宏，便于实现其他配置方式<br/></p>

<h1>define _AVL_initspace <br/></h1>

<h1>define _AVL_allocate() (ANode *)malloc(sizeof(ANode))<br/></h1>

<h1>define _AVL_deallocate(p) free(p) <br/></h1>

<p>//ANode space[1000] , *spacehead ;<br/>
//#define <em>AVL_initspace spacehead = space <br/>
//#define </em>AVL_allocate() spacehead++ ;<br/>
//#define <em>AVL_deallocate(p) <br/><br/>
//AVL<br/>
class AVLTree{<br/>
private:<br/>
       PANode root ;<br/>
       void </em>delete_node(PANode p) ;<br/>
       PANode <em>find_subs(PANode pos) ;//寻找删除时用于替换的节点<br/>
       PANode </em>next_node(PANode p) ;//中继前驱<br/>
       PANode <em>prev_node(PANode p) ;//中继后继<br/>
       PANode </em>rotate_left(PANode p ) ;//以p为轴左旋<br/>
       PANode <em>rotate_right(PANode p ) ;//以p为轴右旋<br/>
       PANode </em>balance_left(PANode p ) ;//对p的左枝进行平衡<br/>
       PANode <em>balance_right(PANode p ) ;//对p的右枝进行平衡<br/>
       PANode </em>find_node(PANode p , ElemType d ) ;//从p开始的位置寻找节点<br/>
       PANode <em>find_parent(ElemType d ) ;//寻找d的父节点<br/>
       void </em>in_order(PANode p) ;//p节点的中序遍历<br/>
       void <em>pre_order(PANode p) ;//p节点的前序遍历<br/>
       int </em>check_balance(PANode p) ;//用于测试平衡性是否计算正确<br/>
       int _height(PANode p) ;//用于取得子树高度<br/>
public:<br/>
       ANode bad_node ; //用于获取不存在的节点时给出<br/>
       AVLTree() ;//构造空树<br/>
       ~AVLTree() ;//销毁树<br/>
       PANode Find(ElemType d) ;//查找元素，<br/>
       PANode FindMax() ;//查找最大元素，<br/>
       PANode FindMin() ;//查找最小元素，<br/>
       ElemType&amp; Retrieve(PANode p) ;//获取元素<br/>
       PANode Insert(ElemType d) ;//插入元素<br/>
       void Delete(ElemType d) ;//按元素删除<br/>
       void Erase(PANode p) ;//按节点位置删除<br/>
       void Clear() ;//清除整棵树<br/>
       void InOrder() ; //中序遍历<br/>
       void PreOrder() ; //前序遍历<br/>
       static void Sort(ElemType a[] , int n , int d = 1) ;//利用AVL进行排序，静态函数<br/>
} ;<br/><br/>
//d：1，从小到大，0，从大到小<br/>
void AVLTree::Sort(ElemType a[] , int n , int d){<br/>
       AVLTree tree ;<br/>
       int i ;<br/>
       for ( i = 0 ; i &lt; n ; i ++ ){<br/>
              tree.Insert(a[i]) ;<br/>
       }<br/>
       for ( i = 0 ; i &lt; n ; i ++ ){<br/>
              PANode p ;<br/>
              if ( d ) {<br/>
                     p = tree.FindMin() ;<br/>
              }else{<br/>
                     p = tree.FindMax() ;       <br/>
              }<br/>
              a[i] = tree.Retrieve(p) ;<br/>
              tree.Erase(p) ;<br/>
       }<br/>
}<br/><br/></p>

<h1>define max(x,y) ((x)&gt;(y)?(x):(y))<br/><br/></h1>

<p>int AVLTree::<em>height(PANode p ){<br/>
       if ( !p ) return -1 ;<br/>
       else return max(</em>height(p-&gt;left) , _height(p-&gt;right)) + 1 ;<br/>
}<br/><br/></p>

<h1>undef max<br/><br/></h1>

<p>int AVLTree::<em>check_balance(PANode p){<br/>
       if ( !p ) return 1 ;<br/>
       if ( !</em>check_balance(p-&gt;left) || !<em>check_balance(p-&gt;right) )return 0 ;<br/>
       else {<br/>
              int a = </em>height(p-&gt;left) ;<br/>
              int b = <em>height(p-&gt;right) ;<br/>
              return a - b == p-&gt;balance ;<br/>
       }<br/>
}<br/><br/>
AVLTree::AVLTree(){<br/>
       root = NULL ;<br/>
}<br/><br/>
AVLTree::~AVLTree(){<br/>
       Clear() ;<br/>
}<br/><br/>
void AVLTree::</em>in_order(PANode p){<br/>
       if ( p ) {<br/>
              <em>in_order(p-&gt;left) ;<br/>
              std::cout&lt;&lt;p-&gt;data&lt;&lt;&#8217; &#8216;;//&lt;&lt;p-&gt;balance&lt;&lt;&#8217;,&#8217; ;<br/>
              </em>in_order(p-&gt;right) ;<br/>
       }<br/>
}<br/><br/>
void AVLTree::<em>pre_order(PANode p){<br/>
       if ( p ) {<br/>
              std::cout&lt;&lt;p-&gt;data&lt;&lt;&#8217; &#8217; ;<br/>
              </em>pre_order(p-&gt;left) ;<br/>
              <em>pre_order(p-&gt;right) ;<br/>
       }       <br/>
}<br/><br/>
void AVLTree::InOrder(){<br/>
       </em>in_order(root) ;<br/>
       std::cout&lt;&lt;std::endl;<br/>
}<br/><br/>
void AVLTree::PreOrder(){<br/>
       <em>pre_order(root) ;<br/>
       std::cout&lt;&lt;std::endl;<br/>
}<br/><br/>
PANode AVLTree::</em>next_node(PANode p){<br/>
       if ( !p ) return NULL ;<br/>
       if ( p-&gt;right != NULL ){<br/>
              p = p-&gt;right ;<br/>
              while ( p-&gt;left ) p = p-&gt;left ;<br/>
       }else{<br/>
              while ( p-&gt;parent &amp;&amp; p-&gt;parent-&gt;right == p ) p = p-&gt;parent ;<br/>
              p = p-&gt;parent ;<br/>
       }<br/>
       return p ;<br/>
}<br/><br/>
PANode AVLTree::<em>prev_node(PANode p){<br/>
       if ( !p ) return NULL ;<br/>
       if ( p-&gt;left != NULL ){<br/>
              p = p-&gt;left ;<br/>
              while ( p-&gt;right ) p = p-&gt;right ;<br/>
       }else{<br/>
              while ( p-&gt;parent &amp;&amp; p-&gt;parent-&gt;left == p ) p = p-&gt;parent ;<br/>
              p = p-&gt;parent ;<br/>
       }<br/>
       return p ;       <br/>
}<br/><br/>
PANode AVLTree::Find(ElemType d){       <br/>
       return </em>find_node(root , d) ;<br/>
}<br/><br/>
PANode AVLTree::FindMax(){<br/>
       if ( root == NULL ) return NULL ;<br/>
       PANode p = root ;<br/>
       while ( p-&gt;right ){<br/>
              p = p-&gt;right ;<br/>
       }<br/>
       return p ;<br/>
}<br/><br/>
PANode AVLTree::FindMin(){<br/>
       if ( root == NULL ) return NULL ;<br/>
       PANode p = root ;<br/>
       while ( p-&gt;left ){<br/>
              p = p-&gt;left ;<br/>
       }<br/>
       return p ;<br/>
}<br/><br/>
ElemType&amp; AVLTree::Retrieve(PANode p){<br/>
       if ( p ) <br/>
              return p-&gt;data ;<br/>
       else return bad_node.data ;<br/>
}<br/><br/>
//左旋<br/>
PANode AVLTree::<em>rotate_left(PANode p ){<br/>
       PANode child = p-&gt;right ;<br/>
       p-&gt;right = child-&gt;left ;<br/>
       if ( child-&gt;left ) child-&gt;left-&gt;parent = p ;<br/>
       child-&gt;left = p ;<br/>
       PANode ancestor = p-&gt;parent ;<br/>
       if ( ancestor ) {<br/>
              if ( ancestor-&gt;left == p ) ancestor-&gt;left = child ;<br/>
              else ancestor-&gt;right = child ;<br/>
       }else{<br/>
              root = child ;<br/>
       }<br/>
       child-&gt;parent = ancestor ;<br/>
       p-&gt;parent = child ;<br/>
       return child ;<br/>
}<br/><br/>
//右旋<br/>
PANode AVLTree::</em>rotate_right(PANode p ){<br/>
       PANode child = p-&gt;left ;<br/>
       p-&gt;left = child-&gt;right ;<br/>
       if ( child-&gt;right ) child-&gt;right-&gt;parent = p ;<br/>
       child-&gt;right = p ;<br/>
       PANode ancestor = p-&gt;parent ;<br/>
       if ( ancestor ) {<br/>
              if ( ancestor-&gt;left == p ) ancestor-&gt;left = child ;<br/>
              else ancestor-&gt;right = child ;<br/>
       }else{<br/>
              root = child ;<br/>
       }<br/>
       child-&gt;parent = ancestor ;<br/>
       p-&gt;parent = child ;<br/>
       return child ;<br/>
}<br/><br/>
//左平衡<br/>
PANode AVLTree::<em>balance_left(PANode p ){<br/>
       PANode child = p-&gt;left ;<br/>
       PANode re ;<br/>
       int tmp ;<br/>
       switch ( child-&gt;balance ) {<br/>
       case 1:<br/>
              re = </em>rotate_right(p) ;<br/>
              re-&gt;balance = 0 ;<br/>
              re-&gt;right-&gt;balance = 0 ;<br/>
              break;<br/>
       case -1:<br/>
              <em>rotate_left(child) ;<br/>
              re = </em>rotate_right(p) ;<br/>
              tmp = re-&gt;balance ;<br/>
              re-&gt;balance = 0 ;<br/>
              switch(tmp){<br/>
              case 0:<br/>
                     re-&gt;left-&gt;balance = 0 ;<br/>
                     re-&gt;right-&gt;balance = 0 ;<br/>
                     break;<br/>
              case 1:<br/>
                     re-&gt;left-&gt;balance = 0 ;<br/>
                     re-&gt;right-&gt;balance = -1 ;<br/>
                     break;<br/>
              case -1:<br/>
                     re-&gt;left-&gt;balance = 1 ;<br/>
                     re-&gt;right-&gt;balance = 0 ;<br/>
                     break;<br/>
              }<br/>
              break;<br/>
       case 0:<br/>
              re = <em>rotate_right(p) ;<br/>
              re-&gt;balance = -1 ;<br/>
              re-&gt;right-&gt;balance = 1 ;<br/>
              break;<br/>
       default:;<br/>
              //assert(&#8220;false&#8221;) ;<br/>
       }<br/>
       return re ;<br/>
}<br/><br/>
//右平衡<br/>
PANode AVLTree::</em>balance_right(PANode p ){<br/>
       PANode child = p-&gt;right ;<br/>
       PANode re ;<br/>
       int tmp ;<br/>
       switch ( child-&gt;balance ) {<br/>
       case 1:<br/>
              <em>rotate_right(child) ;<br/>
              re = </em>rotate_left(p) ;<br/>
              tmp = re-&gt;balance ;<br/>
              re-&gt;balance = 0 ;<br/>
              switch(tmp){<br/>
              case 0:<br/>
                     re-&gt;left-&gt;balance = 0 ;<br/>
                     re-&gt;right-&gt;balance = 0 ;<br/>
                     break;<br/>
              case 1:<br/>
                     re-&gt;left-&gt;balance = 0 ;<br/>
                     re-&gt;right-&gt;balance = -1 ;<br/>
                     break;<br/>
              case -1:<br/>
                     re-&gt;left-&gt;balance = 1 ;<br/>
                     re-&gt;right-&gt;balance = 0 ;<br/>
                     break;<br/>
              }<br/>
              break;<br/>
       case -1:<br/>
              re = <em>rotate_left(p) ;<br/>
              re-&gt;balance = 0 ;<br/>
              re-&gt;left-&gt;balance = 0 ;<br/>
              break;<br/>
       case 0:<br/>
              re = </em>rotate_left(p) ;<br/>
              re-&gt;balance = 1 ;<br/>
              re-&gt;left-&gt;balance = -1 ;<br/>
              break;<br/>
       default:;<br/>
              //assert(&#8220;false&#8221;) ;<br/>
       }<br/>
       return re ;       <br/>
}<br/><br/>
PANode AVLTree::<em>find_node(PANode p , ElemType d ){<br/>
       if ( !p ) return root ;//说明p是根节点的父节点<br/>
       while ( p &amp;&amp; p-&gt;data != d ){<br/>
              if ( d &lt; p-&gt;data ) p = p-&gt;left ;<br/>
              else p = p-&gt;right ;<br/>
       }       <br/>
       return p ;<br/>
}<br/><br/>
PANode AVLTree::</em>find_parent(ElemType d ){<br/>
       if ( root == NULL ) return NULL ;<br/>
       PANode p = NULL ;<br/>
       PANode q = root ;<br/>
       do{<br/>
              if ( q-&gt;data == d ) return p ;<br/>
              p = q ;<br/>
              if ( d &lt; q-&gt;data ) q = q-&gt;left ;<br/>
              else q = q-&gt;right ;<br/>
       }while (q) ;<br/>
       return p ;<br/>
}<br/><br/>
PANode AVLTree::Insert(ElemType d){       <br/>
       //空树<br/>
       if ( !root ) {<br/>
              root = <em>AVL_allocate() ; <br/>
              root-&gt;init(d) ;<br/>
              return root ;<br/>
       }<br/>
       <br/>
       PANode parent = </em>find_parent(d) ;<br/>
       PANode child = <em>find_node(parent , d) ;<br/>
       if ( child ){//已经存在该节点<br/>
              return child ;<br/>
       }<br/><br/>
       //不存在该节点<br/>
       PANode p = </em>AVL_allocate() ;<br/>
       p-&gt;init(d) ;<br/>
       p-&gt;parent = parent ;<br/>
       if ( d &lt; parent-&gt;data ) parent-&gt;left = p ;<br/>
       else parent-&gt;right = p ;<br/><br/>
       child = p ;<br/>
       //查找待调整的树<br/>
       while ( parent != NULL ){<br/>
              if ( child == parent-&gt;left ){//左枝增高<br/>
                     switch( parent-&gt;balance ){<br/>
                     case 0:<br/>
                            parent-&gt;balance = 1 ;<br/>
                            child = parent ;<br/>
                            parent = parent-&gt;parent ;<br/>
                            break;<br/>
                     case 1:<br/>
                            parent-&gt;balance = 2 ;<br/>
                            <em>balance_left(parent) ;<br/>
                            return p ;<br/>
                            break;<br/>
                     case -1:<br/>
                            parent-&gt;balance = 0 ;<br/>
                            return p ;<br/>
                            break;<br/>
                     default:;<br/>
                            //assert(&#8220;false&#8221;) ;<br/>
                     }<br/>
              }else{//右枝增高<br/>
                     switch( parent-&gt;balance ){<br/>
                     case 0:<br/>
                            parent-&gt;balance = -1 ;<br/>
                            child = parent ;<br/>
                            parent = parent-&gt;parent ;<br/>
                            break;<br/>
                     case 1:<br/>
                            parent-&gt;balance = 0 ;<br/>
                            return p ;<br/>
                            break;<br/>
                     case -1:<br/>
                            parent-&gt;balance = -2 ;<br/>
                            </em>balance_right(parent) ;<br/>
                            return p ;<br/>
                            break;<br/>
                     default:;<br/>
                            //assert(&#8220;false&#8221;) ;<br/>
                     }                     <br/>
              }<br/>
       }<br/>
       <br/>
       return p ;<br/>
}<br/><br/>
//该函数仅被Erase过程调用<br/>
PANode AVLTree::<em>find_subs(PANode pos){<br/>
       PANode su = pos;<br/>
       //ElemType tmp = pos-&gt;data ;//可删<br/>
       while ( (su-&gt;left != NULL) || (su-&gt;right != NULL) ) {<br/>
              if ( su-&gt;balance == 1 ) {<br/>
                     su = </em>prev_node(pos) ;<br/>
              }else{<br/>
                     su = <em>next_node(pos) ;<br/>
              }<br/>
              pos-&gt;data = su-&gt;data ;<br/>
              pos = su ;<br/>
       }<br/>
       //su-&gt;data = tmp ;//可删，<br/>
       return su ;<br/>
}<br/><br/>
void AVLTree::Erase(PANode pos){<br/>
       if ( pos == NULL ) return ;<br/>
       PANode su = </em>find_subs(pos) ;//替换节点<br/>
       PANode child = su ;<br/>
       PANode parent = child-&gt;parent ;<br/>
       bool over = false ;<br/>
       int tmp ;<br/>
       while ( parent &amp;&amp; !over ) {<br/>
              if ( child == parent-&gt;left ){//左枝<br/>
                     switch (parent-&gt;balance){<br/>
                     case 0:<br/>
                            parent-&gt;balance = -1 ;<br/>
                            over = true ;<br/>
                            break;<br/>
                     case 1:<br/>
                            parent-&gt;balance = 0 ;<br/>
                            child = parent ;<br/>
                            parent = parent-&gt;parent ;<br/>
                            break;<br/>
                     case -1:<br/>
                            parent-&gt;balance = -2 ;<br/>
                            tmp = parent-&gt;right-&gt;balance ;<br/>
                            child = <em>balance_right(parent) ;<br/>
                            parent = child-&gt;parent ;<br/>
                            if ( tmp == 0 ) over = true ;<br/>
                            break;<br/>
                     default:break;<br/>
                            //assert(&#8220;false&#8221;) ;<br/>
                     }<br/>
              }else{//右枝<br/>
                     switch (parent-&gt;balance){<br/>
                     case 0:<br/>
                            parent-&gt;balance = 1 ;<br/>
                            over = true ;<br/>
                            break;<br/>
                     case 1:<br/>
                            parent-&gt;balance = 2 ;<br/>
                            tmp = parent-&gt;left-&gt;balance ;<br/>
                            child = </em>balance_left(parent) ;<br/>
                            parent = child-&gt;parent ;<br/>
                            if ( tmp == 0 ) over = true ;<br/>
                            break;<br/>
                     case -1:<br/>
                            parent-&gt;balance = 0 ;<br/>
                            child = parent ;<br/>
                            parent = parent-&gt;parent ;<br/>
                            break;<br/>
                     default:break;<br/>
                            //assert(&#8220;false&#8221;) ;<br/>
                     }                     <br/>
              }<br/>
       }       <br/>
       if ( su-&gt;parent ){<br/>
              if (su == su-&gt;parent-&gt;left) su-&gt;parent-&gt;left = NULL ;<br/>
              else su-&gt;parent-&gt;right = NULL ;<br/>
       }else{<br/>
              root = NULL ;<br/>
       }<br/>
       <em>AVL_deallocate(su) ;<br/>
}<br/><br/>
void AVLTree::Delete(ElemType d){<br/>
       PANode p = Find(d) ;<br/>
       if ( p ) {<br/>
              Erase(p) ;<br/>
       }<br/>
}<br/><br/>
void AVLTree::</em>delete_node(PANode p){<br/>
       if ( p != NULL ){<br/>
              <em>delete_node(p-&gt;left) ;<br/>
              </em>delete_node(p-&gt;right) ;<br/>
              <em>AVL_deallocate(p) ;<br/>
       }<br/>
}<br/><br/>
void AVLTree::Clear(){<br/>
       </em>delete_node(root) ;<br/>
       root = NULL ;<br/>
}<br/><br/><br/>
//测试代码<br/>
using namespace std;<br/></p>

<h1>include &lt;algorithm&gt;<br/><br/></h1>

<p>const TOTAL = 50000 ;<br/>
int c[TOTAL] ;<br/><br/>
int main(){<br/>
       int a[] = {3,2,9,7,5,8,6} ;<br/>
//       int a[] = {5 , 2 , 3} ;<br/>
       int b[10] ;<br/>
       int sz = sizeof(a) / sizeof(int)  ;<br/>
       int i;<br/><br/>
       //初始化空间<br/>
        _AVL_initspace ;<br/><br/>
       for ( i = 0 ; i &lt; sz ; i ++ ) b[i] = a[i] ;<br/><br/>
       //排序测试<br/>
       AVLTree::Sort(a , sz , 1) ;<br/>
       for ( i = 0 ; i &lt; sz ; i ++ )cout&lt;&lt;a[i]&lt;&lt;&#8217; &#8216;;<br/>
       cout&lt;&lt;endl;<br/>
       <br/>
       AVLTree tree ;<br/><br/>
       //插入，删除，中序遍历，空树测试<br/>
       tree.Insert(1) ;<br/>
       tree.InOrder() ;<br/>
       tree.Insert(1) ;<br/>
       tree.InOrder() ;<br/>
       tree.Delete(1) ;<br/>
       tree.InOrder() ;<br/><br/>
       //插入测试，根据中序和前序，可以构造出整树，来检验插入是否正确<br/>
       for ( i = 0 ; i &lt; sz ; i ++ ){<br/>
              tree.Insert(a[i]) ;<br/>
              tree.InOrder() ;<br/>
              tree.PreOrder() ;<br/>
       }<br/>
       cout&lt;&lt;endl;<br/><br/>
       //查找测试<br/>
       //不存在元素<br/>
       cout&lt;&lt;tree.Find(4)&lt;&lt;endl;<br/>
       cout&lt;&lt;endl;<br/>
       //存在的元素<br/>
       cout&lt;&lt;tree.Find(9)&lt;&lt;endl;<br/>
       cout&lt;&lt;tree.Find(9)-&gt;data&lt;&lt;endl;<br/>
       //删除元素<br/>
       tree.Delete(9) ;<br/>
       cout&lt;&lt;tree.Find(9)&lt;&lt;endl;<br/><br/>
       tree.InOrder() ;<br/>
       tree.PreOrder() ;<br/><br/>
       //清除测试<br/>
       cout&lt;&lt;endl;<br/>
       cout&lt;&lt;tree.Find(3)&lt;&lt;endl;<br/>
       cout&lt;&lt;tree.Retrieve(tree.Find(3))&lt;&lt;endl;<br/>
       tree.Clear() ;<br/>
       cout&lt;&lt;tree.Find(3)&lt;&lt;endl;       <br/>
       tree.PreOrder() ;<br/><br/>
//大数据测试<br/>
       for ( i = 0 ; i &lt; TOTAL ; i ++ ) c[i] = i ; <br/>
       random_shuffle(c , c + TOTAL) ;<br/>
//       可选择输出数据检验<br/>
//       for ( i = 0 ; i &lt; TOTAL ; i ++ ) cout&lt;&lt;c[i]&lt;&lt;&#8217; &#8217; ;<br/>
//       cout&lt;&lt;endl;<br/>
//       return 0 ;<br/>
       AVLTree::Sort(c , TOTAL , 1) ;<br/>
       for ( i = 0 ; i &lt; TOTAL ; i ++ ) if ( c[i] != i ) break; <br/>
       if ( i == TOTAL ) cout&lt;&lt;&#8221;ok&#8221;&lt;&lt;endl;<br/>
       else cout&lt;&lt;&#8221;bad alg!&#8221;&lt;&lt;endl;<br/><br/>
       return 0 ;<br/>
}<br/><br/><font color="#0000ff">三。后面的废话</font><br/><br/>
至于为什么只有少量注释，主要是前面说过了，这个东西的情况太多了。。<br/>
瞟一眼代码就发现很多的if，switch等等。<br/>
要详细地讲一下，总觉得语言已到极限，只有自己边写边画，弄一棵出来就明白其中的道理了。<br/><br/>
还有这东西写到今天早上的时候 ，已经通过了前面的各种测试。<br/>
正想发，又想了下用大数据检验一下。一测，果然有错。。<br/>
于是又郁闷地调了两个多小时。<br/><br/>
可见<font color="#ff0000">大数据</font>的重要性，通过他不能保证程序正确，<br/>
但至少以我们有限的能力来说，对该程序的信任明显增强。<br/><br/>
为了这个东西拖了一屁股的作业。。。赶之去。<img src="http://img.baidu.com/hi/jx/j_0016.gif"/><br/><br/>
下一个目标RBTree<img src="http://img.baidu.com/hi/jx/j_0019.gif"/>。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/05/17/%E5%8D%95%E7%BA%AF%E5%BD%A2%E6%B3%95%EF%BC%88%E7%BD%9A%E5%87%BD%E6%95%B0%EF%BC%8CMATLAB%29/">单纯形法（罚函数，MATLAB)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-05-17T10:14:00+08:00" pubdate data-updated="true">May 17<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.5.17<br/><br/>
周四就开始纠结，最后发现是初始解写错了（后面标红），<br/>
膜拜某人若干月前就用C写得很顺手了。<br/>
下面这个还是不完善，跑起来经常出warning。<br/>
只能说大致有那个意思了吧。<br/><br/><font color="#ff0000">没考虑，无解，无数解等情况。</font><br/>
用矩阵形式推导完成。<br/><br/><font color="#0000ff">函数如下：</font><br/><br/>
function [z , x] = mylinprog(A , b , c , M)<br/><font color="#339966">%solving following problem:<br/>
% min z = 4 * x1 + 3 * x2 + 8 * x3 <br/>
% s.t.<br/>
%         x1 + x3 &gt;= 2 <br/>
%         x2 + 2 * x3 &gt;= 5<br/>
%         x1 , x2 , x3 &gt;= 0 <br/>
%you should use:<br/>
% M = 1e10 ;<br/>
% c = [ 4 ; 3 ; 8 ; 0 ; 0 ] ;<br/>
% A = [<br/>
%        1 0 1 -1 0 ;<br/>
%         0 1 2 0 -1 ;<br/>
% ] ;<br/>
% b = [ 2 ; 5] ;<br/>
%[z x] = mylinprog(A , b , c , M)<br/>
%where M is a extremely large constant for your problem<br/>
%vectors are column ones</font><br/><br/>
n = length(c) ;<br/>
m = length(b) ;<br/>
B = [ n + 1 : n + m]&#8217;;%initial base<br/>
A = [ A , eye(m) ] ;<br/>
c = [ c ; ones(m , 1) * M] ;<br/><font color="#ff0000">x = [ zeros(n , 1) ; b ] ;%initial root</font><br/><br/>
while 1<br/>
   <font color="#008080"> %for entering variable</font><br/>
      found = 0 ;<br/>
      for j = 1:n+m<br/>
          if ~length(find(B == j))<br/>
            db = -inv(A(:,B)) * A(: , j) ;<br/>
            cj_bar = c(j) - c(B)&#8217; * inv(A(: , B)) * A(: , j) ;<br/>
            if cj_bar &lt; 0<br/>
                found = 1 ;<br/>
                break;<br/>
            end<br/>
          end<br/>
      end<br/>
        <font color="#008080">%j,cj_bar,db;just test of some variables</font><br/>
        if ~found<br/>
            break;<font color="#339966">%already minimum         </font><br/>
        else<br/>
            d = zeros( n + m , 1 ) ;<br/>
            d(B) = db ;<br/>
            d(j) = 1 ;<br/>
            sb = x(B) ./ d(B) ;<br/>
            sb(sb &gt;= 0) = -M ;<br/>
            [theta i] = min(-sb) ;<br/>
            x1 = x + theta * d ;<br/>
            B(i) = j ;<font color="#008080">%excluding B(i),so entering j</font><br/>
            x = x1 ;<br/>
        end<br/>
end<br/>
z = c&#8217; * x ;<br/>
x = x(1:n) ;<br/><br/><font color="#0000ff">变量解释：</font><br/><br/>
A,b,c,x同问题定义。b，c，x都是列向量<br/>
n，变量个数<br/>
m，约束个数<br/>
B，基下标<br/>
found，找到可以优化的解的标志<br/>
d，优化解的方向<br/>
theta，优化解的步长<br/>
x1，优化后的解，有x1 = x + theta * d<br/>
cj_bar，减值费用（reduced cost）<br/>
db，优化方向中，由基变量所在维度组成的序列<br/><font color="#0000ff"><br/>
大体流程：</font><br/><br/>
1.构造初始解，和初始基<br/><br/>
引入人工变量，相应的费用设为M。在A矩阵中，人工变量的系数排起来应该是个单位阵。<br/>
通过x(B) = B<sup>(-1)</sup> * b = b 构造出初始解。<br/><font color="#ff0000">x = [ zeros(n , 1) ; b ] ;%initial root</font><br/>
我之前就写成了：<br/><font color="#ff0000">x = [ zeros(n , 1) ; ones(m,1) ] ;%initial root</font><br/>
于是很囧很囧。。。<br/><br/>
初始基下标就是最后添进去的m个人工变量。<br/><br/>
2.选择进入变量<br/><br/>
就是计算所有的cj_bar。有小于0的话，说明可以改造，否则以达最优。<br/><br/>
依据这里选出的j，可以构造改进方向d<br/><br/>
3.选择退出变量<br/><br/>
通过改进方向d和式子：<br/>
x1 = x + theta * d<br/><br/>
选择保证x1 &gt;= 0约束下的最大的theta作为步长<br/><br/>
4.领x = x1，重复2，3<br/><br/><font color="#0000ff">后记：</font><br/><br/>
前后看了三份资料。。<br/>
1.某first course in MM<br/>
2.最优化老师的课件<br/>
3.《运筹学基础》张莹<br/><br/>
第1份有详细操作，适合不需要原理，但要进行简单手算的使用。<br/>
第2份有详细的矩阵推导，完全没有转化成算法的指导，适合喜欢理论的使用。<br/>
第3份有详细的普通推导，和求解过程，矩阵推导一节戛然而止。。。<br/><br/>
综合了一下，终于憋出来个矩阵计算的。。。<img src="http://img.baidu.com/hi/jx/j_0019.gif"/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/05/15/KEILA51%E9%80%9F%E6%9F%A5%E7%AC%94%E8%AE%B0/">KEIL A51 速查笔记</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-05-15T23:58:00+08:00" pubdate data-updated="true">May 15<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>从上一把正式用ASM写51的程序到现在都很久了，<br/>
估计后面很长的时间不会再用了。<br/><br/>
这份资料只是个人作为速查使用。<br/>
在若干年后的某天，当我要再用A51写程序的时候，<br/>
我会先来翻翻这个东西，于是就可迅速上手了。<br/><br/>
有模板，语言提要，一些特殊的事情，<br/>
最后附上完整的指令表。。<br/>
（这个东西网上找了好久没找到。。在一本书的后面拍下来的）<br/><br/>
==================================<br/><br/>
(hplonline)2009.5.15<br/><br/><font color="#0000ff">先来一个模板：</font><br/>
org 00h<br/>
ljmp func_main<br/>
;这之间为中断向量腾出空间<br/>
org 30h<br/>
func_main:;这里才是主函数开始<br/>
;这里是主函数<br/>
sjmp $;一般在逻辑最后都要加上死循环，否则会一直执行到复位。。<br/>
end ;给编译器看的伪指令<br/><br/><font color="#0000ff">两个命名习惯：</font><br/>
因为汇编程序的扁平性，大程序必须处理好标号<br/>
函数：func_functionname（如：func_main)<br/>
标号：functionname_lp???(如：main_label1)<br/><br/><font color="#0000ff">寻址方式</font><br/>
mov P1 , 0ffh ;地址为0ffh的单元 <br/>
mov P1 , #0ffh;这个才是立即数#0ffh<br/>
mov A , @R1 ;间接寻址<br/><font color="#0000ff"><br/>
间接寻址</font>，<font color="#ff0000">只有A</font>能作为除了地址寄存器的另一个寄存器。<br/>
mov A , @R1;8位内部寻址<br/>
movx A , @R1;8位外部寻址<br/>
movx A , @DPTR;16位外部寻址<br/><br/>
movc 仅有两种，寻址程序rom<br/>
movc A , @A + DPTR<br/>
movc A , @A + PC <br/><br/><font color="#0000ff">DPTR</font>是唯一16位操作数，支持inc，不支持dec<br/><br/><font color="#0000ff">EQU 定义</font>的时候，不能出现#<br/>
比如：CTRL EQU      7fffh<br/>
这导致如果是用立即数的话，不能忘了#CTRL。<br/><br/>
SWAP A<br/>
比较特殊的指令，交换A的上下部分<br/><br/><font color="#0000ff">逻辑类指令：</font><br/>
ANL,ORL,XRL，都以A为核心<br/>
例外：可以用直接寻址数和立即数操作<br/><br/>
记住清零有专门的<font color="#ff0000">CLR</font>,不要老想着异或。。。<br/>
取反有<font color="#ff0000">CPL</font> ， 不要老想着异或。。。<br/><br/><font color="#0000ff">C</font>，是个可<font color="#ff0000">独立</font>操作的单元，<br/>
CLR C，SETB C，等等。<br/><br/><font color="#0000ff">堆栈指针：</font><font color="#ff0000">SP</font><br/>
堆栈是<font color="#ff0000">向上增长</font>的，指针指向栈顶元素。<br/>
push A有问题，要push ACC&#8230;<br/><br/>
不带进位加法ADD<br/>
带进位加法ADDC<br/>
带借位减SUBB<br/>
没有不带借位的减法指令<br/>
MUL AB ，A*B,因此最终结果用1个16位数来表达，其中高8位放在B中，低8位放在A中<br/>
DIV AB，A/B ,商放在A中，余数放在B中<br/><br/>
AJMP ADDR11      ， 双字节指令<br/>
LJMP ADDR16      ， 三字节指令<br/>
SJMP REL_ADDR ， ？<br/>
JMP @A+DPTR      ， 查表跳转<br/><br/>
LCALL addr16 ;长调用指令<br/>
ACALL addr11 ;短调用指令<br/><br/><font color="#0000ff">伪指令：</font><br/>
READ EQU P1（定义文本相等）<br/>
SUM DATA 1FH（定义数据，可先使用后定义）<br/>
RECORD BIT P2.2（定义位）<br/>
DS 06H（保留字节备用,在代码数据分存的单片机体系中，无用）<br/>
DB 定义字节<br/>
DW 定义字<br/><br/><font color="#0000ff">编译期宏：</font><br/>
MOD<br/>
/<br/>
HIGH，取高位<br/>
LOW，取低位<br/><br/><font color="#0000ff">KEIL中查看内存:</font><br/>
打开内存视窗，  <br/>
在地址框填写：  <br/>
C:0000      ;查看      CODE      区  <br/>
D:0000      ;查看      DATA      区  <br/>
I:0000      ;查看      IDATA      区  <br/>
X:0000      ;查看      XDATA      区<br/><br/>
=============================<br/>
（下面是从某书后面照下来的指令表，<br/>
不容易找到，分享给大家，大图比较清晰）<br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/b0aea7345706fd93d1a2d3f6.jpg" small="0" class="blogimg"/></div></p>

<div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/c4d3bc00c67775a3e850cdf7.jpg" small="0" class="blogimg"/></div>


<div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/c813dd2a90dc6a09d52af1f0.jpg" small="0" class="blogimg"/></div>


<div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/a3114916b5a4006e21a4e9f1.jpg" small="0" class="blogimg"/></div>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/05/12/%E8%B4%B4%E4%B8%80%E4%B8%AA%E6%B5%B7%E6%98%8E%E7%A0%81%28HammingCode%29/">贴一个海明码(HammingCode)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-05-12T18:58:00+08:00" pubdate data-updated="true">May 12<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.5.12<br/><br/>
海明码在通信网中的应用还是挺有价值的。<br/><br/>
总地说，这码就是在m长度的数据中，参杂r位的码，<br/>
这样，接收方收到后，可以在只有一位错误的情况下进行纠正。<br/><br/>
数据和码的排列是。二的整数次幂位置上放码，其他位置放数据，比如：<br/><br/>
123456789<br/><font color="#ff0000">rr</font>m<font color="#ff0000">r</font>mmm<font color="#ff0000">r</font>m<br/><br/>
注意下标是从1开始的，这点在后面编码的时候要特别注意，<br/>
因为我们常用的存储结构都是从开始编下标的。<br/><br/>
上面的整串按照下面的形式来写：<br/>
r1 , r2 , m3 , r4 , m5 , m6 , m7 , r8 , m9<br/><br/><font color="#0000ff">encode：</font><br/>
mi的值就是数据串依次排下来的结果。<br/>
定义与rj相关的mi是 i &amp; rj == 1 的所有mi。<br/>
于是rj就等于所有与他相关的mi的异或（模2加）。<br/><br/><font color="#0000ff">decode：</font><br/>
对每个rj，把他与跟他相关的mi异或。<br/>
k = sum{j : rj == 1}<br/>
那么k即为出错的位。<br/>
把该位上的数取反即可纠错。<br/><br/>
为0，表示没有出错。<br/>
如果a的值超过了整个串长，说明可能有多个位出错，此时的结果不可信。<br/>
（即使没有超过，也只在一位出错时可信，<br/>
当有一位以上出错的概率小到忽略是即可）<br/><br/><font color="#0000ff">原理比较明了：</font><br/>
考虑encode和decode其实是两个相反的过程。<br/>
encode的时候把相关的mi异或到了rj上面。<br/>
decode的时候又异或了一遍。<br/>
如果所有数据都没有改动，显然rj为0。<br/>
如果rj为1，并且我们假设了只有1位出错，则该位（或是r或是m）一定与rj相关。<br/>
而与rj1,rj2,rj3&#8230;都相关的位（或是r或是m）是唯一的。<br/>
因为j1,j2,j3&#8230;都是2的幂。<br/><font color="#0000ff"><br/><br/>
代码：</font><br/><br/></p>

<h1>include &lt;stdio.h&gt;<br/></h1>

<h1>include &lt;string&gt;<br/></h1>

<h1>include &lt;iostream&gt;<br/><br/></h1>

<p>//using namespace std;<br/><br/>
//海明码由数据m和码r组成<br/>
//下标从1开始计算<br/>
//r占据的是2的整数次幂的下标<br/>
//m依次占据其他空位<br/><br/>
class HammingCode{<br/>
private:<br/>
      std::string data ;<br/>
      std::string code ;<br/>
      int hamminglength ;<br/>
      int calhamminglength(int l) ;//计算长度为l的串要多少位的码<br/>
      int calhamminglength2(int l) ;//计算长度为l的总串中有多少位是码<br/>
      int lowbit(int x) ;//得到的最低比特<br/>
      int nextn2power(int x) ;//下一个非2的幂的下标<br/>
public:<br/>
      HammingCode() ;<br/>
      ~HammingCode() ;<br/>
      void SetData(std::string s) ;<br/>
      void SetCode(std::string s) ;<br/>
      void Encode() ;<br/>
      bool Decode() ;<br/>
      std::string&amp; GetData() ;<br/>
      std::string&amp; GetCode() ;<br/>
      int GetHammingLength() ;<br/>
};<br/><br/>
//下一个非2的幂的下标<br/>
//2的幂的下标将存放海明码<br/>
int HammingCode::nextn2power(int x){<br/>
      do{<br/>
            x ++ ;<br/>
      }while ( lowbit(x) == x )  ;<br/>
      return x ;<br/>
}<br/><br/>
//得到的最低比特<br/>
int HammingCode::lowbit(int x){<br/>
      return x&amp;(-x) ;<br/>
}<br/><br/>
//1byte = 8bit ，使用4个位做海明码<br/>
int HammingCode::calhamminglength(int l){<br/>
      //纠错码纠错一位所需位数r满足：<br/>
      //l + r + 1 &lt;= 2 ^ r<br/>
      int r = 1 ;<br/>
      int pr = 2 ;<br/>
      while ( l + r + 1 &gt; pr ) {<br/>
            r = r + 1 ;<br/>
            pr &lt;&lt;= 1 ;<br/>
      }<br/>
      return r ;<br/>
}<br/><br/>
//计算长度为l的总串中有多少位是码<br/>
int HammingCode::calhamminglength2(int l){<br/>
      int r = 1 ;<br/>
      int pr = 2 ;<br/>
      while ( l &gt;= pr ) {<br/>
            r = r + 1 ;<br/>
            pr &lt;&lt;= 1 ;<br/>
      }<br/>
      return r ;<br/>
}<br/><br/>
HammingCode::HammingCode(){<br/><br/>
}<br/><br/>
HammingCode::~HammingCode(){<br/><br/>
}<br/><br/>
void HammingCode::SetData(std::string s){<br/>
      data = s ;<br/>
      hamminglength = calhamminglength(s.size()) ;<br/>
}<br/><br/>
void HammingCode::SetCode(std::string s){<br/>
      code = s ;<br/>
      hamminglength = calhamminglength2(s.size()) ;<br/>
}<br/><br/>
void HammingCode::Encode(){<br/>
      int i; <br/>
      int curpos = 1 ;//初始的数据放置点<br/>
      code.reserve(hamminglength + data.length()) ;<br/>
      code = &#8220;&#8221; ;<br/>
//      cout&lt;&lt;code.length()&lt;&lt;&#8217; &#8216;&lt;&lt;code.capacity()&lt;&lt;endl;<br/>
      //置0，因为0是异或操作的证同元素<br/>
      for ( i = 0 ; i &lt; hamminglength + data.length() ; i ++ ) {<br/>
            code += &#8216;\0&#8217; ;<br/>
      }<br/>
      //字符变化为数字<br/>
      for ( i = 0 ; i &lt; data.length() ; i ++ ) {<br/>
            data[i] -= &#8216;0&#8217; ;<br/>
      }<br/>
      //下面注意对code[x]引用的时候，string是从0开始的，所以要减1<br/>
      for ( i = 0 ; i &lt; data.length() ; i ++ ) {<br/>
            curpos = nextn2power(curpos) ;<br/>
            code[curpos - 1] = data[i] ;<br/>
            int tmp = curpos ;<br/>
            int lb ;<br/>
            //加到相关位上，即下标中2进制位为1的位上<br/>
            while ( tmp ) {<br/>
                  lb = lowbit(tmp) ;<br/>
                  code[lb - 1] ^= data[i] ;<br/>
                  tmp -= lb ;<br/>
            }<br/>
      }<br/>
      for ( i = 0 ; i &lt; data.length() ; i ++ ){<br/>
            data[i] += &#8216;0&#8217; ;<br/>
      }<br/>
      for ( i = 0 ; i &lt; code.length() ; i ++ ){<br/>
            code[i] += &#8216;0&#8217; ;<br/>
      }<br/>
}<br/><br/>
bool HammingCode::Decode(){<br/>
      int i ;<br/>
      int curpos = 1 ;<br/>
      int wpos = 0 ;//计算出错位<br/>
      data.reserve(code.length() - hamminglength) ;<br/>
      data = &#8220;&#8221; ;<br/>
      for ( i = 0 ; i &lt; code.length() ; i ++ ) {<br/>
            code[i] -= &#8216;0&#8217; ;<br/>
      }<br/>
      <br/>
      for ( curpos = 3 ; curpos &lt;= code.length() ; curpos = nextn2power(curpos) ){<br/>
      //      code[curpos - 1] = data[i] ;<br/>
            int tmp = curpos ;<br/>
            int lb ;<br/>
            //加到相关位上，即下标中2进制位为1的位上<br/>
            while ( tmp ) {<br/>
                  lb = lowbit(tmp) ;<br/>
                  code[lb - 1] ^= code[curpos - 1] ;<br/>
                  tmp -= lb ;<br/>
            }<br/>
      }<br/>
      <br/>
      for ( i = 1 ; i &lt;= code.length() ; i &lt;&lt;= 1 ){<br/>
            if ( code[i - 1] ) wpos += i ;<br/>
      }<br/><br/>
      //可能不止一位出错，解码失败<br/>
      if ( wpos &gt; code.length() ) return false ;<br/>
      if ( wpos ) code[wpos - 1] = !code[wpos - 1] ;<br/>
      <br/>
      data = &#8220;&#8221; ;<br/>
      for ( curpos = 3 ; curpos &lt;= code.length() ; curpos = nextn2power(curpos) ){<br/>
            data += code[curpos - 1] ;<br/>
      }<br/><br/>
      for ( i = 0 ; i &lt; code.length() ; i ++ ){<br/>
            code[i] += &#8216;0&#8217; ;<br/>
      }<br/>
      for ( i = 0 ; i &lt; data.length() ; i ++ ){<br/>
            data[i] += &#8216;0&#8217; ;<br/>
      }<br/>
      return true ;<br/>
}<br/><br/>
std::string&amp; HammingCode::GetData(){<br/>
      return data ;<br/>
}<br/><br/>
std::string&amp; HammingCode::GetCode(){<br/>
      return code ;<br/>
}<br/><br/>
int HammingCode::GetHammingLength(){<br/>
      return hamminglength ;<br/>
}<br/><br/>
//测试部分开始<br/>
using namespace std;<br/><br/>
int main(){<br/>
      string src = &#8220;11100010&#8221; ;<br/>
      string dst ;<br/>
      HammingCode hc ;<br/><br/>
      cout&lt;&lt;&#8221;original:&#8221;&lt;&lt;endl;<br/>
      cout&lt;&lt;src&lt;&lt;endl;<br/><br/>
      cout&lt;&lt;&#8221;hamming encoding:&#8221;&lt;&lt;endl;<br/>
      hc.SetData(src) ;<br/>
      hc.Encode() ;<br/>
      dst = hc.GetCode() ;<br/>
      cout&lt;&lt;dst&lt;&lt;endl;<br/>
      <br/>
      if ( dst[3] == &#8216;1&#8217; ) dst[3] = &#8216;0&#8217; ;<br/>
      else dst[3] = &#8216;1&#8217; ;<br/><br/>
      cout&lt;&lt;&#8221;modified by 1 bit:&#8221;&lt;&lt;endl;<br/>
      cout&lt;&lt;dst&lt;&lt;endl;<br/><br/>
      hc.SetCode(dst) ;<br/>
      hc.Decode() ;<br/>
      cout&lt;&lt;&#8221;hamming decoding:&#8221;&lt;&lt;endl;<br/>
      cout&lt;&lt;hc.GetData()&lt;&lt;endl;<br/>
      return 0 ;<br/>
}</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/backup-hplonline/blog/page/17/">&larr; Older</a>
    
    <a href="/backup-hplonline/blog/archives">Blog Archives</a>
    
    <a class="next" href="/backup-hplonline/blog/page/15/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/backup-hplonline/blog/2013/05/04/test/">Test</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/04/09/%E5%86%8D%E8%B0%88stl%E7%9A%84rotate/">再谈stl的rotate</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%BA%8C%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、二）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%89%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、三）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%80%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、一）</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - hplonline -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
