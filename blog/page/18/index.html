
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>hplonline</title>
  <meta name="author" content="hplonline">

  
  <meta name="description" content="(hplonline)2009.5.4
就是乱逛看到篇文章。原文地址：
http://www.abarnett.demon.co.uk/tutorial.html
可参考的译文：
http://just-study.blogbus.com/logs/37238127.html
http:// &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hupili.github.io/backup-hplonline/blog/page/18">
  <link href="/backup-hplonline/favicon.png" rel="icon">
  <link href="/backup-hplonline/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/backup-hplonline/atom.xml" rel="alternate" title="hplonline" type="application/atom+xml">
  <script src="/backup-hplonline/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/backup-hplonline/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/backup-hplonline/">hplonline</a></h1>
  
    <h2>backup from 2006 to 2012 (original hi.baidu.com/hplonline/)</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/backup-hplonline/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hupili.github.io/backup-hplonline" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/backup-hplonline/">Blog</a></li>
  <li><a href="/backup-hplonline/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/05/04/%E6%9F%90%E4%B8%AAC%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0%E7%9A%84%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/">某个C优化笔记的读后笔记</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-05-04T20:06:00+08:00" pubdate data-updated="true">May 4<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.5.4<br/><br/>
就是乱逛看到篇文章。<br/><br/><font color="#0000ff">原文地址：</font><br/>
http://www.abarnett.demon.co.uk/tutorial.html<br/><font color="#0000ff"><br/>
可参考的译文：</font><br/>
http://just-study.blogbus.com/logs/37238127.html<br/>
http://just-study.blogbus.com/logs/37238535.html<br/><br/>
因为那网页说的会一直update。<br/>
所以，为了和我下面的评论配套，<br/>
down了一份下来，跟我的这篇文章一起放在<a href="http://www.box.net/shared/kebyrbxnza" target="_blank">这里</a>。<br/><br/>
======================下面是笔记，可能要打开原文对着看<br/><br/><font color="#0000ff">     * Array Indices</font><br/><br/>
这个应该是很通用的一点，个人认为谈不上优化，<br/>
只是算一种编程的手法，<br/>
但是不解有很多在大学混了3年的学生<br/>
依然舍不得用循环和数组去代替if或者switch<br/><br/><font color="#0000ff">     * Aliases</font><br/><br/>
这个事情看编译器了，在VC里面会开完优化会吧<em>data的值放在寄存器内的。<br/>
有时反而担心编译器优化过分了。<br/>
详细可以参考前面讲的<a href="http://hi.baidu.com/hplonline/blog/item/baf29d2bb27a5ff2e7cd400b.html" target="_blank">volatile</a><br/><br/><font color="#0000ff">     * Registers<br/><br/><br/>
     * Integers</font><br/><br/>
貌似在现在CPU上，有无符号差异很不明显了。<br/>
不过，在可能的时候，用整数代替浮点的建议是应该牢记的。<br/>
速度是其次，关键是不失精度。<br/>
但有时这样做可能会导致更多的开发代价。<br/><br/><font color="#0000ff">     * Loop Jamming</font><br/><br/>
节约了循环变量自增的一段时间，不过感觉是小头。<br/>
应该注意的是下面的note那句话。<br/>
如果两个循环访问的内存空间相去很远，且都超过chache大小不少，<br/>
放在一个循环内交替执行反而会造成chache频繁不命中。<br/><br/><font color="#0000ff">     * Dynamic Loop Unrolling - can make a big difference.</font><br/><br/>
效果要明显应该是要在循环体很轻的时候吧。<br/>
否则，循环变量的操作减少可能带来不了多少效果。<br/><br/>
最后的建议貌似不好。。<br/>
在51中，这种改法，可以用一条djnz来代替若干指令，<br/>
减少了指令条数，自然减少时间。<br/>
但在我们的PC上，CPU有很多优化，像流水操作这样，<br/>
指令执行的速度不是独立的，应该算一段时间中各指令的平均速度。<br/>
而<font color="#ff0000">CISC的指令集不利于CPU本身去发挥诸如乱序执行之类的特色</font>，<br/>
所以，即使把自减用一个loop来代替了，也不见得更快。<br/><br/>
     <font color="#0000ff"></em> Faster for() loops</font><br/><br/>
for( i=10; i&#8211;; ) { &#8230; }<br/>
for(i=10; i; i&#8211;){}<br/>
这两个显然是有差别的啊。。。<br/>
如果他们仅仅是控制循环次数。。那么确实一样。<br/>
但是在循环体中引用的时候肯定数值不一样。<br/><br/><font color="#0000ff">     * Switch</font><br/><br/>
这条的解释是错的。。<br/>
当我们痛恨国内教材的时候，也要清醒地认识到，<br/>
其实老外也会YY的。<br/>
不过出于严谨的措辞：<br/>
it may be faster to use a switch: <br/>
这个“may”很关键<br/>
(关于错误见<a href="http://hi.baidu.com/hplonline/blog/item/68db0055fd7f77ccb645ae3d.html" target="_blank">上一篇</a>）<br/><br/><font color="#0000ff">     * Pointers</font><br/><br/>
这个没啥好说的，用指针来减少数据传送是显然的。<br/>
C++里面的 &amp;<br/>
VB里面的 byref<br/>
PASCAL里面的 var<br/>
基本上是个语言就会提供类似的机制。<br/><br/><font color="#0000ff">     * Early loop breaking</font><br/><br/>
这个。。感觉既然写个程序就应该要这样才对。。<br/>
包括更高层次的算法，也要注意这种剪枝类似的东西。<br/><br/><font color="#0000ff">     * Misc</font><br/><br/>
这点下面太多了，摘点有共鸣的。<br/><br/>
1.Declare anything within a file (external to functions) as static, unless it is intended to be global.<br/><br/>
这个东西我其实也经常不注意，但确实很重要，<br/>
给文件级的全局变量或函数加static修饰可以防止他们出现在导出表中。<br/>
减少代码体积其实是次要的，更有意义的是，<br/>
当别人使用你的成果（.obj)，而他自己又有同名的工程级全局变量或函数时，<br/>
不至于因为ambiguous造成link error。<br/><br/>
2.Use word-size variables if you can, as the machine can work with these better ( instead of char, short, double, bitfields etc. ).<br/><br/>
这点确实。。记得高中整PASCAL的时候，<br/>
老是斤斤计较地写integer而只在必要时用long。<br/>
后来知道这点后很郁闷。。。<br/>
因为其实可以完全不管直接用long，速度上更有优势，<br/>
只在必要的时候（空间不够）用integer才是。。。<br/><br/>
3.Don&#8217;t use recursion<br/><br/>
个人觉得不能因噎讳食。<br/><br/>
4.Single dimension arrays are faster than multi-dimensioned arrays.<br/><br/>
这是因为高级语言中的寻址问题。<br/>
很多时候，完全可以自己算出偏移量，来改善。<br/>
有篇讲类似思想的。<br/><a href="http://hi.baidu.com/hplonline/blog/item/52fc6722a32d1cac4723e83e.html" target="_blank">高维迷宫</a><br/>
借用类似思想来访问高维数组可以提高效率。<br/><br/>
5.Compilers can often optimise a whole file - avoid splitting off closely related functions into separate files, the compiler will do better if can see both of them together (it might be able to inline the code, for example).<br/>
这个确实，因为外部符号的访问要多一点步骤的。<br/>
如果放在不同文件的话，即使不考虑内联的可能性，<br/>
单说访问，也是要费点事的。<br/><br/>
6.Floating point multiplication is often faster than division - use val * 0.5 instead of val / 2.0.<br/>
这个有实验证明。<br/>
准备过一下把实验整理出来。<br/><br/>
7.Addition is quicker than multiplication - use val + val + val instead of val * 3<br/>
古老的优化手段，但在现在不尽然，<br/>
现在很多地方MUL的执行可以平均到2个周期了。<br/><br/>
8.puts() is quicker than printf(), although less flexible.<br/>
那是显然的。。putchar()还要快点。。<br/>
同理getchar()还是很牛。。。<br/>
耍<a href="http://hi.baidu.com/hplonline/blog/item/68db005503fdd1ccb645aeb3.html" target="_blank">外挂</a>的同学应该很有共鸣。。<br/><br/>
9.Last but definitely not least ，<br/>
标记这点的原因是认为这个句型不错。。。<br/><br/><font color="#0000ff">后记：</font><br/><br/>
最后看完了看到这句：<br/><title>C Optimisation tutorial</title>
 Last updated July 1998 <br/><br/>
。。毕竟这么老的东西了，很多东西可以理解。。。<br/>
都过了11年的时间了，足以让这个人成为大牛了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/05/04/%E4%B8%8D%E8%A6%81YY%EF%BC%9Aif%E5%92%8Cswitch%E7%9A%84%E9%82%A3%E4%B9%88%E4%BA%9B%E4%BA%8B%E6%83%85%EF%BC%88C%29/">不要YY：if和switch的那么些事情（C)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-05-04T19:50:00+08:00" pubdate data-updated="true">May 4<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.5.4<br/><br/>
今天看到有个老外写了下面这段话：<br/><title>C Optimisation tutorial</title><h3>switch() instead of if&#8230;else&#8230;</h3>
For large decisions  involving if&#8230;else&#8230;else&#8230;, like this:</p>

<pre>if( val == 1)        <br/>dostuff1();<br/> else if (val == 2)        <br/>dostuff2();<br/> else if (val == 3)        <br/>dostuff3();</pre>


<p>it may be faster to use a switch:</p>

<pre>switch( val ) {       <br/> case 1: dostuff1(); break;        <br/> case 2: dostuff2(); break;         <br/>case 3: dostuff3(); break; <br/>}</pre>


<p>In the if() statement, if the last case is required, all the previous  ones will be tested first. The switch lets us cut out this extra work. If you  have to use a big if..else.. statement, test the most likely cases first. <br/><br/>
=====注意从这开始是我写的了。。<br/><br/><font color="#0000ff">啥都不说，写代码测试：</font><br/></p>

<h1>include &lt;stdio.h&gt;<br/><br/></h1>

<p>void f1(){}<br/>
void f2(){}<br/>
void f3(){}<br/><br/>
int main()<br/>
{<br/>
       int val ;<br/>
       val = 0x1111 ;       <br/>
       if( val == 1)<br/>
              f1();<br/>
       else if (val == 2)<br/>
              f2();<br/>
       else if (val == 3)<br/>
              f3();<br/>
       <br/>
       //       it may be faster to use a switch:<br/>
       <br/>
       val = 0x2222 ;<br/>
       switch( val )<br/>
       {<br/>
       case 1: f1(); break;              <br/>
       case 2: f2(); break;              <br/>
       case 3: f3(); break;<br/>
       }<br/>
       return 0;<br/>
}<br/><font color="#0000ff"><br/>
然后，看汇编：</font><br/><br/><font color="#ff6600">这是对应if的那一组：</font><br/>
004010D8  |.  C745 FC 11110&gt;mov        dword ptr [ebp-4], 1111<br/>
004010DF  |.  837D FC 01       cmp        dword ptr [ebp-4], 1<br/>
004010E3  |.  75 07            jnz        short 004010EC<br/>
004010E5  |.  E8 25FFFFFF      call       0040100F<br/>
004010EA  |.  EB 18            jmp        short 00401104<br/>
004010EC  |&gt;  837D FC 02       cmp        dword ptr [ebp-4], 2<br/>
004010F0  |.  75 07            jnz        short 004010F9<br/>
004010F2  |.  E8 13FFFFFF      call       0040100A<br/>
004010F7  |.  EB 0B            jmp        short 00401104<br/>
004010F9  |&gt;  837D FC 03       cmp        dword ptr [ebp-4], 3<br/>
004010FD  |.  75 05            jnz        short 00401104<br/>
004010FF  |.  E8 01FFFFFF      call       00401005<br/><br/><font color="#ff6600">这是对应switch的那一组：</font><br/>
00401104  |&gt;  C745 FC 22220&gt;mov        dword ptr [ebp-4], 2222<br/>
0040110B  |.  8B45 FC          mov        eax, dword ptr [ebp-4]<br/>
0040110E  |.  8945 F8          mov        dword ptr [ebp-8], eax<br/>
00401111  |.  837D F8 01       cmp        dword ptr [ebp-8], 1<br/>
00401115  |.  74 0E            je         short 00401125<br/>
00401117  |.  837D F8 02       cmp        dword ptr [ebp-8], 2<br/>
0040111B  |.  74 0F            je         short 0040112C<br/>
0040111D  |.  837D F8 03       cmp        dword ptr [ebp-8], 3<br/>
00401121  |.  74 10            je         short 00401133<br/>
00401123  |.  EB 13            jmp        short 00401138<br/>
00401125  |&gt;  E8 E5FEFFFF      call       0040100F<br/>
0040112A  |.  EB 0C            jmp        short 00401138<br/>
0040112C  |&gt;  E8 D9FEFFFF      call       0040100A<br/>
00401131  |.  EB 05            jmp        short 00401138<br/>
00401133  |&gt;  E8 CDFEFFFF      call       00401005<br/><br/>
我想。。视力正常的人都看出来谁长谁短了。。。<br/><br/>
很明显，<font color="#ff0000">switch还要多几句话。不过比较次数是一样的。</font><br/><br/>
从高级语言的层面上来看，switch给人的感觉确实是:<br/>
一次switch，直接到相应的case。貌似很快<br/><br/>
而用if却要不断地if,else,if,else。。。。<br/><br/>
不过，上面的代码充分说明那是YY出来的。<br/><font color="#ff0000">实际上，switch有多少case就要cmp,je多少次。</font><br/><br/>
所以，当我们痛恨国内教材的时候，也要清醒地认识到，<br/>
其实老外也会YY的。<br/>
不过出于严谨的措辞：<br/>
it may be faster to use a switch: <br/>
这个“may”很关键<br/><br/>
话又说回来，最后一句：<br/><font color="#ff0000">test the most likely cases first</font><br/><br/>
倒是真的，能随时记着最好。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/05/02/%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%A8%A1%E6%8B%9F%E4%B8%AD%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E7%94%9F%E6%88%90%EF%BC%88%E5%88%86%E5%8C%BA%E5%86%8D%E9%9A%8F%E6%9C%BA%EF%BC%8C%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC%EF%BC%8C%E4%B8%89%E9%98%B6%E6%A0%B7%E6%9D%A1%E6%8F%92%E5%80%BC%EF%BC%89%EF%BC%88MATLAB%EF%BC%89/">蒙特卡罗模拟中随机数据的生成（分区再随机，线性插值，三阶样条插值）（MATLAB）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-05-02T22:16:00+08:00" pubdate data-updated="true">May 2<span>nd</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.5.2<br/><br/>
完整程序：<a href="http://www.box.net/shared/ij78zuzn34" target="_blank">Monte_Carto_random_num.m<br/></a> <br/>
首先，假设我知道了世界上有蒙特卡罗模拟这个东西。<br/><br/>
因为这东西要用到随机数据。<br/><br/>
突然发现生成随机数据还是有讲究的，<br/>
特别是因为我们<font color="#ff0000">产生随机数的基础</font>就无法保证，<br/>
那么这一点更重要。<br/><br/>
往往我们是从<font color="#ff0000">均匀分布的rand()</font>出发，根据使用环境构造出另外一组随机数据。<br/><br/>
考虑下面的一组数据。<br/>
这组数据描述的是一个超市里面，顾客购物件数和对应的频率<br/><br/><font color="#0000ff">件数 </font>         ≤8          9～19          20～29          30～39          40～49          ≥50<br/><font color="#0000ff">频率 </font>         0.12          0.10          0.18          0.28          0.20          0.12<br/><br/>
那么，既然是从均匀分布出发，我们就要先得到一组均匀分布的数据：<br/>
假设要生成m个。<br/>
m = 1000 ;<br/>
x = rand(1 , m) ;<br/><br/>
现在的关键就是通过这m个均匀分布的数据，对应出m个购物的件数。<br/><br/>
先把上面的统计值换成MATLAB里面的表达。<br/>
num = [ 0 8 19 29 39 49 60 ] ;<br/>
fre = [ 0 0.12 0.10 0.18 0.28 0.20 0.12] ;<br/><br/>
然后对频率做累积。<br/>
n = size(fre,2) ;<br/>
for i = 2 : n<br/>
          fre(i) = fre(i) + fre(i - 1) ;<br/>
end<br/><br/>
这样的话，得到的x(i)如果在fre(i)到fre(i+1)之间，那么，<br/>
我们就对应生成一个购物件数在num(i)和num(i+1)之间。<br/><br/>
现在问题就来了，这个事情里面，我们的<font color="#ff0000">频率是按照区间给出的</font>。<br/><br/>
如果现在确定了应该生成一个0..8之间的数字，那么我们应该生成几呢？？？<br/><br/>
这里就是这篇主要关注的问题。<br/><br/>
当然，在关注之前，先假设出一个上限，maxn = 60。表示最多购物数为60.<br/>
因为前面的表中只有≥50，并没有标定上限，为后面三个方法都造成障碍。<br/><br/><font color="#0000ff">1.分区再随机</font><br/>
%法1，将x只作为划区间使用，在划定的区间内<br/>
%再次随机，即将该区间内部作为线性的<br/>
n1 = 0 ;<br/>
for i = 1:m<br/>
         for j = 2:n<br/>
             if x(i) &lt; fre(j) <br/>
                 break<br/>
             end<br/>
         end%这里是找到属于的区间<br/>
         a = num(j - 1) ;<br/>
         b = num(j) ;%区间的端点值<br/>
         n1(i) = fix(rand(1,1) * (b - a + 1)) + a ;%再次随机<br/>
end<br/><br/>
下面两个方法，用到插值，因为假定购物件数为整数，所以，用来插值的xi向量定为：<br/>
xi = 0:maxn<br/><br/><font color="#0000ff">2.线性插值</font><br/>
%法二，用线性插值得到的yi1来生成数据<br/>
yi1 = interp1(num , fre , xi) ;%线性插值<br/>
n2 = 0 ;<br/>
for i = 1:m<br/>
         flag = 0 ;<br/>
         for j = 2:maxn+1<br/>
             if x(i) &lt; yi1(j)<br/>
                 flag = 1 ;<br/>
                 break;<br/>
             end<br/>
         end%直接找到对应的件数<br/>
         if flag%判断x是否大于总的累积频率<br/>
             n2(i) = j - 1 ;<br/>
         else<br/>
             n2(i) = maxn + 1;         <br/>
         end<br/>
end<br/><br/><font color="#0000ff">3.三阶样条插值</font><br/>
%法三，用三阶样条插值的yi2来生成数据<br/>
yi2 = interp1(num , fre , xi , &#8216;spline&#8217; ) ;%三阶样条插值<br/>
n3 = 0 ;<br/>
for i = 1:m<br/>
         flag = 0 ;<br/>
         for j = 2:maxn+1<br/>
             if x(i) &lt; yi2(j)<br/>
                 flag = 1 ;<br/>
                 break;<br/>
             end<br/>
         end%直接找到对应的件数<br/>
         if flag%判断x是否大于总的累积频率<br/>
             n3(i) = j - 1 ;<br/>
         else<br/>
             n3(i) = maxn + 1;         <br/>
         end<br/>
end<br/><br/><font color="#0000ff">效果对比：</font><br/><br/>
毕竟是随机的东西，所以每次跑出来的肯定不一样。。。<br/><br/>
先来看一下我们<font color="#ff0000">依赖</font>的x的histogram：<br/>
hist(x) ;<br/><div forimg="1"><img height="396" border="0" width="529" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/273b252e6ba63b734ec226c8.jpg"/></div>
横轴是概率，划分成了10个区间，纵轴是，落在这个区间里面的x的频数。<br/>
只能说将就吧。但这不是我们能够改变的，<br/>
我们生成各种随机数的前提条件就是信赖rand()是均匀分布。<br/><br/>
那么三种方式产生的数据的histogram如下：<br/>
hist([n1 ; n2 ; n3]&#8217;) ;<br/><div forimg="1"><img height="443" border="0" width="592" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/b66cc3177498c72ac83d6dd7.jpg"/></div></p>

<br/>


<p>这个趋势究竟如何呢？<br/><br/>
做一点改造x = linspace(0,1,m);<br/>
即我们现在用于生成数据的x向量是严格均匀分布在(0,1)之间的。<br/><br/>
画图：<br/><br/><div forimg="1"><img height="426" border="0" width="570" src="http://hiphotos.baidu.com/hplonline/pic/item/8fc50d087481b313e82488a3.jpg" small="0" class="blogimg"/><br/>
仔细看，2，3法出来的结果虽然相互有差异，但在不同x时趋势上很相似。<br/>
而1法的结果就显得更波动。<br/><br/>
从原理上来说，如果我们的rand()均匀透顶了，<br/>
那么1法再随机一次，即是产生那个区间上的均匀分布，变化在那个区间里面是线性的。<br/>
于是跟2法的线性插值所出的结果应该是一致的。<br/><br/>
但是很明显，2法中我们不用非常信任rand()，因为我们对x的值进行了更充分的利用。<br/>
也就是说我们只要认为x的均匀程度符合要求就行了。<br/><br/>
那么你说x也是rand()产生的，这不是一样吗？<br/>
有两点：<br/><br/>
1.我们可以不用rand()，比如我们先令x = linspace(0,1,m);然后对x进行洗牌。<br/>
这样出来的就是m个绝对均匀的数据，并且洗牌使得元素的出现是“随机”的。<br/><br/>
2.即使用rand()去生成x，减少更多的rand()也是有意义的。<br/>
因为x是按照一个系列产生的，我们可以先评估x的均匀性是否符合要求。<br/>
而1法每次再随机的rand()是一次一个生成的，我们无法跟踪他的效果。<br/><br/>
这么说了，就是一点：<font color="#ff0000">用线性插值取代再随机法可以更充分利用已有的随机序列</font><br/><br/>
那么线性插值和三次样条之间的区别呢？<br/><br/>
画图之：<br/><br/>
plot(num , fre , &#8216;*&#8217; , xi , yi1 , xi , yi2) ;<br/><br/><div forimg="1"><img height="438" border="0" width="586" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/12d151b56f44b5ed37d3cad8.jpg"/></div>
星号是问题中给出的数据点，蓝色是线性，红色是三阶样条。<br/><br/>
在这个问题的数据下，应该说差不多，只不过三阶样条保证了插值曲线的光滑。<br/>
这两个之间的取舍如何，貌似不好说。<br/><br/>
特别是这里的物品件数是整数，当可以为实数的时候就会比较困难一点。<br/><br/><font color="#ff0000">从生成数据的过程来看，可以认为是先得到均匀分布x，<br/>
再算出插值曲线的反函数h，然后生成数据序列h(x)。</font><br/><br/>
当为整数的时候，我们可以不用计算反函数。<br/>
就像上面程序一样，跑一个循环，在插值曲线中去卡一个区间即可。<br/><br/>
而待生成数据为实数的时候，就非得要反函数了。<br/>
线性函数的反函数很好算，而三次函数的反函数就麻烦了。。。<br/><br/><font color="#0000ff">后记</font><br/><br/>
啰嗦了这么一堆，其实大可不必去管的。。<br/>
很多时候做文章rand()出一堆数据，让别人觉得很<font color="#ff0000">壮观</font>就行了。。。<br/>
既然读文章的人不较真，写文章的人何必劳神呢。。。<br/>
再说，如果因为你的一时较真，<br/>
让别人觉得自己曾经做过的很多事情都有漏洞，<br/>
从此茶饭不思，毕竟不太好吧。</div></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/04/29/LSB%E6%95%B0%E5%AD%97%E6%B0%B4%E5%8D%B0%E5%92%8C%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F/">LSB数字水印和信息隐藏</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-04-29T16:12:00+08:00" pubdate data-updated="true">Apr 29<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>连着几天赶制实验室要的程序。没啥新东西，放个一个月前的LSB上来。<br/><br/>
(hplonline)2009.3.24<br/><br/><font color="#ff6600">程序，源码，以及某天的PPT就一起放上来了。</font><br/><br/>
仅仅针对24位的位图有用。<br/>
有数字水印和信息隐藏两个模块。<br/><br/><a href="http://www.box.net/shared/i43gdhhnun" target="_blank">http://www.box.net/shared/i43gdhhnun</a><br/><br/>
比较囧的是貌似没注释，可以对着后面的细节提示来看<br/><br/><font color="#0000ff">一。效果？？</font><br/><br/>
这一幅是原图：<br/><br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/c62071cbce129c3cbf09e606.jpg" small="0" class="blogimg"/><br/>
这一幅是加了水印的图</div></p>

<div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/40e5d3f9077e0e7a242df206.jpg" small="0" class="blogimg"/><br/>
模拟加水印的图被修改过</div>


<div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/12d151b511be7bed37d3ca06.jpg" small="0" class="blogimg"/><br/>
根据水印提取的修改痕迹</div>


<div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/2739df396a5454d03b87ce06.jpg" small="0" class="blogimg"/><br/><br/>
关于上面看到的图片，只能是个大意演示。。<br/>
因为图片上传后，百度会重新对图像进行压缩，所以看到的就不是以前的东西了。<br/><br/>
下了程序后可以观察到这个效果，但是拷贝以上图片，存为BMP是没有意义的。<br/><br/><font color="#0000ff">二。LSB？？</font><br/><br/>
Least Significant Bit 。<br/>
 因为8位来表示的颜色的低位的改变对人眼来说很不明显，<br/>
于是可以在这些低位做点文章。<br/><br/>
生成一些特征码放到这些位置上。<br/>
收回图片的时候，按相同的规则检查特征码，不同的认为已经被修改。<br/>
于是就做好<font color="#ff0000">数字水印</font>了。<br/><br/>
把要隐藏的文件进行按位分割，依次放到（或加密后放到）这些低位。<br/>
提取的时候，只是个逆过程。这样就做好<font color="#ff0000">信息隐藏</font>了。<br/><br/>
简单吧。。所以说LSB是最容易实现的一种数字水印算法。<br/><br/>
详细的内容在上面的包里有程序，附有当时一个戳瓢的PPT。<br/><br/><font color="#0000ff">三。细节提示</font></div>


<p><font color="#ff6600">myBits类：<br/></font><br/>
是为了更方便地实现位操作。<br/>
可以插入一定的比特数，或者取出一定的比特数。<br/><br/>
（这难道不是一个很简单的事吗？需要一个类？<br/>
呵呵。。我最初想的一样。。但是写了一半写囧了。。<br/>
于是老老实实把这个功能封装好，一上架就全通了。。）<br/><br/><font color="#ff6600">myBmpInfo类：</font><br/><br/>
这个类处理有关位图信息。<br/>
比如读取位图信息，把占有的位图信息写入另一个文件。<br/>
其他一些诸如显示图像和信息的在后面就没有用到了，<br/>
这些功能只是最初做这个类的时候的一个尝试。<br/><br/>
（我猜有比较成熟的函数或者类来处理这些砸碎吧。。<br/>
也没去查他们了，因为当时正好研究BMP的格式。。就很暴力地自己写了个用）<br/><br/><font color="#ff6600">myBmpCode类：</font><br/><br/>
实现水印嵌入提取和信息隐藏提取的类。内含一个myBmpInfo。<br/><br/>
除了这几个类就只是界面的一些问题了。。<br/><br/>
这几个类拿到控制台下也可以用，<br/>
像myBmpInfo里面的在CWnd中显示之类的函数去掉就可以了。<br/><br/>
毕竟没时间把注释写得特详细，再说这东西比较简单，就这样差不多了吧。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/04/26/%E6%A0%87%E5%AE%9A%E7%BB%98%E5%9B%BE%E4%BD%8D%E7%BD%AE%E7%9A%84%E4%B8%80%E7%A7%8D%E8%AE%BE%E8%AE%A1%EF%BC%88VC6.MFC.CWnd.GetWindowPlacement%29/">标定绘图位置的一种设计（VC6.MFC.CWnd.GetWindowPlacement)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-04-26T21:21:00+08:00" pubdate data-updated="true">Apr 26<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline) 2009.4.26<br/><br/>
比如现在要实现这样的功能：<br/><br/><font color="#ff6600">我们在某个窗口上绘图，图形的相对位置是可以在设计时改变的。</font><br/><br/>
当然我们可以在绘图函数里面写上一个偏移。<br/>
或者把这个偏移定义为某些常量，然后根据设计的需要来更改。<br/><br/>
这个就有点像创建一个CButton对象，调用他的Create。<br/>
在该函数里面指定创建出按钮的坐标。<br/>
然后当我更改界面的时候，就去修改这句创建按钮的语句。<br/><br/>
功能虽然达到了，可是这样就很麻烦。<br/><br/>
好比在处理按钮这个问题上，MFC允许我们在对话框中“画”出这个按钮。<br/>
我们更改界面的时候，只需要去拖动他就行了。<br/><br/>
那么，我上面提到的绘图应该也能找到一种类似的方法。<br/><font color="#ff6600">这种方法使得我们设计相关绘图函数的时候，多考虑一些细节。<br/>
而改变界面的时候，也能通过&#8221;拖动“这样的操作来实现，</font><br/>
而无需修改绘图的函数，<font color="#ff0000">这显然规避修改代码带来的风险</font>。<br/><br/>
想了一下，可以像下面这样做：用 CStatic标定一个位置，作为我们绘图开始的左上角<br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/5de26406a22f5a58030881ac.jpg" small="0" class="blogimg"/><br/><br/>
而绘图函数这样写：<br/><font color="#ff6600">假设该标签的ID为IDC_MARK。</font><br/><br/>
     CStatic <em>pstatic = (CStatic</em>) GetDlgItem(IDC_MARK) ;<br/>
     RECT rect ;<br/>
     WINDOWPLACEMENT wp ;<br/>
     pstatic-&gt;GetWindowPlacement(&amp;wp) ;<br/>
     rect = wp.rcNormalPosition ;<br/>
     rect.right = rect.left + 100 ;<br/>
     rect.bottom = rect.top + 100 ;<br/>
     dc.Rectangle(&amp;rect);<br/><br/>
效果如下：<br/><br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/5adca6af3866f3ef7dd92aac.jpg" small="0" class="blogimg"/></div></p>

<br/>


<p>要绘制其他的图形，也可以加上rect的左上角的偏移即可。<br/><br/>
之后，我们无需再动这个绘图函数了，把标签拖到我们想要的地方即可。<br/>
（<font color="#ff0000">当然，开发完成后，把这个标签设置成不可见就行了</font>）<br/><br/>
这段代码看起来轻巧。。还是搞了我很久。。<br/><br/>
开始只知道有GetWindowRect和GetClientRect。<br/>
结果这两个得到的区域都不能满足要求。。<br/><br/>
又仔细看了MSDN，淘宝到了GetWindowPlacement这个函数。<br/><br/>
那么附上这三个函数的区别：<br/><font color="#0000ff">GetWindowRect</font>得到的是相对于整个屏幕的区域<br/><font color="#0000ff">GetClientRect</font>得到的是该窗体的客户区，（返回的左上坐标始终为0，0）<br/><font color="#0000ff">WINDOWPLACEMENT </font>结构的<font color="#0000ff">rcNormalPosition</font> 标定的区域是相对父窗口的客户区而言的。</div></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/04/24/%E5%B0%BD%E9%87%8F%E9%81%BF%E5%85%8Dstackoverflow%E7%9A%84quicksort%E7%9A%84%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95/">尽量避免stack Overflow的quick Sort的一种写法</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-04-24T21:39:00+08:00" pubdate data-updated="true">Apr 24<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.4.24<br/><br/>
关于quick sort，人类给出了不少讨论。<br/>
有讲median of three的，有讲蒙特卡罗优化的，有讲intro-sort的。<br/><br/>
而最近在STL里面淘宝。。很火星地发现了qsort的另外一种写法。<br/>
那一处候老师的批注是<font color="#ff0000">可读性较差</font>。。<br/>
我也这么认为，不过仔细一想，发现科学家毕竟就是科学家。。<br/>
问题考虑得如此之细致。<br/><br/>
这里我不会关注其他方面的优化，仅仅是说一下这个可以尽量<font color="#ff0000">避免stack overflow</font>的写法<br/><br/>
先给出一个以前很常用的写法。<br/><br/><font color="#ff6600">//对[first , last)区间排序<br/>
void qs( int <em>first , int </em>last ){<br/>
     int <em>i , </em>j ;<br/>
     i = first ; <br/>
     j = last - 1 ;<br/>
     if ( i &gt;= j ) return ;<br/>
     int t = <em>first ;<br/>
     while ( i &lt; j ){<br/>
          while ( i &lt; j &amp;&amp; t &lt;= </em>j ) j &#8211; ;<br/>
          <em>i = </em>j ;<br/>
          while ( i &lt; j &amp;&amp; <em>i &lt;= t ) i ++ ;<br/>
          </em>j = <em>i ;<br/>
     }<br/>
     </em>i = t ;<br/>
     qs(first , i) ;<br/>
     qs(i + 1 , last) ;<br/>
}</font><br/><br/>
这个写法应该说很好懂的。估计搞OI和ACM的人都能瞬间拍出来。<br/><br/>
而提到qsort。人们常喜欢讨论的是在数据几乎有序的情况下，时间有多糟糕。<br/><br/>
其实，再怎么糟糕也是n<sup>2的。而少有人提到的但更糟糕的其实是&lt;font</sup> color=&#8221;#ff0000&#8221;>stack overflow</font>。<br/><br/>
比如在我机器上，跑10000的数组上面那算法就爆堆栈了。（跟具体环境有关系）<br/>
但是，下面将给出的改造的qsort，同样也是蜕化到n<sup>2，瞬间出解。<br/><br/></sup>
也就是，在某些情况下，爆堆栈比耗时间更严重。<br/>
于是要想办法改进。。<br/><br/>
那么，仿照STL中sort的写法，给出一个下面的版本：<br/>
（说仿照，因为STL的sort还有许多其他优化，而我这里关注的是其中一点，<br/>
于是就把核心思想提取出来了）<br/><br/><font color="#ff6600">//对[first , last)区间排序<br/>
void qs2( int <em>first , int </em>last ){<br/>
     int <em>i , </em>j ;<br/>
     while ( first &lt; last ){<br/>
          int t = <em>first ; <br/>
          i = first ; <br/>
          j = last - 1 ;<br/>
          while ( i &lt; j ){<br/>
               while ( i &lt; j &amp;&amp; t &lt;= </em>j ) j &#8211; ;<br/>
               <em>i = </em>j ;<br/>
               while ( i &lt; j &amp;&amp; <em>i &lt;= t ) i ++ ;<br/>
               </em>j = <em>i ;<br/>
          }<br/>
          </em>i = t ;<br/>
          if ( i - first &lt; last - i ){<br/>
               qs2( first , i ) ;<br/>
               first = i + 1 ;<br/>
          }else{<br/>
               qs2( i + 1 , last ) ;<br/>
               last = i ;     <br/>
          }<br/>
     }<br/>
} </font><br/><br/>
其中的主要优化，就在于用：<br/><br/><font color="#ff6600">         if ( i - first &lt; last - i ){<br/>
               qs2( first , i ) ;<br/>
               first = i + 1 ;<br/>
          }else{<br/>
               qs2( i + 1 , last ) ;<br/>
               last = i ;     <br/>
          }</font><br/><br/>
去代替了原来的递归。<br/><br/>
优化前，是对分区后的左段和右段分别递归。<br/>
那么，数据有序时，会向右递归n层下去，显然是个很大的数字。<br/>
爆堆栈太正常了。<br/><br/>
改进的算法先进行判断，然后递归排序短的那一段，<br/>
同时修改原来标定的[first,last)区间，得以在同一层递归中再次对新区间排序。<br/>
因为选的是较小的一层递归，所以总层数一定不会超过log(n)的。<br/><br/>
所以有的时候，我们不仅要关注一个抽象级别的时间和空间复杂度。<br/>
也要注意编码上的优化，要考虑到机器的实际运行情况。。<br/><br/>
一点小小的改动，使得可以应对的数据增长了相当之多<br/>
（从耗栈的角度考察。。如果要从时间上说，当然还需要其他优化）<br/><br/>
再次膜拜科学家。。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/04/22/list.sort%28greater%26%2360%3BT%26%2362%3B%29%E7%9A%84%E7%94%A8%E6%B3%95%28DEV-C%2CVC6%29%28vc6.errorc2934%29/">list.sort(greater&#60;T&#62;)的用法(DEV-C,VC6)(vc6.error C2934)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-04-22T14:08:00+08:00" pubdate data-updated="true">Apr 22<span>nd</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.4.22<br/><br/>
纠结了若干天的问题终于在无意中搞定了。<br/><br/>
在STL中，排序是个很重要的话题。<br/><br/><font color="#ff6600">1.algorithm 里的sort()只接收RandomAccessIterator<br/>
用于像vector,dequeue的排序<br/><br/>
2.像set,map，这种关联式容器，本身就由RBTree维护了有序，只要遍历一遍就行了。<br/><br/>
3.而list比较特殊一点，由于只有BidirectionalIterator。而又不本身有序。<br/>
所以该容器自带了一个用来排序的函数。</font><br/><br/>
现在有个问题，如果在list里面存的是char<em>的元素。<br/>
那么排序的时候，就会按照指针的大小来排。<br/>
而如果我们本来用char</em>来表达一个字符串的话，这样就不符合要求了。（见下例输出1）<br/><br/>
而list.sort有一个带参数的用法。<br/>
可以设计一个函数（如下的mycmp），传给list.sort。<br/><br/>
这种用法我一直感觉很纠结，因为list.sort的参数是<br/>
greater&lt;T&gt;<br/>
也就是一个functor(函数对象，函子，仿函数），本质上是一个类。<br/>
而把函数名（本质上是个指针）传进去做参数。。。居然也可以。。<br/><br/>
从我们使用的语义上来说，似乎是可以的，因为functor传进去了之后，<br/>
会调用该类的“（）”操作符，也就是我们会把他视作一个函数来使用。<br/>
可是明明他们就是不同的东西。。。<br/><br/>
这种用法在DEV-C下可以通过。（貌似VS也可以）<br/><br/><font color="#0000ff">在DEV-C下的例子</font>：<br/><br/></p>

<h1>include &lt;iostream&gt;<br/></h1>

<h1>include &lt;list&gt;<br/></h1>

<h1>include &lt;string.h&gt;<br/></h1>

<h1>include &lt;iterator&gt;<br/><br/></h1>

<p>using namespace std;<br/><br/>
char <em>ss[] = { &#8220;bb&#8221; , &#8220;aa&#8221; , &#8220;cc&#8221; , &#8220;ee&#8221; , &#8220;dd&#8221; } ;<br/><br/>
bool mycmp( char </em>&amp;s1 , char <em>&amp;s2){<br/>
      return strcmp(s1 , s2) == -1 ;<br/>
}<br/><br/>
int main(){<br/>
      list&lt;char</em>&gt; l(ss , ss + sizeof(ss) / sizeof(char<em>)) ;<br/>
      ostream_iterator&lt;char</em>&gt; oit(cout , &#8221; &#8220;) ;//构造输出迭代器 <br/>
      copy( l.begin() , l.end() , oit) ;cout&lt;&lt;endl;//输出原序列 <br/>
      l.sort() ;//默认的排序，其实是按指针大小排序 <br/>
      copy( l.begin() , l.end() , oit) ;cout&lt;&lt;endl;//输出1 <br/>
      l.sort(<font color="#ff0000">mycmp</font>);//传入函数指针的排序 <br/>
      copy( l.begin() , l.end() , oit) ;cout&lt;&lt;endl;//输出2 <br/>
      system(&#8220;pause&#8221;);<br/>
      return 0 ;<br/>
}<br/><br/><font color="#0000ff">输出：</font><br/><br/>
bb aa cc ee dd<br/>
bb aa cc ee dd<br/>
aa bb cc dd ee<br/><br/>
可见不带参数的是按指针从小到大排序的。<br/><br/>
而这段在<font color="#ff0000">VC6</font>里就会报错，即使把mycmp加上<font color="#ff0000">ptr_fun</font>的修饰也不行。<br/><br/>
主要是list的sort参数实在太奇怪了。<br/>
STL里面有很多函数提供两个版本，其中一个以默认方式进行比较，<br/>
另一个版本可以允许传入一个functor，以该functor进行比较。<br/><br/><font color="#ff0000">而这个list.sort直接限定死了传进去的是greater&lt;T&gt;</font><br/><br/>
比如，我们直接设计一个functor<br/><br/>
struct c{<br/>
      operator()(char <em>&amp;s1 , char </em>&amp;s2){<br/>
            return strcmp(s1,s2) == -1 ;<br/>
      }<br/>
};<br/><br/>
后面调用：l.sort(c());<br/><br/><font color="#0000ff">编译器会给出下面的信息：</font><br/><br/>
cannot convert parameter 1 from &#8216;struct c&#8217; to &#8216;struct std::greater&lt;char <em>&gt;&#8217;<br/>
          No constructor could take the source type, or constructor overload resolution was ambiguous<br/><br/>
其实就是类型不匹配。。。-_-编译器只认greater这个functor。<br/><br/>
虽然我们可以改变greater的实现，但是那样，把代码复制到其他地方，<br/>
执行的结果肯定就不一样了。。。<br/><br/>
就是这里纠结了很久。。后来终于不小心搞定了，用<font color="#ff0000">特化</font>！！<br/><br/>
像下面这样：（代码直接从泛化的greater复制过来，做相应修改就可以了）<br/><font color="#ff6600"><br/>
      struct greater&lt;char</em>&gt; : binary_function&lt;char<em>, char</em>, bool&gt; {<br/>
      bool operator()(const char<em>&amp; _X, const char</em>&amp; <em>Y) const<br/>
            {return (strcmp(</em>X,_Y) == -1); }<br/>
      };</font><br/><br/>
在DEV里面，全特化要求加入 template&lt;&gt;开头，VC里面可以不加。<br/><br/>
那么后面直接这样调用就可以了：l.sort(greater&lt;char<em>&gt;()) ;<br/><br/>
这时编译器选择的就不是前面泛化的greater了，就是我们量身定做的char</em> 的greater。<br/><br/>
且慢，在VC6里面还要报错。<br/><br/><font color="#ff0000">error C2934: &#8216;greater&lt;char *&gt;&#8217; : template-class-id redefined as a nested &#8216;struct&#8217; of &#8216;&lt;Unknown&gt;&#8217;</font><br/><br/>
又是这个东西。。让我一直没有搞定。。网上也没找到相应的解决方案。<br/><br/>
今天突然发现了。。<font color="#ff0000">namespace</font>的问题。因为greater是定义在std里面的。。<br/>
汗啊。。感觉这报错好没提示性。。于是一改果然可以了。<br/><br/><font color="#0000ff">下面这份代码和前面的差不多。在VC6下运行正常：</font><br/><br/>
相信通过前面的解释能够很容易明白。<br/><br/></p>

<h1>include &lt;iostream&gt;<br/></h1>

<h1>include &lt;list&gt;<br/></h1>

<h1>include &lt;string.h&gt;<br/></h1>

<h1>include &lt;algorithm&gt;<br/></h1>

<h1>include &lt;vector&gt;<br/><br/></h1>

<p>using namespace std;<br/><br/>
char <em>ss[] = { &#8220;bb&#8221; , &#8220;aa&#8221; , &#8220;cc&#8221; , &#8220;ee&#8221; , &#8220;dd&#8221; } ; <br/><br/><font color="#ff0000">namespace std{</font><br/>
      struct greater&lt;char</em>&gt; : binary_function&lt;char<em>, char</em>, bool&gt; {<br/>
      bool operator()(const char<em>&amp; _X, const char</em>&amp; <em>Y) const<br/>
            {return (strcmp(</em>X,_Y) == -1); }<br/>
      };<br/><font color="#ff0000">}</font><br/><br/>
int main(){<br/>
      list&lt;char<em>&gt; l(ss , ss + sizeof(ss) / sizeof(char</em>)) ;<br/>
      ostream_iterator&lt;char<em>&gt; oit(cout , &#8221; &#8220;) ;<br/>
      copy( l.begin() , l.end() , oit) ;cout&lt;&lt;endl;<br/>
      l.sort() ;<br/>
      copy( l.begin() , l.end() , oit) ;cout&lt;&lt;endl;<br/>
      l.sort(greater&lt;char</em>&gt;()) ;<br/>
      copy( l.begin() , l.end() , oit) ;cout&lt;&lt;endl;<br/>
      return 0 ;<br/>
}</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/04/19/%E4%B9%8C%E9%BE%9F%E8%B7%AF%E7%BA%BF/">乌龟路线</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-04-19T18:45:00+08:00" pubdate data-updated="true">Apr 19<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.4.19<br/><br/>
今天跑去传源码，翻出来了这么个东西，<br/>
用到的算法确实很简单，不过当时是才学在VC下的DC的使用，不太熟。<br/><br/>
那天是在百度知道上看到有人在问，于是用VC做了个出来。<br/><br/><font color="#0000ff">所谓乌龟路线：</font><br/>
把四个乌龟放在正方形的四个角上，<br/>
第i个乌龟始终朝着(i + 1) % 4号乌龟走。<br/><br/>
那么你能想出来是什么样子吗？<br/><br/>
其实就是：<br/><br/><div forimg="1"><a href="http://hiphotos.baidu.com/hplonline/pic/item/1dd98d44a9d3e26e500ffe5c.jpg" target="_blank"><img height="200" width="199" border="0" src="http://hiphotos.baidu.com/hplonline/abpic/item/1dd98d44a9d3e26e500ffe5c.jpg" small="1" class="blogimg"/></a></div></p>

<br/>


<p>在VC里创建一个DLG程序，加一个按钮。<br/>
双击写代码。红色的是你自己的DLG类名和按钮函数名。<br/><br/>
算法就是迭代法。给定一个初始状态，然后按照很小的步长，模拟乌龟的运动。。。<br/><br/></p>

<h1>include &lt;math.h&gt;<br/><br/><font color="#ff0000">void CMy9Dlg::OnButton1() </font><br/></h1>

<p>{<br/><br/></p>

<h1>define sqr(x) (x)*(x) <br/><br/></h1>

<p>      typedef struct pt_type{<br/>
            double x,y ;<br/>
      }myPOINT;<br/><br/>
      const double EDGE = 300 ; //the length of each side of the square<br/>
      const double VEL = 2 ; //magnitude of the velocity<br/>
      const double DT = 0.01 ;//the unit time of iteration<br/>
      const int N = 30000 ; //the iteration times<br/>
      <br/>
      myPOINT turtle[4] = {<br/>
            {0,0},{EDGE,0},{EDGE,EDGE},{0,EDGE}<br/>
      };//the position<br/>
      myPOINT last[4]= {<br/>
            {0,0},{EDGE,0},{EDGE,EDGE},{0,EDGE}<br/>
      };//the previous position<br/>
      myPOINT velocity[4] = {<br/>
            {VEL,0},{0,VEL},{-VEL,0},{0,-VEL}<br/>
      };//the heading direction<br/>
      <br/>
      int i;<br/>
      CClientDC dc (this);<br/>
      <br/>
      dc.Rectangle(0,0,EDGE,EDGE);<br/><br/>
      for (int n = 0 ; n &lt; N ;n ++){<br/>
            //paint the route<br/>
            for (i = 0 ; i &lt; 4 ; i ++){<br/>
                  dc.MoveTo(int(last[i].x),int(last[i].y));<br/>
                  dc.LineTo(int(turtle[i].x),int(turtle[i].y));<br/>
                  last[i] = turtle[i];<br/>
            }<br/>
            //iterates for next state<br/>
            for (i = 0 ;i &lt; 4; i ++){<br/>
                        turtle[i].x += DT * velocity[i].x ;<br/>
                  turtle[i].y += DT * velocity[i].y ;<br/>
                  int j = (i + 1) %4;<br/>
                  double mag = sqrt ( sqr(turtle[j].x-turtle[i].x) + sqr(turtle[j].y-turtle[i].y) );<br/>
                  velocity[i].x = VEL / mag * (turtle[j].x-turtle[i].x);<br/>
                  velocity[i].y = VEL / mag * (turtle[j].y-turtle[i].y);<br/>
            }<br/>
      }<br/>
}</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/04/18/STL%E7%9A%84%E6%95%88%E7%8E%87%E7%9A%84%E6%84%9F%E5%8F%97%E4%BB%A5%E5%8F%8A%E6%94%B9%E8%BF%9B%EF%BC%88%E6%94%B9%E5%8F%98%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A0%87%E5%BF%97%E4%BB%A5%E8%B0%83%E7%94%A8%E4%B8%8D%E5%90%8C%E7%AE%97%E6%B3%95%EF%BC%89%EF%BC%88VC6%E6%93%8D%E4%BD%9C%E5%AE%9E%E8%B7%B5%EF%BC%89/">STL的效率的感受以及改进（改变迭代器标志以调用不同算法）（VC6操作实践）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-04-18T21:31:00+08:00" pubdate data-updated="true">Apr 18<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.4.18<br/><br/>
还只看了一小部分STL的源码，已经对他的效率处理感到惊愕了。。<br/><font color="#ff0000">世界上居然有这么精打细算的东西</font>。。。（虽然也有失误，后面会看到）<br/><br/>
众所周知的copy这样出名的例子，对效率的考虑很详细，讨论也很多了。<br/>
我这里拿来试一下的是rotate这个函数。<br/><br/>
基本用法是rotate(b,m,e)<br/>
这样会把[b,m),[m,e)区间进行交换。<br/><br/>
这个功能是很简单的，初学程序的时候估计很多人都练习过。<br/>
在许多面试题里面，也经常见到让你用常数的辅助空间来解决这个问题。<br/><br/>
算法我会在后面拿出来讨论，STL的实现对<font color="#ff0000">三种</font>不同的迭代器使用了不同的算法。<br/>
（其中对random_access_iterator的实现很不错，效率也是最高的，同时也没怎么看到有人讨论他）<br/><br/><font color="#0000ff">测试程序：</font><br/><br/></p>

<h1>include &lt;iostream&gt;<br/></h1>

<h1>include &lt;algorithm&gt;<br/></h1>

<h1>include &lt;time.h&gt;<br/><br/></h1>

<p>using namespace std;<br/><br/>
int a[10000] ;<br/><br/>
int main(){<br/>
      int tt = clock() ;  <br/>
      int i;      <br/>
      for ( i = 0 ; i &lt; 1000 ; i ++ )<br/>
            rotate(a , a + 5000 , a + 10000 ) ;<br/>
      printf(&#8220;%d\n&#8221;,clock() - tt );<br/>
      return 0 ;  <br/>
}<br/><br/><font color="#ff0000">下面是很关键的部分，需要拿出胆量，因为我们现在要去改STL的源码了</font>。。。<br/>
（我的所有操作是在VC6下做的，其他地方由于采用的STL版本不一样，会有出入）<br/><br/>
改之前先到VC6的include目录下备份<font color="#ff0000">UTILITY</font>这个文件。<br/>
（这是显然的，如果改戳了好恢复啊。。）<br/><br/>
那么开始，为了找到相应的函数，<br/>
在vc里面本来可以在rotate上点右键，然后go to definition of rotate这样。<br/>
我操作的时候老是跑到不知道哪里去，所以换个方法。<br/><br/>
直接进行跟踪。<font color="#ff0000">先跟进rotate</font>。来到这里：<br/><br/>
template&lt;class <em>FI&gt; inline<br/>
      void rotate(</em>FI <em>F, </em>FI <em>M, </em>FI <em>L)<br/><font color="#ff6600">      {if (</em>F != <em>M &amp;&amp; </em>M != <em>L)</font><br/>
            </em>Rotate(<em>F, </em>M, <em>L, </em>Iter_cat(<em>F)); }<br/><br/>
光标停在标黄的一行。<br/>
该函数调用了</em>Rotate。而<em>Rotate前面的参数就是照搬rotate的参数。<br/><br/>
关键的地方就在于最后一个参数。这个参数决定了将去向哪个函数。<br/><br/>
</em>Iter_cat是iterator category的缩写。<br/><br/>
这时候向下面浏览一下，有三个函数：<br/><br/>
      void <em>Rotate(</em>FI <em>F, </em>FI <em>M, </em>FI <em>L,<br/>
            forward_iterator_tag)<br/><br/>
      void </em>Rotate(<em>BI </em>F, <em>BI </em>M, <em>BI </em>L,<br/>
            bidirectional_iterator_tag)<br/><br/>
      void <em>Rotate(</em>RI <em>F, </em>RI <em>M, </em>RI <em>L,<br/>
                  random_access_iterator_tag)<br/><br/>
他们也只有最后一个参数有区别，就是上面的</em>Rotate根据迭代器标志（iterator_tag）选择的去向。<br/><br/>
然后继续跟进，会到<font color="#ff0000"><em>Iter_cat(</font><br/><br/>
template&lt;class </em>Ty&gt; inline<br/>
      <font color="#ff0000">random_access_iterator_tag</font> <strong>cdecl <em>Iter_cat(const </em>Ty <em>)<br/>
      {<font color="#ff0000">random_access_iterator_tag</font> _RandIterTag;<br/>
       <font color="#ff0000">random_access_iterator_tag</font></em> <em>pRandIterTag;<br/>
      </em>pRandIterTag = &amp;<em>RandIterTag;      // Workaround for C4700 warning<br/><br/>
到达的这个位置其实是</em>Iter_cat的一个特化版本。<br/>
因为我们调用rotate的时候传的是原生指针，<br/>
而原生指针都是<font color="#ff0000">random_access_iterator。</font>所以这里将返回一个random_access_iterator_tag。<br/><br/>
根据前面对<em>Rotate的考察，发现他对下面三种迭代器给出了各自的版本：<br/><font color="#ff6600">forward_iterator_tag<br/>
bidirectional_iterator_tag <br/>
random_access_iterator_tag </font><br/>
（这几个迭代器从上到下是派生关系，也就是如果满足下面的标志，那么一定也可以是上面的）<br/><br/>
于是我们现在把上面</em>Iter_cat中标红的部分依次替换成这几个迭代器标志，<br/>
如：<br/><br/>
template&lt;class _Ty&gt; inline<br/>
      <font color="#ff0000">bidirectional_iterator_tag</font> </strong>cdecl <em>Iter_cat(const </em>Ty <em>)<br/>
      {<font color="#ff0000">bidirectional_iterator_tag</font> _RandIterTag;<br/>
       <font color="#ff0000">bidirectional_iterator_tag</font></em> <em>pRandIterTag;<br/>
      </em>pRandIterTag = &amp;<em>RandIterTag;      // Workaround for C4700 warning<br/>
      return (</em>RandIterTag); }<br/><br/>
这样，分别改成三种，并运行前面的测试程序。得到一个时间。<br/>
三个的时间如下：<br/><br/>
forward_iterator_tag <font color="#ff6600">325</font><br/>
bidirectional_iterator_tag<font color="#0000ff"> </font><font color="#0000ff">665</font><br/>
random_access_iterator_tag <font color="#ff6600">110</font><br/><br/>
可见，三个算法确实效率不同，能用random_iterator的地方，绝对不应该调用前面两种算法。<br/><br/>
可是<font color="#ff0000">这里却似乎是一个败笔</font>。<br/>
我们明显的看到bidirectional_iterator_tag比forward_iterator_tag慢。<br/><br/>
而能够给forward_iterator_tag用的算法，是一定可以给bidirectional_iterator_tag用的。<br/>
那当时为什么给bidirectional_iterator_tag单独设计出一个算法呢？<br/>
况且这个算法还要慢一些。。。<br/><br/>
当然，这只是我的一家之言，也许在其他地方的测试结果不是如此。<br/><br/>
那么，如果在大多数情况下的测试皆是如此，为了达到最大效率。<br/>
可以直接把下面的函数注释掉：<br/><br/><font color="#339966">/<em>template&lt;class <em>BI&gt; inline<br/>
      void </em>Rotate(<em>BI </em>F, <em>BI </em>M, <em>BI </em>L,<br/>
            bidirectional_iterator_tag)<br/>
      {reverse(<em>F, </em>M);<br/>
      reverse(<em>M, </em>L);<br/>
      reverse(<em>F, </em>L); }</em>/</font><br/><br/>
这是不会出问题的，因为bidirectional_iterator_tag出现时，<br/>
没有找到完全匹配的，会找一个他的基类迭代器标志，于是会进入<br/>
forward_iterator_tag_tag的处理函数。<br/><br/><font color="#0000ff">总结：</font><br/><br/>
STL确实是很精当的东西，不过圣人千虑，必有一失。<br/><br/>
同时，通过这次操作，增加了胆量，满足了动手欲望。。。<br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/04/18/%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E5%B9%B6%E7%AD%89%E5%BE%85%E7%BB%93%E6%9D%9F/">创建进程并等待结束</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-04-18T20:21:00+08:00" pubdate data-updated="true">Apr 18<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.4.18<br/><br/>
最近搞图论的作业，有两个算法要比较。<br/><br/>
当然是写一个judge出来，产生不同的数据，然后调用执行两个程序。<br/><br/>
比较输出的优越性和执行时间。<br/><br/>
一开始直接用WinExec运行，没管那么多。<br/>
试运行一遍，发现数据全错，吓我一跳，因为两个算法程序我也是用大数据测试过的。<br/><br/>
才想起要等待结束后才能继续执行。<br/>
否则大家一起乱搞输出文件，就弄乱了。<br/><br/>
所以需要这么一个函数。<font color="#ff6600">创建进程并等待执行结束</font>。<br/><br/>
翻了下MSDN，上面正好有个例程，把需要的部分提取了一下，就是下面这个样子了。<br/><br/>
void RunAndWait(char *filename){<br/>
     PROCESS_INFORMATION pi ;<br/>
     STARTUPINFO si ;<br/>
     ZeroMemory( &amp;si, sizeof(si) );//初始化为0<br/>
     si.cb = sizeof(si);//cb是指定结构体的长度<br/>
     ZeroMemory( &amp;pi, sizeof(pi) );//初始化为0<br/>
     CreateProcess(filename, NULL, NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, &amp;pi) ;//创建进程<br/>
     WaitForSingleObject( pi.hProcess, INFINITE );//等待结束<br/>
     CloseHandle( pi.hProcess );//消除句柄<br/>
     CloseHandle( pi.hThread );     <br/>
}<br/></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/backup-hplonline/blog/page/19/">&larr; Older</a>
    
    <a href="/backup-hplonline/blog/archives">Blog Archives</a>
    
    <a class="next" href="/backup-hplonline/blog/page/17/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/backup-hplonline/blog/2013/05/04/test/">Test</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/04/09/%E5%86%8D%E8%B0%88stl%E7%9A%84rotate/">再谈stl的rotate</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%BA%8C%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、二）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%89%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、三）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%80%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、一）</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - hplonline -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
