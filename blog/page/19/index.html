
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>hplonline</title>
  <meta name="author" content="hplonline">

  
  <meta name="description" content="(hplonline)2009.4.16
很早听说过SOLLIN这个算法，虽然说起来有那么点意思，
但是总觉得实现上常数会很大，也就一直没动。
另外在OI界和ACM界，MST的应用很广泛的，但很很少看到人用这个算法。
最近的图论课要做PROJECT，老师上课也提到了这个算法。
于是搞了个出来， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hupili.github.io/backup-hplonline/blog/page/19">
  <link href="/backup-hplonline/favicon.png" rel="icon">
  <link href="/backup-hplonline/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/backup-hplonline/atom.xml" rel="alternate" title="hplonline" type="application/atom+xml">
  <script src="/backup-hplonline/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/backup-hplonline/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/backup-hplonline/">hplonline</a></h1>
  
    <h2>backup from 2006 to 2012 (original hi.baidu.com/hplonline/)</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/backup-hplonline/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hupili.github.io/backup-hplonline" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/backup-hplonline/">Blog</a></li>
  <li><a href="/backup-hplonline/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/04/16/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88KRUSCAL%2CPRIM%E6%80%9D%E6%83%B3%E5%8F%8ASOLLIN%E5%AE%9E%E7%8E%B0%29/">最小生成树（KRUSCAL,PRIM思想及SOLLIN实现)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-04-16T20:46:00+08:00" pubdate data-updated="true">Apr 16<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.4.16<br/><br/>
很早听说过SOLLIN这个算法，虽然说起来有那么点意思，<br/>
但是总觉得实现上常数会很大，也就一直没动。<br/><br/>
另外在OI界和ACM界，MST的应用很广泛的，但很很少看到人用这个算法。<br/><br/>
最近的图论课要做PROJECT，老师上课也提到了这个算法。<br/>
于是搞了个出来，总得来说，这个实现只是描述了算法的意思，<br/>
其常数非常非常大，而且相关的数据都用STL来组织，偷点懒。<br/><br/>
KRUSCAL和PRIM相信网上到处都是，就只提思想了。<br/>
SOLLIN因为第一次写，给一个CP的实现（没有交过题，不确定正确性和效率）<br/><br/><font color="#0000ff">一。最小生成树的条件</font><br/><br/>
树上边：在最小生成树上的边<br/><br/>
非树上边：不在最小生成树上的边<br/><br/>
树上路径：最小生成树上两点间的唯一路径<br/><br/><font color="#ff0000">路径最优：任一非树上边的权重都大于它所对应的树上路径上的每条边的权重。<br/>
（否则用该边形成的生成树权重更小）</font><br/><br/>
割边：任意树上边把树分为两部分，连接该两部分的边为割边<br/><br/><font color="#ff0000">割最优：任一树上边的权重都小于它所对应的割集中每条边的权重。<br/>
（否则用比该边小的割边来连接成的生成树更小）</font><br/><div class="O"></p>

<div style="text-align: center;"> </div>


<p></div></p>

<br/><font color="#0000ff">二。KRUSCAL</font><br/><br/><font color="#ff6600">KRUSCAL：根据路径最优构造。</font><br/><br/><font color="#0000ff">算法1</font>：（直观）<br/>


<p>先随便构造一个树，依次检查非树上边，<br/>
如果发现破坏路径最优条件，即用该边替换一个比他大的树上边。<br/><br/>
这个算法，可以描述，但是写出来很慢。要改进<br/><br/><font color="#0000ff">算法2</font>：（换个角度，即KRUSCAL）<br/>
把所有边从小到大排序，依次加入边集。<br/>
如果某边加入后成环了（非树），则PASS掉。<br/><br/>
这样在加边的时候，因为从小到大，自然保证了路径最优。<br/><font color="#0000ff"><br/>
三。PRIM</font><br/><br/><font color="#ff6600">PRIM：根据割最优</font><br/><br/><font color="#0000ff">算法3</font>：（就是PRIM）<br/><br/>
假设现在已经有了一棵包含某些点的树了，<br/>
要把它和剩下的点连起来，从该树有许多割边指出，<br/>
那么根据割最优条件，选取最小的一个，一定在树上，<br/>
同时该树上的点增加一个。<br/><br/>
初始的时候随便选一个点就可以了。<br/><br/><font color="#0000ff">四。SOLLIN</font><br/><br/><font color="#0000ff">算法4：其实还是根据割最优</font><br/><br/>
该算法的核心在于。不是像PRIM选择一颗树，逐步扩大。<br/>
他一开始把所有的点做成独立的树，形成一个森林。<br/>
根据割最优条件，从这些树指出的割边一定是在MST上的。<br/>
于是把这些边都加入MST的边集，同时合并相连的树。<br/>
重复到只有一棵树为止。<br/><br/>
思想上感觉很有前途。实现的时候要考虑不少东西。<br/>
比如怎样表示树？怎样表示森林？<br/>
每次搜索出来的最小割边集有重复的，怎样避免多次加入？<br/>
。。。<br/><br/><font color="#ff6600">当然，我捡懒不想了，用了很庞大的一堆STL的组件来做。<br/>
下面这个代码显然没有实用价值，他只能表达一种意思。</font><br/><br/></p>

<h1>include &lt;iostream&gt;<br/></h1>

<h1>include &lt;set&gt;<br/></h1>

<h1>include &lt;vector&gt;<br/></h1>

<h1>include &lt;list&gt;<br/></h1>

<h1>include &lt;algorithm&gt;<br/></h1>

<h1>include &lt;fstream&gt;<br/><br/></h1>

<h1>pragma warning(disable: 4786)<br/><br/></h1>

<p>using namespace std;<br/><br/>
const int MAX = 10000000 ;<br/><br/>
typedef set&lt;int&gt; TREE ;<br/>
typedef set&lt;TREE&gt; FOREST ;<br/>
typedef list&lt;int&gt; ADJEDGE ;//邻接边，记录的是vedges中该边的下标<br/>
typedef vector&lt;ADJEDGE&gt; ADJLIST ;//邻接表<br/><br/>
typedef struct _edge_type{<br/>
      int a ;<br/>
      int b ;<br/>
      int w ;<br/>
}EDGE ;<br/><br/>
int n , m ;<br/>
vector&lt;EDGE&gt; vedges ;<br/><br/>
/<em><br/>
边的比较，未用到<br/>
struct cmp_edge{<br/>
      bool operator()(const int &amp;ie1 , const int &amp;ie2)const {<br/>
            return vedges[ie1].w &lt; vedges[ie2].w ;<br/>
      };<br/>
};<br/>
</em>/<br/><br/>
FOREST::iterator find_tree( FOREST &amp;f , int v){<br/>
      FOREST::iterator ifr ;<br/>
      for ( ifr = f.begin() ; ifr != f.end() ; ifr ++ ){<br/>
            if ( (<em>ifr).count(v) ) return ifr ;<br/>
      }<br/>
//      cout&lt;&lt;&#8221;eee&#8221;&lt;&lt;endl;<br/>
}<br/><br/>
void output(FOREST &amp;f){<br/>
      FOREST::iterator it ;<br/>
      int i = 0 ;<br/>
      for ( it = f.begin() ; it != f.end() ; it ++ ){<br/>
            cout&lt;&lt;&#8221;tree &#8220;&lt;&lt;++i&lt;&lt;endl;<br/>
            TREE::iterator ii ;<br/>
            TREE &amp;ct = (</em>it) ;<br/>
            for ( ii = ct.begin() ; ii != ct.end() ; ii ++ ){<br/>
                  cout&lt;&lt;(<em>ii)&lt;&lt;&#8217; &#8217; ;<br/>
            }<br/>
            cout&lt;&lt;endl;<br/>
      }<br/>
}<br/><br/>
int main(){<br/>
      int i;<br/>
      FOREST forest ;<br/>
      ADJLIST adjlist ;<br/>
      set&lt;int&gt; mst_edges ;<br/><br/>
      ifstream fin(&#8220;test.txt&#8221;);<br/><br/>
      fin&gt;&gt;n&gt;&gt;m ;<br/>
      <br/>
      adjlist.clear() ;<br/>
      for ( i = 0 ; i &lt; n ; i ++ ){<br/>
            adjlist.push_back(ADJEDGE());<br/>
      }<br/><br/>
      vedges.clear() ;<br/>
      for ( i = 0 ; i &lt; m ; i ++ ){<br/>
            EDGE t;<br/>
            fin&gt;&gt;t.a&gt;&gt;t.b&gt;&gt;t.w ;<br/>
            vedges.push_back(t) ;<br/>
            adjlist[t.a].push_back(i);<br/>
            adjlist[t.b].push_back(i);<br/>
      }<br/>
      <br/>
      for ( i = 0 ; i &lt; n ; i ++ ){<br/>
            TREE t ;<br/>
            t.clear() ;<br/>
            t.insert(i);<br/>
            forest.insert(t);<br/>
      }<br/><br/>
      mst_edges.clear() ;<br/>
      while ( forest.size() != 1 ){<br/>
            set&lt;int&gt; minedges ;<br/>
            FOREST::iterator iforest ;<br/>
            minedges.clear();<br/>
            for ( iforest = forest.begin() ; iforest != forest.end() ; iforest ++ ){<br/>
                  TREE &amp;curtree = </em>iforest ;<br/>
                  TREE::iterator itree ;<br/>
                  int min_weight = MAX ;<br/>
                  int min_edge ;<br/>
                  //找到该树最小割边<br/>
                  for ( itree = curtree.begin() ; itree != curtree.end() ; itree ++ ){<br/>
                        ADJEDGE &amp;curedge = adjlist[<em>itree] ;<br/>
                        ADJEDGE::iterator iedge ;<br/>
                        for ( iedge = curedge.begin() ; iedge != curedge.end() ; iedge ++ ){<br/>
                              if ( curtree.count(vedges[(</em>iedge)].a) <br/>
                                    &amp;&amp; curtree.count(vedges[(<em>iedge)].b) ){<br/>
                                    continue ;//该边在同一树内      <br/>
                              }<br/>
                              if ( vedges[</em>iedge].w &lt; min_weight ){<br/>
                                    min_weight = vedges[<em>iedge].w ;<br/>
                                    min_edge = </em>iedge ;<br/>
                              }<br/>
                        }<br/>
                  }<br/>
                  minedges.insert(min_edge);<br/>
            }<br/><br/>
            set&lt;int&gt;::iterator iminedge ;<br/>
            for ( iminedge = minedges.begin() ; iminedge != minedges.end() ; iminedge ++ ){<br/>
            //      output(forest) ;<br/>
                  int a = vedges[<em>iminedge].a ;<br/>
                  int b = vedges[</em>iminedge].b ;<br/>
                  FOREST::iterator ita = find_tree( forest , a ) ;<br/>
                  FOREST::iterator itb = find_tree( forest , b ) ;<br/>
                  if ( ita == itb ) continue ;<br/>
                  mst_edges.insert(<em>iminedge) ;<br/>
            //      set_union((</em>ita).begin() , (<em>ita).end() , (</em>itb).begin() , (<em>itb).end() , (</em>ita).end() ) ;<br/>
                  TREE::iterator itr ;<br/>
                  for ( itr = (<em>itb).begin() ; itr != (</em>itb).end() ; itr ++ ){<br/>
                        (<em>ita).insert(</em>itr) ;<br/>
                  }<br/>
            //      cout&lt;&lt;(<em>ita).size()&lt;&lt;endl;<br/>
                  forest.erase(itb);<br/>
            }<br/>
      }<br/>
      <br/>
      set&lt;int&gt;::iterator it ;<br/>
      int mst_weight = 0 ;<br/>
      cout&lt;&lt;&#8221;the edges:&#8221;&lt;&lt;endl;<br/>
      for ( it = mst_edges.begin() ; it != mst_edges.end() ; it ++ ){<br/>
            cout&lt;&lt;vedges[</em>it].a&lt;&lt;&#8217; &#8216;&lt;&lt;vedges[<em>it].b&lt;&lt;&#8217; &#8216;&lt;&lt;vedges[</em>it].w&lt;&lt;endl;<br/>
            mst_weight += vedges[*it].w ;<br/>
      }<br/>
      cout&lt;&lt;&#8221;mst weight:&#8221;&lt;&lt;mst_weight&lt;&lt;endl;<br/>
      return 0 ;<br/>
}<br/><br/><font color="#0000ff">用到的test.txt文件内容如下组织：</font><br/><br/>
5 7<br/>
0 1 35<br/>
0 2 40<br/>
1 2 25<br/>
1 3 10<br/>
2 3 20<br/>
3 4 30<br/>
2 4 15 <br/><br/>
格式：<br/>
顶点数 边数<br/>
｛点a 点b 权重｝（边数行）<br/>
顶点从0开始编号<br/><br/><font color="#ff0000">PS：我没有充分检查，谁发现BUG了麻烦说一声</font></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/04/14/STL%E7%9A%84%E5%A0%86%EF%BC%88%E5%A0%86%E5%87%BD%E6%95%B0%E5%8F%8A%E6%B3%9B%E5%9E%8B%E5%A0%86%E5%AE%9E%E7%8E%B0%EF%BC%89/">STL的堆（堆函数及泛型堆实现）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-04-14T22:49:00+08:00" pubdate data-updated="true">Apr 14<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.4.14<br/><br/>
STL并没有提供“堆”这个东西，但是提供了一套堆函数，<br/>
以及一个封装好的priority_queue。<br/><br/>
曾经也在网上找了一通，看得迷迷糊糊的。<br/>
今天把堆函数的源码看了，才知道原来是那么回事。<br/><br/><font color="#0000ff">一。封装一个泛型堆</font><br/><br/>
先展示一下这一套堆函数的易用性，紧跟后面再详细阐述他们的用法。<br/><br/></p>

<h1>include &lt;iostream&gt;<br/></h1>

<h1>include &lt;algorithm&gt;<br/></h1>

<h1>include &lt;vector&gt;<br/></h1>

<h1>include &lt;functional&gt;  <br/><br/></h1>

<p>using namespace std ;<br/><br/>
//接口说明<br/>
//bool empty()            判空<br/>
//size()                  堆大小<br/>
//clear()                  清空堆<br/>
//push(const T&amp; x)      推入元素x<br/>
//const T&amp; top()      堆顶元素<br/>
//pop()                        弹出堆顶<br/>
template&lt;class T , class Compare = less&lt;T&gt; &gt;<br/>
class myheap{<br/>
private:<br/>
      vector&lt;T&gt; data ;<br/>
      Compare comp ;<br/>
public:<br/>
      myheap(){};<br/>
      bool empty(){return data.empty() ;}<br/>
      vector&lt;T&gt;::size_type size(){return data.size();} ;<br/>
      void clear(){data.clear();} ;<br/>
      void push(const T&amp; x){<br/>
            data.push_back(x);<br/>
            push_heap(data.begin() , data.end() , comp) ;<br/>
      }<br/>
      const T&amp; top(){<br/>
            return *(data.begin()) ;<br/>
      }<br/>
      void pop(){<br/>
            pop_heap(data.begin() , data.end() , comp) ;<br/>
            data.pop_back() ;<br/>
      }<br/>
} ;<br/><br/><font color="#0000ff">二。测试该泛型堆</font><br/><br/>
      int a[] = {2,5,1,67,95,9,0,4,6} ;<br/>
      int sz = sizeof(a) / sizeof(int) ;<br/>
      int i;<br/>
      myheap&lt;int&gt; h ;<br/>
      <br/>
      h.clear() ;<br/>
      for ( i = 0 ; i &lt; sz ; i ++ ){<br/>
            h.push(a[i]) ;<br/>
      }<br/>
      for ( i = 0 ; i &lt; sz ; i ++ ) {<br/>
            cout&lt;&lt;h.top()&lt;&lt;&#8217; &#8216;;<br/>
            h.pop() ;<br/>
      }<br/><br/>
      return 0 ;<br/><br/>
输出：95 67 9 6 5 4 2 1 0<br/><br/>
这里是STL堆算法默认的大顶堆。<br/><br/>
做如下修改：<br/><br/>
      int a[] = {2,5,1,67,95,9,0,4,6} ;<br/>
      int sz = sizeof(a) / sizeof(int) ;<br/>
      int i;<br/>
   <font color="#ff0000"> myheap&lt;int , greater&lt;int&gt; &gt; h ;</font><br/>
      <br/>
      h.clear() ;<br/>
      for ( i = 0 ; i &lt; sz ; i ++ ){<br/>
            h.push(a[i]) ;<br/>
      }<br/>
      for ( i = 0 ; i &lt; sz ; i ++ ) {<br/>
            cout&lt;&lt;h.top()&lt;&lt;&#8217; &#8216;;<br/>
            h.pop() ;<br/>
      }<br/><br/>
      return 0 ;<br/><br/>
输出：0 1 2 4 5 6 9 67 95<br/><br/>
这一次就是小顶堆了。<br/><br/>
总得来说，这个实现看上去有点别扭，默认传的是less&lt;T&gt;作为比较器，却是大顶堆。<br/>
而传greater&lt;T&gt;却是小顶堆。是因为STL的堆算法按照小于比较的时候排出来的是大顶堆。<br/><br/>
为了改善这个名字上的别扭，可以参考<font color="#ff0000">STL.functional</font>里面的less和greater的写法。<br/>
自己写一个诸如myheap_small_top , myheap_big_top这样的functor。<br/><br/>
（顺便补充一句。。肯定有同学看出来了。其实上面这个泛型堆就是仿照priority_queue的写法。）<br/><br/><font color="#0000ff">三。STL的堆函数</font><br/><br/>
这些函数看别人用起来，觉得别扭，但一看这些函数的实现，却又真是那么回事。<br/>
只不过他们的名字可能取得不太好，所以理解起来有点不容易。<br/><br/><font color="#ff0000">首先，要知道STL的堆函数要求的是RandomIterator 。<br/>
然后，要知道STL普遍采用的是前闭后开的区间表示。</font><br/><br/><font color="#0000ff">push_heap</font><br/>
这个函数与其说是push，更好的说是一个adjust。<br/>
pre-condition:[begin,end-1)区间内已经成堆，end-1放的是新入堆的元素<br/>
post-condition:[begin,end)区间调整成堆。<br/><br/>
所以用法是先把要放进堆的元素放到容器的尾端。<br/>
然后再调用这个函数，把整体的堆区间传进去，将调整好。<br/><br/>
例：<br/>
            data.push_back(x);<br/>
            push_heap(data.begin() , data.end() , comp) ;<br/><br/><font color="#0000ff">pop_heap</font><br/>
这个函数做的是把堆顶的元素放到堆尾，并调整好堆。<br/>
pre-condition:[begin,end)已经成堆<br/>
post-condition:堆顶元素（begin的位置）放到end-1的位置，[begin,end-1)调整成堆<br/><br/>
所以出堆的做法是先调用该函数，然后从底层容器弹出最后的元素。<br/><br/>
例：<br/>
          pop_heap(data.begin() , data.end() , comp) ;<br/>
          data.pop_back() ;<br/><br/><font color="#0000ff">make_heap</font><br/>
建堆的函数。<br/>
pre-condition:无<br/>
post-condition:[begin,end)区间成堆<br/><br/>
这个函数本质上就是区间的一半处开始，依次向前调整成堆。<br/>
调用的是内部使用的<em>Adjust_heap函数。<br/><br/><font color="#0000ff">sort_heap</font><br/>
这个函数我认为最容易让人误解。<br/>
根据名字，我们知道是“堆排序”，那么就想，<br/>
传进去一个区间，他就使用堆排序把该区间弄成有序的。<br/>
（正如我们调用sort一样）<br/>
但是这个函数是有<font color="#ff0000">前置条件</font>的。（为什么要有这个条件见后）<br/>
pre-condition:[begin,end)已经成堆<br/>
post-condition:[begin,end)被排序<br/><br/><font color="#ff0000">用之前一定要make_heap一下</font><br/><br/>
上面两个函数的综合例子：<br/>
     int a[] = {2,5,1,67,95,9,0,4,6} ;<br/>
     int sz = sizeof(a) / sizeof(int) ;<br/>
     ostream_iterator&lt;int&gt; oit(cout , &#8221; &#8220;)  ;<br/>
     make_heap(a , a + sz);<br/>
     sort_heap(a , a + sz);<br/>
     copy(a , a + sz , oit) ;cout&lt;&lt;endl;<br/>
输出：<br/>
0 1 2 4 5 6 9 67 95<br/><br/>
如果把make_heap一句注释掉，发现输出的是乱序的。<br/>
这就是前置条件未满足的结果。<br/><br/>
用copy输出，这个用法在一般的讲STL的手册上应该都要出现。不是这里关心的。<br/><br/><font color="#ff0000">从最初的对sort_heap的疑惑，到解决这个疑惑，中间仅仅是看一下代码这么简单。</font><br/>
我把VC中的PJ实现复制过来：<br/><br/>
  template&lt;class </em>RI&gt; inline<br/>
     void sort_heap(<em>RI </em>F, <em>RI </em>L)<br/>
     {for (; 1 &lt; <em>L - </em>F; &#8211;<em>L)<br/>
          pop_heap(</em>F, <em>L); }<br/>
          // TEMPLATE FUNCTION sort_heap WITH PRED<br/><br/>
当看到这么些长得很怪的符号时，不要吓到，耐心读一下就可知其大意。<br/><br/>
这个函数就只有一个循环。<br/>
他不断的对[</em>F,<em>L)区间执行pop_heap操作。并且递减右界</em>L。<br/><br/>
根据前面对pop_heap的说明，<br/>
每一次，该函数把堆顶放到区间尾端，<br/>
同时把除尾元素外的区域调整成堆。<br/><br/>
如果是大顶堆，第一个到尾端的是最大的元素。<br/>
紧接着，第二大的元素到倒数第二个位置。<br/>
。。。<br/>
于是就排好了。<br/><br/><font color="#ff6600">有时候，去理解前人的工作，并不代表我们也要去实现这些东西，<br/>
仅仅是为了更好地使用已有的成果。</font></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/04/13/explicit%28c%2B%2B%29/">Explicit(c++)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-04-13T20:03:00+08:00" pubdate data-updated="true">Apr 13<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.4.13<br/><br/>
这个关键字可以用来限制类的构造函数要<font color="#ff0000">显式调用</font>。<br/><br/>
如下例子：<br/><br/>
class cls{<br/>
     int data ;<br/>
public :<br/>
     cls(){} ;<br/>
     cls(int x){data = x ;} ;<br/>
};<br/><br/>
int main(){<br/>
     cls c1(1) ;<br/>
     cls c2 = 1 ;<br/>
     return 0 ;<br/>
}<br/><br/>
有了 cls(int x)之后，cls c2 = 1  也是成立的。<br/>
相当于<font color="#ff0000">隐式调用</font>了c2.cls(1)。（我说相当于，因为直接这样写是通不过的）<br/><br/>
那么现在加一个explicit看下。<br/><br/>
class cls{<br/>
     int data ;<br/>
public :<br/>
     cls(){} ;<br/>
     <font color="#ff0000">explicit </font>cls(int x){data = x ;} ;<br/>
};<br/><br/>
int main(){<br/>
     cls c1(1) ;<br/>
     cls c2 = 1 ;<br/>
     return 0 ;<br/>
}<br/><br/>
于是报错了：<br/><br/>
cannot convert from &#8216;const int&#8217; to &#8216;class cls&#8217;<br/>
         No constructor could take the source type, or constructor overload resolution was ambiguous<br/><br/>
把第二句改一下。<br/>
cls c2 = cls(1) ;<br/>
于是又可以了。<br/>
等号右边就是一个显示的调用构造函数。<br/><br/>
那么做这样的限制有什么实际意义呢，我想还是在具体的工程中去体会。<br/><br/>
我现在暂时也没感受到，不过STL的源码里面出现很多这个东西。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/04/13/mutable%28c%2B%2B%29/">Mutable(c++)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-04-13T19:32:00+08:00" pubdate data-updated="true">Apr 13<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.4.13<br/><br/>
首先，要知道const对函数的修饰。<br/><br/>
当我们<font color="#ff0000">用const修饰一个成员函数的时候，<br/>
表示该函数不会改变该类的状态。</font><br/>
关于“状态”，我觉得可以理解为所有成员变量的值。<br/><br/>
比如我们设计一个获取数据的元素。<br/>
int readdata()const {<br/>
我们的期望是他不改变类中数据域的值，所以用const修饰。<br/><br/>
假设我们现在要这样一个功能。<br/><font color="#ff6600">一方面，我们可以从readdata()得到数据。<br/>
另一方面，我们要知道这个数据有没有被读取过。</font><br/><br/>
那么写出如下代码：<br/><br/>
class cls{<br/>
private :<br/>
      bool data_has_been_read ;<br/>
      int data;<br/>
      cls():data_has_been_read(false),data(0){};<br/>
      int readdata()const {<br/>
            data_has_been_read = true ;<br/>
            return data ;<br/>
      }<br/>
};<br/><br/>
显然，由于const对readdata的修饰，这段代码编译报错：<br/>
l-value specifies const object<br/><br/>
那么，我又偏偏想实现这个功能，<br/>
同时我又想readdata具有不改变该类状态的语义（即不得去掉const）<br/>
（这里我们关心的是data本身，只要data不改变，即认为类的状态没有改变，<br/>
而不关心一个该data是否被读取过的标记）<br/><br/>
所以C++给出了mutable 这样一个东西。<br/><br/>
如下改动：<br/><br/>
class cls{<br/>
private :<br/>
      <font color="#ff0000">mutable</font> bool data_has_been_read ;<br/>
      int data;<br/>
      cls():data_has_been_read(false),data(0){};<br/>
      int readdata()const {<br/>
            data_has_been_read = true ;<br/>
            return data ;<br/>
      }<br/>
};<br/><br/>
这时，这个类就通过编译了。<br/><br/>
下面是lingoes上查下该单词的意思：<br/><br/><div style="margin: 0px 0px 5px; color: rgb(128, 128, 128); line-height: normal;"><span style="font-size: 10.5pt; color: rgb(0, 0, 0); line-height: normal;"><strong>mutable</strong></span>   <span style="font-size: 10.5pt; line-height: normal;">[<font color="#009900">mu·ta·ble || &#8216;mjuːtəbl</font>]</span></div></p>

<div style="margin: 0px 0px 5px;">
<div style="margin: 4px 0px;"><font color="#c00000">adj.</font>  易变的,  性情不定的</div>
</div>


<br/><div style="margin: 0px 0px 5px; color: rgb(128, 128, 128); line-height: normal;"><span style="font-size: 10.5pt; color: rgb(0, 0, 0); line-height: normal;"><strong>volatile</strong></span>   <span style="font-size: 10.5pt; line-height: normal;">[<font color="#009900">vol·a·tile || &#8216;vɑlətl /&#8217;vɒlətaɪl</font>]</span></div>


<div style="margin: 0px 0px 5px;">
<div style="margin: 4px 0px;"><font color="#c00000">adj.</font>  挥发性的, 不稳定的,  可变的</div>
</div>


<br/>


<p>同时，上一篇用的<a href="http://hi.baidu.com/hplonline/blog/item/baf29d2bb27a5ff2e7cd400b.html" target="_blank">volatile</a>也给出来了。<br/><br/>
感觉他们的意思也差不多，那么创始人是怎么选择单词的呢。。<br/>
看来我们对C++的肤浅认识正如我们不理解英语一样。。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/04/13/volatile%28c%2B%2B%29/">Volatile(c++)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-04-13T18:37:00+08:00" pubdate data-updated="true">Apr 13<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.4.13<br/><br/>
曾经听说过也被人问过，就是没有试验过。那么今天来试一下。<br/><br/>
先做这样一个程序：<br/><br/></p>

<h1>include &lt;iostream&gt;<br/></h1>

<h1>include &lt;windows.h&gt;<br/><br/></h1>

<p>using namespace std;<br/><br/>
DWORD WINAPI ThreadProc(<br/>
LPVOID lpParameter     // thread data<br/>
){<br/>
      Sleep(3000) ;<br/>
      <em>(int</em>)(lpParameter) = 1 ;<br/>
      return 0 ;<br/>
}<br/><br/>
void wait(int <em>p){<br/>
      while ( </em>p == 0 ) ;<br/>
}<br/><br/>
int main(){<br/>
      int n = 0 ;<br/>
      CreateThread(NULL , 0 , ThreadProc , &amp;n , NULL , NULL ) ;<br/>
      wait(&amp;n) ;<br/>
      cout&lt;&lt;&#8221;terminated normally&#8221;&lt;&lt;endl;<br/>
      return 0 ;<br/>
}<br/><br/>
wait函数就是一直读取变量n的状态，直到不为0就结束，然后输出<br/>
terminated normally<br/><br/>
在wait前，先把n设置为0，并且启动一个线程，把n的地址传给线程参数。<br/>
在该线程中，先等待3000毫秒，然后改变n的值为1。<br/><br/>
那么我们预计，这个程序三秒后将会出现<br/>
terminated normally<br/><br/>
现在使用最快速度优化编译。<br/><font color="#ff0000">VC6中直接build-&gt;set active configuration-&gt;release。</font><br/>
选择release方式编译，操作简单。<br/><br/>
可以看到程序一直不结束。（我只等了一会儿。。也许你可以等上若干年。。说不定就结束了。。-_-）<br/><br/>
这点与预期不同。<br/><br/>
于是看一下wait的汇编代码:<br/><br/>
00401090 mov       eax, dword ptr [esp+4]<br/>
00401094 cmp       dword ptr [eax], 0<br/>
00401097 jnz       short 0040109B<br/><font color="#ff0000">00401099 jmp       short 00401099</font><br/>
0040109B retn<br/><br/>
可见，该程序从变量p（[esp + 4])取出地址到eax，然后与0比较。<br/>
获得标志位Z的值。<br/>
然后判断，Z为0就一直死循环（00401099 jmp       short 00401099），不为0 就跳出。<br/><br/>
这个逻辑在单线程的时候确实是成立的。<br/>
所以编译器这样达到了最快速度优化。<br/>
可是在多线程的时候却有问题。因为我们的<font color="#ff0000">p<font color="#0000ff">所指向的内容</font>有可能在其他地方改变</font>。<br/><br/>
下面做一个修改。加上volatile关键字：即下面这行。<br/>
void wait(<font color="#ff0000">volatile </font>int *p){<br/><br/>
运行后，3秒延迟，然后程序正常结束。达到了我们的要求。<br/><br/>
再看一下wait的代码：<br/><br/>
00401090  mov       eax, dword ptr [esp+4]<br/><font color="#ff6600">00401094  cmp       dword ptr [eax], 0<br/>
00401097  jnz       short 0040109E</font><br/>
00401099  cmp       dword ptr [eax], 0<br/>
0040109C  je        short 00401099<br/>
0040109E  retn<br/><br/>
其中00401094 ，00401097 两句其实可以省去的。。<br/>
（看来编译器的行为确实很难理解&#8230;)<br/><br/>
现在代码就是先把，p的值放到eax里面。<br/>
然后不断对eax寻址得到的值与0比较。判断。<br/><br/>
那么这段代码存不存在<font color="#ff0000">隐患</font>呢？<br/><br/>
如果，我说如果，<font color="#ff0000">p<font color="#0000ff">的值</font>在运行过程中会改变，那么这段代码也有问题了</font>。<br/>
因为他先把p的值放入了eax中，如果这个时候，p的值变了。<br/>
即p指向了另一处内存，而此处内存完全可以是1。<br/>
但是我们用eax去寻址，导致一直读的是原来p指向的位置，他可能一直为0，导致无法退出。<br/><br/>
不过，<font color="#ff6600">这在正常编程时是不会出现的</font>。因为p所占据的是函数参数的空间。<br/>
一般，从C的层面上，我们没有办法去得到这个位置。（当然可以特殊构造）<br/>
所以在遇到这种多线程的时候，记得加一个volatile就OK了。<br/><br/>
那么，我上面既然说过特殊构造，我就来一段：<br/><br/></p>

<h1>include &lt;iostream&gt;<br/></h1>

<h1>include &lt;windows.h&gt;<br/><br/></h1>

<p>using namespace std;<br/><br/>
DWORD v_esp ;<br/><br/>
int one = 1 ;<br/><br/>
DWORD WINAPI ThreadProc(<br/>
  LPVOID lpParameter    // thread data<br/>
  ){<br/>
     Sleep(3000) ;<br/>
     <strong>asm{<br/>
          mov ebx , v_esp ;<br/>
          sub ebx , 4 ;<br/>
          mov eax , OFFSET one ;<br/>
          mov [ebx] , eax ;<br/>
     }<br/>
     return 0 ;<br/>
}<br/><br/>
void wait(<font color="#ff0000">volatile</font> int <em>p){<br/>
     while ( </em>p == 0 ) ;<br/>
}<br/><br/>
int main(){<br/>
     int n = 0 ;<br/>
     cout&lt;&lt;&#8221;begin&#8221;&lt;&lt;endl;<br/>
     CreateThread(NULL , 0 , ThreadProc , &amp;n , NULL , NULL ) ;<br/>
     cout&lt;&lt;&#8221;end&#8221;&lt;&lt;endl;<br/>
     </strong>asm{<br/>
          mov v_esp , esp ;<br/>
     }<br/>
     wait(&amp;n) ;<br/>
     cout&lt;&lt;&#8221;terminated normally&#8221;&lt;&lt;endl;<br/>
     return 0 ;<br/>
}<br/><br/>
在VC6下测试，<font color="#ff6600">这个程序用release编译，就一直不结束。<br/>
用debug编译就会在3秒后正常结束。</font><br/>
（注意是写有volatile的）<br/><br/>
这就是我前面提过的，release下，虽然比较“<font color="#ff0000">老实&#8221;</font>了，他知道每次去取那一段内存。<br/>
但是还是<font color="#ff0000">“不够老实”</font>，我们看到了，编译器把p放在了eax里面。<br/><br/>
而<font color="#ff0000">debug下出来的东西就非常的“老实”</font>，我们看一下：<br/><br/>
004011F8  mov      eax, dword ptr [ebp+8]<br/>
004011FB  cmp      dword ptr [eax], 0<br/>
004011FE  jnz      short 00401202<br/>
00401200  jmp      short 004011F8<br/><br/>
每次都会从p处（参数所占空间）取得一个地址，然后再寻址。<br/>
这就对了哈，debug真是乖孩子。<br/><br/>
看来这是个危险的社会啊。。。<br/><br/>
不过像我最后给出的这种畸形的写法。。相信各位不会搞到自己的软里面。。<br/><br/>
所以说volatile足够了，该优化的时候还是放心让编译器去做。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/04/13/__based%28c%2B%2B%29/">__based(c++)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-04-13T14:38:00+08:00" pubdate data-updated="true">Apr 13<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.4.13<br/><br/>
发现了这样一个东西，不过感觉很没有应用价值。。。。<br/><br/>
<strong>based用来指定一个相对的指针。<br/>
在</strong>based(x)处的x为基地址。<br/><br/>
看下面这个例子，大家就知道是怎么一回事了。<br/><br/>
int a[10] = {10,20,30,40,50,60,70,80,90,10} ;<br/><br/>
int main(){<br/>
     int<em> pa = a ;<br/>
     int __based(pa)</em> p ;<br/>
     p = 0 ;<br/>
     cout&lt;&lt;<em>p&lt;&lt;endl;<br/>
     p += 3; <br/>
     cout&lt;&lt;</em>p&lt;&lt;endl;<br/>
     return 0 ;<br/>
}<br/><br/>
我在VC6上试的时候，p只能赋0，不能赋其他的值<br/>
算术运算也只支持+=,-=,++,&#8211;这些，乘除也是不可以的。<br/><br/>
而且脱指针引用(dereference)的时候，依然是把这个偏移加上基址来的。<br/>
如下：<br/><br/>
mov      dword ptr [ebp-4], offset a ;[ebp - 4]是pa<br/>
xor      eax, eax<br/>
mov      dword ptr [ebp-8], eax;[ebp - 8]是p , p = 0 <br/>
push     004010C8;endl<br/>
mov      ecx, dword ptr [ebp-8]<br/>
add      ecx, dword ptr [ebp-4]<br/>
mov      edx, dword ptr [ecx];edx = pa + p<br/>
push     edx<br/>
mov      ecx, offset std::cout;__thiscall，类的地址放ecx中<br/>
call     004010FF;operator&lt;&lt;<br/>
mov      ecx, eax;eax返回的是cout的引用，放入ecx，达到&lt;&lt;的级联使用<br/>
call     004011E0;operator&lt;&lt;<br/><br/><img src="http://img.baidu.com/hi/tsj/t_0009.gif"/>又没效率上的优势，功能也有限制。。那我们发明他干嘛呢。<br/>
求高手解。<br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/04/12/C%2B%2B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%28static_cast%2Creinterpret_cast%29/">C++类型转换(static_cast,reinterpret_cast)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-04-12T15:33:00+08:00" pubdate data-updated="true">Apr 12<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.4.12<br/><br/><font color="#0000ff">先来个实验</font>。<br/>
定义如下三个类。<br/><br/>
class ca{<br/>
public:<br/>
     int ia ;<br/>
};<br/><br/>
class cb{<br/>
public:<br/>
     int ib1,ib2 ;<br/>
};<br/><br/>
class cc:public ca,public cb{<br/>
public:<br/>
};<br/><br/>
然后打印出一组数据:<br/><br/>
     cc c ;<br/>
     cc <em>pc = &amp;c ;<br/>
     cb </em>pb1 = pc ;<br/>
     cb <em>pb2 = static_cast&lt;cb</em>&gt;(pc);<br/>
     cb <em>pb3 = (cb</em>)(void<em>)pc ;<br/>
     cout&lt;&lt;pc&lt;&lt;endl;<br/>
     cout&lt;&lt;pb1&lt;&lt;endl;<br/>
     cout&lt;&lt;pb2&lt;&lt;endl;<br/>
     cout&lt;&lt;pb3&lt;&lt;endl;<br/><br/><font color="#0000ff">结果为：</font><br/><br/>
0012FF3C<br/>
0012FF40<br/>
0012FF40<br/>
0012FF3C<br/><br/>
可以发现 。<br/>
pb1 = pc + sizeof(ca)<br/>
pb2 = pc + sizeof(ca)<br/>
pb3 = pc<br/><br/>
由于cc是从ca和cb派生出来的，安排数据元素的时候，ca在cb之前。<br/>
所以得到了一个cc的指针之后（pc），<br/>
把他转换成cb的指针，自然后移一个ca的长度。<br/>
     cb </em>pb1 = pc ;<br/>
相当于隐式的static_cast。所以结果和<br/>
     cb <em>pb2 = static_cast&lt;cb</em>&gt;(pc);<br/>
是一样的。<br/>
这一点对有多重派生的类很重要。可见指针包含的信息很丰富：<br/><font color="#ff0000">1。地址。我们最初认识指针的时候，就知道<br/>
2。长度信息。比如int<em>一次前进4个字节，double</em>一次前进8个字节<br/>
3。类型的相对位置。就好比这里的cc中  cb放在ca之后 。=号赋值的时候引发相对移动。</font><br/>
（这点我一直没有关注到）<br/><br/>
而<br/>
cb <em>pb3 = (cb</em>)(void<em>)pc ;<br/>
用了void进行中转。于是编译器无法知道(void</em>)pc处放的是个cc。<br/>
只能机械地把地址给pb3。<br/><br/><font color="#0000ff">第二个实验：</font><br/><br/>
     float f = 1.2 ;<br/>
     float <em>pf = &amp;f ;<br/>
     int i = static_cast&lt;int&gt;(f);<br/>
    // i = f ;<br/>
     int </em>pi = reinterpret_cast&lt;int<em>&gt;(pf);<br/>
    // pi = (int</em>)pf ;<br/>
     cout&lt;&lt;i&lt;&lt;endl;<br/>
     cout&lt;&lt;<em>pi&lt;&lt;endl;<br/>
     cout&lt;&lt;</em>(float<em>)pi&lt;&lt;endl;<br/><br/><font color="#0000ff">结果：</font><br/><br/>
1<br/>
1067030938<br/>
1.2<br/><br/>
第一个i，经过转换后，把float变成了int<br/><br/>
int </em>pi = reinterpret_cast&lt;int<em>&gt;(pf);<br/>
这句如果用static_cast就编译不过。因为两种指针指向的东西就不一致。<br/>
但是可以使用reinterpret重新解释，强制转换这样一种指针。<br/>
输出</em>pi。可见是没有意义的。因为里面是按照float的标准存放的数据。<br/>
cout&lt;&lt;<em>(float</em>)pi&lt;&lt;endl;<br/>
这句又做个强制转换回float的指针，再dereference。于是可以输出pi所指内存的原本值。<br/><br/>
其中注释了两句话，如果用他们去替换对应的语句，结果也是一样的。<br/><br/>
所以，可以看出，“=”本身具有static_cast意思。<br/>
int     i = f ;这句是成功的<br/>
int<em> pi = pf ;这句是失败的<br/>
这里和static_cast是相应的。<br/><br/>
而强制指针类型转换，有reinterpret_cast的意思。<br/>
int</em> pi = (int<em>)pf ;<br/>
int </em>pi = reinterpret_cast&lt;int<em>&gt;(pf);<br/>
以上两句的功能是相同的。<br/><br/>
但同时强制指针类型转换，也有static_cast的意思。<br/>
cb </em>pb2 = reinterpret_cast&lt;cb<em>&gt;(pc); //0012FF3C<br/>
cb </em>pb2 = static_cast&lt;cb<em>&gt;(pc);//0012FF40<br/>
cb </em>pb3 = (cb*)pc ;//0012FF40</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/04/12/%E5%9B%9B%E7%A7%8D%E9%94%AE%E7%9B%98%E7%9A%84%E6%80%BB%E7%BB%93%EF%BC%88%E5%8D%95%E6%8E%92%E9%94%AE%E7%9B%98%E3%80%82%E8%AF%91%E7%A0%81%E9%94%AE%E7%9B%98%E3%80%82%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98%E3%80%82%E7%9F%A9%E9%98%B5%E8%AF%91%E7%A0%81%E9%94%AE%E7%9B%98%E3%80%82%EF%BC%89/">四种键盘的总结（单排键盘。译码键盘。矩阵键盘。矩阵译码键盘。）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-04-12T12:18:00+08:00" pubdate data-updated="true">Apr 12<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.4.12<br/><br/>
首先，来看一个表，给出了控制相应数目的按钮四种键盘分别需要占用的IO口数。<br/><br/><table cellspacing="0" cellpadding="0" width="691" border="0" style="border-collapse: collapse; width: 519pt;"><col width="174" style="width: 131pt;"/><col width="184" style="width: 138pt;"/><col width="113" span="2" style="width: 85pt;"/><col width="107" style="width: 80pt;"/><tbody><tr height="19" style="height: 14.25pt;"><td height="19" width="174" class="xl24" style="height: 14.25pt; width: 131pt;">按钮数</td></p>

<pre><code>        &lt;td width="184" class="xl24" style="width: 138pt;"&gt;单排键盘&lt;/td&gt;
        &lt;td width="113" class="xl24" style="width: 85pt;"&gt;单排译码键盘&lt;/td&gt;
        &lt;td width="113" class="xl24" style="width: 85pt;"&gt;矩阵键盘&lt;/td&gt;
        &lt;td width="107" class="xl24" style="width: 80pt;"&gt;矩阵译码键盘&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl24" style="height: 14.25pt;"&gt;4&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;4&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;2&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;2&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;3&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl24" style="height: 14.25pt;"&gt;16&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;16&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;4&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;4&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;4&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl26" style="height: 14.25pt;"&gt;32&lt;/td&gt;
        &lt;td align="right" class="xl25"&gt;32&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;5&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;6&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;5&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl24" style="height: 14.25pt;"&gt;64&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;64&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;6&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;8&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;5&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl24" style="height: 14.25pt;"&gt;256&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;256&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;8&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;16&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;6&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl26" style="height: 14.25pt;"&gt;1024&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;1024&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;10&lt;/td&gt;
        &lt;td align="right" class="xl25"&gt;32&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;7&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl24" style="height: 14.25pt;"&gt;4096&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;4096&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;12&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;64&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;8&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl24" style="height: 14.25pt;"&gt;16384&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;16384&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;14&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;128&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;9&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl24" style="height: 14.25pt;"&gt;65536&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;65536&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;16&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;256&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;10&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl24" style="height: 14.25pt;"&gt;262144&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;262144&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;18&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;512&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;11&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl24" style="height: 14.25pt;"&gt;1048576&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;1048576&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;20&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;1024&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;12&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl24" style="height: 14.25pt;"&gt;4194304&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;4194304&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;22&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;2048&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;13&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl24" style="height: 14.25pt;"&gt;16777216&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;16777216&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;24&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;4096&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;14&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl24" style="height: 14.25pt;"&gt;67108864&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;67108864&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;26&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;8192&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;15&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl24" style="height: 14.25pt;"&gt;268435456&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;268435456&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;28&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;16384&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;16&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl24" style="height: 14.25pt;"&gt;1073741824&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;1073741824&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;30&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;32768&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;17&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl26" style="height: 14.25pt;"&gt;4294967296&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;4294967296&lt;/td&gt;
        &lt;td align="right" class="xl25"&gt;32&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;65536&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;18&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl24" style="height: 14.25pt;"&gt;17179869184&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;17179869184&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;34&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;131072&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;19&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl24" style="height: 14.25pt;"&gt;68719476736&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;68719476736&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;36&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;262144&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;20&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl24" style="height: 14.25pt;"&gt;274877906944&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;274877906944&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;38&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;524288&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;21&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl24" style="height: 14.25pt;"&gt;1099511627776&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;1099511627776&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;40&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;1048576&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;22&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl24" style="height: 14.25pt;"&gt;4398046511104&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;4398046511104&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;42&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;2097152&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;23&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl24" style="height: 14.25pt;"&gt;17592186044416&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;17592186044416&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;44&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;4194304&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;24&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl24" style="height: 14.25pt;"&gt;70368744177664&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;70368744177664&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;46&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;8388608&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;25&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl24" style="height: 14.25pt;"&gt;281474976710656&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;281474976710656&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;48&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;16777216&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;26&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl24" style="height: 14.25pt;"&gt;1125899906842620&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;1125899906842620&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;50&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;33554432&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;27&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl24" style="height: 14.25pt;"&gt;4503599627370500&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;4503599627370500&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;52&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;67108864&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;28&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl24" style="height: 14.25pt;"&gt;18014398509482000&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;18014398509482000&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;54&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;134217728&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;29&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl24" style="height: 14.25pt;"&gt;72057594037927900&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;72057594037927900&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;56&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;268435456&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;30&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl24" style="height: 14.25pt;"&gt;288230376151712000&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;288230376151712000&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;58&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;536870912&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;31&lt;/td&gt;
    &lt;/tr&gt;&lt;tr height="19" style="height: 14.25pt;"&gt;&lt;td height="19" align="right" class="xl26" style="height: 14.25pt;"&gt;1152921504606850000&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;1152921504606850000&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;60&lt;/td&gt;
        &lt;td align="right" class="xl24"&gt;1073741824&lt;/td&gt;
        &lt;td align="right" class="xl25"&gt;32&lt;/td&gt;
    &lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;br/&gt;&lt;br/&gt;
</code></pre>

<p>自然，假设把51的32个口都拿来连键盘。四种的极限能力如下：<br/><br/><font color="#ff6600">单排键盘：32<br/>
单排译码键盘：4294967296<br/>
矩阵键盘：1024<br/>
矩阵译码键盘：1152921504606850000</font><br/><br/>
我在之前的文章中大致翻了一下，四种键盘对应的例子都有出现。下面分别给出：<br/>
设控制的键数为n，占用IO口数为x<br/><br/><font color="#0000ff">单排键盘。</font><br/><a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/cc2e5bda324f2cd3b7fd4812.html">http://hi.baidu.com/hplonline/blog/item/cc2e5bda324f2cd3b7fd4812.html</a><br/><font color="#ff0000">x = n </font><br/>
上面那个例子虽然是练习8255的，其实右下角的开关组就是单排键盘的那种意思。<br/>
这键盘构造最为简单，一般初学都会练一下，并且没人想叫他键盘。。<br/><br/><br/><font color="#0000ff">单排译码键盘。</font><br/><a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/2210888be48af6dbfc1f10e2.html">http://hi.baidu.com/hplonline/blog/item/2210888be48af6dbfc1f10e2.html</a><br/><font color="#ff0000">x = ln(n)/ln(2)</font><br/>
上面的例子就是典型的8键到3口。<br/>
从一开始给出的表上来看，这种键盘的能力其实很强的。<br/>
256键仅需要8个口。<br/>
但是不知道为什么没看到有人说。<br/><br/><br/><font color="#0000ff">矩阵键盘。</font><br/><a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/89c8780e2764d3c27acbe1ed.html">http://hi.baidu.com/hplonline/blog/item/89c8780e2764d3c27acbe1ed.html</a><br/><font color="#ff0000">x = sqrt(n)</font><br/>
不得不说，最早想出这么搞的人思路的确不错。<br/>
利用按钮在行列交点的特性，做到了开方的级别。<br/>
这也是很多教材和网友讨论得很多的一种。<br/>
可是从表上看出，其能力还不足单排译码键盘，<br/>
而且该种键盘的编程总是让初学者觉得打脑壳。。<br/><br/><font color="#0000ff">矩阵译码键盘。</font><br/><a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/93ccc5fc8ec8ea8ab801a0b6.html">http://hi.baidu.com/hplonline/blog/item/93ccc5fc8ec8ea8ab801a0b6.html</a><br/><font color="#ff0000">x = ln(sqrt(n))/ln(2) + 2</font><br/>
这个在硬件上要多做一些功夫，但是看过我的例子就知道。<br/>
程序上简单得出奇。。<br/>
主要是一些思想的问题。既然矩阵键盘大家都很熟悉了，<br/>
而译码器又是一客观存在，那么我们完全可以发挥一下创意，结合起来玩。<br/>
首先是基于矩阵键盘，就达到了开方级。<br/>
而一般讲矩阵键盘，是直接一IO口对应一个行线（列线），显然存在太多浪费。<br/>
可以用编码器来获得线上的状态。<br/>
另外的两个口，一个是用来表达有无键按下的，另一个用来输出行列测试信号。<br/><br/><br/><br/><br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/04/11/%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84o%28nlogn%29%E7%BA%A7%E6%8E%92%E5%BA%8F%EF%BC%88VC6.STL%29/">基于链表的o(nlogn)级排序（VC6.STL)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-04-11T22:37:00+08:00" pubdate data-updated="true">Apr 11<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline) 2009.4.11<br/><br/>
罪过啊罪过。。前段时间跟同学讲stl的list的sort是o(n<sup>)的。。。<br/><br/></sup>
这也难怪，我们直观一想，作为一个list的某个节点，由于是双向的，<br/>
他可以知道自己的前驱和后继，但仅限于此。他的迭代器不是RandomIterator。<br/><br/>
而&lt;algorithm&gt;里面的sort要求传进去的迭代器是RandomIterator。<br/>
于是就主观认为list的sort肯定不能用快排，而要达到稳定，一定就是冒泡了。。<br/>
（现在想起来真是太主观了）<br/><br/>
近来看STL源码，看到了sort这里。<br/>
参考的是侯捷的那本《STL源码剖析》<br/>
（经典，推荐之）<br/><br/>
本来准备PASS掉的，突然瞟到候老师注释的是<font color="#ff0000">quick sort</font>。<br/><br/>
感觉一震。。于是细看了一下。<br/>
当然，大师只要点到即止，自然没有对该算法的实现做注释了。<br/>
此等杂务交由我辈完成<sup>_<sup>。<br/></sup></sup>
（这也是网络分享的乐趣所在，不同的人按照自己的标准进行剖析，<br/>
自然有需要的人能找到需要的资料。）<br/>
看完了发现是归并排序(<font color="#ff0000">merge sort</font>) 。 不过意思上大致如此。只要是o(nlogn)就行了。<br/><br/>
之所以说<font color="#ff0000">发现</font>，是因为我并不能直接看出来他就是。。<br/>
以前也写过mergesort，但是没想过这个事情还可以换一种角度来做。。<br/>
做得如此有<font color="#ff0000">艺术性</font>，ORZ。。<br/><br/>
下面这个东西是从VC6拷贝出来的。。。<br/>
我觉得长得很难看。。<br/><br/>
     void sort()<br/>
          {if (2 &lt;= size())<br/>
               {const size_t <em>MAXN = 15;<br/>
               </em>Myt <em>X(allocator), </em>A[<em>MAXN + 1];<br/>
               size_t </em>N = 0;<br/>
               while (!empty())<br/>
                    {<em>X.splice(</em>X.begin(), *this, begin());<br/>
                    size_t <em>I;<br/>
                    for (</em>I = 0; <em>I &lt; </em>N &amp;&amp; !<em>A[</em>I].empty(); ++<em>I)<br/>
                         {</em>A[<em>I].merge(</em>X);<br/>
                         <em>A[</em>I].swap(<em>X); }<br/>
                    if (</em>I == <em>MAXN)<br/>
                         </em>A[<em>I].merge(</em>X);<br/>
                    else<br/>
                         {<em>A[</em>I].swap(<em>X);<br/>
                         if (</em>I == <em>N)<br/>
                              ++</em>N; }}<br/>
               while (0 &lt; <em>N)<br/>
                    merge(</em>A[&#8211;<em>N]); }}<br/><br/>
merge sort的思想就不用废话了。只是不同人的实现上有区别。所以我对照这份给个简要的描述。<br/><br/><font color="#0000ff">先说下他的变量类型：</font><br/>
</em>Myt <em>X(allocator), </em>A[<em>MAXN + 1];<br/>
</em>Myt 这个类型和当前需要排序的list是同一个类型。<br/>
<em>X 是一个临时变量。<br/>
</em>A 是我所谓的精华（没想过merge sort还可以如此实现）<br/><font color="#ff0000">可以理解为一系列的桶。<em>A[i]这个桶内list的长度是2<sup>i</font>。<br/></sup>
（所以这里的最大桶支持的长度为32768）<br/>
size_t </em>N 记录的是当前的最大的桶的编号。<br/><br/><font color="#0000ff">然后有几个已经实现的函数来提一下：</font><br/>
merge。当两个list有序的时候，调用该函数合并出来的list也是有序的。<br/>
splice。是一个实现list剪切，粘贴的函数。<br/><br/><font color="#0000ff">最后来看他的实现思路：</font><br/>
1。从待排链表中取出头节点。放入临时链表<em>X<br/>
2。让该临时链表从小到大依次和每个桶里的链表merge。<br/>
3。如果已经合并到了当前最大长度的桶处（</em>N），或者该长度的桶是空的。<br/>
3Y。跳出循环。<br/>
3N。继续合并。<br/>
4。如果这时候应当合并的桶是最大的桶（<em>MAXN）<br/>
4Y。直接与该桶合并<br/>
4N。把临时链表</em>X存入此桶。<br/>
5。如果当前指向的桶是当前最大长度桶（<em>I == </em>N），扩充当前最大长度桶。<br/>
6。如果待排序链表非空，转1。<br/>
7。依次把每个桶的内容merge到待排序链表中（这步之前他已经为空）<br/><br/><font color="#0000ff">总结：</font><br/>
这份代码和SGI的实现上还是有点差别，总得来说要节省不少空间。<br/><font color="#ff6600">SGI的实现是开够64个桶</font>，想下2<sup>64是多么的大啊。。。我们估计没有那么长的list。<br/></sup>
于是就省去了第4步的判断。<br/>
而VC这份PJ实现只支持到最大桶32768。显然少开了不<font color="#ff0000">少局部变量。这里很省空间</font>。<br/>
如果要顾及时间的话。<br/>
又如果非要用到超长list，那么可以自己<font color="#ff0000">DIY一下这个_MAXN</font>就OK 了。<br/><br/>
以前自己写的时候，一般是做一个步长，从2开始翻倍。<br/>
依次merge该区段里的元素。<br/>
这个写法在连续空间，如数组上写起来比较方便。<br/>
而且，根据步长的翻倍 ，很容易感受到对数级这一概念。<br/><br/>
STL list.srot这种写法真的很隐蔽。。<br/>
在不直接说他是merge sort的时候还真难考虑。<br/>
（因为候老师说是quick sort ，就一直拿quick sort的框架去考虑。。。发现不成）<br/><br/>
精华就在于那一组桶。<font color="#ff0000">从小桶归并到大桶是一个长度翻倍的过程，很自然。</font><br/>
而且不用像步长法那样考虑一些尾巴上的特殊判断。比如7个元素，不是2的方幂。<br/><font color="#ff0000">只要在最后归并完了，依次把所有的桶再merge到该list中就可以了</font>。<br/><br/>
做人。。还是不能太主观了。。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/04/09/%E7%BC%96%E7%A0%81%E5%99%A8%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98%EF%BC%88%E4%BA%94%EF%BC%89%E6%B5%8B%E8%AF%95%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BA%A7%E7%94%9F%EF%BC%8874LS373%29%EF%BC%88%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84hazard%2Cglitch%2Cracecondition%29/">编码器矩阵键盘（五）测试信号的产生（74LS373)（要注意的hazard,glitch,race Condition)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-04-09T20:27:00+08:00" pubdate data-updated="true">Apr 9<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.4.9<br/><br/><font color="#0000ff">需求分析：</font><br/><br/>
前面把大量的工作做好了。这里来收一下尾。我们还差一个test信号。<br/><br/>
这一块要干的事：<br/><font color="#ff6600">1.使所有行线为1，所有测试信号与列线相接的端口为高阻态<br/>
2.使能列编码器，禁止行编码器</font><br/>
（反之也有）<br/><br/><font color="#0000ff">电路：</font><br/><br/><div forimg="1"><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/5e28df627b979dffe6113acb.jpg"/><br/><br/>
有了这些需求后，自然想到74LS373。这东西真的好用。<br/><br/>
先用一个非门，产生test的反信号itest。<br/><br/>
test有效的时候，是行为1，测试列线，所以ecol和itest为同一电平。<br/>
erow和test为同一电平。<br/><br/>
然后看U10<br/><br/>
test为1的时候row0和row1要为1.<br/>
所以使d0，d1为test，OE为itest。<br/><br/>
另一边正好相反，所以成高阻。这些都是很好想到的。<br/><font color="#0000ff"><br/>
关于test_d的解释。：</font><br/><br/><font color="#ff0000">各位注意U11的下面OE端是test_d。</font>。。<br/><br/>
再看U16，把itest取反，其实其值就是test。那么这个d仅仅是为了延迟（delay之意）<br/><br/>
这就涉及到数电里面提到的hazard（危害，冒险)了，有的地方也叫glitch（电路尖峰）。<br/>
按照正常的来说，先学数电，再学单片机，会认为这些都是很熟悉的内容。。。<br/>
只有我这样先学单片机。。才开始学数电的发现了才觉得很囧。。。<br/>
（这个问题找了很久。。。其中乱改一通，<br/>
有时proteus报告：race condition detected。<br/>
不以为然，继续乱改，后来终于看到这里来了。。。<br/>
果然是竞争状态。。唉。。。）<br/><br/>
首先，要搞清楚373的工作。<br/><br/>
如果把test直接接到OE上。<br/>
假设这时test为1。该373是高阻的。<br/>
然后我们把test变为0 。<br/>
这个时候itest由于非门延迟，还么有变为1。而OE端成了0，输出有效。<br/>
于是Q0Q1成了0 。<br/>
非门延迟过后，itest成了1。<br/><br/>
以前只考虑静态逻辑，想到反正OE是低，输入为1，输出也就1。<br/>
可以373的动态逻辑是，在OE的下降延来输出的。<br/><br/>
所以输出0之后，虽然itest成了1，但是我们的373已经不理他了。<br/><br/>
这样，不管怎么按键，读到的行线都是低，反向为高，不进行编码。。。<br/><br/>
所以，把itest再次反向，形成test_d，让使能信号与数据信号之后跳变。这个问题就解决了。<br/><font color="#ff6600"><br/>
没想到一个proteus这么五脏俱全。一点hazard都不放过，厉害。。</font><br/>
囧了我这么久才囧出来。。</div></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/backup-hplonline/blog/page/20/">&larr; Older</a>
    
    <a href="/backup-hplonline/blog/archives">Blog Archives</a>
    
    <a class="next" href="/backup-hplonline/blog/page/18/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/backup-hplonline/blog/2013/05/04/test/">Test</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/04/09/%E5%86%8D%E8%B0%88stl%E7%9A%84rotate/">再谈stl的rotate</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%BA%8C%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、二）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%89%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、三）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%80%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、一）</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - hplonline -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
