
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>hplonline</title>
  <meta name="author" content="hplonline">

  
  <meta name="description" content="(hplonline)2010.11.11
前天上课的时候听到了这个东西，还是有点意思。
》》相关知识回顾
SOCKET中有两个队列，
姑且一个叫syn队列，一个叫accept队列。
对于TCP来说，对方发起连接的时候，会建立一个SOCKET放到syn队列里面。
当连接建立好的时候， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hupili.github.io/backup-hplonline/blog/page/2">
  <link href="/backup-hplonline/favicon.png" rel="icon">
  <link href="/backup-hplonline/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/backup-hplonline/atom.xml" rel="alternate" title="hplonline" type="application/atom+xml">
  <script src="/backup-hplonline/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/backup-hplonline/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/backup-hplonline/">hplonline</a></h1>
  
    <h2>backup from 2006 to 2012 (original hi.baidu.com/hplonline/)</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/backup-hplonline/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hupili.github.io/backup-hplonline" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/backup-hplonline/">Blog</a></li>
  <li><a href="/backup-hplonline/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/11/11/SYNCookies/">SYN Cookies</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-11-11T23:57:00+08:00" pubdate data-updated="true">Nov 11<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.11.11<br/><br/>
前天上课的时候听到了这个东西，还是有点意思。<br/><font color="#0000ff"><br/>
》》相关知识回顾</font><br/><br/>
SOCKET中有两个队列，<br/>
姑且一个叫syn队列，一个叫accept队列。<br/>
对于TCP来说，对方发起连接的时候，会建立一个SOCKET放到syn队列里面。<br/>
当连接建立好的时候，就从syn队列到accept队列。<br/>
当然，syn“队列”这个叫法不一定科学，<br/>
因为有网络延迟的差异，连接不总是先到的就先建立好。<br/>
当我们调用SOCKET的accept接口时，<br/>
实际上连接早已建立好，并且放在accept队列中了。<br/><br/>
这两个队列都有最大的长度。<br/>
在服务器调用listen的时候可以设定一个backlog值，<br/>
但该值具体对应的是哪个队列还需要再考察，和实现有关。<br/>
另外，除了backlog之外，系统本身也会加上限。<br/><br/><font color="#ff0000">(update,2010.11.15)<br/>
在linux下，accept队列的最大长度由/proc/sys/net/core/somaxconn指定。<br/>
listen参数的backlog对应的也是该队列，调用listen的时候系统会检查。<br/>
默认的accept队列最大长度是128，许多服务器需要修改增大。<br/>
syn队列的最大长度由/proc/sys/net/ipv4/tcp_max_syn_backlog指定。<br/>
没有用户接口去设定，其默认值是1024。</font><br/><br/>
既然是队列，那就有充满的那么一天。<br/>
这样新的连接无法进来，造成服务的拒绝。<br/><br/>
对于accept队列，一般有三种处理：<br/>
增大backlog，修改系统上限，提高accept的处理速度。<br/>
由于这个队列只依赖本地的处理，<br/>
我们可以尽量快地从系统接管其中的SOCKET资源，<br/>
这样，就可以最大可能地保证其非满。<br/><br/>
但syn队列会依赖网络对端，很容易被半开的连接充满。<br/>
特别是当syn flood发生的时候，服务器会维护一大堆没有用的连接信息。<br/>
正常的连接过来的时候，会由于syn队列满而无法建立。<br/>
此时，就算服务器还有很多闲散资源，也无法为客户提供服务。<br/>
SYN Cookies即可解决这种问题。<br/><br/><font color="#0000ff">》》SYN Cookies</font><br/><br/>
在我们设计程序的过程中，经常考虑的就是时间和空间的折衷。<br/>
syn队列本质消耗的是空间，而拒绝服务也是由于队列空间耗尽所致。<br/>
这样，可以想一种办法，把本来需要存储的信息进行“编码”，<br/>
交给客户端，下次返回的时候，花点时间“解码”即可。<br/>
这个思路很像服务器和浏览器之间交换的cookies。<br/><br/>
但最早的TCP协议并没有作出类似的规范，<br/>
所以我们无法在DATA域中放入这些信息，并让客户端乖乖传回。<br/>
好在TCP有规定一个SEQ值，初始的时候可以由服务器选定，<br/>
但客户在回送的时候，其ACK_client=SEQ_server+1。<br/>
服务器设计一种只有自己能读懂的SEQ值就行了。<br/><br/>
一般的实现会考虑这几个部分：<br/>
timestamp，用于判断连接是否超时。<br/>
sign = f(time, ip_src, port_src, ip_dst, port_dst)，用于签名防伪。<br/><br/>
f()的实现是服务器保密的，并且只要bit数足够，多个客户撞车的可能性也很小。<br/>
timestamp需要选取一个较大的粒度，以便能在32-bit的SEQ中的一部分中存下。<br/>
很不幸的是，为了保证签名的安全，留给timestamp的bit数量肯定很少。<br/>
一个可选的实现是：timestamp=(time()&gt;&gt;6)&amp;0x1f<br/>
这样，服务器对时间的分辨率可以达到64秒，数值循环周期大概半小时。<br/><br/>
到目前为止，一个SYN Cookies已经可用了，但还有个细节：<br/>
TCP有个MSS的选项，该选项只能在初始的数据包中设定。<br/>
如果客户发送了MSS，而我们不在syn队列中维护这个信息，就直接搞丢了。<br/>
所以还有个需求，就是把MSS也编码进SYN Cookies中。。。<br/>
真是艰苦卓绝，原先的timestamp和sign还得匀出点空间给MSS。<br/><br/>
由于MSS只能用少数几个bit表达，所以支持的种类是很少的。<br/>
好在目前基本是ethernet+ip一统天下，大部分的MSS都是经典的1460。<br/>
根据不同的环境，配置几种MSS也就够应付大部分需求了。<br/>
而一个正常的客户，应该不大可能手动设定一个非主流的MSS。<br/><br/>
除了MSS之外，TCP还有其他的选项，就姑且不考虑了，<br/>
毕竟这些选项在之后的交互中还可以再协商。<br/>
总得来说，回送的SEQ中有下面三个必要的部分：<br/>
timestamp,sign,MSS<br/>
可以自行设计分配他们的空间和签名的算法。<br/><br/>
参考资料：<a target="_blank" href="http://en.wikipedia.org/wiki/SYN_cookies">http://en.wikipedia.org/wiki/SYN_cookies</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/11/06/perl%E4%B8%AD%E7%9A%84%E5%BC%95%E5%8F%B7/">Perl中的引号</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-11-06T14:26:00+08:00" pubdate data-updated="true">Nov 6<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.11.6<br/><font color="#0000ff"><br/>
一。一段测试代码</font><br/><br/>
应该是涵盖了常见的知识点了。<br/><font color="#ff0000">(1)单引号和双引号，在转义和变量内插方面不同<br/>
(2)q，qq，qw，这几个元词在使用字符串和字符串数组的时候比较方便。<br/>
(3)直接print数组和内插到双引号中数组的区别<br/>
(4)多行文本块</font><br/><br/></p>

<h1>!/usr/bin/perl -w <br/><br/></h1>

<p>$me = &#8220;hpl&#8221; ;<br/></p>

<h1>the basic difference between single and double quotes<br/></h1>

<p>print &#8220;test\t$me&#8221; ; print &#8220;\n&#8221; ;<br/>
print &#8216;test\t$me&#8217; ; print &#8220;\n&#8221; ;<br/></p>

<h1>the nesting of quotes <br/></h1>

<p>print &#8216;&#8220;test&#8221; $me&#8217; ; print &#8220;\n&#8221; ;<br/>
print &#8220;&#8216;test&#8217; $me&#8221; ; print &#8220;\n&#8221; ;<br/></p>

<h1>the following two lines don&#8217;t work<br/></h1>

<h1>print &#8221;test&#8217; $me&#8217; ; print &#8220;\n&#8221; ;<br/></h1>

<h1>print &#8220;&#8221;test&#8221; $me&#8221; ; print &#8220;\n&#8221; ;<br/></h1>

<h1>test the meta word q and qq<br/></h1>

<p>print q(&#8216;&#8220;test $me) ;  print &#8220;\n&#8221; ;<br/>
print qq(&#8216;&#8220;test $me) ;  print &#8220;\n&#8221; ;<br/></p>

<h1>the bracket should be escaped<br/></h1>

<p>print qq(&#8216;(test $me) ;  print &#8220;\n&#8221; ;<br/></p>

<h1>other escape char can be used<br/></h1>

<p>print q[(&#8216;&#8220;test $me)] ;  print &#8220;\n\n&#8221; ;<br/><br/></p>

<h1>test array<br/><br/></h1>

<h1>the obsolete way you see in other languages<br/></h1>

<h1>@arr = (&#8220;one&#8221;, &#8220;two&#8221;, &#8220;three&#8221;) ; <br/></h1>

<p>@arr = qw(one two three) ;<br/>
print @arr ; print &#8220;\n&#8221; ;<br/>
print &#8220;@arr&#8221; ; print &#8220;\n\n&#8221; ;<br/><br/>
$multi_line = &lt;&lt;&#8221;END&#8221; ;<br/>
this is to show you the scheme of multiline strings,<br/>
where &#8216;&lt;&lt;&#8221;END&#8221;&#8217; specifies the end of the string.<br/>
you can change the end tag to any other strings you like.<br/>
test $me .<br/>
END<br/>
print $multi_line ; print &#8220;\n&#8221; ;<br/><br/>
$multi_line2 = &lt;&lt;&#8217;END&#8217; ;<br/>
let&#8217;s try single-quote here.<br/>
see what happens to $me?<br/>
END<br/>
print $multi_line2 ; print &#8220;\n&#8221; ;<br/><br/>
结果就不贴了，一跑便知，当个速记。<br/><br/>
参考资料：<a href="http://www.perlmonks.org/?node_id=401006" target="_blank">http://www.perlmonks.org/?node_id=401006</a><br/><br/><font color="#0000ff">二。用处</font><br/><br/>
单双引号的区别是基本，<br/>
能够互相嵌套，但不能同型号嵌套，<br/>
这个需要区分一下，看字符串中的需求。<br/>
变量内插上的特性也很有用，<br/>
特别是双引号对数组，可以在中间加入空格。<br/><br/>
一个把字符串按单词逆序的例子。（很多面试题喜欢考的哇）<br/>
$str = &#8220;a1 b2 c3&#8221; ;<br/>
@arr = reverse(split &#8221; &#8220;, $str) ; <br/>
print &#8220;@arr\n&#8221; ;<br/>
不过这里不是演示算法，就是解决打印数组加空格的问题。<br/><br/>
多行文本块也比较有用，<br/>
比如打印usage信息、打印其他语言的块。<br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/10/17/%E4%B8%80%E5%A5%97win%E4%B8%8B%E7%9A%84perl%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%EF%BC%88cygwin%EF%BC%8Ce-texteditor%EF%BC%8C%E5%8F%82%E6%95%B0%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%89/">一套win下的perl工作环境（cygwin，e-texteditor，参数解决方案）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-10-17T23:37:00+08:00" pubdate data-updated="true">Oct 17<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.10.17<br/><br/><font color="#0000ff">》》背景</font><br/><br/>
自从在公司被逼着用了perl之后，就有点习惯了。<br/>
有时候想处理点小东西，第一反映居然是用perl。<br/>
处理点字符串和简单的统计确实比较方便，<br/>
以前做mcm的时候如果会这东西，<br/>
在数据的搜集和预处理上，应该要提高不少效率。<br/><br/>
今天在xq和auxten的帮助下，搞了套perl的工作环境。<br/>
以后要用ruby、python什么的，也比较类似。<br/><br/><font color="#0000ff">》》下载</font><br/><br/>
e:<br/><br/><a target="_blank" href="http://www.cehx.com/portal.php?mod=view&amp;aid=12205">E-TextEditor v1.0.39(crack)</a><br/><br/>
cygwin:<br/><br/><a target="_blank" href="http://cygwin.com/win-9x.html">CygWin-legacy</a> 里面的setup-legacy.exe下下来配置。<br/>
（e需要旧的cygwin支持）<br/><br/><font color="#0000ff">》》cygwin</font><br/><br/>
一路默认下去，直到选择要安装的组件。<br/>
中间镜像可以添个，<br/>
http://mirrors.sohu.com/cygwin<br/><br/>
可以安装的组件比较多，除了默认的，<br/>
把gcc，perl，还有其他一些小工具安上。<br/>
反正后面用到缺少哪个命令的时候，<br/>
随时回头来安装就行了。<br/><br/><font color="#0000ff">》》e-texteditor</font><br/><br/>
这编辑器做得不错，就是名字太短，“e”。<br/>
名字短本身也不是什么大的缺陷，<br/>
但是在各个地方搜索的时候，经常无法召回。<br/>
毕竟TFIDF还是IR这方面的基础，<br/>
e貌似又是英文中出现频率最高的字母，囧。<br/><br/>
界面就下面这样子：<br/><br/><span><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/c0f979f095919de7a50f52a1.jpg"/></span><br/><span><br/>
一般编辑器该有的功能都有，像tab，普通快捷键这些。<br/>
最大的这块是编辑区域，下面是脚本执行后的输出。<br/>
e的撤销确实比较nb，保存文件重启e之后，还可以进行撤销操作。<br/><br/>
左边是Bundle的编辑。<br/>
Bundle就是一些模版(snippet)或者命令(command)的集合，<br/>
可以对应上相应的触发词或者快捷键。<br/>
通过编辑bundle可以扩充这个编辑器的功能。<br/>
扩充snippet是编辑器本身支持的，但要用comman的需要cygwin的支持。<br/>
测试cygwin是否有效：edit-&gt;settings-&gt;UNIX-&gt;show version information<br/><br/>
下面看下bundle的样子，<br/>
左边是bundle浏览器，展开了perl的if..elsif..else模版。<br/>
右边就是这个模版的内容。<br/><br/>
里面的$1-9是几个编辑位置。<br/>
snippet展开后，首先到$1，<br/>
编辑完第一个位置，直接tab就可以到$2。<br/>
这样可以大大缩短打括号再方向键切回来的时间。<br/><br/><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/4f3587b10c818e1c082302a1.jpg"/></span><br/><br/>
在代码中输入触发词，“ifee”，按下tab，<br/>
展开上面所示的那个模版如下：<br/><br/><span><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/dff197164a686819f2de32a1.jpg"/></span><br/><br/>
其中#号后面的只是提示词，输入任意字符后就消失。<br/>
you needn&#8217;t bother to delete them manually..<br/><br/>
再看下command的样子，<br/>
下面这个就是perl下面的run script命令。<br/>
不过不是原版的，是我修改过后的样子。<br/><br/><span><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/63614d1049800fb4c2ce79a1.jpg"/></span><br/><br/>
scope selector是指定作用域，比如目前这个就是在perl源码里面都有效。<br/>
command本质是一个shell脚本，里面可以引用很多环境变量，和linux命令。<br/>
TM_SCOPE 常量中记载了光标目前所处的作用域，<br/>
可以识别出函数名、行首tab等等语法上的关键位置。<br/>
编辑高级功能的时候，自己把这个常量打出来就知道可以用的有哪些了。<br/><br/>
另外一个可以关注的output这里，指定命令执行后输出的方式。<br/>
可以把输出直接插入到到文本中，或者替换一段文本。<br/>
这样就给了很大的发挥空间，用command做出更复杂的编辑。<br/>
但像run script这样的功能，我们就是想看下标准输出。<br/>
可惜的是，e没有提供output as plaintext的方式，<br/>
所以在输出成html之前要做处理，后面详述。<br/><br/>
关于bundle更多的信息，可以参考<a target="_blank" href="http://www.e-texteditor.com/wiki/index.php/Bundles">官方帮助页</a>。<br/>
很短，读完差不多就可以个性化自己的编辑器了。<br/><br/><font color="#0000ff">》》perl解释设置</font><br/><br/>
安装好后，perl默认的run script是这样的：<br/><br/><font color="#ff9900">export TM_RUBY=$(type -p &#8220;${TM_RUBY:-ruby}&#8221;)<br/>
&#8221;${TM_RUBY}&#8221; &#8211; &#8220;$TM_BUNDLE_SUPPORT/PerlMate/perlmate.rb&#8221;</font><br/><br/>
如果cygwin也ok，把ruby安装好，可以直接运行。<br/><br/>
不过这样一个中转之后，实在是太慢，<br/>
并且ruby中转过的输出页面很丑陋。<br/><br/>
其实在command的Evironment中选择Cygwin(generic)之后，直接下面就行了：<br/><font color="#ff9900">/usr/bin/perl ${TM_FILEPATH}</font><br/>
后面这个环境变量是被调用文件的绝对路径。<br/>
这个用法与在实际linux中无异。<br/><br/>
其实我倾向更简洁一点的写法：<br/><font color="#ff9900">${TM_FILEPATH}</font><br/>
在perl脚本的首行，加上解释器路径即可：<br/><font color="#ff9900">#!/usr/bin/perl -w</font><br/><br/>
这样弄好后，运行没问题了，不过输出会没有换行。<br/>
因为这个版本的e只提供了输出为html的方式，<br/>
所以必须手动使用&lt;br /&gt;标签去换行；<br/>
或者也可以试试&lt;pre&gt;&lt;/pre&gt;标签。<br/><br/>
我这里直接把\r\n或者\n替换为&lt;br /&gt;，<br/>
那么run script命令就是这样了：<br/><font color="#ff9900">${TM_FILEPATH} | perl -npe&#8217;s/\r?\n/&lt;br \/&gt;/g&#8217; </font><br/><br/>
把输出解决之后，基本上就可以用了。<br/>
剩下一个问题，就是要传入参数怎么办。<br/>
实际用的时候可以手动输入，<br/>
但在编辑+调试阶段，每次都去命令行也不方便。<br/><br/>
想了个变相的方法。<br/>
如果决定给自己的脚本带参数，<br/>
就在同目录下写个&lt;filename&gt;.args的文件，<br/>
把要带的参数写在这个文件里面即可。<br/>
这样，run script脚本就先判断一下，是否有args这个文件。<br/>
最终的代码如下：<br/><br/><font color="#ff9900">if [[ -e ${TM_FILEPATH}.args ]] ; then<br/>
perl_arg_line=<code>head -n1 ${TM_FILEPATH}.args</code><br/>
${TM_FILEPATH} ${perl_arg_line} | perl -npe&#8217;s/\r?\n/&lt;br \/&gt;/g&#8217; <br/>
else <br/>
${TM_FILEPATH} | perl -npe&#8217;s/\r?\n/&lt;br \/&gt;/g&#8217; <br/>
fi </font><br/><br/><font color="#ff0000">(2010.10.22,update)</font><br/><br/>
前面的虽然对于换行没有问题了，但是中文支持上不好。<br/>
即使用run script默认的ruby脚本，output出来的中文还是有问题。<br/>
经过测试，应该是e的那个输出显示窗口的毛病，<br/>
直接输出到文件的结果是对的。<br/>
所以改一下，重定向脚本输出到<em>.stdout,</em>.stderr，<br/>
最后调用e自己打开这两个文件就是了。<br/><br/>
先在cygwin下面ln -s给e的可执行文件建一个软连接，<br/>
我这里是/bin/e-texteditor，<br/><br/>
echo &#8220;begin running script&lt;/br&gt;&#8221;<br/>
if [[ -e ${TM_FILENAME}.args ]] ; then<br/>
perl_arg_line=<code>head -n1 ${TM_FILENAME}.args</code><br/>
./${TM_FILENAME} ${perl_arg_line} 1&gt;${TM_FILENAME}.stdout 2&gt;${TM_FILENAME}.stderr<br/>
else <br/>
./${TM_FILENAME} 1&gt;${TM_FILENAME}.stdout 2&gt;${TM_FILENAME}.stderr<br/>
fi <br/>
e-texteditor ${TM_FILENAME}.stderr<br/>
e-texteditor ${TM_FILENAME}.stdout<br/>
echo &#8220;running script complete&lt;/br&gt;&#8221;<br/><br/><br/><font color="#0000ff">》》cygwin shell</font><br/><br/>
用cygwin.bat打开的shell比较丑，<br/>
疼哥给了个很暴力的方法：<br/>
在cygwin中安上sshd，然后securecrt去连自己机器。<br/><br/>
先还是用setup-legacy.exe装上sshd这个组件。<br/>
配置方法，就按照<a target="_blank" href="http://www.baidu.com/baidu?wd=cygwin+sshd&amp;tn=monline_dg">网上讲的</a>即可。<br/>
sshd会开启成为windows的系统服务，<br/>
还会添加上一个特殊的用户。<br/><br/>
登陆的时候用的是自己的windows账户。<br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/09/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%B1%82printf%E7%9A%84%E5%8F%82%E6%95%B0%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E4%B8%A4%E4%B8%AA%EF%BC%9F%EF%BC%9F/">为什么要求printf的参数大于等于两个？？</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-09-24T22:13:00+08:00" pubdate data-updated="true">Sep 24<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.9.24<br/><br/>
之前用某代码检测工具的时候，被扣分了。<br/>
查看错误log发现是printf的参数只有一个。<br/><br/>
其实我只是简单地用printf打印一些信息到console，<br/>
中间也不涉及格式化其他变量，<br/>
故一直没有想明白这样做的意义何在。<br/>
大致就像这样吧：printf(&#8220;something&#8221;) ;<br/><br/>
printf确实有些危险的地方，<br/>
比如格式字符和后面的压栈的变量不匹配。<br/>
这样，在有指针操作的时候可能出问题，比如%s，<br/>
如果后面没有对应有效的指针，就可能打出一些古怪的东西。<br/><br/>
今天跟jingmi吃饭，说到了这个问题，原来主要是考虑到“%”的转义问题。<br/><br/>
比如传给printf的可能并非一个字符常量，而是一个变量。<br/>
直接 printf(s); 最大的问题就是s[]里面可能有“%”。<br/>
而s处于格式化字符串的位置，所以解析上会有问题。<br/>
而客户代码在调用的时候，没有理由用两个%去先做一次替换，<br/>
总不能假定我传过去的东西总是放在格式字符串的位置吧。<br/>
所以该代码检测工具也是有理的，提醒大家注意一下仅打印纯字符信息的情况。<br/>
最好是稍作修改：printf(&#8220;%s&#8221;,s); 这样会规避掉许多问题。<br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/09/20/pthread%E5%AF%B9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%85%A8%E5%B1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%94%AF%E6%8C%81/">Pthread对多线程访问全局数据结构的支持</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-09-20T22:03:00+08:00" pubdate data-updated="true">Sep 20<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.9.20<br/><br/>
pthread库里有两个函数，<br/>
对多线程访问全局数据结构提供了比较简易的解决方案：<br/>
pthread<em><font color="#ff0000">set</font>specific(key,value)<br/>
pthread</em><font color="#ff0000">get</font>specific(key)<br/>
使用之前得再man一下，需要create了key才能在这两个函数中使用。<br/>
后面就用set和get来代替他们了。<br/>
set可以将一个线程相关的value绑定到一个全局的key上面；<br/>
get可以从这个全局的key中取得线程相关的value。<br/><br/><font color="#0000ff">》》一个单线程示例</font><br/><br/>
global_data ; // in global scope<br/>
&#8230;<br/>
init(){ initialize global_data; }<br/>
&#8230;<br/>
op1(){ do something with global_data; }<br/>
op2(){ do something with global_data; }<br/>
&#8230;<br/>
opn(){ do something with global_data; }<br/>
&#8230;<br/>
work(){<br/>
init();<br/>
op1();<br/>
op2();<br/>
&#8230;<br/>
opn();<br/>
}<br/><br/>
比较常见的就是，在init里面，使用malloc之类的分配空间，<br/>
而这个所谓的global_data，就是分配空间后返回的指针。<br/>
在后续的各个操作函数中，通过这个指针去引用一些全局的数据。<br/><br/>
不要问我为什么不封装一下之类的，这个的原因可能很多。<br/>
比如，当年写这段代码的人没这个意识。<br/>
比如，为了少敲点键盘。如果放在参数里的话，每一处都会带上这么个指针。<br/>
反正各种原因和可能性，就不多说了。<br/><br/>
现在的问题是，由于时代发展了，我们想把这样一套东西多线程化。<br/>
但是这样一个global_data并非线程间共享的，<br/>
而是每个线程应该独有的数据结构，就是thread specific。<br/><br/><font color="#0000ff">》》一般的解决方案</font><br/><br/>
arr_global_data[N] ; // in global scope<br/>
&#8230;<br/>
init(data){ initialize data; }<br/>
&#8230;<br/>
op1(data){ do something with global_data; }<br/>
op2(data){ do something with global_data; }<br/>
&#8230;<br/>
opn(data){ do something with global_data; }<br/>
&#8230;<br/>
work(data){<br/>
init(data);<br/>
op1(data);<br/>
op2(data);<br/>
&#8230;<br/>
opn(data);<br/>
}<br/><br/>
main(){<br/>
create_thread(th0,work,arr_global_data[0]);<br/>
create_thread(th1,work,arr_global_data[1]);<br/>
&#8230;<br/>
create_thread(thn,work,arr_global_data[n]);<br/>
}<br/><br/>
这个方法倒是比较通用，<br/>
在各个系统下，创建线程的结构一般都允许传入工作函数和参数。<br/>
不管有多少参数，打包成一个结构，然后传入指针总是可以的。<br/>
之前只有单个的全局变量，现在开成数组即可。<br/><br/>
问题虽然解决了，但是有一点不方便的就是，我们大量修改了接口。<br/>
首先，各个操作函数需要传入参数，标识自己该用哪一块数据。<br/>
然后，可以预见到会有一定量的名称替换。<br/>
不过好处是，这样的写法在各个平台下都行，<br/>
不用依赖某些特殊的线程库的实现。<br/><br/><font color="#0000ff">》》pthread支持的解决方案</font><br/><br/><font color="#ff0000">global_data_key</font> ; // in global scope<br/>
&#8230;<br/>
init(){ initialize <font color="#ff00ff">data</font>; set(<font color="#ff0000">global_data_key</font>,<font color="#ff00ff">data</font>)}<br/>
&#8230;<br/>
op1(){ <font color="#ff00ff">data</font>=get(<font color="#ff0000">global_data_key</font>) ; do something with <font color="#ff00ff">data</font>; }<br/>
op2(){ <font color="#ff00ff">data</font>=get(<font color="#ff0000">global_data_key</font>) ; do something with <font color="#ff00ff">data</font>; }<br/>
&#8230;<br/>
opn(){ <font color="#ff00ff">data</font>=get(<font color="#ff0000">global_data_key</font>) ; do something with <font color="#ff00ff">data</font>; }<br/>
&#8230;<br/>
work(){<br/>
init() ;<br/>
op1();<br/>
op2();<br/>
&#8230;<br/>
opn();<br/>
}<br/><br/>
main(){<br/><font color="#ff0000">global_data_key </font>= create_key() ;<br/>
create_thread(th0,work,NULL);<br/>
create_thread(th1,work,NULL);<br/>
&#8230;<br/>
create_thread(thn,work,NULL);<br/>
}<br/><br/>
可以看到，这套解决方案在全局的位置，只是把data本身替换成了一个key。<br/>
在main函数中，对这个key进行初始化即可。<br/>
各个线程调用init后，可以将自身相关的data绑定到key上。<br/>
后面虽然各个op函数是相同的，但在get操作的时候，<br/>
pthread库帮忙判定是从哪个线程调用该op的，得到的就是对应的data。<br/><br/><font color="#0000ff">》》简评</font><br/><br/>
特别适合用在那种刚开始不是按照多线程进行设计的地方。<br/>
单线程程序work得很好后，通过这套接口来多线程化。<br/>
实际中遇到的项目可能并不像我这里一个work，里面几个op这么简单。<br/>
很可能是各种函数调用，到处都会引用到这样一个<font color="#ff0000">线程全局</font>的结构。<br/>
这时，逐一修改接口的成本是很大的，比较麻烦。<br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/08/16/n%E7%B3%BB%E5%88%97%E5%87%BD%E6%95%B0%E7%A9%B6%E7%AB%9F%E5%AE%89%E5%85%A8%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F%28snprintf%2Cstrncpy%2Cfgets%29/">N系列函数究竟安全在哪里？(snprintf,strncpy,fgets)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-08-16T22:15:00+08:00" pubdate data-updated="true">Aug 16<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.8.16<br/><br/>
最早建立起缓冲区长度这个意识是几年前参加astar的时候。<br/>
当时记得要求我们不能用gets进行输入，<br/>
即使是从标准输入来读，也要用fgets来传入stdin。<br/>
刚开始只是从官网上看到说这个函数不安全，<br/>
但究竟哪里不安全，没想明白，也没看到说清楚的。<br/><br/>
可能有人很直观地从技术上解释这个问题，<br/>
毕竟没有len就无法限制向缓冲区写入的数量。<br/>
这个确实到点子上了， 而我打一开始也知道这个。<br/>
但我一直存在的问题是，有len就安全了吗。。？<br/>
假设一个人很2，缓冲区只有1，他给len传了个10。<br/>
这种情况下，fgets也是逃不了厄运的。<br/><br/>
然后有人就说了，虽然不安全，但总归减少了一些隐患。<br/>
但我想大家都认同C的设计哲学：<br/><font color="#ff0000">程序员有最大的自由，并且充分知道每个动作的后果。</font><br/>
在这样的哲学下，多个len绝对是个50步与100步的问题。<br/>
所以，单纯从技术上来解释这个问题是不完善的。<br/><br/>
这几天，阅读了公司的内部编码规范，<br/>
又开始接手一个模块，看了很多历史遗留代码。<br/>
最后，突然意识到了答案：<br/><font color="#ff0000">n系列函数的安全实质上是责任的安全。</font><br/>
一开始来听这句话很别扭，<br/>
但仔细从工程的角度考量，<br/>
会发现说的确实是那么一回事。<br/><br/>
先来说说n系列函数，这个是我自己的叫法。<br/>
主要原因在于它们往往比我们常用的版本名字里面多了个n，<br/>
像snprintf、strncpy这些，同时参数里面多个len。<br/>
如果该函数需要产生的输出信息大于了这个len，<br/>
它不会傻傻地一直写缓冲，而是立刻停止。<br/><br/>
为什么说是责任安全呢？这个主要在于工程的合作性。<br/>
写C程序很容易会由于指针的问题，导致出core。<br/>
出core了第一时间当然是修复bug，<br/>
第二件事，很难免要追究某人的责任。<br/>
我们来看下，假设gets是你写的，而我是调用者。<br/>
这个时候，我只给开了1个字节的缓冲区，传给你。<br/>
因为没有len的参数，你不知道，就一直写，搞溢出了。<br/>
要是正好在你写的时候出core了，<br/>
那我们一追查，发现是gets把程序搞挂的。<br/>
这个时候你一定叫苦，以前的人都把缓冲区传够的， <br/>
就我这个2B开1字节就传了，明显是陷害的。<br/>
这个时候，虽然我自己很理亏，我确实手抖少打了两个0，<br/>
但我绝对会死不认账，反正不是core在我的代码上。<br/><br/>
对于gets和sprintf这种函数还好，<br/>
因为他们是标准的库函数，<br/>
我们会假定程序员一定是对他们了解透彻了的。<br/>
这就包括我们能够预估出一个最大的缓冲区长度，<br/>
一律开够了空间才进行调用。<br/>
这种假定下，责任当然是很好仲裁的。<br/>
但在一些大工程里面，如果出现类似的缓冲区操作，<br/>
我们总不能假定每个新加入的成员都知道前面的人写了个啥。<br/>
而函数的说明文档，不可能详细到教你怎么计算要多少缓冲。。<br/>
如果一定要细到这个程度，那客户自己就可以进行实现了。<br/><font color="#ff0000">合作的意义就在于不用了解细节，通过接口完成任务</font>。<br/>
如果一定要先计算好的话，那客户代码的信息量是可以赶上被调代码了。<br/>
比如，我可以给你封装一个函数，去计算sprintf要多大缓冲区：<br/>
&#8230;.<br/>
char buf[very_very_very_big] ;// global variable to avoid stack overflow<br/>
&#8230;.<br/>
int n = srpintf(buf, &#8220;xxxx&#8221;, &#8220;yy&#8221;, &#8220;zz&#8221;, &#8230;) ;<br/>
return n ;<br/>
&#8230;.<br/>
之所以这样写，是因为从格式字符串和参数计算缓冲大小太啰嗦了。<br/>
但像上面这样一写，就是明显的脱了裤子放屁。<br/><br/>
n系列函数就可以很好解决信息量不全的问题。<br/>
调用者只需要预估一个大小，传给被调者。<br/>
被调者是不允许操作限定外的空间，<br/>
并且从道德上讲，被调者应该返回执行状态。<br/>
这样调用者能够判断是否缓冲区过小，<br/>
决定是再开大点或者干脆就打条log撒手不干了。<br/><br/>
出core了当然很好判断。<br/>
如果调用者开了个小缓冲，传了个大的len，就打他屁股。<br/>
此外，被调者是不应该发生缓冲操作上的问题。<br/>
通过这么一个len，一下就实现了责任级的安全。<br/><br/><font color="#0000ff">》》外记</font><br/><br/>
像clapack这样的库，<br/>
新手拿到很痛苦的就是参数太多。<br/>
一看，很多接口上都要传缓冲和长度信息。<br/>
这个就是做事的一个极端，<br/>
clapack自己是不动态分配空间的，<br/>
完全让调用者来做好一些准备。<br/>
除了像我们平时传的，输入和输出缓冲，<br/>
它还有种中间运算的缓冲。<br/>
根据你给的缓冲大小，选择不同时空复杂度的算法。。<br/>
如果中间运算缓冲不够，有详细的返回值来帮助纠错。<br/>
这应该算是缓冲区处理上的一个极致：<br/>
不仅要你声明给我的缓冲区有多大，<br/>
甚至运算空间都让你开，省的我malloc出错了挂在这里。。<br/><br/>
还有一些函数，像SOCKET里的inet_ntoa。<br/>
一个IP转换后会有多少个字符是不定的，<br/>
所以也需要考虑究竟给多少缓冲的问题。<br/>
这个例子还好，因为我们知道IP的点分十进制的最大长度。<br/>
不过SOCKET给了另外一个接口，直接返回结果缓冲的指针。<br/>
通过静态分配支持最大长度的缓冲，<br/>
避免了与调用者交互相关信息。<br/>
在最初设计的时候，这个接口做到了方便和安全（对这里的缓冲区长度问题安全）。<br/>
不过在多线程的时候，问题就出来了。<br/>
静态分配的地址都是同一块，<br/>
大家一起调用inet_ntoa就会导致数据不同步。<br/>
解决办法可以是重写个动态分配的版本，<br/>
于是又要面临本篇提及和没提及的相关琐碎。<br/>
还有种方法就是直接加锁，<br/>
用系统级的mutex来同步即可。<br/>
这样可以做到接口不变，不影响既有代码。<br/><br/><font color="#0000ff">》》后记</font><br/><br/>
现在混江湖了，好不容易有点时间。<br/>
有时间的时候，有些事情又不能说得太细。。<br/>
放屁前也要先包装一下，不能把原始信息透露了。<br/>
讲问题只能讲原理，要不重写一份不一样的实现。<br/><br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/07/10/%E7%A6%BB%E6%A0%A1%E5%89%8D%E9%85%B1%E6%B2%B9%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%AF%94%E8%B5%9B%EF%BC%88%E6%95%B0%E7%8B%AC%E6%B8%B8%E6%88%8F%EF%BC%89/">离校前酱油最后一个比赛（数独游戏）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-07-10T17:44:00+08:00" pubdate data-updated="true">Jul 10<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.7.9<br/><br/>
游戏，源码，工程，文档：<a href="http://www.box.net/shared/cqvr7du92i" target="_blank">下载</a><br/>
（比赛提交的原样内容）<br/><br/><font color="#0000ff">》》背景：</font><br/><br/>
华为这次也是拖了够久了，都要吐血了。<br/>
这效率。。。唉。。只能说唉。。<br/><br/>
比赛从早上9点一直刚到下午5点，<br/>
中午管饭的，但饮水机缺水好几次。。<br/>
找的房间没空调，急得人直冒汗。<br/>
比到半截，刚不起了，下楼找实验室，<br/>
自带了一个风扇，继续写。。<br/><br/>
说来也是奇怪，<br/>
一个号称的程序设计大赛居然和通信合作。<br/>
这种事情再怎么也要找计算机的专业点吧。<br/>
通信的机房倒是安了一堆CCS这样我们不用的东西，<br/>
结果连最基本的MSDN都没有。<br/>
于是最初为了绘那几个界面，<br/>
折腾了半天，连猜带懵加看头文件。<br/><br/>
这学期毕设一直是用C#酱油界面，<br/>
搞得VC的一套都很生疏了。<br/>
最后利用的强大的windows画图板，<br/>
把题目说明中的图样修改了下，<br/>
弄成了背景，和鼠标悬停高亮的样子。<br/><br/>
不过VC就是好，虽然记不清楚细节，<br/>
但只要有点想法，总有变通解决方案。<br/>
如果是C#就惨了，很多东西不知道就没法用，<br/>
真正做的时候，也是需要什么搜什么。<br/><br/>
算法方面就更酱油了，<br/>
按理说一天纯写算法的话也够多种优化了。<br/>
记得以前看过<a href="http://blog.csdn.net/mathe/archive/2007/08/23/1755672.aspx" target="_blank">mathe总结的数独</a>，<br/>
大概有10来种直接推法。<br/>
大部分的数独都可以直接用这些方法推出，<br/>
只用进行一点点的枚举就行了，<br/>
真是总结得很到位，太强大了。<br/>
上面链接过去能找到他做的程序，<br/>
操作很方便，而且附带提示功能，<br/>
用于学习数独技巧也是很好的。<br/><br/>
最初没有想到是做这样的东西，<br/>
时间分配很不均匀。<br/>
前面基本上是学习绘图，做UI，<br/>
最后个多小时写的算法和文档。。<br/>
所以成品中的算法异常简陋，<br/>
只是有考虑候选数的回溯，<br/>
连唯一数和隐含唯一数两种最简单的判断都没写。<br/>
跑了下，题目附带的前20号游戏都能出结果，<br/>
时间耗得最长的也就是秒级，于是接受了。<br/><br/>
生成局面的算法，下来后才反应过来。<br/>
其实最简单的就是直接拿那20个有解的做种子，<br/>
从中间随机去掉一些数字就行了，<br/>
这样可以避免有解的判断。<br/>
当时是直接向上面填数字，<br/>
虽然是从候选数中填上的，<br/>
从直接局面看是无冲突的，<br/>
但最后也可能填到无解的情况。<br/><br/><font color="#0000ff">》》效果：</font><br/><br/><span><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/c762de3f91e20dfd7c1e71fb.jpg" small="0" class="blogimg"/></span><br/><br/>
点击左键弹出这样一个面板，可以输入数字或者候选数字。<br/>
感觉这个弹框比较丑，没时间做美化了。。<br/>
如果要删除某个输入的数字或者候选数字，在上面右击即可。<br/><br/><span><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/1e5905246cd1700cc99559fb.jpg" small="0" class="blogimg"/></span><br/><br/>
一个放大的细节。<br/>
橘黄色的是高亮当前格，<br/>
这个黄框也是从题目的word文档中改造过来的，<br/>
看起来总觉得不行。。<br/>
蓝色是原有的数字，红色是填入的数字，<br/>
小的斜体“3、5、4”是用户输入的可能候选数。<br/>
这个候选数只是辅助用户思考所用。<br/><br/><span><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/1bbfb919a9b21e7a42a9adc4.jpg" small="0" class="blogimg"/></span><br/><br/>
这是随手写的一个最简单的单格提示功能，<br/>
把每个格子用行列宫的规则判断后，<br/>
剩下能填的数都列在里面，帮助用户思考。<br/><br/><span><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/56fab312c78a6af1c2fd78fb.jpg" small="0" class="blogimg"/></span><br/><br/>
选择全部解答后，自动填上的数字。<br/><br/><span><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/a973a301287ec7391c9583c4.jpg" small="0" class="blogimg"/></span><br/><br/><font color="#0000ff">》》改进：</font><br/><br/>
UI需要统一一下风格：<br/>
输入数字的弹窗，<br/>
载入游戏的弹窗，<br/>
生成新游戏的弹窗。<br/>
都弄成主界面这个样子的。<br/><br/>
增加撤销和重复操作的功能。<br/>
现在程序里面有的是删除数字的功能。<br/>
而撤销是带有顺序的，<br/>
可以删除一连串的填入。<br/>
这个很有必要，<br/>
因为前后数字的填入是有相关性的。<br/>
简单删除可能会由于误操作而形成混乱。<br/><br/>
高亮效果还是用DC直接画吧，<br/>
贴图的太不逼真了。。<br/>
而且还是mspaint修饰出来。。<br/>
特别是如果后面要加其他演示效果，<br/>
贴图叠在一起的样子可能更不好控制。<br/><br/>
算法上，确实差得比较远，<br/>
可以考虑向mathe谈到的几种靠近。<br/>
可以把各种提示的演示都加出来。<br/><br/>
不过说归说，这些都不打算做了，记下而已。<br/>
没想到酱油这么个小东西都折腾了一天。。<br/><font color="#0000ff"><br/>
》》关于绘图</font><br/><br/>
一般的小游戏，刷新不频繁，用DC就够了。<br/>
代码构造一般是：<br/>
输入事件的处理中，改变游戏状态，<br/>
必要的时候触发绘图事件。<br/>
绘图事件中，根据游戏状态依次绘制各个元素。<br/><br/>
触发绘图事件一般用Invalidate。<br/><br/>
如果绘图有闪烁，可以Invalidate(false)。<br/>
这样可以不用系统擦除背景，提高点效率。<br/><br/>
如果还是比较闪烁，可以考虑双缓冲。<br/>
先在一个兼容的内存DC里面画图，<br/>
画完后再一次性地bitblt到屏幕上面。<br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/06/20/%E8%A7%A3%E6%9E%90IP%E5%A4%B4%E7%9A%84demo/">解析IP头的demo</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-06-20T21:35:00+08:00" pubdate data-updated="true">Jun 20<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.6.20<br/><br/>
以前应付作业，抓抓包，抄几个数据，<br/>
并没有发现这里面太多的猫腻。<br/>
今天看课件的时候，发现一处错误。<br/>
课件上对IP头的结构体定义为：<br/><br/>
typedef struct _iphdr1{<br/>
UCHAR version;    /<em> IP version number ,header length??? </em>/<br/>
UCHAR tos;        /<em> Type of service </em>/<br/>
USHORT length;    /<em> Total length </em>/<br/>
USHORT id;        /<em> Identification </em>/<br/><font color="#ff0000">    unsigned int congest:1;/<em> Congestion experienced bit (exp) </em>/<br/>
unsigned int df:1;        /<em> Don&#8217;t fragment flag </em>/<br/>
unsigned int mf:1;        /<em> More Fragments flag </em>/<br/>
USHORT Offset:13;        /<em> Fragment offset in bytes </em>/</font><br/>
UCHAR ttl;            /<em> Time to live </em>/<br/>
UCHAR protocol;        /<em> Protocol </em>/<br/>
USHORT checksum;    /<em> Header checksum </em>/<br/>
ULONG source;        /<em> Source address </em>/<br/>
ULONG dest;        /<em> Destination address </em>/<br/>
UCHAR optlen;        /<em> Length of options field, bytes </em>/<br/>
UCHAR options[IP_MAXOPT];    /<em> Options field </em>/<br/>
} iphdr1;<br/><br/>
标红的这段在顺序上应该是有问题的。<br/><br/>
关于IP头的格式详细定义：<a href="http://hi.baidu.com/hplonline/blog/item/6a639451076bc22e43a75ba8.html" target="_blank">这里</a>。<br/>
关于位域细节的说明：<a href="http://hi.baidu.com/hplonline/blog/item/4411b8fba8d9562f4e4aeaa3.html" target="_blank">这里</a>。<br/><br/>
有了以上认识之后，就可以知道标红的段有两个错误：<br/><font color="#ff0000">1。顺序与IP头的定义不一致。<br/>
2。会造成对齐上的错误。</font><br/><br/>
另外，这个定义把VERSION和HLEN合成了一个VERSION字段。<br/>
这个也不算错误，只能说是一种工程上的简化。<br/>
在大多数情况下，第一个字节都是0x45。（IPv4，5*4=20的头长）<br/>
这样，我们直接定义成一个整字节就行了，<br/>
然后在收到数据包的时候，提取低4位看下是多少。<br/><br/><font color="#0000ff">》》实验程序</font><br/><br/></p>

<h1>include &lt;stdio.h&gt;<br/></h1>

<h1>include &lt;string.h&gt;<br/></h1>

<h1>include &lt;winsock.h&gt;<br/><br/></h1>

<h1>pragma comment(lib, &#8220;ws2_32.lib&#8221;)<br/><br/></h1>

<p>typedef unsigned char UCHAR ;<br/>
typedef unsigned short USHORT ;<br/>
typedef unsigned int UINT ;<br/>
typedef unsigned long ULONG ;<br/><br/></p>

<h1>define IP_MAXOPT 20 <br/><br/></h1>

<p>typedef struct <em>iphdr1{<br/>
UCHAR version;    /<em> IP version number ,header length??? </em>/<br/>
UCHAR tos;        /<em> Type of service </em>/<br/>
USHORT length;    /<em> Total length </em>/<br/>
USHORT id;        /<em> Identification </em>/<br/><font color="#ff0000">    unsigned int congest:1;/<em> Congestion experienced bit (exp) </em>/<br/>
unsigned int df:1;        /<em> Don&#8217;t fragment flag </em>/<br/>
unsigned int mf:1;        /<em> More Fragments flag </em>/<br/>
USHORT Offset:13;        /<em> Fragment offset in bytes </em>/</font><br/>
UCHAR ttl;            /<em> Time to live </em>/<br/>
UCHAR protocol;        /<em> Protocol </em>/<br/>
USHORT checksum;    /<em> Header checksum </em>/<br/>
ULONG source;        /<em> Source address </em>/<br/>
ULONG dest;        /<em> Destination address </em>/<br/>
UCHAR optlen;        /<em> Length of options field, bytes </em>/<br/>
UCHAR options[IP_MAXOPT];    /<em> Options field </em>/<br/><font color="#ff0000">} iphdr1;</font><br/><br/>
typedef struct </em>iphdr2{<br/>
UCHAR version;    /<em> IP version number ,header length??? </em>/<br/>
UCHAR tos;        /<em> Type of service </em>/<br/>
USHORT length;    /<em> Total length </em>/<br/>
USHORT id;        /<em> Identification </em>/<br/><font color="#ff0000">    USHORT Offset:13;        /<em> Fragment offset in bytes </em>/<br/>
unsigned int mf:1;        /<em> More Fragments flag </em>/<br/>
unsigned int df:1;        /<em> Don&#8217;t fragment flag </em>/<br/>
unsigned int congest:1;/<em> Congestion experienced bit (exp) </em>/</font><br/>
UCHAR ttl;            /<em> Time to live </em>/<br/>
UCHAR protocol;        /<em> Protocol </em>/<br/>
USHORT checksum;    /<em> Header checksum </em>/<br/>
ULONG source;        /<em> Source address </em>/<br/>
ULONG dest;        /<em> Destination address </em>/<br/>
UCHAR optlen;        /<em> Length of options field, bytes </em>/<br/>
UCHAR options[IP_MAXOPT];    /<em> Options field </em>/<br/><font color="#ff0000">} iphdr2;</font><br/><br/>
typedef struct _iphdr3{<br/>
UCHAR version;    /<em> IP version number ,header length??? </em>/<br/>
UCHAR tos;        /<em> Type of service </em>/<br/>
USHORT length;    /<em> Total length </em>/<br/>
USHORT id;        /<em> Identification </em>/<br/><font color="#ff0000">    USHORT Offset:13;        /<em> Fragment offset in bytes </em>/<br/>
USHORT mf:1;        /<em> More Fragments flag </em>/<br/>
USHORT df:1;        /<em> Don&#8217;t fragment flag </em>/<br/>
USHORT congest:1;/<em> Congestion experienced bit (exp) </em>/</font><br/>
UCHAR ttl;            /<em> Time to live </em>/<br/>
UCHAR protocol;        /<em> Protocol </em>/<br/>
USHORT checksum;    /<em> Header checksum </em>/<br/>
ULONG source;        /<em> Source address </em>/<br/>
ULONG dest;        /<em> Destination address </em>/<br/>
UCHAR optlen;        /<em> Length of options field, bytes </em>/<br/>
UCHAR options[IP_MAXOPT];    /<em> Options field </em>/<br/>
}<font color="#ff0000"> iphdr;</font><br/><br/>
char buf1[] = {0x45 ,0x00 ,0x05 ,0xdc ,0x00 ,0x26 ,0x20 ,0x00 ,0x80 <br/>
,0x01 ,0x72 ,0xa5 ,0xc0 ,0xa8 ,0x0b ,0x02 ,0xc0 ,0xa8 ,0x16 ,0x03} ;<br/><br/>
char buf2[] = {0x45 ,0x00 ,0x00 ,0x30 ,0x00 ,0x26 ,0x00 ,0xb9 ,0x80 <br/>
,0x01 ,0x97 ,0x98 ,0xc0 ,0xa8 ,0x0b ,0x02 ,0xc0 ,0xa8 ,0x16 ,0x03} ;<br/><br/>
void analyze(char <em>bufin , int len){<br/>
char buf[512] ;<br/>
memcpy(buf , bufin , len) ;<br/>
static count = 0 ;<br/>
printf(&#8220;IP HEADER: %d\n&#8221; , ++count) ;<br/>
puts(&#8220;=============&#8221;) ;<br/>
iphdr </em>p = (iphdr<em>)buf ;<br/>
printf(&#8220;version:0x%x\n&#8221; , p-&gt;version) ;<br/>
printf(&#8220;tos:0x%x\n&#8221; , p-&gt;tos) ;<br/>
printf(&#8220;length:%d\n&#8221; , ntohs(p-&gt;length)) ;<br/>
printf(&#8220;identifier:0x%x\n&#8221; , ntohs(p-&gt;id)) ;<br/>
USHORT </em>pu = (USHORT<em>)&amp;p-&gt;id + 1 ;<br/>
//printf(&#8220;%x\n&#8221; , </em>pu) ;<br/>
<em>pu = ntohs(</em>pu) ;<br/>
//printf(&#8220;%x\n&#8221; , <em>pu) ;<br/>
printf(&#8220;congest?:%d\n&#8221; , p-&gt;congest) ;<br/>
printf(&#8220;don&#8217;t fragment?:%d\n&#8221; , p-&gt;df) ;<br/>
printf(&#8220;more gragment?:%d\n&#8221; , p-&gt;mf) ;<br/>
printf(&#8220;offset:0x%x , (%d Bytes)\n&#8221; , p-&gt;Offset , p-&gt;Offset * 8) ;<br/>
printf(&#8220;ttl:%d\n&#8221; , p-&gt;ttl) ;<br/>
printf(&#8220;protocol:%d\n&#8221; , p-&gt;protocol) ;<br/>
printf(&#8220;checksum:0x%x\n&#8221; , ntohs(p-&gt;checksum)) ;<br/>
SOCKADDR_IN addr ;<br/>
addr.sin_addr.S_un.S_addr = p-&gt;source ;<br/>
printf(&#8220;source ip:%s\n&#8221; , inet_ntoa(addr.sin_addr)) ;<br/>
addr.sin_addr.S_un.S_addr = p-&gt;dest ;<br/>
printf(&#8220;destination ip:%s\n&#8221; , inet_ntoa(addr.sin_addr)) ;    <br/>
puts(&#8220;=============&#8221;) ;<br/>
putchar(&#8216;\n&#8217;) ;<br/>
}<br/><br/>
int main(){<br/>
analyze(buf1 , sizeof(buf1)) ;<br/>
analyze(buf2 , sizeof(buf2)) ;<br/>
return 0 ; <br/>
}<br/><br/>
程序里面，将需要测试的结构typedef为iphdr，<br/>
另外的typedef为其他名字即可，<br/>
这样，可以依次测试三种写法的效果。<br/><br/>
buf1和buf2是实际ping的时候，<br/>
抓出来的IP头部分的字节流。<br/><br/><font color="#0000ff">》》实验结果</font><br/><br/>
以WireShark的输出为标准，先来看下：<br/><br/>
第一个报文：<br/><span><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/28eb2b3f18a8b6d155e723aa.jpg" small="0" class="blogimg"/></span><br/><span><br/>
第二个报文：<br/><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/34c7de2a5d92f9a6023bf6aa.jpg" small="0" class="blogimg"/></span><br/><br/><font color="#ff00ff">结构体1的输出：</font><br/><br/>
IP HEADER: 1<br/>
=============<br/>
version:0x45<br/>
tos:0x0<br/>
length:1500<br/>
identifier:0x26<br/>
congest?:0<br/>
don&#8217;t fragment?:0<br/>
more gragment?:0<br/>
offset:0x8c0 , (17920 Bytes)<br/>
ttl:11<br/>
protocol:2<br/>
checksum:0xc0a8<br/>
source ip:204.204.204.204<br/>
destination ip:204.204.204.204<br/>
=============<br/><br/>
IP HEADER: 2<br/>
=============<br/>
version:0x45<br/>
tos:0x0<br/>
length:48<br/>
identifier:0x26<br/>
congest?:0<br/>
don&#8217;t fragment?:0<br/>
more gragment?:0<br/>
offset:0x8c0 , (17920 Bytes)<br/>
ttl:11<br/>
protocol:2<br/>
checksum:0xc0a8<br/>
source ip:204.204.204.204<br/>
destination ip:204.204.204.204<br/>
=============<br/><br/><font color="#ff00ff">结构体2的输出：</font><br/><br/>
IP HEADER: 1<br/>
=============<br/>
version:0x45<br/>
tos:0x0<br/>
length:1500<br/>
identifier:0x26<br/>
congest?:0<br/>
don&#8217;t fragment?:0<br/>
more gragment?:0<br/>
offset:0x0 , (0 Bytes)<br/>
ttl:192<br/>
protocol:168<br/>
checksum:0xb02<br/>
source ip:192.168.22.3<br/>
destination ip:204.204.204.204<br/>
=============<br/><br/>
IP HEADER: 2<br/>
=============<br/>
version:0x45<br/>
tos:0x0<br/>
length:48<br/>
identifier:0x26<br/>
congest?:0<br/>
don&#8217;t fragment?:0<br/>
more gragment?:0<br/>
offset:0xb9 , (1480 Bytes)<br/>
ttl:192<br/>
protocol:168<br/>
checksum:0xb02<br/>
source ip:192.168.22.3<br/>
destination ip:204.204.204.204<br/>
=============<br/><br/><font color="#ff00ff">结构体3的输出：</font><br/><br/>
IP HEADER: 1<br/>
=============<br/>
version:0x45<br/>
tos:0x0<br/>
length:1500<br/>
identifier:0x26<br/>
congest?:0<br/>
don&#8217;t fragment?:0<br/>
more gragment?:1<br/>
offset:0x0 , (0 Bytes)<br/>
ttl:128<br/>
protocol:1<br/>
checksum:0x72a5<br/>
source ip:192.168.11.2<br/>
destination ip:192.168.22.3<br/>
=============<br/><br/>
IP HEADER: 2<br/>
=============<br/>
version:0x45<br/>
tos:0x0<br/>
length:48<br/>
identifier:0x26<br/>
congest?:0<br/>
don&#8217;t fragment?:0<br/>
more gragment?:0<br/>
offset:0xb9 , (1480 Bytes)<br/>
ttl:128<br/>
protocol:1<br/>
checksum:0x9798<br/>
source ip:192.168.11.2<br/>
destination ip:192.168.22.3<br/>
=============<br/><br/><font color="#0000ff">》》结论</font><br/><br/>
很显然，第三种写法才是对的。<br/><br/>
但重要的不是什么对，而是前两个错在哪里。<br/>
从代码可以看到，第二个在第一个的基础上交换了conget，df，mf，offset的顺序。<br/>
在输出结果中，可以看到，程序打印出了正确的offset。<br/>
但由于“对齐”的问题，另外三个flag被放到下一个int里面去了。<br/>
这也导致后面的数据域被推后了，所以均产生错误。<br/>
第三个在第二个的基础上用USHORT统一了定义。<br/>
上篇对<a href="http://hi.baidu.com/hplonline/blog/item/4411b8fba8d9562f4e4aeaa3.html" target="_blank">位域</a>详细分析过了，<br/>
只有都用USHORT，临近的成员才能放在一起。<br/><br/><font color="#0000ff">》》关于analyze函数</font><br/><br/>
其实这个demo的关键在于记录了一种方法：<br/><font color="#ff0000">通过结构体来对缓冲区进行格式化。</font><br/><br/>
再摘抄一下：<br/><br/>
void analyze(char </em>bufin , int len){<br/>
char buf[512] ;<br/>
memcpy(buf , bufin , len) ;<br/>
static count = 0 ;<br/>
printf(&#8220;IP HEADER: %d\n&#8221; , ++count) ;<br/>
puts(&#8220;=============&#8221;) ;<br/>
iphdr <em>p = (iphdr</em>)buf ;<br/>
printf(&#8220;version:0x%x\n&#8221; , p-&gt;version) ;<br/>
printf(&#8220;tos:0x%x\n&#8221; , p-&gt;tos) ;<br/>
printf(&#8220;length:%d\n&#8221; , <font color="#ff0000">ntohs(</font>p-&gt;length)) ;<br/>
printf(&#8220;identifier:0x%x\n&#8221; , <font color="#ff0000">ntohs(</font>p-&gt;id)) ;<br/><font color="#ff0000">   USHORT <em>pu = (USHORT</em>)&amp;p-&gt;id + 1 ;<br/>
//printf(&#8220;%x\n&#8221; , <em>pu) ;<br/>
</em>pu = ntohs(<em>pu) ;<br/>
//printf(&#8220;%x\n&#8221; , </em>pu) ;</font><br/>
printf(&#8220;congest?:%d\n&#8221; , p-&gt;congest) ;<br/>
printf(&#8220;don&#8217;t fragment?:%d\n&#8221; , p-&gt;df) ;<br/>
printf(&#8220;more gragment?:%d\n&#8221; , p-&gt;mf) ;<br/>
printf(&#8220;offset:0x%x , (%d Bytes)\n&#8221; , p-&gt;Offset , p-&gt;Offset * 8) ;<br/>
printf(&#8220;ttl:%d\n&#8221; , p-&gt;ttl) ;<br/>
printf(&#8220;protocol:%d\n&#8221; , p-&gt;protocol) ;<br/>
printf(&#8220;checksum:0x%x\n&#8221; , <font color="#ff0000">ntohs(</font>p-&gt;checksum)) ;<br/>
SOCKADDR_IN addr ;<br/>
addr.sin_addr.S_un.S_addr = p-&gt;source ;<br/>
printf(&#8220;source ip:%s\n&#8221; ,<font color="#ff0000"> inet_ntoa(</font>addr.sin_addr)) ;<br/>
addr.sin_addr.S_un.S_addr = p-&gt;dest ;<br/>
printf(&#8220;destination ip:%s\n&#8221; , <font color="#ff0000">inet_ntoa(</font>addr.sin_addr)) ;    <br/>
puts(&#8220;=============&#8221;) ;<br/>
putchar(&#8216;\n&#8217;) ;<br/>
}<br/><br/>
以前，对<a href="http://hi.baidu.com/hplonline/blog/item/6a639451076bc22e43a75ba8.html" target="_blank">IP和TCP格式的记录</a>中有一段十分生涩的话。<br/>
虽然有点朦胧的感觉，还是硬性记录了下来，<br/>
但在多次跟别人交流的时候，总是无法把这个问题说清楚。<br/>
如果一个人不进行实际的编程，就无法意识到这中间的猫腻，<br/>
脑袋里的唯一印象就是：“这东西我看着很自然的啊，你搞复杂了吧“。<br/><br/>
这个analyze函数所展示的，主要是<font color="#ff0000">网络字节序</font>的问题。<br/><br/>
先来看下IP头的定义：<br/><br/><span><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/4868b8b7d14f52db33add162.jpg" small="0" class="blogimg"/></span><br/><br/>
对于整字节的元素（8bit，16bit，32bit），我们可以直接操作。<br/>
比如TOTAL LENGTH，直接按照USHORT读出来即可。<br/>
在代码中，使用ntohs进行转化，就得到了以主机字节序表示的总长。<br/><br/>
但是注意第二个红框（flags，offset），这里就比较麻烦了。<br/>
对于这种非整字节组合的域，不能直接读取。<br/>
首先应该按照基础存储类型取出（就是结构定义中的USHORT），<br/>
使用ntohs转化为主机字节序，再写回到缓冲区中的原位置。<br/>
（不写也可以，那么就需要自行提取高3位和低13位，<br/>
这失去了<font color="#ff0000">定义结构体的意义</font>）<br/>
（定义结构体，就是为了不用通过指针和偏移访问缓冲，<br/>
直接引用结构体的成员就行了）<br/>
而<a href="http://hi.baidu.com/hplonline/blog/item/4411b8fba8d9562f4e4aeaa3.html" target="_blank">上篇</a>提到过，不能取位域的地址，<br/>
这个定义非常的不爽，于是只有手动获得指针：<br/><font color="#ff0000">   USHORT <em>pu = (USHORT</em>)&amp;p-&gt;id + 1 ;</font><br/>
而这个动作，一瞬间就把结构体的优美特性抹杀了。。<br/><br/>
那么能不能通过比较好的定义flags和offset，<br/>
以达到不需要通过指针偏移和ntohs来交换，直接解析呢？？<br/><font color="#ff0000">在小尾机上我是真没啥好办法，有好办法的同学麻烦通知一下。</font><br/>
在大尾机上当然就不用题了，因为ntohs就是一个空壳函数，<br/>
于是我们正确定义了结构后（比如上面的第三个结构），直接读出来就行了。。。<br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/06/20/%E6%9C%89%E5%85%B3C%E4%BD%8D%E5%9F%9F%E4%BD%BF%E7%94%A8%E7%9A%84%E7%BB%86%E8%8A%82/">有关C位域使用的细节</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-06-20T20:43:00+08:00" pubdate data-updated="true">Jun 20<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.6.20<br/><br/><font color="#0000ff">》》位域</font><br/><br/>
位域就是这样的东西：<br/><br/>
struct _mystr{<br/>
int b:<font color="#ff0000">1 </font>;<br/>
}<br/><br/>
一般写上层程序的时候很少使用，<br/>
毕竟最初发明它主要是出于存储开销的考虑。<br/>
随便一想，就知道这东西其实并不能给执行效率带来什么好处。<br/>
既然是处理位域，那么一个通用的赋值显然有三个部分组成：<br/><font color="#ff0000">1。原变量and上一个掩码，清空要赋值的部分<br/>
2。把要赋的值进行移位，以对齐到位域的最低位<br/>
3。用一个or把值赋上去。</font><br/><br/>
当然，这几个部分可能由编译器进行一定量的合并，<br/>
但这并不能从本质上改进什么东西。<br/><br/>
在很早很早的时候，计算机的容量又小，网络环境又差。<br/>
于是在不少协议中，位域得到了比较广泛的应用。<br/><br/>
关于位域，至少可以想到两个问题：<br/><font color="#ff9900">1。定义顺序和存储顺序？<br/>
2。如何进行内存对齐？</font><br/><br/><font color="#0000ff">》》实验</font><br/><br/><font color="#ff0000">环境：小尾机，VC6.DEBUG，.cpp编译</font><br/><br/></p>

<h1>include &lt;stdio.h&gt;<br/></h1>

<h1>include &lt;string.h&gt;<br/><br/></h1>

<p>typedef struct <em>str1{<br/>
unsigned int b1:1 ;<br/>
unsigned int b2:1 ;<br/>
unsigned int b3:1 ;<br/>
unsigned int rest:13 ;<br/>
}STR1 ;<br/><br/>
typedef struct </em>str2{<br/>
unsigned int b1:1 ;<br/>
unsigned int b2:1 ;<br/>
unsigned int b3:1 ;<br/><font color="#ff0000">unsigned short</font> rest:13 ;<br/>
}STR2 ;<br/><br/>
typedef struct <em>str3{<br/>
unsigned short b1:1 ;<br/>
unsigned short b2:1 ;<br/>
unsigned short b3:1 ;<br/>
unsigned short rest:13 ;<br/>
}STR3 ;<br/><br/><font color="#ff0000">#pragma pack(1)</font><br/>
typedef struct </em>str4{<br/>
unsigned int b1:1 ;<br/>
unsigned int b2:1 ;<br/>
unsigned int b3:1 ;<br/>
unsigned short rest:13 ;<br/>
}STR4 ;<br/><font color="#ff0000">#pragma pack()</font><br/><br/>
int main(){<br/>
printf(&#8220;%d,%d,%d,%d\n&#8221; , sizeof(STR1) , sizeof(STR2) , sizeof(STR3) , sizeof(STR4)) ;<br/><br/>
STR1 str ;<br/>
memset(&amp;str , 0 , sizeof(str)) ;<br/>
str.b1 = 1 ;<br/>
printf(&#8220;%x\n&#8221; , (unsigned int)<em>(unsigned int</em>)&amp;str) ;<br/>
str.b3 = 1 ;<br/>
printf(&#8220;%x\n&#8221; , (unsigned int)<em>(unsigned int</em>)&amp;str) ;<br/>
str.rest = 7 ;<br/>
return 0 ;<br/>
}<br/><br/>
输出：<br/><br/>
4,8,2,6<br/>
1<br/>
5<br/><br/><font color="#0000ff">》》结论</font><br/><br/>
定义顺序和存储顺序与一般的结构成员是一致的：<br/><font color="#ff0000">定义在前面（上面）的元素会放在低位。</font><br/><br/>
内存对齐的原则是，以pack的设置和基类型为标准。（STR1和STR3）<br/>
STR2告诉我们，如果前后的基类型不同，<br/>
不会按照位域进行合并，头一个基类型会直接填充满。<br/>
STR4告诉我们，即使用pack也无法缩减掉基类型中的空白。<br/><br/>
这几个结论，对于刚刚看完百科式C语言教材的人来说，<br/>
也许是显然的，但实验的方法让我们可以应对不同环境。<br/>
并且，这种显然的结论，当自己手写程序的时候，往往就不那么显然了。<br/>
比如，上面定义的几个结构体，其实就是模仿看到的某段IP头结构体的定义。<br/>
congest,df,mf三个1bit的位，加上13bit的offset。<br/><br/>
另外有一点很不爽的是，<br/><font color="#ff0000">C不允许我们对位域取地址（用&amp;操作符）。</font><br/>
在实践中，这实际上会引起一些不方便，<br/><font color="#ff0000">我觉得</font>更合适的定义是：<br/><font color="#ff0000">对位域取地址得到的是其基础类型所在的地址。</font><br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/06/18/C%E4%B8%AD%E7%9A%84Trigraphs/">C中的Trigraphs</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-06-18T21:12:00+08:00" pubdate data-updated="true">Jun 18<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.6.18<br/><br/>
今天又在论坛火星地发现一个东西了。。<br/>
先来个加强版的demo：<br/><font color="#ff00ff"><br/></p>

<h1>include &lt;stdio.h&gt;<br/><br/></h1>

<p>int main()??&lt;<br/>
printf(&#8220;??!&#8221;) ;<br/>
printf(&#8220;%d&#8221; ,  1 ??&#8217; 0) ;<br/>
return 0 ;<br/>
??&gt;</font><br/><br/><font color="#0000ff">》》转：关于Trigraphs</font><br/><br/>
Trigraphs<br/>
The source character set of C source programs is contained within the 7-bit ASCII character set but is a superset of the ISO 646-1983 Invariant Code Set. Trigraph sequences allow C programs to be written using only the ISO (International Standards Organization) Invariant Code Set. Trigraphs are sequences of three characters (introduced by two consecutive question marks) that the compiler replaces with their corresponding punctuation characters. You can use trigraphs in C source files with a character set that does not contain convenient graphic representations for some punctuation characters.<br/><br/>
Table 1.1 shows the nine trigraph sequences. All occurrences in a source file of the punctuation characters in the first column are replaced with the corresponding character in the second column.<br/><br/>
Table 1.1   Trigraph Sequences<br/><br/>
Trigraph Punctuation Character<br/>
??= #<br/>
??( [<br/>
??/ &lt;br/>
??) ]<br/>
??’ ^<br/>
??&lt; {<br/>
??!  |<br/>
??&gt; }<br/>
??-  ~<br/><br/><br/>
A trigraph is always treated as a single source character. <font color="#ff0000">The translation of trigraphs takes place in the firsttranslation phase</font>, before the recognition of escape characters in string literals and character constants. Only the nine trigraphs shown in Table 1.1 are recognized. All other character sequences are left untranslated.<br/><br/>
The character escape sequence, \?, prevents the misinterpretation of trigraph-like character sequences. (For information about escape sequences, see Escape Sequences.) For example, if you attempt to print the string What??! with this printf statement<br/><br/>
printf( &#8220;What??!\n&#8221; );<br/><br/>
the string printed is What| because ??! is a trigraph sequence that is replaced with the | character. Write the statement as follows to correctly print the string:<br/><br/>
printf( &#8220;What?\?!\n&#8221; );<br/><br/>
In this printf statement, a backslash escape character in front of the second question mark prevents the misinterpretation of ??! as a trigraph.<br/><br/><br/>
上面标红的这个first translation phase很关键！<br/>
编译器对trigraphs的解析是在所有动作之前的，<br/>
甚至在对转义字符“\“的前面。<br/>
所以转文附带了一个在问号前加转义的例子。<br/>
又正由于这个特性，<br/>
连前后大小括号也可以这么替代。。。<br/>
于是就出现了上面这个长的很别扭的程序。<br/><br/>
据说是因为以前有些键盘没有这些符号才这样搞的，<br/>
但这应该是很早很早以前的事了吧。。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/backup-hplonline/blog/page/3/">&larr; Older</a>
    
    <a href="/backup-hplonline/blog/archives">Blog Archives</a>
    
    <a class="next" href="/backup-hplonline/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/backup-hplonline/blog/2013/05/04/test/">Test</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/04/09/%E5%86%8D%E8%B0%88stl%E7%9A%84rotate/">再谈stl的rotate</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%BA%8C%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、二）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%89%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、三）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%80%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、一）</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - hplonline -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
