
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>hplonline</title>
  <meta name="author" content="hplonline">

  
  <meta name="description" content="(hplonline)2009.4.9编码电路： 74LS148在之前也用过。 简单说一下就是，优先编码，EI使能，7到0，优先降低，A2A1A0输出。
当编码工作的时候GS有效，当编码未工作的时候EO有效。
熟悉这个芯片的同学，一定很快发现我在设计上的一点缺陷了。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hupili.github.io/backup-hplonline/blog/page/20">
  <link href="/backup-hplonline/favicon.png" rel="icon">
  <link href="/backup-hplonline/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/backup-hplonline/atom.xml" rel="alternate" title="hplonline" type="application/atom+xml">
  <script src="/backup-hplonline/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/backup-hplonline/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/backup-hplonline/">hplonline</a></h1>
  
    <h2>backup from 2006 to 2012 (original hi.baidu.com/hplonline/)</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/backup-hplonline/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hupili.github.io/backup-hplonline" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/backup-hplonline/">Blog</a></li>
  <li><a href="/backup-hplonline/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/04/09/%E7%BC%96%E7%A0%81%E5%99%A8%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98%EF%BC%88%E5%9B%9B%EF%BC%89%E7%BC%96%E7%A0%81%E9%83%A8%E5%88%86%EF%BC%8874LS148%29/">编码器矩阵键盘（四）编码部分（74LS148)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-04-09T20:04:00+08:00" pubdate data-updated="true">Apr 9<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.4.9<br/><br/><font color="#0000ff">编码电路：</font><br/><br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/6a065ee7ce73570cb83820cb.jpg" small="0" class="blogimg"/></div></p>

<br/><a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/2210888be48af6dbfc1f10e2.html">74LS148</a>在之前也用过。<br/><br/>


<p>简单说一下就是，优先编码，EI使能，7到0，优先降低，A2A1A0输出。<br/>
当编码工作的时候GS有效，当编码未工作的时候EO有效。<br/><br/>
熟悉这个芯片的同学，一定很快发现我在设计上的一点缺陷了。<br/><font color="#ff0000">前面我用两个列线的或来表示有没有键按下。<br/>
其实用跟列相关的148（U5)的GS就可以表示。</font><br/>
为低的时候表示有键按下，为高的时候表示没有。<br/>
由于在proteus仿真的时候，老是没有反映，所以放弃这一方法。<br/><br/>
由于优先编码的问题，所以，把148没有用的输入端全部接高。<br/><br/>
编码出来的rowo0和rowo1等都是低有效，当未编码的时候，输出全1。<br/>
所以把行和列的编码输出相与并取反，就可以获得高有效的码了。<br/><br/>
这时，直接从P1口相应位读出来就是按下的键所在列（行）：<br/>
col = (P1 &amp; 0x01 ) + 1;      //获得列值<br/>
这里只用了1位，如果是4*4的就P1 &amp; 0x03就行了。<br/>
后面加1是我对行列从1编号的缘故。<br/><font color="#ff0000">这里要注意的就是&amp;比+的优先级低。</font><br/>
（地球人都知道？确实。。。不过地球人大多爱犯这错。。。）<br/><br/>
再看左端。行线和列线row0,row1,col0,col1都是接下拉电阻到地的。<br/>
所以常态下为低。<br/>
如果我们对row0,row1置高，那么有键按下的那一列就被拉高。<br/>
经过反向后为低有效，对其编码。<br/>
（并且可以知道，多键同时按下的时候，标号大的优先译码）<br/><br/>
还有一点，就是行赋全1的时候，列编码工作，列赋全1的时候，行编码工作。<br/><br/>
所以，留下两个erow和ecol信号来使能两片编码器。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/04/09/%E7%BC%96%E7%A0%81%E5%99%A8%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98%EF%BC%88%E4%B8%89%EF%BC%89%E9%94%AE%E7%9B%98%E9%83%A8%E5%88%86%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%B4%E6%98%8E/">编码器矩阵键盘（三）键盘部分和原理说明</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-04-09T19:46:00+08:00" pubdate data-updated="true">Apr 9<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div forimg="1">(hplonline)2009.4.9<br/><br/>
这一部分是最简单的。<br/>
不过因为我的战线拉得比较长，看的时候要记住各个标号不容易。<br/>
估计看到后面的时候要不时翻一下。<br/><br/><font color="#0000ff">电路：</font></div>


<div forimg="1"><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/8637ab44499621a0b3b7dccb.jpg"/><br/><br/>
这里的b1其实是没有用的。因为一开始的还是想做4*4的。于是留了b0和b1两个。<br/>
后来觉得太麻烦，做个概念出来就行了，于是搞2*2的。<br/>
那么两线编码只需要1线，所以b1就放那不管了，实际上只用了3个IO口。<br/><br/>
行线和列线分别编号，row0,row1,col0,col1。意义上应该是到位的。<br/><br/>
P1.2是所谓的 KEY_PRESSED 信号，因为不用和其他地方相接，就只在程序里面表示出来了。<br/><br/>
test是高的时候为列测试信号，低的时候为行测试信号。<br/><br/><font color="#0000ff">原理：</font><br/><br/>
首先，得知道<a href="http://hi.baidu.com/hplonline/blog/item/89c8780e2764d3c27acbe1ed.html" target="_blank">一般的矩阵键盘</a>实现的原理。<br/><br/>
而当你理解了矩阵键盘的精华在于行列扫描。<br/>
同时也知道了编码器这个东西后，自然会想到以下一些：<br/><br/><font color="#ff6600">1.矩阵键盘采用行列分别赋值的办法<br/><br/>
2.行列赋值的时候，总是全1或全0<br/><br/>
3.读取行线或列线的时候可以用编码器编码</font><br/><br/>
第1点启示我们，其实行线和列线的读取可以复用同一组IO口（就是这里的b0，b1）<br/>
第2点其实我们，<br/>
可以用1根信号线指定是给行全1，读取列<br/>
或者给列全1，读取行<br/>
第3点是很显然的，一般做4*4的矩阵键盘，把P1的高低四位都占上，显然存在大量冗余<br/><br/><font color="#0000ff">那么这个事情就算完了吗？</font><br/>
就像你把STL的源码读了一遍后，感觉酣畅淋漓，自己来写却是到处囧起。<br/>
有时间的话，不妨先别往后看，试着做一个出来。<br/>
既然已经做出来，自然也就不需要看我的废话了。<br/><br/>
实现上，还有些细节要考虑到的：（先列出来，后面部分会一一看到）<br/><br/><font color="#ff0000">1.行列在同一时刻只能有一个全1，另一个读数据编码。<br/>
所以要加入三态锁存机制<br/><br/>
2.被按下的键所在线会通高电平，所以行列线都应该加下拉电阻<br/><br/>
3.编码器是低有效，所以加反向器<br/><br/>
4.TEST信号发出在两片373的时候会出现电路冒险。<br/>
（为了这个事情找了5个小时左右）</font><br/><br/><br/><font color="#0000ff">或门OR的解释：</font><br/><br/>
我们让test信号为高，即所有行线为高电平，（怎么办到的见后）<br/>
由于行列都是加了下拉电阻的，所以平时的列线全为0。<br/><br/>
当有键按下的时候，相应列线为高。<br/><br/>
而所有列线相或，代表的就是有键按下这个信号。<br/><br/>
程序上就是这个意思：<br/><br/>
          TEST = 1 ;<br/>
          if ( KEY_PRESSED ) {<br/>
             &#8230;&#8230;..获得行列值，显示<br/>
          }else{<br/>
               P2 = 0x00;//没有键的时候输出 0 0 <br/>
          }<br/><br/>
定义：<br/><br/>
sbit TEST = P1 ^ 3 ;       //测试信号，高为列测试，低为行测试<br/>
sbit KEY_PRESSED = P1 ^ 2 ;     //有按键信号，高有效</div>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/04/09/%E7%BC%96%E7%A0%81%E5%99%A8%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98%EF%BC%88%E4%BA%8C%EF%BC%89%E6%98%BE%E7%A4%BA%E9%83%A8%E5%88%86%EF%BC%8874LS47%2B%E5%85%B1%E9%98%B3LED%2C74LS48%2B%E5%85%B1%E9%98%B4LED%29/">编码器矩阵键盘（二）显示部分（74LS47+共阳LED,74LS48+共阴LED)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-04-09T19:31:00+08:00" pubdate data-updated="true">Apr 9<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.4.9<br/><br/>
这一回多用了些不同的器件。主要也是才听说，顺便试一下。<br/>
（毕竟都学到这个时候了，要是写一篇专门练习74LS47的，就感觉有点戳了。<br/>
而我看到一个新东西，就有用一下的欲望）<br/><br/>
这两块都是BCD编码显示的芯片，只是驱动的类型不同。<br/><font color="#ff0000">74LS47+共阳LED<br/>
74LS48+共阴LED</font><br/><br/><font color="#ff6600">47据说是OC（集电极开路）结构，也就是输出端要加相应的电阻。</font><br/>
我这里没有加也仿真出来了（-<em>-|，于是就捡懒不加了。<br/><br/><font color="#0000ff">电路如下</font>：<br/><br/><div forimg="1"><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/db6a6f38ec75e90196ddd8cb.jpg"/><br/><br/>
上方的</em>high和_low是先准备好的高低电平的标号，因为这个作品多出用到。<br/><br/>
译码器的用法上，这两块都和<a href="http://hi.baidu.com/hplonline/blog/item/2210888be48af6dbfc1f10e2.html" target="_blank">CD4511</a>很相似，就不多说了。<br/>
译码有效的组合是：<br/><font color="#ff0000">LT = 1 <br/>
RBI = 0 <br/>
BI = 1</font><br/><br/>
做好这样一个电路之后。显示是很容易的事情。<br/><br/>
P2 = 0x51 ;<br/><br/>
就一句话，就可以下面的显示5，上面的显示1了。<br/><br/>
可见BCD译码器确实方便。。</div></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/04/09/%E7%BC%96%E7%A0%81%E5%99%A8%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%BF%B0/">编码器矩阵键盘（一）概述</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-04-09T19:20:00+08:00" pubdate data-updated="true">Apr 9<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.4.9<br/><br/><font color="#0000ff">动机：<br/></font><br/>
前天数电课上讲了<font color="#ff0000">编码器</font>，突然想到了用编码器来做<font color="#ff0000">矩阵键盘</font>。<br/><br/>
因为学单片机之前，也在其他环境下写过不少程序，所以，<br/>
理解了一个简单的硬件环境之后，用复杂的程序来实现某个功能没多大乐趣。。<br/><br/>
所以我一直喜欢在硬件上搞点花样，当然不少花样也是有价值的，<br/><font color="#ff0000">比如减少IO口的占用数，简化程序的编写</font>等等<br/>
（我这个2<em>2的矩阵键盘只用了3个口，传统编法要用四个口，<br/>
后面我会总结一下几类键盘）<br/><br/><font color="#ff6600">为了演示的简单性，就只用了2</em>2的键盘，可以推知4<em>4的键盘只用四个IO口。8</em>8的只用5个口。。。。</font><br/><br/>
这个东西，说出来了之后就是一显然的事实，没说出来之前就不见人做。。。<br/>
并且我做的时候，在某些问题上囧了很久，所以迫不及待地要展示两个东西。<br/><br/><font color="#0000ff">成品：</font><br/><br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/24c0cc5cc89a2b61faf2c0cb.jpg" small="0" class="blogimg"/></div>
先分别介绍四个区，后面的四个部分将专门进行描述：<br/><br/><font color="#ff6600">1.显示部分</font><br/>
下面的是行的值，上面的是列的值，按照从1开始计，没有按键的时候显示的是两个0<br/><br/><font color="#ff6600">2.键盘部分</font><br/>
包括键盘和扫描键盘用的IO口，可以看到占用的口数<br/>
（其中的P1.1是一开始画上的，其实没用到）<br/><br/><font color="#ff6600">3.编码部分</font><br/>
即是把矩阵键盘的行列线编码成要的数值<br/><br/><font color="#ff6600">4.扫描信号部分</font><br/>
用于产生行列扫描信号，在这里因为没有考虑到“冒险”的问题，囧了很久<br/><br/><font color="#0000ff">程序：</font><br/><br/><font color="#ff0000">我相信就这个程序的长度就足以诱惑一个人去细看是怎么实现的。。。</font><br/><br/>
typedef unsigned char uchar ;<br/><br/>
sbit TEST = P1 ^ 3 ;       //测试信号，高为列测试，低为行测试<br/>
sbit KEY_PRESSED = P1 ^ 2 ;     //有按键信号，高有效<br/><br/>
void main(){<br/>
     uchar tmp ;<br/>
     uchar col ;<br/>
     uchar row ;<br/>
     while(1){<br/>
          TEST = 1 ;<br/>
          if ( KEY_PRESSED ) {<br/>
               col = (P1 &amp; 0x01 ) + 1;     //获得列值<br/>
               TEST = 0 ;<br/>
               row = (P1 &amp; 0x01 ) + 1;     //获得行值<br/>
               tmp = ( row &lt;&lt; 4 ) + col ; //产生显示BCD码<br/>
               P2 = tmp ;     //送47，48译码显示<br/>
          }else{<br/>
               P2 = 0x00;//没有键的时候输出 0 0 <br/>
          }<br/>
     };<br/>
}<br/><br/>
不少初学者一开始做的时候，觉得扫描键盘的程序很臃肿。<br/>
这是由外电路的简单性决定的，（貌似地球人的玩法都如出一辙）<br/>
而我已经<font color="#ff0000">尽量将冗余操作放到了外电路上</font>，<br/>
所以程序自然很短。<br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/04/08/%E7%BC%96%E7%A0%81%E5%8F%8A%E6%98%BE%E7%A4%BA%E8%AF%91%E7%A0%81%E7%94%B5%E8%B7%AF%EF%BC%8874LS148%EF%BC%86CD4511%EF%BC%89/">编码及显示译码电路（74LS148＆CD4511）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-04-08T18:37:00+08:00" pubdate data-updated="true">Apr 8<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.4.8<br/><br/><font color="#0000ff">目的：</font><br/><br/>
才知道有这么两个东西可以用，那么就用来玩玩。<br/><br/><font color="#0000ff">电路：</font><br/><br/><div forimg="1"><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/c0a9a74bbf751dd283025c16.jpg"/></div></p>

<br/><font color="#0000ff">一点说明：</font><br/><br/>


<p>左边是开关排和下拉电阻，<a href="http://hi.baidu.com/hplonline/blog/item/8065aaece104673527979195.html" target="_blank">前面</a>使用过多次。<br/><br/>
74LS148是优先编码器，7的优先级最高。<br/><br/>
CD4511的输入是DCBA排成的BCD码。那么在这里，只有0到7，把D接地。<br/><br/>
CD4511的LT,BE,LE。<br/>
一开始很YY地接成001.。。从反向圈可以看出来有效电平的问题。<br/>
发现没有效果，一看DATASHEET，居然是110.。。<br/>
感觉有点不合习惯。。谁知道是怎么回事呢？</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/04/07/Pegsolitaire--%E7%B1%BB%E4%BC%BC%E5%AD%94%E6%98%8E%E6%A3%8B%E7%9A%84%E6%B8%B8%E6%88%8F%EF%BC%88BFS%2B%E5%AE%8C%E5%85%A8%E6%95%A3%E5%88%97%EF%BC%89/">Peg solitaire&#8211;类似孔明棋的游戏（BFS+完全散列）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-04-07T22:21:00+08:00" pubdate data-updated="true">Apr 7<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline) 2009.3.23<br/><br/>
看到有同学在做，当时正好顺便练手，就搞了一个出来。<br/><br/>
下面的字符宽度上看起来有点别扭，不过将就了吧。<br/><br/><h3 style="margin: 6pt 0cm;"><span style="font-size: 14pt;">Background</span></h3></p>

<p align="left" style="text-align: left;" class="MsoNormal"><span style="color: rgb(51, 51, 0); display: none;"> </span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="color: rgb(51, 51, 0);">Peg solitaire is a traditional game, played with marbles (O) sat on wooden board. The game begins in some known state e.g.:</span></p>


<p class="MsoNormal"><span style="color: rgb(51, 51, 0);">. <span>       </span>. <span>       </span>O<span>        </span>. <span>       </span>.</span></p>


<p class="MsoNormal"><span style="color: rgb(51, 51, 0);">. <span>       </span>.<span>         </span>O<span>        </span>.<span>         </span>.</span></p>


<p class="MsoNormal"><span style="color: rgb(51, 51, 0);">O <span>      </span>O <span>      </span>. <span>       </span>O <span>      </span>O</span></p>


<p class="MsoNormal"><span style="color: rgb(51, 51, 0);">. <span>       </span>. <span>       </span>O <span>      </span>. <span>       </span>.</span></p>


<p class="MsoNormal"><span style="color: rgb(51, 51, 0);">. <span>       </span>. <span>       </span>O <span>      </span>. <span>       </span>.</span></p>


<p class="MsoNormal"><span style="color: rgb(51, 51, 0);">The pegs can take another peg by jumping it (as in draughts) going up, down, left or right. For the above board, the next board would look like:</span></p>


<table cellspacing="0" cellpadding="0" border="1" style="border: medium none ; border-collapse: collapse;" class="MsoNormalTable"><tbody><tr><td width="152" valign="top" style="border: 1pt solid windowtext; padding: 0cm 5.4pt; width: 114.15pt;">
            <p align="left" style="text-align: left;" class="MsoNormal"><span>&#8230;   . .</span></p>
            <p class="MsoNormal"><span>&#8230; . .</span></p>
            <p class="MsoNormal"><span>O O O O O</span></p>
            <p class="MsoNormal"><span>. . O . .</span></p>
            <p class="MsoNormal"><span>. . O . . </span></p>
            <p class="MsoNormal"><span> </span></p>
            </td>
            <td width="140" valign="top" style="border-style: solid solid solid none; border-color: windowtext windowtext windowtext -moz-use-text-color; border-width: 1pt 1pt 1pt medium; padding: 0cm 5.4pt; width: 104.65pt;">
            <p class="MsoNormal"><span>. . O . .</span></p>
            <p class="MsoNormal"><span>. . O . .</span></p>
            <p class="MsoNormal"><span>. . O O O</span></p>
            <p class="MsoNormal"><span>. . O . .</span></p>
            <p class="MsoNormal"><span>. . O . .</span></p>
            <p class="MsoNormal"><span> </span></p>
            </td>
            <td width="152" valign="top" style="border-style: solid solid solid none; border-color: windowtext windowtext windowtext -moz-use-text-color; border-width: 1pt 1pt 1pt medium; padding: 0cm 5.4pt; width: 114.1pt;">
            <p align="left" style="text-align: left;" class="MsoNormal"><span>. . O   . .</span></p>
            <p class="MsoNormal"><span>. . O . .</span></p>
            <p class="MsoNormal"><span>O O O O O</span></p>
            <p class="MsoNormal"><span>&#8230; . .</span></p>
            <p class="MsoNormal"><span>&#8230; . .</span></p>
            <p class="MsoNormal"><span> </span></p>
            </td>
            <td width="124" valign="top" style="border-style: solid solid solid none; border-color: windowtext windowtext windowtext -moz-use-text-color; border-width: 1pt 1pt 1pt medium; padding: 0cm 5.4pt; width: 93.2pt;">
            <p class="MsoNormal"><span>. . O . .</span></p>
            <p class="MsoNormal"><span>. . O . .</span></p>
            <p class="MsoNormal"><span>O O O . .</span></p>
            <p class="MsoNormal"><span>. . O . .</span></p>
            <p class="MsoNormal"><span>. . O . .</span></p>
            <p align="left" style="text-align: left;" class="MsoNormal"><span> </span></p>
            </td>
        </tr></tbody></table>


<p class="MsoNormal"><span style="color: rgb(51, 51, 0); display: none;"> </span></p>


<p class="MsoNormal"><span style="color: rgb(51, 51, 0); display: none;"> </span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="color: rgb(51, 51, 0);">You are going to read in a 5<em>x</em>5 board and find the correct moves to return it to the completed state:</span></p>


<p class="MsoNormal"><span>&#8230; . .</span></p>


<p class="MsoNormal"><span>&#8230; . .</span></p>


<p class="MsoNormal"><span>. . O . .</span></p>


<p class="MsoNormal"><span>&#8230; . .</span></p>


<p class="MsoNormal"><span>&#8230; . .</span></p>


<br/><h3 style="margin: 6pt 0cm;"><span style="font-size: 14pt;">Requirements</span></h3>


<p class="MsoNormal"><span style="color: rgb(51, 51, 0); display: none;"> </span></p>


<p align="left" style="text-align: left;" class="MsoNormal"><span style="color: rgb(51, 51, 0);">Write a program that:</span></p>


<p style="background: white none repeat scroll 0% 0%; margin-left: 18pt; text-indent: -18pt; line-height: 12pt; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;" class="MsoNormal"><span style="color: black;"><span>1.<span>          </span></span></span><span style="color: black;">Reads in a 5x5 board from a file, and checks that it is valid. Boards are specified in a file that has 5 lines of 5 characters each. Each character is either a full-stop or an uppercase ‘O’ (oh) or a lowercase ‘o’.</span></p>


<p style="background: white none repeat scroll 0% 0%; margin-left: 18pt; text-indent: -18pt; line-height: 12pt; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;" class="MsoNormal"><span style="color: black;"><span>2.<span>          </span></span></span><span style="color: black;">Prints out the correct solution (reverse order is fine) and running times. </span></p>


<p class="MsoNormal"><span style="color: rgb(51, 51, 0); display: none;"> </span></p>


<p style="margin: 0cm 0cm 0.0001pt; line-height: 12pt;"><span style="font-size: 10.5pt;">You must write your program in VC ++6.0 and create an executable code which will run on the University computer. </span></p>


<br/><font color="#0000ff">SOLUTION:</font><br/><br/>


<p>这个数据量可谓很小很小，直接BFS。<br/><br/>
2<sup>(5*5)的量的完全散列。<br/><br/></sup>
跟一般做的OJ题目有点不同，就是需要验证输入，看看是否规范。<br/><br/><font color="#0000ff">CODE:</font><br/><br/></p>

<h1>include &lt;stdio.h&gt;<br/></h1>

<h1>include &lt;string.h&gt;<br/></h1>

<h1>include &lt;time.h&gt;<br/><br/></h1>

<p>const int MAX_FILENAME_LEN = 50 ;<br/>
//add test files&#8217; name here<br/>
//all files in &#8220;.\testfiles&#8221; directory<br/>
const char <em>filenames[] = {<br/>
&#8220;a.txt&#8221;,<br/>
&#8220;b.txt&#8221;,<br/>
&#8220;c.txt&#8221;,<br/>
&#8220;d.txt&#8221;,<br/>
&#8220;e.txt&#8221;,<br/>
&#8220;f.txt&#8221;,<br/>
&#8220;g.txt&#8221;,<br/>
&#8220;h.txt&#8221;<br/>
};<br/>
const int TEST_FILE_NUM = sizeof(filenames) / 4 ;<br/><br/>
const int MAX_HASH = 33554432 ;<br/>
const int MAX_LINE_LEN = 100 ;<br/>
const int MAX_QUEUE = MAX_HASH ;<br/><br/>
const int dx[4] = { 0 , 0 , 1 , -1 } ;<br/>
const int dy[4] = { 1 , -1 , 0 , 0 } ;<br/><br/>
typedef int STATE ;<br/><br/>
bool init(FILE </em>fp);<br/>
int hash(char c[5][5]);<br/>
bool process() ; <br/>
void output(STATE s);<br/>
void outsteps(int index) ;<br/><br/>
bool appeared[MAX_HASH] ;<br/>
STATE start , end ;//states <br/>
STATE q[MAX_QUEUE] ;<br/>
int from[MAX_QUEUE] ;<br/>
int front , rear ;//pointer for the queue <br/>
int stp ;<br/><br/><br/>
int main(){<br/>
       int i ;<br/>
       FILE <em>fp ; <br/>
       time_t tt ;<br/>
       bool ok ;<br/>
       char fullname[MAX_FILENAME_LEN] ;<br/>
       freopen( &#8220;output.txt&#8221; , &#8220;w&#8221; , stdout ) ;<br/>
       for ( i = 0 ; i &lt; TEST_FILE_NUM ; i ++ ){<br/>
              printf(&#8220;\n=====now begin test case : %d\nfile name:%s\n&#8221; , i , filenames[i] ) ;<br/>
              strcpy( fullname , &#8220;testfiles&#34; ) ;<br/>
              strcat(fullname , filenames[i]) ;<br/>
              fp = fopen( fullname , &#8220;r&#8221; ) ;<br/>
              if ( !fp ){<br/>
                     printf(&#8220;can&#8217;t read from file:%s\n&#8221; , filenames[i] ) ;<br/>
              }<br/>
              if ( !init(fp) ){<br/>
                     puts(&#8220;file format error!!&#8221;) ;<br/>
              }else{<br/>
                     puts(&#8220;file validation passed!!&#8221;) ;<br/>
                     puts(&#8220;initial state:&#8221;);<br/>
                     output(start);<br/>
                     puts(&#8220;final state:&#8221;);<br/>
                     output(end);<br/>
                     tt = clock() ;<br/>
                     ok = process() ;<br/>
                     printf(&#8220;processing time %.2fs\n&#8221; , double( clock() - tt ) / CLOCKS_PER_SEC);<br/>
                     if ( ok ){;<br/>
                            puts(&#8220;succeed !! steps are:&#8221;);<br/>
                            stp = 1 ;<br/>
                            outsteps(front) ;<br/>
                     }else{<br/>
                            puts(&#8220;no solution was found!&#8221;) ;<br/>
                     }       <br/>
              }<br/>
              printf(&#8220;========end of case %d\n\n&#8221; , i ) ;<br/>
       }<br/>
       return 0 ;<br/>
}<br/><br/>
//check if the file is valid <br/>
//and make initial and terminal state<br/>
//also , initialize some variants <br/>
//return :<br/>
//true : valid<br/>
//false: invalid<br/>
bool init(FILE </em>fp){<br/>
       char m[6][MAX_LINE_LEN] ; // raw data from files<br/>
       char c[5][5] ; // standardized data 0 for vacancies and 1 for pegs<br/>
       int i , j ;<br/>
       for ( i = 0 ; i &lt; 5 &amp;&amp; !feof(fp) ; i ++ ){<br/>
              fscanf( fp , &#8220;%s&#8221; , m[i] ) ;<br/>
       }<br/>
       if ( i != 5 ) return false ; // not enough lines<br/>
       for ( i = 0 ; i &lt; 5 ; i ++ ){<br/>
              for ( j = 0 ; j &lt; 5 ; j ++ ){<br/>
                     if ( m[i][j] == &#8216;.&#8217; ){<br/>
                            c[i][j] = 0 ;<br/>
                            continue ;<br/>
                     }<br/>
                     if ( m[i][j] == &#8216;o&#8217; || m[i][j] == &#8216;O&#8217; ){<br/>
                            c[i][j] = 1 ;<br/>
                            continue ;<br/>
                     }<br/>
                     return false ; //other symbols in the file<br/>
              }<br/>
              if ( m[i][j] != &#8216;\0&#8217; ) return false ; //more than 5 columns <br/>
       }<br/>
       if ( EOF !=       fscanf( fp , &#8220;%s&#8221; , m[5] ) ){<br/>
              if ( m[5][0] != &#8216;\0&#8217; ) return false ; //more than 5 rows<br/>
       }<br/>
       <br/>
       start = hash(c) ;<br/>
       end = 4096 ; // 2 ^ 12 <br/><br/>
       return true ;<br/>
}<br/><br/>
//caculate the hash key for a state<br/>
STATE hash(char c[5][5]){<br/>
       int i , j , t = 0 , b = 1 ;<br/>
       for ( i = 0 ; i &lt; 5 ; i ++ ){<br/>
              for ( j = 0 ; j &lt; 5 ; j ++ ){<br/>
                     if ( c[i][j] )<br/>
                            t |= b ;<br/>
                     b &lt;&lt;= 1 ;<br/>
              }<br/>
       }<br/>
       return t ;<br/>
}<br/><br/>
void rhash(char c[5][5] , STATE s ){<br/>
       int i , j ; <br/>
       for ( i = 0 ; i &lt; 5 ; i ++ ){<br/>
              for ( j = 0 ; j &lt; 5 ; j ++ ) {<br/>
                     c[i][j] = s &amp; 1 ;<br/>
                     s &gt;&gt;= 1 ;<br/>
              }<br/>
       }<br/>
}<br/><br/>
bool valid( int x , int y ){<br/>
       return x &gt;= 0 &amp;&amp; x &lt; 5 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; 5 ;<br/>
}<br/><br/>
bool process(){<br/>
       STATE curs , news ;<br/>
       char c[5][5] ;<br/>
       int x1 , y1 , x2 , y2 , x3 , y3 , k ;<br/>
       int fr ;<br/>
       front = 0 ;<br/>
       rear = 1 ;<br/>
       memset(appeared , false , sizeof(appeared) ) ;<br/>
       q[0] = start ;<br/>
       appeared[start] = true ;<br/>
       from[0] = -1 ;<br/>
       while ( front &lt; rear ) {<br/>
              fr = front ;<br/>
              curs = q[front ++ ] ;<br/>
       //       output(curs);<br/>
              if ( curs == end ) break ; <br/>
              rhash( c , curs ) ;<br/>
              for ( x1 = 0 ; x1 &lt; 5 ; x1 ++ ){<br/>
                     for ( y1 = 0 ; y1 &lt; 5 ; y1 ++ )if ( c[x1][y1] ){<br/>
                            c[x1][y1] = 0 ;<br/>
                            for ( k = 0 ; k &lt; 4 ; k ++ ){<br/>
                                   x2 = x1 + dx[k] ;<br/>
                                   y2 = y1 + dy[k] ;<br/>
                                   if ( valid(x2 , y2) &amp;&amp; c[x2][y2]){<br/>
                                          c[x2][y2] = 0 ;<br/>
                                          x3 = x2 + dx[k] ;<br/>
                                          y3 = y2 + dy[k] ;<br/>
                                          if (valid( x3 , y3 ) &amp;&amp; !c[x3][y3] ) {<br/>
                                                 c[x3][y3] = 1 ;<br/>
                                                 news = hash(c) ;<br/>
                                          //       output(news);<br/>
                                                 if ( !appeared[news] ){<br/>
                                                        appeared[news] = true ;<br/>
                                                        from[rear] = fr ;<br/>
                                                        q[rear ++ ] = news ;<br/>
                                                 }<br/>
                                                 c[x3][y3] = 0 ;<br/>
                                          }<br/>
                                          c[x2][y2] = 1 ;<br/>
                                   }<br/>
                            }              <br/>
                            c[x1][y1] = 1 ;<br/>
                     }<br/>
              }<br/>
       }<br/>
       if ( curs == end ){<br/>
              front &#8211; ;<br/>
              return true ;<br/>
       }<br/>
       else return false ;<br/>
}<br/><br/>
//output single state<br/>
void output(STATE s){<br/>
       char c[5][5] ;<br/>
       int i , j ; <br/>
       rhash( c , s ) ;<br/>
       for ( i = 0 ; i &lt; 5 ; i ++ ){<br/>
              for ( j = 0 ; j &lt; 5 ; j ++ ){<br/>
                     printf(&#8220;%d &#8220;,c[i][j] ) ;<br/>
              }<br/>
              printf(&#8220;\n&#8221;);<br/>
       }<br/>
       printf(&#8220;\n&#8221;);<br/>
}<br/><br/>
//output the moving steps<br/>
void outsteps(int index){<br/>
       if ( index != -1 ){<br/>
              outsteps(from[index]) ;<br/>
              printf(&#8220;step %d:\n&#8221;,stp) ;<br/>
              stp ++ ;<br/>
              output(q[index]);<br/>
       }<br/>
}<br/><br/><br/>
在<a href="http://www.box.net/shared/bivh8xgvgv" target="_blank">这里</a>取得完整的工程文件和，测试文件。<br/><p style="background: white none repeat scroll 0% 0%; margin-left: 18pt; text-indent: -18pt; line-height: 12pt; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;" class="MsoNormal"> </p></p>

<br/><p style="background: white none repeat scroll 0% 0%; margin-left: 18pt; text-indent: -18pt; line-height: 12pt; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;" class="MsoNormal"> </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/04/06/FFT%E4%BC%98%E5%8C%96%E7%9A%84%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E5%AE%9E%E7%8E%B0%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95/">FFT优化的高精度乘法（三）实现高精度乘法</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-04-06T21:26:00+08:00" pubdate data-updated="true">Apr 6<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.4.6<br/><br/>
上一节涉及的数学方面的东西实在太多。<br/><br/>
没办法细讲，但是拿着实现好的傅立叶类来做一个高精度乘法也是不失乐趣的。<br/><br/><font color="#0000ff">粗糙的&#8221;原理&#8221;:</font><br/><br/>
我得用我不准确的语言来描述以下内容，<br/>
细致一点的还是应该翻书看看。<br/><br/><font color="#0000ff">结论1：</font>时域的卷积可以用频域上的乘积来实现。<br/><font color="#0000ff">结论2：</font>高精度乘法的结果相当于离散序列卷积经过模10整理后的结果<br/><font color="#0000ff">结论3：</font>当DFT的长度为M &gt;= A + B - 1(A,B是两序列的长度时，循环卷积和线性卷积对应）<br/><br/>
那么，我们的步骤如下：<br/><br/><font color="#ff6600">1.选择M = 2 ^ K &amp;&amp; M &gt; A &amp;&amp; M &gt; B ，M作为fft和ifft的长度<br/>
2.将乘数的作为序列的实部，虚部为0 <br/>
3.对两乘数进行FFT变换<br/>
4.对两变换后的序列数对应相乘<br/>
5.对乘积序列做IFFT<br/>
6.把实部整数化，作为离散卷积结果<br/>
7.把卷积结果整理成整数高精度乘法后的结果</font><br/><br/>
用到的<a href="http://hi.baidu.com/hplonline/blog/item/bebbf9de8308c65c95ee371d.html" target="_blank">CBigInt</a>前面已经有了，这里只是多实现一个mul_fft:<br/><br/><font color="#0000ff">在类的声明中添加：</font><br/>
CBigInt&amp; mul_fft(CBigInt &amp;bi) ;<br/><br/><font color="#0000ff">实现：</font><br/><br/>
const int MAXFL = 2 * MAXL ;<br/><br/>
//can be allocated in mul_fft function <br/>
complex a[MAXFL] , b[MAXFL] ;<br/><br/>
CBigInt&amp; CBigInt::mul_fft(CBigInt &amp;bi){<br/>
           int <em>c ;<br/>
           int i , m ; <br/><br/>
           //实部为乘数的每一位，虚部为0<br/>
           for ( i = 0 ; i &lt; l ; i ++ ){<br/>
                      a[i].real = data[i] ;<br/>
                      a[i].imag = 0 ;<br/>
           }<br/>
           for ( i = 0 ; i &lt; bi.l ; i ++ ){<br/>
                      b[i].real = bi.data[i] ;<br/>
                      b[i].imag = 0 ;<br/>
           }<br/><br/>
           //求出的m是: m = 2 ^ k , 且m &gt; a.l &amp;&amp; m &gt; b.l 的最小数<br/>
           m = 1 ;<br/>
           while ( m &lt; l || m &lt; bi.l ) m &lt;&lt;= 1 ;<br/>
           m &lt;&lt;= 1 ;<br/><br/>
           //把两个串的高位部分置0<br/>
           for ( i = l ; i &lt; m ; i ++ ) {<br/>
                      a[i].real = 0 ;<br/>
                      a[i].imag = 0 ;<br/>
           }<br/>
           for ( i = bi.l ; i &lt; m ; i ++ ){<br/>
                      b[i].real = 0 ;<br/>
                      b[i].imag = 0 ;<br/>
           }<br/><br/>
           //FFT变换<br/>
           fr.fft( a , m ) ;<br/>
           fr.fft( b , m ) ;<br/>
           //相乘<br/>
           for ( i = 0 ; i &lt; m ; i ++ ) a[i] </em>= b[i] ;<br/><br/>
           //反变换，得到卷积 conv( a , b )  <br/>
           fr.ifft( a , m ) ;<br/>
           <br/>
           //节约空间，直接用b分配的区域<br/>
           c = (int<em>) b ;<br/>
           memset( c , 0 , sizeof(int) * MAXL ) ;<br/><br/>
           //获取整数部分<br/>
           for ( i = 0 ; i &lt; m ; i ++ ) c[i] = round ( a[i].real ) ;<br/>
           <br/>
           //将卷积整理成乘积<br/>
           for ( i = 0 ; i &lt; m - 1 ; i ++ ) {<br/>
                      c[i + 1] += c[i] / 10 ;<br/>
                      c[i] %= 10 ;<br/>
           }<br/><br/>
           //得到乘积长度<br/>
           for ( i = m - 1 ; i &gt;= 0 ; i &#8211; )if ( c[i] != 0 ) break; <br/>
           l = i + 1 ;<br/>
           for ( i = 0 ; i &lt; l ; i ++ ) data[i] = c[i] ;<br/><br/>
           return </em>this ;<br/>
}</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/04/06/FFT%E4%BC%98%E5%8C%96%E7%9A%84%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E5%AE%9E%E7%8E%B0%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/">FFT优化的高精度乘法（二）实现傅立叶变换</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-04-06T21:24:00+08:00" pubdate data-updated="true">Apr 6<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.4.6<br/><br/>
这一节，毕竟我的能力有限。<br/><br/>
要画图，写公式，排版，弄一套出来的话，不知会花多少时间去了。<br/>
所以只能简单提一下。<br/><font color="#ff0000">有关发散出去的部分都会标红，可以从其他资料进行了解</font>。<br/><br/>
根据我的经验，先在网上看一些简短的资料，有个大致了解。<br/>
然后还是需要一本DSP的书，认真看一下就懂了。<br/>
网络资料往往很残缺，有许多细节没有提到。<br/><br/>
但是如果是个实践者，也可以不用理会原理性的东西。<br/>
直接找到相应的算法描述框架，写成程序即可。<br/><br/><font color="#0000ff">傅立叶类：</font><br/><br/></p>

<h1>ifndef <em>FOURIER_H</em><br/><br/></h1>

<h1>define <em>FOURIER_H</em><br/><br/></h1>

<h1>include &#8220;complex.h&#8221;<br/><br/></h1>

<p>class fourier{<br/>
private:<br/>
        static double PI ;<br/>
        complex <em>w ;<br/>
        void initw(int size , int dir) ;<br/>
        int rbit(int b , int m ) ;<br/>
        void bitreverse(complex </em>x , int size , int m ) ;<br/>
        void fft_ifft_common(complex <em>x , int size ) ;<br/>
public:<br/>
        fourier() ;<br/>
        ~fourier() ;        <br/>
        bool dft(complex </em>x , int size) ;<br/>
        bool idft(complex <em>x , int size) ;<br/>
        bool fft(complex </em>x , int size) ;<br/>
        bool ifft(complex <em>x , int size) ;<br/>
        void output(complex </em>x , int size) ;<br/>
};<br/><br/></p>

<h1>endif<br/><br/></h1>

<p>相应的函数就是对应的FT的名称。<br/>
这里虽然是实现FFT，也先实现一套DFT和IDFT，用于检测FFT和，IFFT的正确性。<br/><br/><font color="#ff0000">FFT和IFFT变换的序列长度一定要是2的方幂</font><br/><br/><font color="#ff6600">w为旋转因子。w[i] = exp(-j * i * 2 * pi / N ) </font><br/><br/>
离散时间傅立叶变换很对称，<br/><font color="#ff0000">正反变换的区别就在于旋转因子的不同和最后系数的不同。</font><br/><br/><font color="#0000ff">1.initw</font><br/><br/>
在做变换之前，要搞定对w的初始化：<br/><br/>
//exp(-j * ( 2 * pi * i / N ) ) <br/>
//size W<br/>
//dir: 1 , increase<br/>
//dir: -1 , decrease<br/>
void fourier::initw(int size , int dir){<br/>
        if ( w != NULL ) free(w);<br/>
        w = (complex <em>) malloc(size</em>sizeof(complex)) ;<br/>
        int i ;<br/>
        if ( dir == 1){<br/>
                for ( i = 0 ; i &lt; size ; i ++ ){<br/>
                        w[i].real = cos( 2 * PI * i / size ) ;<br/>
                        w[i].imag = -sin( 2 * PI * i / size ) ;<br/>
                }<br/>
        }<br/>
        else{<br/>
                for ( i = 0 ; i &lt; size ; i ++ ){<br/>
                        w[i].real = cos( 2 * PI * (-i) / size ) ;<br/>
                        w[i].imag = -sin( 2 * PI * (-i) / size ) ;<br/>
                }        <br/>
        }<br/>
}<br/><br/>
这个根据定义是很好理解的。<br/><br/><font color="#0000ff">2.output</font><br/>
输出序列的函数<br/><br/>
void fourier::output(complex <em>x , int size){<br/>
        int i;<br/>
        for ( i = 0 ; i &lt; size ; i ++ ){<br/>
                x[i].output() ;<br/>
                putchar(&#8216;\n&#8217;);<br/>
        }<br/>
}<br/><br/><font color="#0000ff">3.dft和idft</font><br/><br/>
bool fourier::dft(complex </em>x , int size){<br/>
        initw(size , 1);<br/>
        complex <em>tmp = ( complex * ) malloc( size * sizeof ( complex )) ;<br/>
        int i , j ;<br/>
        for ( i = 0 ; i &lt; size ; i ++ ) {<br/>
                tmp[i].real = 0 ;<br/>
                tmp[i].imag = 0 ;<br/>
                for ( j = 0 ; j &lt; size ; j ++ ){<br/>
                        tmp[i] += x[j] * w[ i * j % size ] ;<br/>
                }<br/>
        }<br/>
        for ( i = 0 ; i &lt; size ; i ++ ) {<br/>
                x[i] = tmp[i] ;<br/>
        }<br/>
        free(tmp) ;<br/>
        return true ;<br/>
}<br/><br/>
bool fourier::idft(complex </em>x , int size){<br/>
        initw(size , -1) ;<br/>
        complex <em>tmp = ( complex * ) malloc( size * sizeof ( complex )) ;<br/>
        int i , j ;<br/>
        for ( i = 0 ; i &lt; size ; i ++ ) {<br/>
                tmp[i].real = 0 ;<br/>
                tmp[i].imag = 0 ;<br/>
                for ( j = 0 ; j &lt; size ; j ++ ){<br/>
                        tmp[i] += x[j] * w[ i * j % size ] ;<br/>
                }<br/>
        }<br/>
        for ( i = 0 ; i &lt; size ; i ++ ) {<br/>
                x[i].real = tmp[i].real / size ;<br/>
                x[i].imag = tmp[i].imag / size ;<br/>
        }<br/>
        free(tmp) ;<br/>
        return true ;<br/>
}<br/><br/>
dft和idft的定义可以查找相关资料，这个就是很直接的实现。<br/><font color="#0000ff"><br/>
4.fft和ifft的基本框架</font><br/><br/>
//pre-condition: size = 2 ^ m<br/>
//post-condition: x be the FT of x<br/>
bool fourier::fft(complex </em>x , int size){<br/><br/>
        initw(size , 1) ;<br/>
        fft_ifft_common(x , size);<br/>
        <br/>
        return true ;<br/>
}<br/><br/>
//pre-condition: size = 2 ^ m<br/>
//post-condition: x be the FT of x<br/>
bool fourier::ifft(complex <em>x , int size){<br/>
        int i;<br/><br/>
        initw(size , -1) ;<br/>
        fft_ifft_common(x , size);<br/><br/>
        for ( i = 0 ; i &lt; size ; i ++ ) {<br/>
                x[i].imag /= size ;<br/>
                x[i].real /= size ;<br/>
        }<br/><br/>
        return true ;<br/>
}<br/><br/>
除去公共部分外，正反变换的差异清晰可见。<br/><br/><font color="#0000ff">5.位反序函数</font><br/><br/>
int fourier::rbit(int b , int m){<br/>
        int t = 0 ;<br/>
        int i = 1 ;<br/>
        while ( m &#8211; ) {<br/>
                t &lt;&lt;= 1 ;<br/>
                t |= b &amp; 1 ;<br/>
                b &gt;&gt;= 1;<br/>
        }<br/>
        return t ;<br/>
}<br/><br/>
//bit reverse order for fft caculating<br/>
void fourier::bitreverse(complex </em>x , int size , int m){<br/>
        int i , j ;<br/>
        complex tmp ;<br/>
        for ( i = 0 ; i &lt; size ; i ++ ){<br/>
                j = rbit(i , m);<br/>
                if ( j &gt; i ) {<br/>
                        tmp = x[i] ;<br/>
                        x[i] = x[j] ;<br/>
                        x[j] = tmp ;<br/>
                }<br/>
        }<br/>
}<br/><br/>
在做相应的变换的时候。首先要<font color="#ff0000">位反序</font>。<br/>
这是为了进行<font color="#ff0000">同址运算</font>的。<br/>
这些概念在DSP的书上应该都有介绍。<br/><br/><font color="#0000ff">6.fft和ifft的公共部分</font><br/><br/>
我使用的是<font color="#ff0000">基于时间的抽取</font><br/><br/>
关键在于<font color="#ff0000">蝶形运算</font><br/><br/>
void fourier::fft_ifft_common(complex *x , int size){<br/>
        int i , j ;<br/>
        int m ;<br/>
        complex high , low ;<br/><br/>
        //caculate power m <br/>
        i = size ;<br/>
        m = 0 ;<br/>
        while ( i ) {<br/>
                m ++ ;<br/>
                i &gt;&gt;= 1 ;<br/>
        }<br/><br/>
        bitreverse(x , size , m - 1 ) ;<br/><br/>
        int group_num = size / 2 ;<br/>
        int group_length = 2 ;<br/>
        int group_step = 1 ;<br/>
        while ( m &#8211; ){<br/>
                for ( i = 0 ; i &lt; group_num ; i ++ ){<br/>
                        int group_start = i * group_length ;<br/>
                        for ( j = 0 ; j &lt; group_step ; j ++ ){<br/>
                                int a = group_start + j ;<br/>
                                int b = group_start + j + group_step ;<br/>
                                high = x[a] ;<br/>
                                low = x[b] * w[j * group_num];<br/>
                                x[a] = high + low ;<br/>
                                x[b] = high - low ;<br/>
                        }<br/>
                }<br/>
                group_num &gt;&gt;= 1 ;<br/>
                group_length &lt;&lt;= 1 ;<br/>
                group_step &lt;&lt;= 1 ;<br/>
        }<br/>
}<br/><br/><font color="#0000ff">7.构造和析构函数</font><br/><br/>
fourier::fourier(){<br/>
       w = NULL ;<br/>
}<br/><br/>
fourier::~fourier(){<br/>
       if ( w != NULL ) free(w);<br/>
}</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/04/06/FFT%E4%BC%98%E5%8C%96%E7%9A%84%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%9E%E7%8E%B0%E5%A4%8D%E6%95%B0%E7%B1%BB/">FFT优化的高精度乘法（一）实现复数类</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-04-06T20:57:00+08:00" pubdate data-updated="true">Apr 6<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.4.6<br/><br/><font color="#0000ff">前言：</font><br/><br/>
听说过FFT优化的高精度乘法很久了。<br/>
以前借口没学信号与系统，不做。<br/>
后来学了信号与系统，依然不会。<br/><br/>
上周刷POJ1405的时候，发现很慢，于是想做个FFT优化的高精度乘法。<br/><br/>
首先是在网上看了若干资料。到懂不懂。<br/><br/>
又在网上下了一些FFT的代码，一用发现是囧的。。<br/><br/>
于是只好<font color="#ff0000">打消吃快餐的念头</font>。自己动手从头到尾实现一个。<br/><font color="#ff6600">不懂原理的话，拿着别人写囧的东西就不知道怎么改了。。</font><br/><br/>
当然，我这一套是经过刷题验证的，虽然那道题我的程序不怎么快。<br/>
但是在相同条件下，我的FFT优化比不用FFT优化快。<br/><font color="#ff6600"><br/>
1405       Accepted       2336K       766MS       G++       11147B       2009-04-06 20:27:18<br/>
1405       Accepted       2848K       297MS       G++       11151B       2009-04-06 20:25:30<br/>
（上面的是没用FFT的）</font><br/><br/>
可以说，<font color="#ff0000">正确性能够保证，速度至少说有所提高</font>。<br/><br/>
那么，作为一个实践主义者，你也可以不用管这个实现方法，直接使用就行了。<br/>
不过在不同的编译器上可能出现编译错误。<br/>
这点我也没办法，因为我学C++的时候，就学得不太符合标准。<br/>
各位可以根据相关报错，改一下应该是可以的。<br/><br/><font color="#ff0000">我的整套实现是在VC6下完成的</font>（就是这里将会贴出来的代码）。<br/><br/><font color="#ff0000">交题是用G++过的，在DEV下编译出了不少错误</font>，修改过后交题AC。<br/>
（完整的AC代码在<a target="_blank" href="http://www.box.net/shared/plepep7zbi">这里</a>查看）<br/><br/>
那么就省点废话了。下面开始。<br/><br/><font color="#0000ff">复数类：</font><br/><br/>
实现FFT和IFFT的时候要用这个类。<br/>
这个类的意思应该简单明了。<br/>
不过我实现得不一定漂亮，只能说可以用。<br/><br/><font color="#0000ff">complex.h:</font><br/><br/><br/></p>

<h1>ifndef <em>_COMPLEX_H</em><br/><br/></h1>

<h1>define <em>_COMPLEX_H</em><br/><br/></h1>

<p>class complex{<br/>
public:<br/>
       double real , imag ;<br/>
       complex();<br/>
       complex(double r , double i) ;<br/>
       complex(double r) ;<br/>
       complex(const complex&amp; c) ;<br/>
       ~complex() ;<br/>
       complex&amp; add(complex&amp; c) ;<br/>
       complex&amp; sub(complex&amp; c) ;<br/>
       complex&amp; mul(complex&amp; c) ;<br/>
       complex&amp; div(complex&amp; c) ;<br/>
       complex&amp; operator= ( complex &amp;c) ;<br/>
       complex&amp; operator+= (complex &amp;c) ;<br/>
       complex&amp; operator-= (complex &amp;c) ;<br/>
       complex&amp; operator<em>= (complex &amp;c) ;<br/>
       complex&amp; operator/= (complex &amp;c) ;<br/>
       void output() ;<br/>
};<br/><br/>
complex operator+ ( complex &amp;c1 , complex &amp;c2 ) ;<br/>
complex operator- ( complex &amp;c1 , complex &amp;c2 ) ;<br/>
complex operator</em> ( complex &amp;c1 , complex &amp;c2 ) ;<br/>
complex operator/ ( complex &amp;c1 , complex &amp;c2 ) ;<br/><br/>
const double <em>COMPLEX_EPS = 1e-10 ;<br/>
const int </em>COMPLEX_OUTPUT_WIDTH = 0 ;<br/>
const int _COMPLEX_OUTPUT_DECIMAL = 3 ;<br/><br/></p>

<h1>endif<br/><br/><font color="#0000ff">complex.cpp:</font><br/><br/></h1>

<h1>include &#8220;complex.h&#8221;<br/></h1>

<h1>include &lt;math.h&gt;<br/></h1>

<h1>include &lt;stdio.h&gt;<br/><br/></h1>

<p>complex::complex(){<br/>
       real = 0 ;<br/>
       imag = 0 ;<br/>
}<br/><br/>
complex::complex(double r , double i){<br/>
       real = r ;<br/>
       imag = i ;<br/>
}<br/><br/>
complex::complex(const complex&amp; c){<br/>
       real = c.real ;<br/>
       imag = c.imag ;<br/>
}<br/><br/>
complex::complex(double r){<br/>
       real = r ;<br/>
       imag = 0 ;<br/>
}<br/><br/>
complex::~complex(){<br/>
       <br/>
}<br/><br/>
complex&amp; complex::operator= ( complex &amp;c){<br/>
       real = c.real ;<br/>
       imag = c.imag ;<br/>
       return <em>this;<br/>
}<br/><br/>
complex&amp; complex::add(complex&amp; c){<br/>
       real += c.real ;<br/>
       imag += c.imag ;<br/>
       return </em>this ;<br/>
}<br/><br/>
complex&amp; complex::sub(complex&amp; c){<br/>
       real -= c.real ;<br/>
       imag -= c.imag ;<br/>
       return <em>this ;<br/>
}<br/><br/>
complex&amp; complex::mul(complex&amp; c){<br/>
       complex tmp ;<br/>
       tmp.real = real * c.real - imag * c.imag ;<br/>
       tmp.imag = real * c.imag + imag * c.real ;<br/>
       </em>this = tmp ;<br/>
       return <em>this ;<br/>
}<br/><br/>
complex&amp; complex::div(complex&amp; c){<br/>
       double mo = real * c.real + imag * c.imag ;<br/>
       real = ( real * c.real + imag * c.imag ) / mo ;<br/>
       imag = ( -real * c.imag + imag * c.real ) / mo ;<br/>
       return </em>this ;<br/>
}<br/><br/>
complex&amp; complex::operator+= (complex &amp;c){<br/>
       return add(c);<br/>
}<br/><br/>
complex&amp; complex::operator-= (complex &amp;c){<br/>
       return sub(c);<br/>
}<br/><br/>
complex&amp; complex::operator<em>= (complex &amp;c){<br/>
       return mul(c);<br/>
}<br/><br/>
complex&amp; complex::operator/= (complex &amp;c){<br/>
       return div(c);<br/>
}<br/><br/>
complex operator+ ( complex &amp;c1 , complex &amp;c2 ){<br/>
       complex tmp ;<br/>
       tmp = c1 ;<br/>
       tmp.add(c2);<br/>
       return tmp ;<br/>
}<br/><br/>
complex operator- ( complex &amp;c1 , complex &amp;c2 ){<br/>
       complex tmp ;<br/>
       tmp = c1 ;<br/>
       tmp.sub(c2);<br/>
       return tmp ;<br/>
}<br/><br/>
complex operator</em> ( complex &amp;c1 , complex &amp;c2 ){<br/>
       complex tmp ;<br/>
       tmp = c1 ;<br/>
       tmp.mul(c2);<br/>
       return tmp ;<br/>
}<br/><br/>
complex operator/ ( complex &amp;c1 , complex &amp;c2 ){<br/>
       complex tmp ;<br/>
       tmp = c1 ;<br/>
       tmp.div(c2);<br/>
       return tmp ;<br/>
}<br/><br/>
void complex::output(){<br/>
       printf(&#8220;%<em>.</em>f&#8221;,<em>COMPLEX_OUTPUT_WIDTH,</em>COMPLEX_OUTPUT_DECIMAL,real);<br/>
       if ( fabs(imag) &gt; <em>COMPLEX_EPS ){<br/>
              if ( imag &gt; 0 ) putchar(&#8216;+&#8217;) ;<br/>
              printf(&#8220;%<em>.</em>fi&#8221;,</em>COMPLEX_OUTPUT_WIDTH,_COMPLEX_OUTPUT_DECIMAL,imag);<br/>
       }<br/>
}</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/04/06/%E5%90%91%E4%B8%8A%E5%8F%96%E6%95%B4%26%26%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/">向上取整&&内存对齐</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-04-06T12:02:00+08:00" pubdate data-updated="true">Apr 6<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>hplonline(2009.4.6)<br/><br/>
最近学STL源码，看到一个上调函数，想起了这个问题。。。<br/><br/>
下面说的都是正整数，负数除法根据情况改下就是了。<br/><br/>
一般的有两个int 型，我们直接 a / b得到的就是一个向下取整的值。<br/><br/>
那么要得到一个<font color="#0000ff">向上取整</font>的值呢？可能你早就知道。。但是我一开始是这么写的：<br/><br/><font color="#ff6600"> //return : ceil(a / b)<br/>
int div_ceil1( int a , int b ){<br/>
      double t1 = double(a) / b ;<br/>
      int t2 = a / b ;<br/>
      if ( t1 &gt; t2 ) return t2 + 1 ;<br/>
      else return t2 ;<br/>
}</font><br/><br/>
确实够戳的，用了<font color="#ff0000">一次浮点除法，一次浮点比较，一次整数除法</font>。<br/><br/>
不过这个意思到是很好理解。<br/><br/>
后来，很火星地发现可以这么写。<br/><br/><font color="#ff6600"> //return : ceil(a / b)<br/>
int div_ceil2( int a , int b ){<br/>
      return ( a + b - 1 ) / b ;<br/>
}</font><br/><br/><font color="#ff0000">两次整数加减，一次整数除法</font><br/><br/><font color="#0000ff">证明：</font><br/><br/>
设 a = d * b + k (  0 &lt;= k &lt; b ) <br/><br/>
k = 0 时 ( a + b - 1 ) / b = ( d * b + b - 1 ) / b = d + (b - 1) / b = d ;<br/><br/>
k &gt; 0 &amp;&amp; k &lt; b 时( a + b - 1 ) / b = ( d * b + k + b - 1 ) / b = d + ( k + b - 1 ) / b<br/>
            k + b - 1 &gt;= b &amp;&amp; k + b - 1 &lt; 2 * b .所以( k + b - 1 ) / b = 1<br/>
           于是，最后的结果就是d + 1<br/><br/>
基于这个向上取整，<font color="#0000ff">还有一类问题，就是对齐。</font><br/><br/>
有关内存对齐的介绍可以在网上找到很多。<br/><br/>
这里只是讨论对齐量的计算。<br/><br/>
比如：5对齐到8，就是8，251对齐到16就是256。<br/><br/>
有了上面的取整，第一个写法就很自然。<br/><br/><font color="#ff6600">//for all case <br/>
int round_up1(int x , int align){<br/>
     return ( x + align - 1 ) / align * align ; <br/>
}</font><br/><br/>
前面是向上取整的除法，再乘个对齐因子就得到了。<br/><br/><font color="#ff0000">上面这个例子是对任意的align值的。不过这里有乘法和除法</font>，还是不爽。<br/><br/>
现在想下，<font color="#ff0000">其实align都是2的方幂</font>，这就是可以优化的地方。<br/>
（如果不是2的方幂。。那这个对齐有意义吗。。。。）<br/><br/>
所以SGI-STL的实现用了下面的东西<br/><br/><font color="#ff6600">//available when align = 2 ^ m ;<br/>
int round_up2(int x , int align){<br/>
     return ( x + align - 1 ) &amp; ~( align - 1 ) ;<br/>
}</font><br/><br/>
就难得证了，想一下就清楚是怎么回事了。<br/><br/>
免掉乘除法感觉很爽，不过再仔细一看后半截，发现还可以俭省：<br/><br/><font color="#ff6600">//available when align = 2 ^ m ;<br/>
int round_up3(int x , int align){<br/>
     return ( x + align - 1 ) &amp; ( -align ) ;<br/>
}</font><br/><br/>
OH，YES，又少一条操作。。<br/><br/>
当align = 2 ^ m的时候：<br/><br/>
-align和~ ( align - 1 ) 都是 0 ~ m - 1 位为 0 ，其他位为1 的数。<br/><br/></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/backup-hplonline/blog/page/21/">&larr; Older</a>
    
    <a href="/backup-hplonline/blog/archives">Blog Archives</a>
    
    <a class="next" href="/backup-hplonline/blog/page/19/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/backup-hplonline/blog/2013/05/04/test/">Test</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/04/09/%E5%86%8D%E8%B0%88stl%E7%9A%84rotate/">再谈stl的rotate</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%BA%8C%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、二）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%89%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、三）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%80%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、一）</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - hplonline -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
