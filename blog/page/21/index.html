
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>hplonline</title>
  <meta name="author" content="hplonline">

  
  <meta name="description" content="(hplonline)2009.3.31递推：
如果当前还可以分的数为1/a
那么显然减掉1/(a+1)剩下的是最小的，a+1是比a大的第一个整数。
剩下的是1/(a(a+1))
这个式子仅和a相关，所以前一次剩下的为最小时（a最小），后一次使用此策略为最小。
那么可以递推下去。
2，3，7，43 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hupili.github.io/backup-hplonline/blog/page/21">
  <link href="/backup-hplonline/favicon.png" rel="icon">
  <link href="/backup-hplonline/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/backup-hplonline/atom.xml" rel="alternate" title="hplonline" type="application/atom+xml">
  <script src="/backup-hplonline/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/backup-hplonline/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/backup-hplonline/">hplonline</a></h1>
  
    <h2>backup from 2006 to 2012 (original hi.baidu.com/hplonline/)</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/backup-hplonline/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hupili.github.io/backup-hplonline" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/backup-hplonline/">Blog</a></li>
  <li><a href="/backup-hplonline/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/03/31/POJ1405%EF%BC%88Heritage%EF%BC%89%EF%BC%88%E9%80%92%E6%8E%A8%2B%E9%AB%98%E7%B2%BE%E5%BA%A6%EF%BC%89/">POJ1405 （Heritage） （递推+高精度）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-03-31T09:15:00+08:00" pubdate data-updated="true">Mar 31<span>st</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.3.31<br/><br/><font color="#0000ff">递推：</font><br/><br/>
如果当前还可以分的数为1/a<br/><br/>
那么显然减掉1/(a+1)剩下的是最小的，a+1是比a大的第一个整数。<br/><br/>
剩下的是1/(a<em>(a+1))<br/><br/>
这个式子仅和a相关，所以前一次剩下的为最小时（a最小），后一次使用此策略为最小。<br/><br/>
那么可以递推下去。<br/><br/>
2，3，7，43.。。<br/><br/><font color="#0000ff">公式：</font><br/><br/>
ans[]为第i个分母，b[i]为辅助乘项<br/><br/>
ans[1] = 2 ;<br/><br/>
i &gt;= 2 <br/>
b[i] = mul(ans[j]) ( 1 &lt;= j &lt; i ) <br/>
ans[i] = b[i] + 1<br/><br/>
这样推可以避免减法。（为什么要避免减法。。是为了将就高精度那边）<br/>
计算b[i]的时候，也不用把前面的都累乘起来，想一下，就两个变量递推起走就行了。<font color="#0000ff"><br/><br/>
代码：</font><br/><br/>
CBigInt num;<br/>
CBigInt pre ;<br/><br/>
int main(){<br/>
       int i , n ; <br/>
       CBigInt one(1);<br/>
       num.init(1);<br/>
       pre.init(1);<br/>
       scanf(&#8220;%d&#8221;,&amp;n);<br/>
       for ( i = 1 ; i &lt;= n ; i ++ ){<br/>
              num </em>= pre ;<br/>
              pre = num ;<br/>
              num += one ;<br/>
              num.output() ;<br/>
              putchar(&#8216;\n&#8217;);<br/>
       }<br/>
       return 0;<br/>
}<br/><br/><a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/bebbf9de8308c65c95ee371d.html">CBigInt的实现参考上一篇。</a><br/><br/>
之前RE了若干次，是因为把MAXL算小了。<br/><br/>
这里大概有2W多位的样子。位数是成指数上升的。。<br/><br/>
PS：以<a href="http://hi.baidu.com/hplonline/blog/item/bebbf9de9309d65c95ee371c.html" target="_blank">FFT优化的高精度</a> ， <a href="http://www.box.net/shared/plepep7zbi" target="_blank">1405C++AC完整下载</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/03/31/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%B1%BB%EF%BC%88C%2B%2B%EF%BC%89CBigInt/">高精度类（C++）CBigInt</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-03-31T09:05:00+08:00" pubdate data-updated="true">Mar 31<span>st</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.3.31<br/><br/>
高精度拿来干什么地球人都很清楚了。<br/>
以前写就只顾着能出结果就行。<br/>
后来发现要写个稍微通用点的还是挺麻烦。<br/><br/>
我这个显然就是不太通用的。<br/><br/>
有些细节需要说一下。<br/><font color="#0000ff"><br/>
1.只能应对数据不断增加的正整数。</font><br/><br/>
首先只考虑了正整数的加法和乘法。<br/>
然后通过阅读相关实现就知道。<br/>
如果data[l]之后的数据不全为0，则会出差错。<br/><font color="#ff0000">其实我接触到的很多代码都有这毛病，只是没人说出来罢了</font>。<br/><br/>
不说的原因也很好理解。偶尔在OJ上刷题，用不着考虑那么全面。<br/><font color="#ff0000">我们做高精度类题遇到的数据一般都是正整数。<br/>
给的递推公式一般也只包含乘法和加法。</font><br/>
自然就不用考虑那么多了。<br/><br/><font color="#0000ff">2.mul函数中开的tmp[]，在某些地方得new出来才行。</font><br/><br/>
像TOJ，堆栈只给了<font color="#ff0000">8k</font>的样子。一调这函数就爆掉了。<br/><br/>
而这里直接开在函数里面，也是为了适应小数据时对速度的需求。<br/>
（<font color="#ff0000">new这个东西总得来说很慢。。delete[] 更慢</font>）<br/><br/>
operator+(和operator<em>(就已经是new出临时变量了。<br/>
因为他们用得很少，或者说可以不用。<br/><font color="#ff0000">刷题的时候完全可以把式子转换成 +=和</em>=系列。</font><br/>
这两个系列省去了无聊的中间赋值，更快。<br/><br/><font color="#0000ff">3.输出</font><br/><br/>
输出没有重载了。cout本身就一蜗牛。。给了个printf版和putchar版的。<br/><font color="#ff0000">G++下，getchar和putchar速度优势比较明显。</font><br/><br/><font color="#0000ff">4.扩展</font><br/><br/>
这个类全部是一个字节对应一个10进制位的。<br/>
要扩展成多位的也容易。输出要注意就是了。<br/><font color="#0000ff"><br/>
代码：</font><br/><br/>
/<em><br/>
高精度类<br/>
包含加法和乘法，<br/>
乘法未用FFT优化。<br/>
只能应对数据不断增加的正整数<br/>
by hplonline<br/>
</em>/<br/>
const int MAXL = 30000 ;<br/><br/>
class CBigInt{<br/>
public:<br/>
     char data[MAXL] ;<br/>
     int l ;<br/>
     CBigInt() ;<br/>
     CBigInt(int i) ;<br/>
     CBigInt(CBigInt &amp;bi);<br/>
     CBigInt&amp; add(CBigInt &amp;bi) ;<br/>
     CBigInt&amp; mul(CBigInt &amp;bi) ;<br/>
     CBigInt&amp; operator+(CBigInt &amp;bi) ;<br/>
     CBigInt&amp; operator<em>(CBigInt &amp;bi) ;<br/>
     CBigInt&amp; operator+=(CBigInt &amp;bi) ;<br/>
     CBigInt&amp; operator</em>=(CBigInt &amp;bi) ;<br/>
     CBigInt&amp; operator=(CBigInt &amp;bi) ;<br/>
     void init(int i);<br/>
     void clear() ;<br/>
     void output() ;<br/>
};<br/><br/>
void CBigInt::init(int i){<br/>
     l = 0 ;<br/>
     memset(data,0,sizeof(data)) ;<br/>
     do{<br/>
          data[l] = i % 10 ;<br/>
          i /= 10 ;<br/>
          l ++ ;<br/>
     }while(i);<br/>
}<br/><br/>
void CBigInt::clear(){<br/>
     l = 1 ;<br/>
     memset(data,0,sizeof(data)) ;<br/>
}<br/><br/>
CBigInt::CBigInt(){<br/>
     clear();<br/>
}<br/><br/>
CBigInt::CBigInt(int i){<br/>
     init(i);<br/>
}<br/><br/>
CBigInt::CBigInt(CBigInt &amp;bi){<br/>
     memset(data,0,sizeof(data));<br/>
     int i ;<br/>
     l = bi.l ;<br/>
     for ( i = 0 ; i &lt; l ; i ++ ) data[i] = bi.data[i] ;<br/>
}<br/><br/>
CBigInt&amp; CBigInt::add(CBigInt &amp;bi){<br/>
     int i = 0 ; <br/>
     int p = 0 ;<br/>
     while ( i &lt; l || i &lt; bi.l ){<br/>
          p += data[i] + bi.data[i] ;<br/>
          data[i] = p % 10 ;<br/>
          p /= 10 ;<br/>
          i ++ ;<br/>
     }<br/>
     if ( p ) {<br/>
          data[i] = p ;<br/>
          i ++ ;<br/>
     }<br/>
     l = i ;<br/>
     return <em>this ;<br/>
}<br/><br/>
CBigInt&amp; CBigInt::mul(CBigInt &amp;bi){<br/>
     int tmp[MAXL] ;<br/>
     int i , j , p ;<br/>
     memset(tmp,0,sizeof(tmp)) ;<br/>
     for ( i = 0 ; i &lt; l ; i ++ ){<br/>
          for ( j = 0 ; j &lt; bi.l ;j ++ ){<br/>
               tmp[i + j] += data[i] * bi.data[j] ;<br/>
          }<br/>
     }<br/>
     j = l + bi.l + 1;<br/>
     p = 0 ;<br/>
     for ( i = 0 ; i &lt; j ; i ++ ){<br/>
          p += tmp[i] ;<br/>
          data[i] = p % 10 ;<br/>
          p /= 10 ;<br/>
     }<br/>
     if ( p ){<br/>
          data[i] = p ;<br/>
          i ++ ;<br/>
     }<br/>
     while ( !data[i] ) i &#8211; ;<br/>
     l = i + 1 ;<br/>
     return </em>this ;<br/>
}<br/><br/>
CBigInt&amp; CBigInt::operator+(CBigInt &amp;bi){<br/>
     CBigInt <em>p = new CBigInt(</em>this) ;<br/>
     return p-&gt;add(bi) ;<br/>
}<br/><br/>
CBigInt&amp; CBigInt::operator<em>(CBigInt &amp;bi){<br/>
     CBigInt </em>p = new CBigInt(<em>this) ;<br/>
     return p-&gt;mul(bi);<br/>
}<br/><br/>
CBigInt&amp; CBigInt::operator+=(CBigInt &amp;bi){<br/>
     add(bi);<br/>
     return </em>this ;<br/>
}<br/><br/>
CBigInt&amp; CBigInt::operator<em>=(CBigInt &amp;bi){<br/>
     mul(bi);<br/>
     return </em>this ;<br/>
}<br/><br/>
CBigInt&amp; CBigInt::operator=(CBigInt &amp;bi){<br/>
     int i;<br/>
     memset(data,0,sizeof(data));<br/>
     l = bi.l ;<br/>
     for ( i = 0 ; i &lt; l ; i ++ ) data[i] = bi.data[i] ;<br/>
     return *this ;<br/>
}<br/><br/>
void CBigInt::output(){<br/>
     int i;<br/>
     for ( i = l - 1 ; i &gt;= 0 ; i &#8211; ) printf(&#8220;%d&#8221;,data[i]) ;<br/>
     //for ( i = l - 1 ; i &gt;= 0 ; i &#8211; )putchar(&#8216;0&#8217; + data[i]);<br/>
}<br/><br/><br/><br/><font color="#ff6600">感觉有点水。。。</font></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/03/29/%E5%9F%83%E5%8F%8A%E5%88%86%E6%95%B0%EF%BC%88IDA%2A%29/">埃及分数（IDA*)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-03-29T14:19:00+08:00" pubdate data-updated="true">Mar 29<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.3.29<br/><br/>
这个属于是经典问题。描述就直接从网上COPY下来了：<br/><br/><font color="#ff6600">古代埃及人有一个非常奇怪的习惯，他们喜欢把一个分数表示为若干个分子为一且分母互不相同的分数之和的形式。如<br/>
问题一：<br/>
对于一个给定的真分数a/b(1&lt;=a&lt;b),编程求出a/b的一个上述的表示。<br/>
问题二：<br/>
对于一个给定的分数，它可能有多种满足上述条件的表示方法（这是当然的），我们定义这样的评判标准：<br/>
首先，加数少的比加数多的好，其次，加数个数相同的，最小的分数越大越好。<br/>
如：<br/>
19/45=1/3 + 1/12 + 1/180<br/>
19/45=1/3 + 1/15 + 1/45<br/>
19/45=1/3 + 1/18 + 1/30,<br/>
19/45=1/4 + 1/6 + 1/180<br/>
19/45=1/5 + 1/6 + 1/18.<br/>
最好的是最后一种，因为1/18比1/180,1/45,1/30,1/180都大。 </font><br/><br/>
这题看过也有好几回了，一直舍不得动手，囧之。。<br/><br/>
最近又看了黑书的描述，貌似有点知道那个意思了，于是搞了个出来。<br/>
（<font color="#ff9900">黑书的描述确实经典，不懂的时候就是看不懂，在网上找了一大堆东西看后，<br/>
迷迷糊糊，似懂非懂，再回来看黑书，发现句句都是本质。。ORZ</font>）<br/><br/>
那么要说为什么用IDA<em>，就几点：<br/><font color="#ff0000">1.这个题，首先可以有任意的分数凑成。<br/>
2.对每个个数，如例子中的三个，也可以有不同大小的分数。<br/>
所以状态空间是无穷大，深搜的话，就一直钻下去了，当然不行。<br/>
而宽搜的话，空间消耗也很多。</font><br/><br/>
而<font color="#ff0000">ID</font>(iterative deepening)的实质就是：<font color="#ff0000">使用深搜的框架来写宽搜。</font><br/>
这样兼有宽搜对解最优的保证性，同时如同深搜的空间消耗是线性的。<br/>
那么，总要牺牲一点东西，就是时间，每次的加深的工作量是重复的。<br/>
但是这个重复的工作量，由于搜索的状态空间为指数级增长，可以不记。<br/><br/>
A</em>，就是使用启发函数h，深度函数g，以f = g + h 来对状态节点排序，择小搜索。<br/>
这样做可以<font color="#ff0000">更快地逼近最优解</font>。<br/><br/>
IDA<em>就是把上二者加起来。我这里之所以也说是IDA</em>，是因为所见资料对这个问题的解法都是这样描述的。<br/>
其实，个人认为在细节上是有点出入的：<br/><font color="#ff0000">一般提到的A<em>，是用估价函数来逼近最优解<br/>
而这个题的解法中，虽然也用到了估价，是用这个估价来排除不可能为解的情况。</font><br/><br/>
具体描述这道题就是：<br/><font color="#ff6600">多一个分数，认为是一层，逐层加深。<br/>
每层搜索的时候，后面搜的分母比前面的大，这样可以保证唯一性，而且利于估价。<br/>
估价的方法是，设当前要凑够的分数是a/b，当前的分母是1/c，当前的深度是g，<br/>
如果a</em>c/b + g &gt; max_depth则该方案可以丢弃<br/>
（即假设用的分数最大，都不可能在规定的最大深度内凑够需要的值）<br/>
再一定深度内搜索成功的状态中，选取最小分数最大的一个作为解。</font><br/><br/>
实现上有点细节就是减出来的新分数进行约分，要不可能会变很大。<br/><br/><font color="#0000ff">那么代码：</font><br/><br/></p>

<h1>include &lt;stdio.h&gt;<br/></h1>

<h1>include &lt;string.h&gt;<br/><br/></h1>

<p>//max answer length and searching steps<br/>
const int MAXN = 100 ;<br/>
const int MAXSTEP = 100 ;<br/><br/>
int ans[MAXN];<br/>
int ansnum ;<br/>
int tmp[MAXN];<br/>
bool found ;<br/><br/>
//greatest common divisor<br/>
int gcd( int a , int b ){<br/>
      int r ;<br/>
      do{<br/>
            r = a % b ;<br/>
            a = b ;<br/>
            b = r ;<br/>
      }while(r);<br/>
      return a ;<br/>
}<br/><br/>
//least fractions need to compose num/den<br/>
//using fractions less than 1/cur<br/>
int estimate(int num , int den , int cur){<br/>
      return num * cur / den ; //very optimistic estimate<br/>
}<br/><br/>
//iterative deepening A*<br/>
//params:numerator , denominator , currrent depth , max depth , last denominator<br/>
void ida ( int num , int den , int cur_depth , int max_depth , int last ){<br/>
      int i;<br/>
      //new numerator and denominator<br/>
      int num_new , den_new ;<br/>
      //gcd(num_new,den_new) , heuristic value <br/>
      int d , h ;<br/>
      //answer found<br/>
      if ( num == 0 ){<br/>
            //compare the smallest fractions in the series <br/>
            //and keep the better one for the answer<br/>
            if ( !found || ans[ansnum - 1] &gt; last ){<br/>
                  ansnum = cur_depth ;<br/>
                  for ( i = 0 ; i &lt; ansnum ; i ++ ) ans[i] = tmp[i] ;<br/>
            }<br/>
            found = true ;<br/>
            return ;<br/>
      }<br/>
      //enumeration for the current denominator<br/>
      for ( i = last + 1 ; ; i ++ ){<br/>
            //calculate new fraction left <br/>
            num_new = num * i - den ;<br/>
            den_new = den * i ;<br/>
            if ( num_new &lt; 0 ) continue ;<br/>
            //store current denominator<br/>
            tmp[cur_depth] = i ;<br/>
            //reduction<br/>
            d = gcd( num_new , den_new ) ;<br/>
            num_new /= d ;<br/>
            den_new /= d ;<br/>
            //estimation<br/>
            h = estimate( num_new , den_new , i + 1 ) ;<br/>
            //if can&#8217;t solve in max_depth steps then recur<br/>
            if ( h + cur_depth &gt; max_depth ) break; <br/>
            ida( num_new , den_new , cur_depth + 1 , max_depth , i ) ;<br/>
      }<br/>
}<br/><br/>
bool egypt_fraction(int num , int den){<br/>
      int i ;<br/>
      found = false ;<br/>
      for ( i = 1 ; i &lt; MAXSTEP ; i ++ ){<br/>
            ida( num , den , 0 , i , 1 ) ;<br/>
            if ( found ) return true ;<br/>
      }<br/>
      return false ;<br/>
}<br/><br/>
int main(){<br/>
      int num,den ;<br/>
      int i ;<br/>
      scanf(&#8220;%d/%d&#8221;,&amp;num,&amp;den);<br/>
      if ( egypt_fraction(num,den) ){<br/>
            printf(&#8220;%d/%d = &#8220;,num , den ) ;<br/>
            for ( i = 0 ; i &lt; ansnum ; i ++ ){<br/>
                  if ( i != 0 ) printf(&#8221; + &#8220;) ;<br/>
                  printf(&#8220;1/%d&#8221;,ans[i] ) ;<br/>
            }<br/>
            putchar(&#8216;\n&#8217;);<br/>
      }else{<br/>
            printf(&#8220;not available int %d steps\n&#8221;,MAXSTEP ) ;<br/>
      }<br/>
      return 0 ;<br/>
}<br/><br/>
这个只是根据题目描述来做的，<font color="#ff0000">没有找到OJ相应的题去交</font>。。<br/><br/>
所以不知道对待大数据或者特殊数据是否能通过。<br/><br/>
谁知道题号也给我说下吧。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/03/26/POJ1141%EF%BC%88BracketsSequence%EF%BC%89%EF%BC%88DP%29/">POJ1141（Brackets Sequence）（DP)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-03-26T20:23:00+08:00" pubdate data-updated="true">Mar 26<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.3.26<br/><br/>
就是给括号序列。<br/>
定义了一种regular brackets sequence。<br/>
求最少添加多少括号来形成这种序列。<br/><br/>
半年前怨念地<font color="#ff0000">WA</font>了此题。。今天跑回来，在<font color="#ff0000">WA</font>了两盘后，终于搞定了。。。<br/><br/>
那么说DP：<br/><br/>
s[]是读入的字符串<br/>
f[i][j]是i到j的最少的添加数<br/>
c[i][j]是对应的添加方案<br/><br/>
分几种情况<br/><font color="#ff6600"><br/>
s[i] == &#8216;[&#8217; 在右端添 &#8216;]&#8217; 并求解 s[i + 1][j]<br/>
s[i] == &#8216;(&#8217;<br/>
s[j] == &#8216;)&#8217;<br/>
s[j] == &#8216;]&#8217;类似处理<br/>
s[i] == &#8216;[&#8217; &amp;&amp; s[j] == &#8216;]&#8217; ，求解s[i + 1][j - 1] <br/>
s[i] == &#8216;(&#8217; &amp;&amp; s[j] == &#8216;)&#8217;， 类似<br/><br/>
除了这些特殊情况外。<br/>
对 i &lt;= k &lt; j <br/>
分别求解s[i][k] 和 s[k + 1][j] </font><br/><br/>
实现上选取相应的记法来表达策略：<br/>
//least bracket num ;<br/>
int f[MAXN][MAXN] ;<br/><font color="#ff6600">//strategy:-1,-2,-3,-4,-5</font><br/>
//&#8217;[&#8216;,&#8217;]&#8217;,&#8217;(&#8216;,&#8217;)&#8217;,choose middle<br/>
int c[MAXN][MAXN] ;<br/>
char s[MAXN] ;<br/><br/><font color="#ff6600">即为负的时候相当于上面的5种特殊情况，为非负的时候就是截成两段的一般情况时的分界点</font>。<br/><br/>
于是，程序：<br/><br/></p>

<h1>include &lt;stdio.h&gt;<br/></h1>

<h1>include &lt;string.h&gt;<br/><br/></h1>

<p>const int MAXN = 110 ;<br/>
const int MAX = 100000000 ;<br/><br/>
//least bracket num ;<br/>
int f[MAXN][MAXN] ;<br/>
//strategy:-1,-2,-3,-4,-5<br/>
//&#8217;[&#8216;,&#8217;]&#8217;,&#8217;(&#8216;,&#8217;)&#8217;,choose middle<br/>
int c[MAXN][MAXN] ;<br/>
char s[MAXN] ;<br/><br/>
void output(int l , int r ){<br/>
     if ( l &gt; r ) return ;<br/>
     switch(c[l][r]){<br/>
     case -5 : <br/>
          putchar(s[l]);<br/>
          output( l + 1 , r - 1 );<br/>
          putchar(s[r]);<br/>
          break;<br/>
     case -1 :<br/>
          putchar(&#8216;[&#8216;);<br/>
          output( l , r - 1 ) ;<br/>
          putchar(&#8216;]&#8217;);<br/>
          break;<br/>
     case -2 :<br/>
          putchar(&#8216;[&#8216;);<br/>
          output( l + 1 , r ) ;<br/>
          putchar(&#8216;]&#8217;);<br/>
          break;<br/>
     case -3 :<br/>
          putchar(&#8216;(&#8216;);<br/>
          output( l , r - 1 ) ;<br/>
          putchar(&#8216;)&#8217;);<br/>
          break;<br/>
     case -4 :<br/>
          putchar(&#8216;(&#8216;);<br/>
          output( l + 1, r ) ;<br/>
          putchar(&#8216;)&#8217;);<br/>
          break;<br/>
     default:<br/>
          output( l , c[l][r] ) ;<br/>
          output( c[l][r] + 1 , r ) ;<br/>
          break;<br/>
     }<br/>
}<br/><br/>
int main(){<br/>
     int i , j , k , l ; <br/>
     int p ;<br/>
     <br/>
     gets(s);<br/>
     l = strlen(s);<br/>
     for ( i = 0 ; i &lt; l ; i ++ ){<br/>
          f[i][i] = 1 ;<br/>
          switch(s[i]){<br/>
          case &#8216;[&#8216;:c[i][i] = -2 ;break ;<br/>
          case &#8216;]&#8217;:c[i][i] = -1 ;break ;<br/>
          case &#8216;(&#8216;:c[i][i] = -4 ;break ;<br/>
          case &#8216;)&#8217;:c[i][i] = -3 ;break ; <br/>
          }<br/>
     }<br/>
     for ( i = 1 ; i &lt; l ; i ++ ) f[i][i - 1] = -5 ;<br/><br/>
     for ( k = 1 ; k &lt; l ; k ++ ){<br/>
          for ( i = 0 ; i &lt; l - k ; i ++ ){<br/>
               j = i + k ;<br/>
               f[i][j] = MAX ;<br/>
               if ( s[i] == &#8216;(&#8217; &amp;&amp; s[j] == &#8216;)&#8217; || s[i] == &#8216;[&#8217; &amp;&amp; s[j] == &#8216;]&#8217; ){<br/>
                    f[i][j] = f[i + 1][j - 1] ;<br/>
                    c[i][j] = -5 ;<br/>
               }<br/>
               if ( s[i] == &#8216;[&#8217; &amp;&amp; f[i + 1][j] + 1 &lt; f[i][j] ){<br/>
                    f[i][j] = f[i + 1][j] + 1 ;<br/>
                    c[i][j] = -2 ;<br/>
               }<br/>
               if ( s[j] == &#8216;]&#8217; &amp;&amp; f[i][j - 1] + 1 &lt; f[i][j] ){<br/>
                    f[i][j] = f[i][j - 1] + 1 ; <br/>
                    c[i][j] = -1 ;<br/>
               }<br/>
               if ( s[i] == &#8216;(&#8217; &amp;&amp; f[i + 1][j] + 1 &lt; f[i][j] ){<br/>
                    f[i][j] = f[i + 1][j] + 1 ;<br/>
                    c[i][j] = -4 ;<br/>
               }<br/>
               if ( s[j] == &#8216;)&#8217; &amp;&amp; f[i][j - 1] + 1 &lt; f[i][j] ){<br/>
                    f[i][j] = f[i][j - 1] + 1 ; <br/>
                    c[i][j] = -3 ;<br/>
               }<br/>
               for ( p = i ; p &lt; j ; p ++ ){<br/>
                    if ( f[i][p] + f[p + 1][j] &lt; f[i][j]){<br/>
                         f[i][j] = f[i][p] + f[p + 1][j] ;<br/>
                         c[i][j] = p ;<br/>
                    }<br/>
               }<br/>
          }     <br/>
     }<br/><br/>
     output(0,l - 1) ;<br/>
   <font color="#ff0000"> putchar(&#8216;\n&#8217;);</font><br/>
     <br/>
     return 0 ;<br/>
}<br/><br/>
最后那句红的putchar是很关键的。。因为是SPJ。。所以没有PE的说法。。<br/>
于是我今天又<font color="#ff0000">WA</font>了两盘。。<br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/03/26/sprintf%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%9F%EF%BC%9F/">Sprintf第一个参数？？</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-03-26T17:13:00+08:00" pubdate data-updated="true">Mar 26<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline) 2009.3.26<br/><br/>
他的第一个参数没啥问题，就是指定一个缓冲区。<br/>
想要说的是他对缓冲区是直接操作的。<br/><br/>
从一种比较保险的观点来看。应该是先在某个其他的空闲地方操作。<br/>
生成好了整个字符串，然后再一起strcpy过去。<br/><br/>
这种想法比较完美，不过最初的设计者应该还是出于效率考虑的。<br/><br/>
用个简单的例子：<br/><br/>
int main(){<br/>
      char s[100] ;<br/>
      strcpy(s,&#8221;aa&#8221;);<br/>
      sprintf(s,&#8221;bb%s&#8221;,s);<br/>
      puts(s);      <br/>
      return 0 ;<br/>
}<br/><br/>
在VC6下出来的是bbbb，不是bbaa<br/><br/>
说明的就是这个东西。<br/><br/>
只不过一般来说，不会这么写。<br/><br/>
那么，这个东西其实有点引申到“<font color="#ff0000">序列点</font>”这块上面，有点那个意思。<br/><br/>
我也只是最近听说这名字，没有认真研究过。<br/><br/>
google ”sequential point“　可以出来。<br/><br/>
其实我这里还想土鳖几个才发现的东西。。<br/><br/></p>

<h1>当type=c,s,d,i,u时没有影响<br/></h1>

<p>type=o,x,X时，分别在数值前增加&#8217;0&#8217;,&#8221;0x&#8221;,&#8221;0X&#8221;<br/><br/>
场宽前面加０可以用０填充<br/>
printf(&#8220;%08x\n&#8221;,293842);<br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/03/25/%E5%A4%9A%E7%BB%B4%E8%BF%B7%E5%AE%AB%E7%9A%84%E9%99%8D%E7%BB%B4%E8%A7%A3%E6%B3%95%EF%BC%88POJ3454Hypertheseus%29/">多维迷宫的降维解法（POJ3454 Hypertheseus)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-03-25T12:49:00+08:00" pubdate data-updated="true">Mar 25<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.3.25<br/><br/>
题目应该说是意思很明了。<br/>
就是走一个高维的迷宫。<br/><br/>
走二维的迷宫是此类问题中最直接接触的。<br/>
一般的BFS可以很轻松的搞定。<br/><br/>
我们用dx[4] ={&#8230;},dy[4] = {&#8230;}这样的东西来记录一个增量。<br/>
对当前点依次按照各个增量来走。<br/>
判断新产生的点是否在地图外面，等等。<br/><br/>
当遇到三维的时候，我们习惯性地移植这种方法。加一个dz[4]就可以搞定了。<br/><br/>
有一个事实：每增加一个维度，可以走的方向增加两个。<br/><br/>
但是，当真正的多维迷宫出现的时候。上面的方法显然没法实现。<br/><br/>
就好比，你可以a = 1 , a = 1 + 2 , a = 1 + 2 + 3 <br/>
但是a = 1 + 2 + &#8230; + 100 写起来就很臃肿了。<br/><br/>
对于一个n维迷宫，不至于写n个dXX[]来记录增量嘛。。<br/><br/>
所以，比较简洁的做法就是<font color="#ff0000">降维</font>。这个东西听起来很像个意思。<br/>
写起来还是比较囧的一个事情。<br/><br/><font color="#0000ff">一。思路描述</font><br/><br/>
d，总共的维度数目<br/><br/>
space[i]记录的是迷宫中第i个位置的情况。<br/>
迷宫按照第一个维度，第二个维度。。。这样排成一行，就降成一维了。<br/><br/>
n[i]为第i个维度的长度,i = 0..d<br/><br/>
mv[i]是一个移动矢量，表示在第i个维度上移动一个单位，在space中实际上产生的距离<br/>
那么mv[0] = 1 ;mv[i] = mv[i-1] * n[i-1] ;<br/>
其中mv[d]表达的就是这个图中总共的点数。<br/><br/>
所以，当BFS的时候，对当前点curp依次加减每个维度上的增量。<br/>
就可以得到新点的位置了。<br/><br/>
基本问题是解决了。但是还有一个更重要的问题：<br/>
就是关于新点有效性的判定。<br/><br/>
在做二维的时候，习惯上是生成nx,ny然后看<br/><br/>
if ( nx &gt;= 0 &amp;&amp; nx &lt; sx  &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; sy ){&#8230;}<br/>
sx和sy是x和y维度的大小。<br/><br/>
那么，到n维的时候，这样就不行了。举个例子：<br/><br/>
有3*3的矩阵。排成0..8。当前点是2（即第0行的第2列）。<br/>
如果现在先按照维度移动。可以得到点3（即第1行的第0列）。<br/>
3点显然是在我们空间里面的，但这个移动又显然是不成立的。<br/><br/><font color="#ff0000">所以，要在移动之前判断。</font>而这个判断说起来就比较绕口了。<br/>
（<font color="#ff6600">感觉属于挑战表达能力的极限，那么我开始了。。</font>）<br/><br/>
假设我们要在第i个维度上移动。我们就把前面的所有维度压缩成一个点。<br/>
在i个维度上的移动一次的距离是mv[i]，这个已经求得。<br/>
那么在移动之前我们要检查：<br/><font color="#ff0000">1.如果该点在于第k个i+1维度上，离第k个i+1维度的第一个i维度的距离是0，<br/>
则不能进行减mv[i]的操作。<br/>
2.如果该点在于第k个i+1维度上，离第k个i+1维度的第一个i维度的距离是n[i] - 1 ， <br/>
则不能进行加mv[i]的操作。</font><br/><br/>
拿第一个说一下：<br/>
curp / mv[i] 可以得到curp是总共的第几个i维度<br/>
那么再 % n[i]  就算出离第k个i+1维度的第一个i维度的距离<br/>
跟着判断就行了。<br/><br/>
关键的代码就是：<br/>
  <font color="#ff6600">            if ( ( curp / mv[i] ) % n[i] != n[i] - 1 ){<br/>
                    newp = curp + mv[i] ;<br/>
                    visit(newp);<br/>
               }<br/>
               if ( ( curp / mv[i] ) % n[i] != 0 ){<br/>
                    newp = curp - mv[i] ;<br/>
                    visit(newp);<br/>
               }</font><br/><br/><font color="#0000ff">二。代码</font><br/><br/></p>

<h1>include &lt;stdio.h&gt;<br/></h1>

<h1>include &lt;string.h&gt;<br/><br/></h1>

<p>const int MAXCUBE = 1048576 ;<br/><br/>
int d ;<br/>
int n[21] ;<br/>
int mv[21] ;<br/><br/>
char space[MAXCUBE] ;<br/>
int q[MAXCUBE] ;//队列<br/>
int stp[MAXCUBE] ;//到达space[i]的步数<br/>
int front , rear ;<br/>
bool vst[MAXCUBE] ;//判重<br/><br/>
int p ;<br/>
int s , m , t , curs;<br/><br/>
void visit(int pt){<br/>
     if ( !(pt &gt;= 0 &amp;&amp; pt &lt; mv[d]) ) {<br/>
          return ;<br/>
     }<br/>
     if ( vst[pt] || space[pt] ) return ;<br/>
     vst[pt] = true ;<br/>
     stp[pt] = curs ;<br/>
     q[rear] = pt ;<br/>
     rear ++ ;<br/>
}<br/><br/>
int bfs(int from , int to ){<br/>
     int curp , newp ;<br/>
     int i ;<br/>
     memset(vst , false , sizeof(vst)) ;<br/>
     front = 0 ;<br/>
     rear = 1 ;<br/>
     q[0] = from ;<br/>
     stp[from] = 0 ;<br/>
     vst[from] = true ;<br/>
     while ( front &lt; rear ){<br/>
          curp = q[front ++] ;<br/>
          curs = stp[curp] + 1;<br/>
          if ( curp == to ) {<br/>
               front &#8211; ;<br/>
               break ;<br/>
          }<br/>
          for ( i = 0 ; i &lt; d ; i ++ ){<br/>
               if ( ( ( curp ) / mv[i] ) % n[i] != n[i] - 1 ){<br/>
                    newp = curp + mv[i] ;<br/>
                    visit(newp);<br/>
               }<br/>
               if ( ( ( curp ) / mv[i] ) % n[i] != 0 ){<br/>
                    newp = curp - mv[i] ;<br/>
                    visit(newp);<br/>
               }<br/>
          }<br/>
     }<br/>
     if ( front == rear ) return - 1;<br/>
     else return stp[curp] ;<br/>
}<br/><br/>
char nextchar(){<br/>
     char ch ;<br/>
     do{<br/>
          ch = getchar() ;<br/>
     }while ( ch != &#8216;#&#8217; &amp;&amp; ch != &#8216;.&#8217; &amp;&amp; ch != &#8216;S&#8217; &amp;&amp; ch != &#8216;M&#8217; &amp;&amp; ch != &#8216;T&#8217; ) ;<br/>
     if ( ch == &#8216;S&#8217; ) s = p ;<br/>
     if ( ch == &#8216;M&#8217; ) m = p ;<br/>
     if ( ch == &#8216;T&#8217; ) t = p ;<br/>
     if ( ch == &#8216;#&#8217; ) return 1 ;<br/>
     else return 0 ;<br/>
}<br/><br/>
void readmap(int layer){<br/>
     int i;<br/>
     if ( layer == 0 ){<br/>
          space[p ++ ] = nextchar() ;<br/>
          return ;<br/>
     }<br/>
     for ( i = 0 ; i &lt; n[layer - 1] ; i ++ ) readmap( layer - 1 ) ;<br/>
}<br/><br/>
int main(){<br/>
     int i ;<br/>
     int ans ;<br/>
     while (1){<br/>
          scanf(&#8220;%d&#8221;,&amp;d);<br/>
          if ( d == 0 ) break ;<br/>
          for ( i = 0 ; i &lt; d ; i ++ ){<br/>
               scanf(&#8220;%d&#8221;,n + i ) ;               <br/>
          }<br/>
          mv[0] = 1 ;<br/>
          for ( i = 1 ; i &lt;= d ; i ++ ){<br/>
               mv[i] = n[i - 1] * mv[i - 1] ;<br/>
          }<br/>
          p = 0 ;<br/>
          readmap(d) ;<br/>
          ans = 0 ;<br/>
          space[m] = 1 ;<br/>
          i = bfs(t,s) ;<br/>
          if ( i == -1 ){<br/>
               ans = -1 ;<br/>
          }else{<br/>
               space[m] = 0 ;<br/>
               ans += i ;<br/>
               i = bfs(s,m) ;<br/>
               if ( i == -1 ){<br/>
                    ans = -1 ;<br/>
               }else{<br/>
                    ans += i ;<br/>
                    i = bfs(m,t) ;<br/>
                    if ( i == -1 ){<br/>
                         ans = -1 ;<br/>
                    }else{<br/>
                         ans += i ;<br/>
                    }<br/>
               }<br/>
          }<br/>
          if ( ans == -1 )puts(&#8220;No solution. Poor Theseus!&#8221;);<br/>
          else{<br/>
               printf(&#8220;Theseus needs %d steps.\n&#8221;,ans);<br/>
          }<br/>
     }     <br/>
     return 0 ;<br/>
}<br/><br/><font color="#0000ff">三。后话</font><br/><br/>
这东西在POJ上用G++交不过。。于是很郁闷地去搜了数据。拿下来发现是对的。。<br/><br/>
无解中。。。于是换C++ 交。。。然后就过了。。不知道谁看出是哪的问题了。。求解。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/03/24/%E7%8C%A5%E7%90%90%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA--%E8%AF%B4%E5%A5%BD%E5%90%AC%E7%82%B9%E4%B9%9F%E5%8F%AB%E4%BC%98%E5%8C%96%E3%80%82%E3%80%82%E3%80%82%EF%BC%88G%2B%2B%29/">猥琐的输入输出&#8211;说好听点也叫优化。。。（G++)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-03-24T18:09:00+08:00" pubdate data-updated="true">Mar 24<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div forimg="1">
<div forimg="1">
<div forimg="1">
<div forimg="1"> </div>
</div>
</div>
</div>


<div forimg="1">(hplonline)2009.3.24<br/><br/>
首先这是一道<font color="#ff0000">水题</font>。<br/><br/>
输入规模是n<br/><br/>
运算过程有2*n<br/><br/>
输出过程是n<br/><br/>
那么，有图有真相：全部是G++交的。<br/><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/4f3587b11d63f17508230218.jpg"/><br/><br/>
从下往上看过去。第一个是一般写法。第二个是<font color="#ff0000">猥琐输入</font>。第三个是<font color="#ff0000">猥琐输出</font>。<br/><font color="#0000ff"><br/>
输入部分：</font><br/><br/>
          for ( i = 1 ; i &lt;= n ; i ++ ){<br/>
          //     scanf(&#8220;%d&#8221;,s + i ) ;<br/>
               ch = getchar() ;<br/>
               if ( ch == &#8216;-&#8217; ){<br/>
                    k = 1 ;<br/>
                    j = 0 ;<br/>
               }else{<br/>
                    j = ch - &#8216;0&#8217; ;<br/>
                    k = 0 ;<br/>
               }<br/>
               while((ch = getchar()) &gt;= &#8216;0&#8217;){<br/>
                    j = j * 10 + ch - &#8216;0&#8217; ;<br/>
               }<br/>
               if (k) s[i] = -j ;<br/>
               else s[i] = j ;<br/>
          }<br/><br/><font color="#0000ff">输出部分：</font><br/><br/>
          for ( i = 1 ; i &lt;= n ; i ++ ){<br/>
               //printf(&#8220;%d &#8220;,s[i] ) ;<br/>
               j = 0 ;<br/>
               k = s[i] ;<br/>
               do {<br/>
                    out[j ++] = k % 10 + &#8216;0&#8217;;<br/>
                    k /= 10 ;<br/>
               }while ( k ) ;<br/>
               while ( j &#8211; ){<br/>
                    putchar(out[j]) ;<br/>
               }<br/>
               putchar(&#8217; &#8216;);<br/>
          }<br/><br/>
由此得到一个结论。。<br/><font color="#ff0000">getchar()和putchar()比scanf和printf快多了。。。</font><br/><br/>
就当我是无聊啊。。。</div>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/03/22/PWM%E5%92%8C%E8%B0%83%E5%8E%8B%E6%B3%95%E5%AF%B9%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA%E7%9A%84%E6%8E%A7%E5%88%B6/">PWM和调压法对直流电机的控制</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-03-22T22:48:00+08:00" pubdate data-updated="true">Mar 22<span>nd</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.3.22<br/><br/>
这回的目标就是直流电机。<br/><br/><font color="#0000ff">一。原理</font><br/><br/>
用我的口水话来描述。直流电机大致是这么个东西。<br/><br/><font color="#ff0000">你给他通上电他就会转啦，转的方向取决于电流的方向。<br/>
转的速度，可以说跟电压相关，也可以说跟电流相关。<br/>
（网上可以搜到那些公式，有电压，有磁通，磁通是跟电流相关的）</font><br/><br/>
所以，有两种很明显的控制方法：<br/><font color="#ff6600">1.我一会通电，一会断电，那么他就走走停停，把时间控制好点，宏观上就是很平稳地转了。<br/>
2.我要他转多快，我给多少的电压，或者电流，这样。</font><br/><br/>
一般提到直流电机，大家都会提到的PWM就是第1种这个意思。<br/>
给个方波，调节下占空比，就相当于开开关关这样。<br/>
开得多自然就跑得快点，开得少就慢点。<br/><br/><font color="#ff9900">然后这里为了好玩，再用下第二种方法。</font><br/><br/><font color="#0000ff">二。电路</font><br/><br/>
右半部分如下。<br/><br/><div forimg="1"><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/ccbe5c4e7e287628b2de0518.jpg"/><br/><br/>
这个<a href="http://hi.baidu.com/hplonline/blog/item/8065aaece104673527979195.html" target="_blank">DAC0808</a>就是前面那一篇用过的了。这里把LED换成MOTOR。<br/><br/><font color="#ff0000">要提下的就是，MOTOR的参数里面可以设置转速，默认是6，可以改大一点，要不速度变化过于细微</font>。<br/><br/>
左下的这个MOTOR是用PWM控制的。<br/><br/>
下面是左边的图：</div></p>

<div forimg="1"><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/50de9d0ace3e823e94ca6b18.jpg"/></div>


<br/>


<p>这里涉及到的也就是<a href="http://hi.baidu.com/hplonline/blog/item/a8f8c2fc579ce6f5fd037f20.html" target="_blank">ADC0808</a>的使用。<br/><br/>
那么整个流程就是，采样左边的电阻上的电压，用来调节MOTOR的转速。<br/><br/><font color="#0000ff">三。程序</font><br/><br/></p>

<h1>include &lt;reg51.h&gt;<br/><br/></h1>

<p>sbit CLOCK = P3 ^ 0 ;<br/>
sbit START = P3 ^ 1 ;<br/>
sbit EOC = P3 ^ 2 ;<br/>
sbit OE = P3 ^ 3 ;<br/>
sbit PWM = P3 ^ 4 ;<br/><br/>
void delay(unsigned char c);<br/><br/>
void main(){<br/>
      unsigned char c ;<br/>
      TMOD = 0x02 ;<br/>
      TH0 = 0x20 ;<br/>
      TL0 = 0x00 ;<br/>
      IE = 0x82 ;<br/>
      TR0 = 1;<br/>
      while(1){<br/>
            START = 1 ;<br/>
            START = 0 ;<br/>
            while ( !EOC ) ;<br/>
            OE = 1 ;<br/>
            c = P1 ;<br/>
            P2 = c       ;<br/>
            PWM = 1 ;<br/>
            delay(c);<br/>
            PWM = 0 ;<br/>
            delay( 255 - c );<br/>
            OE = 0 ;<br/>
      }      <br/>
}<br/><br/>
void delay(unsigned char c){<br/>
      while ( c &#8211; ) ;<br/>
}<br/><br/>
void timer0() interrupt 1{<br/>
      CLOCK = !CLOCK ;<br/>
}<br/><br/>
跟前面一篇ADC的有点不同就是让单片机自己输出CLOCK信号。<br/><br/>
这个实验主要就是直流电机的一点东西，其他部分还是之前做过的实验的一个<font color="#ff0000">组装</font>。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/03/22/DAC0808%E5%AE%9E%E7%8E%B0LED%E4%BA%AE%E5%BA%A6%E8%B0%83%E8%8A%82/">DAC0808实现LED亮度调节</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-03-22T22:07:00+08:00" pubdate data-updated="true">Mar 22<span>nd</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.3.22<br/><br/>
练习一下DAC0808<br/><br/>
首先是来自DATASHEET的典型电路。<br/><br/><div forimg="1"><a target="_blank" href="http://hiphotos.baidu.com/hplonline/pic/item/42a9f1f21e163432b17ec577.jpg"></p>

<div forimg="1"><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/42a9f1f21e163432b17ec577.jpg"/></div>


<p></a><br/><br/>
这个就按照接就行了。VO的输出公式也给出了的。<br/><br/>
第二步就是左边的控制部分。<br/><br/><div forimg="1"><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/a9e471ec9ce091f02e2e2177.jpg"/></div></p>

<br/>


<p>下面用了PULLDOWN，因为这个东西用起来很方便，不用考虑阻值，只考虑电平特性。<br/>
正如<a href="http://hi.baidu.com/hplonline/blog/item/5de26406e44d1c73030881af.html" target="_blank">前面发现的PULLUP</a>一样。<br/><br/>
右边的图是<br/><br/><div forimg="1"><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/2bc327f500f93e04bd310977.jpg"/></div>
</div>
主要还是参照典型电路把DAC0808接好。<br/><br/>
最右边这个接地电阻。。其实是比较重要的东西。。一开始居然忘了。。<br/>
搞得电压探针测出来的值一直有问题，怎么换开关都是2点几的样子。。<br/>
因为LED导通后，把电压钳在那里了。<br/><br/>
练习下器件而已。。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/03/22/%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8%E7%9A%84%E8%AF%AD%E4%B9%89%E5%8F%8A%E5%BA%94%E7%94%A8/">数组引用的语义及应用</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-03-22T18:56:00+08:00" pubdate data-updated="true">Mar 22<span>nd</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.3.22<br/><br/>
此篇的实验在DEV C++完成，因为有些特性VC编译并不支持。<br/><br/>
引用，也一直忽略了很久。<font color="#ff0000">因为从最底层来看，大部分引用都是用指针来实现的</font>。<br/>
于是，很多书也给出了这样的结论：<br/><font color="#3366ff">引用就是指针，或者说是一种让编译器自动脱指针运算的方式。</font><br/><br/>
对于一般的引用，通过一个例子来验证以上说法：<br/><font color="#ff6600">int swap(int &amp;a , int &amp;b){<br/>
      int t = a ;<br/>
      a = b ;<br/>
      b = t ;<br/>
}</font><br/><br/><font color="#ff0000">那么把所有引用的声明位置替换成指针声明。把所有引用使用的位置替换成脱指针操作。</font><br/><font color="#ff0000">就可以得到一个等价的程序</font><br/><br/><font color="#ff6600">int swap(int <em>a , int </em>b){<br/>
      int t = <em>a ;<br/>
      </em>a = <em>b ;<br/>
      </em>b = t ;<br/>
}</font><br/><font color="#ff6600">（注：这两段代码是为了表意直接在页面上写的）</font><br/><br/>
这样的一段话实现同样的功能，这让我们更加坚定以上结论。<br/>
他在大多数时候描述的就是事实。而后面给出的替换法则也是通常成立的。<br/><br/>
正如上回偶然看到的<a href="http://hi.baidu.com/hplonline/blog/item/8ed7f2dc0f1e6ea6cc116674.html" target="_blank">数组和指针的差异</a>一样。<br/>
今天突然发现了<font color="#ff0000">数组引用</font>的另外的特性。<br/><br/>
先上一段代码吧:<br/><br/>
void f(int a[5]){<br/>
       cout&lt;&lt;sizeof(a)&lt;&lt;endl;       <br/>
}<br/><br/>
void g(int *a){<br/>
       cout&lt;&lt;sizeof(a)&lt;&lt;endl;       <br/>
}<br/><br/>
void h(<font color="#ff0000">int (&amp;a)[5]</font>){<br/>
       cout&lt;&lt;sizeof(a)&lt;&lt;endl;<br/>
}<br/><br/>
int main(){<br/>
      int a[5];<br/>
      f(a);<br/>
      g(a);<br/>
      h(a);<br/>
      system(&#8220;pause&#8221;);<br/>
      return 0 ;<br/>
}<br/><br/><font color="#0000ff">输出:</font><br/>
4<br/>
4<br/>
20<br/><br/>
前两个说明了一句，我搞忘是哪里说的了：<br/>
作为函数的参数，指针和数组是一样的。<br/><br/>
也就是第一个数组虽然给了长度5，但是，作为函数参数，处理为一个指针，丢失了长度信息。<br/><br/>
而最后一个，就是土鳖我今天发现的新大陆。<br/><font color="#ff0000">数组的引用，携带了有关数组长度的信息。</font><br/><br/>
这里，引用&amp;这种修饰符是针对变量的。所以要用括号结合起来。<br/><br/>
不过这里既然是引用，那么引用和被引用双方一定得是相同的东西了。<br/>
所以如果把a[5];改成a[6];这下编译器就报错了。<br/><br/>
那么，同时在网上看到的一段很通用的模板代码：<br/><br/>
template&lt;typename T, size_t N&gt;<br/>
void f(T (&amp;a)[N])<br/>
{<br/>
     cout&lt;&lt;sizeof(a)&lt;&lt;endl;<br/>
}<br/><br/>
int main(){<br/>
      int a[6];<br/>
      char c[3];<br/>
      f(a);<br/>
      f(c);<br/>
      system(&#8220;pause&#8221;);<br/>
      return 0 ;<br/>
}<br/><br/><font color="#0000ff">输出：</font><br/>
24<br/>
3<br/><br/>
可以适应不同类型和大小的数组。<br/><br/>
可见。。以前对引用的认识不完全。<br/>
那么今后会得到怎样的认识呢。。期待。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/backup-hplonline/blog/page/22/">&larr; Older</a>
    
    <a href="/backup-hplonline/blog/archives">Blog Archives</a>
    
    <a class="next" href="/backup-hplonline/blog/page/20/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/backup-hplonline/blog/2013/05/04/test/">Test</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/04/09/%E5%86%8D%E8%B0%88stl%E7%9A%84rotate/">再谈stl的rotate</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%BA%8C%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、二）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%89%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、三）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%80%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、一）</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - hplonline -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
