
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>hplonline</title>
  <meta name="author" content="hplonline">

  
  <meta name="description" content="(hplonline)2009.3.10
用用PROTEUS的虚拟终端而已
顺便用下MAX232这个芯片一。电路 这里的MAX232外部虽然接了这么些电容。。
其实不接他们也可以运作的。。这就是PROTEUS的强大之处。。
好比你的单片机也没有接晶振啊啥的。。
那么。。他们仅仅是个造型？ &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hupili.github.io/backup-hplonline/blog/page/23">
  <link href="/backup-hplonline/favicon.png" rel="icon">
  <link href="/backup-hplonline/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/backup-hplonline/atom.xml" rel="alternate" title="hplonline" type="application/atom+xml">
  <script src="/backup-hplonline/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/backup-hplonline/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/backup-hplonline/">hplonline</a></h1>
  
    <h2>backup from 2006 to 2012 (original hi.baidu.com/hplonline/)</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/backup-hplonline/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hupili.github.io/backup-hplonline" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/backup-hplonline/">Blog</a></li>
  <li><a href="/backup-hplonline/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/03/10/%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1%E5%92%8C%E8%99%9A%E6%8B%9F%E7%BB%88%E7%AB%AF/">串行通信和虚拟终端</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-03-10T19:11:00+08:00" pubdate data-updated="true">Mar 10<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.3.10<br/><br/>
用用PROTEUS的虚拟终端而已<br/>
顺便用下MAX232这个芯片<br/><br/><font color="#0000ff">一。电路</font><br/><br/><div forimg="1"><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/733afd03935dbbcd09fa93b9.jpg"/></div></p>

<br/>


<p>这里的MAX232外部虽然接了这么些电容。。<br/>
其实不接他们也可以运作的。。这就是PROTEUS的强大之处。。<br/>
好比你的单片机也没有接晶振啊啥的。。<br/><br/>
那么。。他们仅仅是个造型？<br/>
这是好事还是坏事呢？<br/><br/><font color="#ff6600">一方面我们可以专注于主要问题<br/>
另一方面，我们忽略细节</font><br/><br/><font color="#0000ff"><br/>
二。程序</font><br/><br/>
ctrl BIT P3.7<br/><br/>
org 00h<br/>
ljmp func_main<br/><br/>
org 30h<br/>
func_main:<br/><br/>
        mov SCON , #01010000b<br/>
        mov TMOD , #20h<br/>
        orl PCON , #10000000b<br/>
        mov TH1 , #0f3h<br/>
        mov TL1 , #0f3h<br/>
        setb TR1<br/>
        again:<br/>
        jnb RI , $<br/>
        clr RI<br/>
        mov A , SBUF <br/>
        mov SBUF , A<br/>
        jnb TI , $<br/>
        clr TI<br/>
        sjmp again<br/><br/>
sjmp $<br/><br/>
end<br/><br/>
就是一个终端输入什么，单片机返回什么。。没啥特别的..<br/><br/>
mov SCON , #01010000b<br/>
设置允许接收,工作方式1,即波特率可变.<br/><br/>
mov TMOD , #20h<br/>
T1按照方式2工作，即自动重置计时<br/><br/>
orl PCON , #10000000b<br/>
PCON的MSB置1，即SMOD为1<br/><br/>
计时器的溢出率 = fosc / 12 * (0xff - 0xf3)<br/><br/>
波特率 = 溢出率 * 2<sup>SMOD</sup> / 32<br/><br/>
取fosc = 12M<br/><br/>
算得 波特率为 4807.6923076923076923076923076923<br/><br/>
近似为标准的4800<br/><br/>
只要在虚拟终端处有相应的设置就行了。<br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/03/10/74LS165%E4%B8%B2%E8%A1%8C%E8%BE%93%E5%85%A5/">74LS165串行输入</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-03-10T17:12:00+08:00" pubdate data-updated="true">Mar 10<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><font color="#0000ff"><font color="#000000">(hplonline)2009.3.10</font><br/><br/>
一。目标</font><br/>
练习74LS165<br/>
发现了一个很有用8排开关。。<br/>
（比起自己的按钮来说体积小多了。）<br/><br/><font color="#0000ff">二。电路</font><br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/a3fb99138bb6d0a16438dbb7.jpg" small="0" class="blogimg"/></div>
嗯，如果从前面一路看过来的话，这图没啥说的了。。<br/>
要问我为啥喜欢数码管。。原因是这东西封装好。。<br/>
我们仅仅是用来表达一些信息而已。。用8个LED不觉得很难画吗。。<br/><br/><font color="#0000ff">三。程序</font><br/><br/>
ctrl BIT P3.7<br/><br/>
org 00h<br/>
ljmp func_main<br/><br/>
org 30h<br/>
func_main:<br/>
       mov SCON , #10h<br/>
       <em>start:<br/>
       clr ctrl<br/>
       setb ctrl<br/>
       jnb RI , $<br/>
       mov A , SBUF <br/>
       clr RI<br/>
       mov P1 , A<br/>
       acall func_delay<br/>
       sjmp </em>start<br/>
sjmp $<br/><br/>
func_delay:<br/>
       mov R6 , #200<br/>
       <em>lb:<br/>
       mov R5 , #100<br/>
       djnz R5 , $<br/>
       djnz R6 , </em>lb<br/>
ret<br/><br/>
end<br/><br/>
这里主要是165的控制。<br/>
ctrl的地址是165的sh/ld_bar<br/>
       clr ctrl<br/>
       setb ctrl<br/>
先置低，则芯片载入八个开关的状态<br/>
然后置高，则芯片进去移位模式<br/><br/>
TXD发送移位脉冲，<br/>
RXD接收数据。<br/><br/>
PS:今天发现了一个事情，就是。。<font color="#ff9900">PROTEUS里面居然可以双击一个芯片<br/>
然后点旁边的data</font>。。。则会自动下载其datasheet。。。<br/>
原来还在网上到处搜呢。。。郁闷。。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/03/09/%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E6%8E%A7%E5%88%B6%E6%95%B0%E7%A0%81%E7%AE%A1/">移位寄存控制数码管</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-03-09T14:14:00+08:00" pubdate data-updated="true">Mar 9<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.3.9<br/><br/>
原理就是74LS164的用法，和串行通信。<br/>
前面已经练习过了，所以很容易。<br/><br/>
http://hi.baidu.com/hplonline/blog/item/967eaec2c20ad0130ff47762.html<br/><br/>
好处：<br/><font color="#ff0000">无需刷新，只占两个IO口！后接数码管任意多</font><br/><br/><font color="#0000ff">一。电路</font><br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/3695942fffd427191e30898c.jpg" small="0" class="blogimg"/></div></p>

<br/><font color="#0000ff">二。程序</font><br/><br/>


<h1>include &lt;reg51.h&gt;<br/><br/></h1>

<p>sbit dt = P3<sup>0</sup> ;// P1 ^ 1 ;<br/>
sbit clk = P3<sup>1</sup> ; //P1 ^ 0 ;<br/>
typedef unsigned char uchar ;<br/><br/>
void output( uchar cd ){<br/>
     uchar i ;<br/>
     for ( i = 8 ; i ; i &#8211; ){<br/>
          dt = cd &amp; 1 ;<br/>
          cd &gt;&gt;= 1 ; <br/>
          clk = 0 ; <br/>
          clk = 1 ;<br/>
     }<br/>
}<br/><br/>
void main(){<br/>
     output(0x1c);     //&#8221;L&#8221;<br/>
     output(0xce);     //&#8221;P&#8221;<br/>
     while(1);     <br/>
}<br/><br/>
其实很简单的事情。<br/>
这里没有用单片机自己的串行通信机制。<br/>
只是根据这样一种原理，自己模拟这个过程。可以做到更快。<br/><br/>
     <font color="#ff0000">     dt = cd &amp; 1 ;这个就是对数据线赋值<br/>
          clk = 0 ; <br/>
          clk = 1 ;然后发送移位脉冲</font><br/><br/>
这样就可以了。<br/><br/>
好处是不用说了，<font color="#ff6600">缺点有一个，就是只能搞7段的。。<br/>
因为每个移位寄存只供8个口，而要腾出一个继续向后输出数据。<br/><br/>
不过可以想办法改到8段也可以用，只是臃肿了点。<br/>
在只用7段的情况下，这样做很强大。。</font></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/03/09/%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB%EF%BC%88PULLUP%EF%BC%89/">上拉电阻（PULLUP）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-03-09T13:26:00+08:00" pubdate data-updated="true">Mar 9<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.3.9<br/><br/>
不得不承认。。我是土鳖。。今天发现原来上拉电阻这么好用（PULLUP)。。<br/><br/>
OK ，先给个电路图<br/><br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/6267a377d16ebc3ab151b9ec.jpg" small="0" class="blogimg"/></div></p>

<br/>


<p>其实很明显了，这里让P0口全部为1<br/><br/>
看四个灯的情况就知道了。<br/><br/>
第一个啥都没有，显然驱动不了。<br/><br/>
第二个加了PULLUP的直接就驱动了。<br/><br/>
第三个和第四个都是RES，但是阻值不一样。<br/><br/>
可见，<font color="#ff6600">用普通的RES的话，关注的是电流电压特性，要调到合适的值才好用。<br/><br/>
而用PULLUP的话，关注的是端点的电压情况。</font></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/03/08/8255A%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%BA%94%E7%94%A8/">8255A的输入输出应用</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-03-08T20:05:00+08:00" pubdate data-updated="true">Mar 8<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.3.8<br/><br/><font color="#0000ff">一。目标</font><br/>
8255A，可编程并行输入输出芯片。<br/>
练习了看第二份DATASHEET。<br/>
8个开关做输入，控制数码管的8个端口（7个为显示段，一个为共阴输出）<br/><br/>
被一些丑陋的问题困扰了这么久才出来。。。<br/><br/><font color="#0000ff">二。电路</font><br/><div forimg="1"><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/a194c0802bb005f69023d9f7.jpg"/></div>
连接的时候，有几个要注意：<br/><font color="#ff0000">1.ABC口要加驱动（74LS373就可以了），要不PROTEUS直接报错<br/>
2.A0,A1两个地址线不能和P0上的数据线共用。。<br/>
（因为我这里没有对地址锁存。。为了这个问题找了半天。。。）</font><br/><br/><br/><font color="#0000ff">三。程序</font><br/><br/>
PORTA EQU 73fch<br/>
PORTB EQU 77fdh<br/>
PORTC EQU 7bfeh<br/>
CONTROL EQU 7fffh<br/>
MOD_AoutBin EQU 82h<br/><br/>
org 00h<br/>
ljmp func_main<br/><br/>
org 30h<br/>
func_main:<br/><br/>
      mov DPTR ,  #CONTROL<br/>
      mov A , #MOD_AoutBin<br/>
      movx @DPTR , A<br/>
<em>lp:<br/>
      mov DPTR , #PORTB<br/>
      movx A , @DPTR<br/>
      mov DPTR , #PORTA<br/>
      movx @DPTR , A<br/>
      sjmp </em>lp<br/>
sjmp $<br/><br/>
end <br/><br/>
用到的主要就是外部RAM的寻址。<br/>
首先向控制字里面写入8255的工作方式。<br/>
然后在一个循环中不断从B读入，向A输出就可以了。<br/><br/>
关于怎么寻址，地址的计算，在上一篇里面有了。<br/><br/>
这里主要是8255的A1A0组合成的地址的意义：<br/>
0 1 2     3<br/>
A B C CW<br/>
CW:控制字<br/><br/>
一开始向控制字里写入的82h就是设置A为输出，B为输入，<br/>
这个可以在8255A的DATASHEET上查到。<br/><br/>
四。感想<br/><font color="#ff0000">寻址外部RAM的MOVX很不错。。可以简化很多程序上的设计。。<br/>
只是外围会多加一写芯片。</font></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/03/08/74LS273%E8%BE%85%E5%8A%A9%E5%A4%96%E9%83%A8%E5%AF%BB%E5%9D%80%E7%9A%84%E6%95%B0%E7%A0%81%E7%AE%A1/">74LS273辅助外部寻址的数码管</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-03-08T14:06:00+08:00" pubdate data-updated="true">Mar 8<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><font color="#0000ff"><font color="#000000">（hplonline）2009.3.8</font><br/><br/>
一。目标</font><br/>
1.练习74LS273<br/>
2.<font color="#ff0000">体验</font>一种一般学习型最小系统里面不用的控制方式<br/><br/><font color="#0000ff">二。优势</font><br/><br/>
像普通的学习型最小系统里面 ，普遍采用的控制数码管的方式是：<br/><br/><font color="#000000">用一组IO口（7个或8个）控制数码管的段<br/>
用另外一组（8个，如果译码则只要3个）控制数码管的位<br/>
显示的方式就是刷新。</font><br/><br/>
这种方式的缺点，很明显：<br/><br/><font color="#000000">1.因为是靠视觉暂留来保持显示的，导致SCM要不断刷新<br/>
2.在较大的程序里面，管间切换时间不均匀会导致亮度不一<br/>
3.耗费大量SCM的计算资源<br/>
4.如果采用时钟中断，可以改善以上问题，但实际效果不理想<br/>
（因为SCM工作频率不高，无法与现在的PC机CPU相比）</font><br/><br/>
而马上出来的外部寻址法，将解决这些问题，嗯，卖个关子，最后来讲，先上电路了<br/><br/><font color="#0000ff">三。电路</font><br/><br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/1dd98d44dda51e6d500ffe0c.jpg" small="0" class="blogimg"/></div></p>

<br/>


<p>这里就用两个数码管来演示了。多个的完全类推。<br/>
因为这次大量使用了标签，所以截得大一点，可以看得清楚。<br/><br/>
关于标签&#8230;我又想骂有些人写书不写清楚了&#8230;<br/>
最早见到的时候,是教用总线&#8230;大致是让我们先画个总线,<br/>
然后把支线连好,在支线上标号..云云..<br/><br/>
这就导致我一直以为标号是用在总线上面。。。<br/>
今天才发现总线就是一个可有可无的东西。。。<br/>
标同样号的线直接就是连在一起的。。<br/>
那干嘛要用总线呢？。。也许看起来NB一点吧。。<br/>
其实不涉及布线，标下号就可以了。。<br/><br/>
个人感觉：<br/><font color="#ff0000">标号出来的图确实清晰。。<br/>
但是标号的效率不高，能够直连的就直连，可以节省些时间。。</font><br/><br/>
连接思路为：<br/><font color="#ff0000">把273的CLK接到地址线(P2 or P0)与WR_BAR信号相或。<br/>
把273的D端接到数据线(P0)。<br/>
即可利用访问外部RAM同样的方式去寻址控制的8个灯。</font><br/><br/><font color="#0000ff">四。程序</font><br/><br/>
org 00h<br/>
ljmp func_main<br/><br/>
org 30h<br/>
func_main:<br/>
       mov DPTR , #7fffh<br/>
       mov A , #0fh<br/>
       movx @DPTR , A <br/>
       mov DPTR , #0bfffh<br/>
       mov A , #0f0h<br/>
       movx @DPTR , A <br/>
sjmp $<br/><br/>
end <br/><br/>
这个，可谓很简单了，就是访问外部RAM的指令MOVX而已。<br/><font color="#ff0000">所以为啥要用汇编呢？因为汇编里面有（MOV,MOVC,MOVX，让人随时知道自己在干什么事）</font><br/><br/>
这里，第二个数码管的地址是7fffh，第一个的地址是0bfffh。<br/><br/>
这个地址的算法从电路图上来：<br/>
a2标注的是P2.7(A15)，这个端口和WR_BAR端口取或，<br/>
则在两个端口均为0的情况下，输出0。<br/>
而74LS273的CLK为0的时候，将成功写入。<br/>
WR_BAR 将随着  movx @DPTR , A 的执行自动变低。<br/>
也就是这时候，只要a2为低，则片选成功，可以写入。<br/>
执行完后，WR_BAR为高，则74LS273锁存。<br/><br/>
那么让a2为低，就很简单了，其实不仅用7fffh可以，用7f00h之类的都可以。<br/><font color="#ff0000">只要知道原理是让a2为低就可以了。</font><br/><br/>
不过这里是因为电路简单，当外接比较多的东西时，就不太好了。<br/>
所以用7fffh比较标准一点，把其他片选都截止。<br/><br/>
同理，a1也算出来就是0bfffh<br/><br/><font color="#0000ff">五。再谈优势</font><br/><br/><font color="#ff0000">1.直接使用外部寻址指令MOVX，代码简洁。<br/>
2.不用刷新，赋值后直接锁存。<br/>
3.演示使用了两个，当然可以接多个。<br/>
4.显示亮度稳定。<br/>
5.解放了SCM的计算资源。</font><br/><br/>
缺点：<br/><font color="#ff0000">占用了外部RAM的地址空间</font>，但在没有外部RAM的情况下无所谓。<br/><br/>
这种实现解决了一般实现的一些问题。<br/>
不过使用的输出口数量并无优势。<br/><br/>
我这里的实现，用的地址空间是不连续的，相当浪费。<br/>
具体做的时候，还可以对<font color="#ff0000">地址译码</font>，节约地址资源。<br/><br/>
要最大限度地节约输出口，那么可以使用<font color="#ff0000">串行</font>实现。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/03/07/%E5%B8%AE%E4%BA%BA%E6%94%B9%E4%BB%A3%E7%A0%81%EF%BC%88%E5%88%A4%E6%96%AD%E5%B7%A5%E4%BD%9C%E7%B0%BF%E6%89%93%E5%BC%80%E5%90%A6%EF%BC%89%EF%BC%88VBA%29/">帮人改代码（判断工作簿打开否）（VBA)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-03-07T16:38:00+08:00" pubdate data-updated="true">Mar 7<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.3.7<br/><br/>
VBA,除了知道和VB是兄弟外，其实没有专门学过<br/><br/>
但是人家都来问了，像我这么热心的当然要去看一下对吧。<br/><br/>
==============下面是引用<br/><br/>
有人在么<br/><br/>
我在写excel    vba的时候检测工作薄是否打开<br/>
但是总出错阿<br/><br/>
Sub openif()<br/>
Dim bookopenbool As Boolean<br/>
Dim wb As Workbook<br/>
Dim mywb As String<br/>
mywb = &#8220;bb.xls&#8221;<br/>
Set wb = Workbooks(mywb)<br/>
bookopenbool = Not wb Is Nothing<br/>
If bookopenbool Then<br/>
MsgBox &#8220;meiyoudakai&#8221;<br/>
End If<br/>
If Not bookopenbool Then<br/>
MsgBox &#8220;dakaile&#8221;<br/>
End If<br/><br/>
End Sub<br/><br/>
Set wb = Workbooks(mywb)在这一句中<br/><br/>
如果bb.xls没有打开的话<br/>
wb 的值就是nothing<br/><br/>
但这个时候编译器总是报错<br/><br/>
说下届越位<br/><br/>
===========================<br/><br/>
我一看这代码。。雷啊。。。<br/>
下面用两个if ,舍不得用个else<br/><br/>
其实这不是关键。。仔细看他的条件。。当工作簿打开的时候。。<br/>
MsgBox &#8220;meiyoudakai&#8221;<br/><br/>
不过我也不清楚workbooks这个集合。。<br/>
M$的帮助里面也没见提到，不清楚当不存在时会怎么样。。<br/><br/>
于是想啊想。。。<br/><br/>
最后。。终于发现，其实这个问题很简单。。变相实现就可以了:<br/><br/>
     Dim wb As Workbook<br/>
     Dim mywb As String<br/>
     mywb = &#8220;1.xls&#8221;<br/>
     On Error GoTo err1<br/>
     Set wb = Workbooks.Item(mywb)<br/>
     MsgBox &#8220;opened&#8221;<br/>
     Exit Sub<br/>
err1:<br/>
     MsgBox &#8220;not opened&#8221;<br/><br/>
既然没打开的时候，要报下标越界。。就直接把错误给容掉不就OK了。。。<br/><br/>
汗。。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/03/06/%E4%B8%8D%E7%94%A8%E6%9D%A1%E4%BB%B6%2C%E8%BF%94%E5%9B%9E%E5%A4%A7%E6%95%B0%EF%BC%8C%E4%B8%94%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/">不用条件,返回大数，且效率更高</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-03-06T21:30:00+08:00" pubdate data-updated="true">Mar 6<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><pre class="prettyprint"><span class="kwd">(hplonline)2009.3.6<br/><br/>都是老话题了,不过这次讨论一点其他方面的东西,即效率更高<br/><br/><font color="#0000ff">一。代码如下:</font><br/><br/><font color="#ff6600">int</font></span><font color="#ff6600"><span class="pln"> max </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> a</span><span class="pun">,</span><span class="kwd">int</span><span class="pln"> b</span><span class="pun">){</span><span class="pln"><br/></span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="pun">~(</span><span class="pln"> a </span><span class="pun">-</span><span class="pln"> b </span><span class="pun">&gt;&gt;</span><span class="pln"> </span><span class="lit">31</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln"> a </span><span class="pun">-</span><span class="pln"> b </span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> b </span><span class="pun">;</span><span class="pln"><br/></span><span class="pun">}</span></font><span class="pln"><br/><br/><font color="#0000ff">二。原理就很简单了.</font><br/>a-b可以得到一个符号<br/>右移31位，这里是带符号右移，所以结果是<br/>a&gt;b:0;a&lt;b:-1<br/>取反：<br/>a&gt;b:-1;a&lt;b:0<br/>再和a-b与上<br/>a&gt;b:a-b;a&lt;b:0<br/>最后加个b<br/>a&gt;b:a;a&lt;b:b<br/><br/><font color="#ff6600">这里有点问题:就是溢出。</font><br/>比方说,a为负，b为正，两个数的绝对值都超大<br/>减出来可能变成个正数了！<br/><br/>不过，除了极端数据外，应用前景还是有那么点点<br/><br/><font color="#0000ff">三。然后我们来看效率：</font><br/><br/>下面直接引freebsd(jingmi)兄的了：<br/><br/></span><font color="#ff00ff">囧rz，今天不宜灌水，刚刚在另外一个地方讨论也犯了个大错……<br/><br/>实测了一下，这么玩的确是要快点，看数据吧：<br/><br/><span class="kwd">int</span><br/></font></pre>


<p><font color="#ff00ff"><span class="pln">main</span><span class="pun">(</span><span class="kwd">void</span><span class="pun">)</span><span class="pln"><br/></span><span class="pun">{</span><span class="pln"><br/></span><span class="kwd">int</span><span class="pln"> a </span><span class="pun">=</span><span class="pln"> </span><span class="lit">3</span><span class="pun">;</span><span class="pln"><br/></span><span class="kwd">int</span><span class="pln"> b </span><span class="pun">=</span><span class="pln"> </span><span class="lit">2</span><span class="pun">;</span><span class="pln"><br/></span><span class="kwd">int</span><span class="pln"> ret</span><span class="pun">;</span><span class="pln"><br/><br/></span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i</span><span class="pun">=</span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;</span><span class="lit">1000000000</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"><br/></span><span class="pun">{</span><span class="pln"><br/></span><span class="com">#ifdef FUN</span><span class="pln"><br/>
ret </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="pun">~(</span><span class="pln"> a </span><span class="pun">-</span><span class="pln"> b </span><span class="pun">&gt;&gt;</span><span class="pln"> </span><span class="lit">31</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln"> a </span><span class="pun">-</span><span class="pln"> b </span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> b</span><span class="pun">;</span><span class="pln"><br/></span><span class="com">#else</span><span class="pln"><br/>
ret </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">a</span><span class="pun">&gt;</span><span class="pln">b</span><span class="pun">)?</span><span class="pln">a </span><span class="pun">:</span><span class="pln"> b</span><span class="pun">;</span><span class="pln"><br/></span><span class="com">#endif</span><span class="pln"><br/></span><span class="pun">}</span><span class="pln"><br/><br/></span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"><br/></span><span class="pun">}</span><span class="pln"><br/></span><br/><br/>
这里把函数直接放进去了，避免函数调用开销。<br/><br/>
没有 define FUN 的情况下：<br/>
cc -Wall -Wextra -std=c99 test.c -o comp<br/>
jingmi@主机名打码~$time ./comp<br/>
4.311u 0.000s 0:04.31 100.0%    0+0k 0+0io 0pf+0w<br/><br/>
define FUN 的情况下：<br/>
cc -Wall -Wextra -std=c99 -DFUN test.c -o sarl<br/>
jingmi@主机名打码~$time ./sarl<br/>
3.021u 0.000s 0:03.02 100.0%    0+0k 0+0io 0pf+0w<br/><br/>
故意没有开优化，10亿次运算差了1.3秒，还是比较明显。<br/><br/>
但使用 pl 的算法需要注意的就是要 inline，而这个可能和编译器的优化有很大关系，另外生成的代码也比较复杂。<br/><br/>
另外在 c 中，这样写运算符优先级可能有点小问题。</font></p>

<pre class="prettyprint">为什么呢？下面直接引我粗糙的分析了：<br/><br/>几年前的一篇论文里面，<br/><br/>作者在他机器上测得的跳转类指令大概平均耗<font color="#ff0000">40个周期</font><br/><br/>而数据移动，移位，位运算类指令平均<font color="#ff0000">1个周期。</font><br/><br/>如果在这样的一台机器上。<br/><br/>那么用8条如下指令代替条件跳转是有效果的。。</pre>


<p><font color="#ff00ff"><span class="lit">00401578</span><span class="pln">  </span><span class="pun">|.</span><span class="pln">  </span><span class="lit">8B45</span><span class="pln"> </span><span class="lit">08</span><span class="pln">       mov     eax</span><span class="pun">,</span><span class="pln"> dword ptr </span><span class="pun">[</span><span class="pln">ebp</span><span class="pun">+</span><span class="lit">8</span><span class="pun">]</span><span class="pln"><br/></span><span class="lit">0040157B</span><span class="pln">  </span><span class="pun">|.</span><span class="pln">  </span><span class="lit">2B45</span><span class="pln"> </span><span class="lit">0C</span><span class="pln">       </span><span class="kwd">sub</span><span class="pln">     eax</span><span class="pun">,</span><span class="pln"> dword ptr </span><span class="pun">[</span><span class="pln">ebp</span><span class="pun">+</span><span class="pln">C</span><span class="pun">]</span><span class="pln"><br/>
eax </span><span class="pun">=</span><span class="pln"> a </span><span class="pun">-</span><span class="pln"> b<br/></span><span class="lit">0040157E</span><span class="pln">  </span><span class="pun">|.</span><span class="pln">  C1F8 </span><span class="lit">1F</span><span class="pln">       sar     eax</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1F</span><span class="pln"><br/>
eax </span><span class="pun">=</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pln"> </span><span class="kwd">or</span><span class="pln"> </span><span class="lit">0</span><span class="pln"><br/></span><span class="lit">00401581</span><span class="pln">  </span><span class="pun">|.</span><span class="pln">  F7D0          </span><span class="kwd">not</span><span class="pln">     eax<br/>
eax </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="kwd">or</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pln"><br/></span><span class="lit">00401583</span><span class="pln">  </span><span class="pun">|.</span><span class="pln">  </span><span class="lit">8B4D</span><span class="pln"> </span><span class="lit">08</span><span class="pln">       mov     ecx</span><span class="pun">,</span><span class="pln"> dword ptr </span><span class="pun">[</span><span class="pln">ebp</span><span class="pun">+</span><span class="lit">8</span><span class="pun">]</span><span class="pln"><br/></span><span class="lit">00401586</span><span class="pln">  </span><span class="pun">|.</span><span class="pln">  </span><span class="lit">2B4D</span><span class="pln"> </span><span class="lit">0C</span><span class="pln">       </span><span class="kwd">sub</span><span class="pln">     ecx</span><span class="pun">,</span><span class="pln"> dword ptr </span><span class="pun">[</span><span class="pln">ebp</span><span class="pun">+</span><span class="pln">C</span><span class="pun">]</span><span class="pln"><br/>
ecx </span><span class="pun">=</span><span class="pln"> a </span><span class="pun">-</span><span class="pln"> b<br/></span><span class="lit">00401589</span><span class="pln">  </span><span class="pun">|.</span><span class="pln">  </span><span class="lit">23C1</span><span class="pln">          </span><span class="kwd">and</span><span class="pln">     eax</span><span class="pun">,</span><span class="pln"> ecx<br/>
eax </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="kwd">or</span><span class="pln"> ecx<br/></span><span class="lit">0040158B</span><span class="pln">  </span><span class="pun">|.</span><span class="pln">  </span><span class="lit">0345</span><span class="pln"> </span><span class="lit">0C</span><span class="pln">       add     eax</span><span class="pun">,</span><span class="pln"> dword ptr </span><span class="pun">[</span><span class="pln">ebp</span><span class="pun">+</span><span class="pln">C</span><span class="pun">]</span><span class="pln"><br/>
eax </span><span class="pun">=</span><span class="pln"> b </span><span class="kwd">or</span></font><span class="pln"><font color="#ff00ff"> a</font><br/></span><br/><br/>
不过都说了哈，是几年前的数据。我自己机器上没有实测。<img src="http://bbs.stuhome.net/images/post/smile/yang/16.gif"/><br/><br/>
啥时候有空测一下。。<img src="http://bbs.stuhome.net/images/post/smile/yang/18.gif"/><br/><br/>
现在的硬件都优化得很好了，像乘法都平均到2周期了。。</p>

<pre class="prettyprint"><br/><br/>好了我ctrl+c,ctrl+v完了。</pre>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/03/02/KEILC%E7%BC%96%E8%AF%91%E7%9A%84TRICK%E6%8E%A2%E7%A9%B63%EF%BC%88%E5%87%BD%E6%95%B0%E4%B8%AD%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E6%95%B0%E6%8D%AE%EF%BC%89/">KEIL C 编译的TRICK探究3（函数中局部变量的初始数据）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-03-02T17:27:00+08:00" pubdate data-updated="true">Mar 2<span>nd</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>毕竟单片机平台与我们PC有很大的不同，<br/><br/>
比较突出的就是，我们的PC上跑的程序，<br/>
代码和数据都是在RAM里面，从物理上来说是一起的，<br/>
所以，很多东西实现起来可以比较随意。<br/>
比如<br/>
void main(){<br/>
       uchar a[] = {1,2,3,4};<br/>
       &#8230;.<br/>
}<br/>
就可以用DB 把a[]直接放在代码段里面。然后用到的时候直接引就可以了。<br/><br/>
但是单片机的代码是放在ROM里面的，通常有一个内部256B的RAM，来存放临时数据，<br/>
当然还可以外挂比较大的64K RAM。<br/>
从指令上就可以看出是很有区别的：<br/><font color="#ff6600">rom: movc &#8230;<br/>
内部ram:mov&#8230;<br/>
外部ram:movx</font>&#8230;<br/><br/>
那么，像上面那样一个函数，a[]的数据应该放在哪呢？<br/><br/><font color="#0000ff">实验程序：</font><br/></p>

<h1>include &lt;reg51.h&gt;<br/></h1>

<p>typedef unsigned char uchar ;<br/>
uchar table1[]={1,2,3,4,5};<br/>
void main(){<br/>
      uchar table2[] = {6,7,8,9,10};<br/>
      uchar i,j;<br/>
      P1 = 1 ;<br/>
      j = P1 ;<br/>
      i = table1[j];<br/>
      P2 = i ;<br/>
      i = table2[j];<br/>
      P3 = i ;<br/>
      while (1) ;<br/>
}<br/><br/>
至于代码为啥要这样写，是经过多次尝试的，因为KEIL也会优化。<br/>
如果太简单的话，比如只有i=table[0]，<br/>
你可能看到的就只有mov R7 , 1这样一句话。。<br/><br/>
虽然从执行上来说没有区别，对我们的普遍性分析造成了障碍。<br/><br/><font color="#ff0000">而一般的原则是，尽可能用到P0..P3这些东西，<br/>
因为这些东西的值是编译期无法确定的，所以KEIL只有老实点了，哈哈</font><br/><br/>
那么先看上面这个程序的汇编情况：<br/><br/>
C:0x0982      780D       MOV        R0,#0x0D<br/>
C:0x0984      7C00       MOV        R4,#0x00<br/>
C:0x0986      7D00       MOV        R5,#0x00<br/>
C:0x0988      7BFF       MOV        R3,#0xFF<br/>
C:0x098A      7A09       MOV        R2,#0x09<br/>
C:0x098C      79B2       MOV        R1,#0xB2<br/>
C:0x098E      7E00       MOV        R6,#0x00<br/>
C:0x0990      7F05       MOV        R7,#0x05<br/><font color="#ff0000">C:0x0992      1208D0     LCALL      C?COPY(C:08D0)</font><br/>
      10:           P1 = 1 ; <br/>
C:0x0995      759001     MOV        P1(0x90),#0x01<br/>
      11:           j = P1 ; <br/>
C:0x0998      AF90       MOV        R7,P1(0x90)<br/>
      12:           i = table1[j]; <br/>
C:0x099A      7408       MOV        A,#table1(0x08)<br/>
C:0x099C      2F         ADD        A,R7<br/>
C:0x099D      F8         MOV        R0,A<br/>
C:0x099E      E6         MOV        A,@R0<br/>
      13:           P2 = i ; <br/>
C:0x099F      F5A0       MOV        PPAGE_SFR(0xA0),A<br/>
      14:           i = table2[j]; <br/>
C:0x09A1      740D       MOV        A,#0x0D<br/>
C:0x09A3      2F         ADD        A,R7<br/>
C:0x09A4      F8         MOV        R0,A<br/>
C:0x09A5      E6         MOV        A,@R0<br/>
      15:           P3 = i ; <br/>
C:0x09A6      F5B0       MOV        P3(0xB0),A<br/>
      16:           while (1) ; <br/>
C:0x09A8      80FE       SJMP       C:09A8<br/><br/>
KEIL已经分割好了，很容易找到对应C的汇编<br/><br/>
可以看出R7就是我们的j，<br/>
C:0x099A      7408       MOV        A,#table1(0x08)<br/>
C:0x099C      2F         ADD        A,R7<br/>
C:0x099D      F8         MOV        R0,A<br/>
C:0x099E      E6         MOV        A,@R0<br/>
这里就是用哦个table的始地址加上j，放到R0里面供寻址用。<br/><br/>
可以看到table1 的地址是0x08<br/>
同理，table2的地址是0x0d<br/><br/><font color="#ff0000">他们都是用的MOV ，所以数据是放在内部RAM里面的！</font><br/><br/>
这里有一个原则性的东西，<font color="#ff6600">我们写的程序全部在ROM里面，<br/>
包括指定的这些初始数据，那么他们一定在某个时候跑到了RAM里面。</font><br/><br/>
本来准备了table1和table2的，但是时间不够，这次就先分析table2的形成。<br/><br/>
进去KEIL的反汇编，停下来的时候，可以看到，<br/>
table1对应的位置已经有值了，而table2对应的地方还是空的<br/><br/>
然后单步，当执行了：<br/>
C:0x0992      1208D0     LCALL      C?COPY(C:08D0)<br/>
的时候，可以看到，table2对应的地方就有值了。<br/><br/>
嗯，顺带提一句，免得下回我也忘了，就是查内存。<br/>
view -&gt; memory window<br/>
在地址框填写：  <br/>
C:0000     ;查看     CODE     区  <br/>
D:0000     ;查看     DATA     区  <br/>
I:0000    ;查看     IDATA     区  <br/>
X:0000     ;查看     XDATA     区<br/>
这里我们查看的是DATA区<br/><br/>
从C?COPY这个名字，也就能想到他的功能了。<br/><br/>
那么我们的数据其实还是放在ROM里面，运行时copy到RAM里的。<br/>
从我们开始的main函数的代码往下拉<br/><br/>
C:0x09B2      06         INC        @R0<br/>
C:0x09B3      07         INC        @R1<br/>
C:0x09B4      08         INC        R0<br/>
C:0x09B5      09         INC        R1<br/>
C:0x09B6      0A         INC        R2<br/><br/>
这一串看起来就很熟悉了。。不用看后面的指令，实际上就是我们的6,7,8,9,10<br/><br/>
然后回去改一下，比如7,7,7,7,7。。可以看到这里跟着改了，那就没错了。<br/><br/>
不过在调用COPY前，有一大堆东西看起来很迥异，<br/>
也不用急。。比如，现在让我写一个COPY函数，应该怎么写呢？<br/><br/><font color="#ff6600">显然，你要告诉我的COPY函数，从哪开始COPY，要COPY多少字节，等等。</font><br/><br/>
在PC上，一般是push XXX 来传递，这里没有，可见一定是通过前面的寄存器来传递的。<br/><br/><font color="#ff6600">比较容易看到R2R1，组合成的16位地址刚好是我们刚才找到的<br/>
ROM里面存放6,7,8,9,10的地方。<br/><br/>
R7里面的值（5）正好是数据的个数。</font><br/><br/>
不过这是猜测，那么就验证他。<br/>
我们不用跟进COPY函数，那样太麻烦，看得比较不爽。<br/><br/>
直接改数组就行了，比如增加数据个数，看到R7对应增长。<br/><br/>
然后增加代码数量，看到R2R1始终是数据位置的地址。<br/><br/>
至于其他几个寄存器呢？因为我改的过程中没有发现变化，<br/>
所以也不知道有什么用，<br/><br/>
而且这东西在网上搜老半天也没看谁说。。。<br/>
看来大家都不屑于研究这些东西，呵呵。<br/><br/>
下次研究一下全局变量的初始化。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/03/01/KEILC%E7%BC%96%E8%AF%91%E7%9A%84TRICK%E6%8E%A2%E7%A9%B62%EF%BC%88int%E7%B1%BB%E5%9E%8B%EF%BC%89/">KEIL C 编译的TRICK探究2（int类型）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-03-01T21:51:00+08:00" pubdate data-updated="true">Mar 1<span>st</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.3.1<br/><br/>
这也是值得探讨的一个地方。<br/>
因为51机是8位的，但我们用C写的时候又经常用到16-bit int。<br/>
那么编译器肯定有某种实现吧！<br/><br/>
我们用下面的代码：<br/>
      int va,vb,vc ;<br/>
      va = 0x1101;<br/>
      vb = 0x2202 ;<br/>
      vc = va + vb ;<br/>
      while (1) ;<br/><br/>
为什么要选这两个数字，后面再说<br/><br/>
C:0x0800      7401       MOV        A,#0x01<br/>
C:0x0802      2402       ADD        A,#0x02<br/>
C:0x0804      F509       MOV        0x09,A<br/><br/>
C:0x0806      7411       MOV        A,#0x11<br/>
C:0x0808      3422       ADDC       A,#0x22<br/>
C:0x080A      F508       MOV        0x08,A<br/><br/>
这个0x08就是vc的高位存放的地址<br/>
0x09就是vc的低位存放的地址<br/><br/>
这就有趣了，跟我们常用的PC平台不一样。这里居然是大尾顺序。<br/>
不过也不能这么说，因为51本来就是8位运算。且存储单元习惯上按字节来分。<br/>
所有的运算指令也是8位操作。所以，平台本身并没有关于某尾的特征。<br/>
这种实现只是我用的编译器的行为而已。<br/>
我们完全可以仿照实现小尾顺序。<br/><br/>
再说前面的加法，上面半截就是算低地址。<br/>
因为可能有进位，所有下面半截按照带进位加法运算。<br/><br/>
这样就完成了16-bit int 的操作了。<br/>
仿照这种思想，可以实现更多位数的，比如32-bit,64-bit int，<br/>
硬件上的进位标志CY,<br/>
指令里的ADDC ，SUBB等本身就为大整数运算提供了很好支持<br/><br/>
最后来说为啥要选那两个数，主要目的就是为了好辨认。<br/>
还有保证高低位都有值，避免编译器优化到我们认不到的程度。<br/><br/>
其实这个实验里面，编译器已经进行了常数优化了。<br/>
根本就没用到va,vb的空间，直接拿常数参与运算</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/backup-hplonline/blog/page/24/">&larr; Older</a>
    
    <a href="/backup-hplonline/blog/archives">Blog Archives</a>
    
    <a class="next" href="/backup-hplonline/blog/page/22/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/backup-hplonline/blog/2013/05/04/test/">Test</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/04/09/%E5%86%8D%E8%B0%88stl%E7%9A%84rotate/">再谈stl的rotate</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%BA%8C%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、二）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%89%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、三）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%80%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、一）</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - hplonline -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
