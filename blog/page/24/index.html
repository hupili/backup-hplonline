
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>hplonline</title>
  <meta name="author" content="hplonline">

  
  <meta name="description" content="(hplonline)2009.3.1
之前写的时候，用的都是C在写，感觉很顺手。。
这几天看的是一个汇编的实验指导。。所以全部用的汇编。。
这下问题就来了。。C51汇编的指令很少啊。有些东西就不知道是怎么实现的了。
比如INTEL X86里面可以
cmp eax , ebx
jg XXX &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hupili.github.io/backup-hplonline/blog/page/24">
  <link href="/backup-hplonline/favicon.png" rel="icon">
  <link href="/backup-hplonline/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/backup-hplonline/atom.xml" rel="alternate" title="hplonline" type="application/atom+xml">
  <script src="/backup-hplonline/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/backup-hplonline/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/backup-hplonline/">hplonline</a></h1>
  
    <h2>backup from 2006 to 2012 (original hi.baidu.com/hplonline/)</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/backup-hplonline/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hupili.github.io/backup-hplonline" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/backup-hplonline/">Blog</a></li>
  <li><a href="/backup-hplonline/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/03/01/KEILC%E7%BC%96%E8%AF%91%E7%9A%84TRICK%E6%8E%A2%E7%A9%B61%EF%BC%88%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%EF%BC%89/">KEIL C 编译的TRICK探究1（条件跳转）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-03-01T15:58:00+08:00" pubdate data-updated="true">Mar 1<span>st</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.3.1<br/><br/>
之前写的时候，用的都是C在写，感觉很顺手。。<br/><br/>
这几天看的是一个汇编的实验指导。。所以全部用的汇编。。<br/><br/>
这下问题就来了。。C51汇编的指令很少啊。有些东西就不知道是怎么实现的了。<br/><br/>
比如INTEL X86里面可以<br/>
cmp eax , ebx<br/>
jg XXX<br/>
来实现大于跳转<br/><br/>
而翻完了C51的指令集，也没发现类似jg的东西。。<br/><br/>
只有cjne a , b , c这个，当a不等于b的时候跳到c。<br/><br/>
所以比较好奇，看下KEIL是怎样办到的。<br/><br/><font color="#0000ff">一。实验代码</font><br/>
      uchar vc;<br/>
      uchar va , vb;<br/>
      va = 2  ;<br/>
      vb = 8 ; <br/>
      if ( va &gt; vb ) vc = va;<br/>
      else vc = vb ;<br/>
      while (1);<br/><br/><font color="#0000ff">二。直接在KEIL里面看反汇编</font><br/><br/>
C:0x0800      7E02       MOV        R6,#0x02<br/>
       9:           vb = 8 ;  <br/>
C:0x0802      7D08       MOV        R5,#0x08<br/>
      10:           if ( va &gt; vb ) vc = va; <br/>
C:0x0804      EE         MOV        A,R6<br/>
C:0x0805      D3         SETB       C<br/>
C:0x0806      9D         SUBB       A,R5<br/>
C:0x0807      4004       JC         C:080D<br/>
C:0x0809      7F02       MOV        R7,#0x02<br/>
C:0x080B      8002       SJMP       C:080F<br/>
      11:           else vc = vb ; <br/>
C:0x080D      AF05       MOV        R7,0x05<br/>
      12:           while (1); <br/>
C:0x080F      80FE       SJMP       C:080F<br/><br/>
这一点，我觉得KEIL做得不错，看起来很方便，源码与汇编对照。<br/><br/>
首先，通过几个赋值，知道在这里用的是寄存器变量<br/>
R6&lt;-&gt;va<br/>
R5&lt;-&gt;vb<br/>
R7&lt;-&gt;vc<br/><br/>
然后找到比较的核心：<br/>
C:0x0804      EE         MOV        A,R6<br/>
C:0x0805      D3         SETB       C<br/>
C:0x0806      9D         SUBB       A,R5<br/>
C:0x0807      4004       JC         C:080D<br/><br/>
这里就是编译器的TRICK了，你看没有用jg,jng之类，但是实现了这种功能<br/><br/>
其实前三句等于做了这样的一个运算<br/>
A = va - vb - 1<br/><br/>
如果va &gt; vb ， 那么将没有借位 <br/>
相反va &lt;= vb  ， 那么减的时候将设置借位，然后再根据情况跳转就行了。<br/><br/>
实际上，我么86汇编里面丰富的条件跳转也是靠判断这些标志位来的，<br/>
只不过硬件实现了，我们用起来很方便。<br/><br/>
如果把代码的 va &gt; vb改成 va &gt;= vb 呢<br/>
可以看到<br/>
C:0x0805      D3         SETB       C<br/>
被改成了<br/>
C:0x0805      D3        CLR       C<br/><br/>
相当于 A = va - vb<br/><br/>
到这里，条件跳转的问题基本就解决了。。<br/><br/>
顺便记一个事情。。就是51汇编里面只有SUBB，没有不带借位的减法。。<br/>
这个不知道是谁设计的，好囧。。。<br/><br/><font color="#ff6600">研究底层的东西并不表示我们一定要去用它，<br/>
至少让我们对编译器的作者产生感激之情吧。</font></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/03/01/%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98%E5%92%8C%E6%95%B0%E7%A0%81%E7%AE%A1/">矩阵键盘和数码管</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-03-01T15:21:00+08:00" pubdate data-updated="true">Mar 1<span>st</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div forimg="1">(hplonline)2009.3.1<br/><br/>
练习矩阵键盘，然后从数码管显示出来，<br/>
为了从简，就2*2的了。。<br/>
从上到下，从左到右的键，编为1..4号。<br/><br/><br/><font color="#0000ff">一。电路</font><br/><br/><a href="http://hiphotos.baidu.com/hplonline/pic/item/c3f104f4113e174edcc47491.jpg" target="_blank">
<div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/c3f104f4113e174edcc47491.jpg" small="0" class="blogimg"/></div>
<br/></a></div>


<p>我觉得我的形象思维有问题。。<br/>
想了老半天，才把键盘画成这样。。开始一直是看上去一团糟。。<br/>
先按照有个加正电源的方法做了没做出来，然后改成了这种。<br/><br/>
简要的说就是，把含扫描和列扫描线引出排成矩形。之间并不相交。<br/>
每个行扫描线和每个列扫描线之间均通过一个按钮连通。<br/><br/>
这样，扫描按键的时候，<br/>
对行线赋1，列线赋0，再读取行线，<br/>
如果某一行有按键按下，那该行为0.。<br/>
相反，对列线赋1，行线赋0，再读取列线，<br/>
如果某一列有键按下，那该列为0.。<br/>
这样就能定位按下的键了。<br/><br/><br/><font color="#0000ff">二。程序</font><br/><br/>
org 00h<br/>
ljmp func_main<br/><br/>
org 30h<br/>
func_main:<br/>
     <br/>
     mov R2 , #0<br/>
     acall func_getkey<br/>
     cjne R2 , #0 , <em>show<br/>
     sjmp func_main<br/>
     </em>show:<br/>
     acall func_show<br/>
     sjmp func_main<br/><br/>
sjmp $<br/><br/>
func_show:<br/>
     cjne R0 , #1h , <em>nop<br/>
     mov R0 , #0 <br/>
     </em>nop:<br/>
     mov A , R0<br/>
     add A , R1<br/>
     mov DPTR , #table<br/>
     movc A , @A+DPTR<br/>
     mov P0 , A<br/><br/>
ret<br/><br/>
func_getkey:<br/>
     mov P1 , #03h<br/>
     mov R0 , P1<br/>
     cjne R0 , #03h , <em>keypressed<br/>
     sjmp </em>end<br/>
     <em>keypressed:<br/>
     mov A , R0<br/>
     xrl A , #03h<br/>
     mov R0 , A<br/>
     mov R2 , #1<br/>
     mov P1 , #0ch<br/>
     mov A , P1<br/>
     rr A<br/>
     rr A<br/>
     mov R1 , A<br/>
     </em>end:<br/>
ret<br/><br/>
table: db 0 , 110b , 1011011b , 1001111b , 1100110b<br/><br/>
end<br/><br/>
这个，我觉得我的抽象思维有点问题。。写了很久。。才把这个简单的问题写通顺。<br/><br/>
main:<br/>
R2用来表示是否有键按下。有 键按下，才重新显示数字。<br/><br/>
show:<br/>
查询table表，以获得字形码。我这个共阴的数码管。<br/><br/>
getkey:<br/>
就是重复原理中叙述的话而已。。。可能有点废话。。<br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/02/28/%E6%8C%89%E9%92%AE%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E3%80%81%E7%BF%BB%E8%BD%AC%E7%81%AF/">按钮、外部中断、翻转灯</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-02-28T18:12:00+08:00" pubdate data-updated="true">Feb 28<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.2.28<br/><br/>
用四个按钮来控制，按一下，翻转相应的灯<br/><br/><font color="#0000ff">一。电路</font><br/><br/><div forimg="1"><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/2bc327f538493605bd3109a6.jpg"/><br/>
右边为了方便用了总线。<br/>
相当于电源过电阻后接到P1的上面四个口。<br/>
该四口分别过按钮到地。<br/>
这样，常态下，该四口为高电平，按下后为低。<br/>
该四口再“与”到一起，接到INT0上面。<br/>
这样，按下按键后就有中断送入了。<br/><br/><font color="#0000ff">二。程序</font><br/><br/>
org 00h<br/>
ljmp func_main<br/>
org 03h<br/>
ljmp func_xint0<br/><br/>
org 30h<br/>
func_main:<br/><br/>
        setb EA<br/>
        setb EX0<br/><br/>
sjmp $<br/><br/>
func_xint0:<br/>
push PSW<br/><br/>
        jnb P1.7 , <em>l7<br/>
        jnb P1.6 , </em>l6<br/>
        jnb P1.5 , <em>l5<br/>
        jnb P1.4 , </em>l4<br/><br/>
        <em>l7:<br/>
        cpl P0.7<br/>
        sjmp </em>end<br/>
        <em>l6:<br/>
        cpl P0.6<br/>
        sjmp </em>end<br/>
        <em>l5:<br/>
        cpl P0.5  <br/>
        sjmp </em>end<br/>
        <em>l4:<br/>
        cpl P0.4<br/>
        </em>end:<br/>
        acall func_delay<br/>
pop PSW<br/>
reti<br/><br/>
func_delay:<br/>
        mov R5,#10<br/>
        D3:<br/>
        mov R7,#50<br/>
        D1:<br/>
        MOV R6,#200<br/>
        D2:<br/>
        djnz R6,D2<br/>
        djnz R7,D1<br/>
        djnz R5,D3<br/>
ret<br/><br/>
end<br/><br/>
主函数开启中断后就进入死循环了，实际上可以做其他的事情。<br/><br/>
中断处理中，分别判断是哪个键按下了，然后翻转对应的灯。<br/><br/>
中断的最后延迟一段，防止按键抖动。。<br/><br/>
话说。。当时把jnb打成jb了。。查了老半天。。</div></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/02/28/%E4%B8%B2%E8%A1%8C%E6%8E%A7%E5%88%B6%E6%B5%81%E6%B0%B4%E7%81%AF/">串行控制流水灯</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-02-28T15:51:00+08:00" pubdate data-updated="true">Feb 28<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.2.28<br/><br/>
好吧。。又是灯。。因为这个玩起来简洁啊。。这一盘我是来练串口的。。<br/><br/><font color="#0000ff">一。电路图：</font><br/><div forimg="1"><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/2571093bc30b64ca14cecbad.jpg"/><br/><br/>
在串行工作0方式下<br/>
用TXD输出时间信号<br/>
用RXD输出数据<br/>
所以这么接嘛。。</div></p>

<br/><font color="#0000ff">二。代码</font><br/><br/>


<p>org 00h<br/>
ljmp main<br/><br/>
org 30h<br/>
main:<br/><br/>
      mov SCON , #00h<br/>
      mov A , #1h<br/>
      out:<br/>
      mov SBUF , A<br/>
      wait:<br/>
      jnb TI , wait<br/>
      clr TI<br/>
      acall delay<br/>
      rl A<br/>
      sjmp out <br/><br/>
sjmp $<br/><br/>
delay:<br/>
mov R5,#10<br/>
D3:<br/>
mov R7,#100<br/>
D1:<br/>
MOV R6,#200<br/>
D2:<br/>
djnz R6,D2<br/>
djnz R7,D1<br/>
djnz R5,D3<br/>
ret<br/><br/>
end<br/><br/>
嗯，delay和前两个一样的了。。连我都觉得有点熟悉了。。<br/><br/>
mov SCON , #00h<br/>
选择好工作模式0，具体SCON的每位的含义网上也多<br/><br/>
下面就是用A来做循环移位，然后把每次的8位输出就行了<br/>
      out:<br/>
      mov SBUF , A<br/>
。。。<br/>
      rl A<br/>
      sjmp out <br/><br/>
输出了之后，一直忙等待TI，置位表示输出完毕，所以<br/>
      wait:<br/>
      jnb TI , wait<br/><br/>
最后清除TI，供下次使用，并调用延迟，使灯流动可见<br/>
      clr TI<br/>
      acall delay<br/><br/>
嗯。。就是这样。。练个串口而已。。<br/><br/><font color="#ff6600">之所以是汇编。。因为更能看清楚一些东西。。</font></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/02/27/%E5%AE%9A%E6%97%B6%E4%B8%AD%E6%96%AD%E9%97%AA%E7%83%81%E7%81%AF/">定时中断闪烁灯</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-02-27T22:49:00+08:00" pubdate data-updated="true">Feb 27<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div forimg="1">(hplonline)2009.2.27<br/><br/>
电路图依然简单，因为这个练习的目标是定时中断<br/><br/><br/><a href="http://hiphotos.baidu.com/hplonline/pic/item/40e5d3f94f81c679242df2d2.jpg" target="_blank">
<div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/40e5d3f94f81c679242df2d2.jpg" small="0" class="blogimg"/></div>
<br/></a></div>


<p><font color="#0000ff">代码：</font><br/><br/>
v_th EQU 0d8h<br/>
v_tl EQU 0efh<br/>
count EQU 100;100<br/>
v_tmod EQU 1h<br/><br/>
org 00h<br/>
ljmp main<br/>
org 0bh<br/>
ljmp timer0<br/><br/>
org 30h<br/>
main:<br/>
     mov R0 , #0<br/>
     mov P1 , #0<br/>
     mov TH0 , #v_th<br/>
     mov TL0 , #v_tl<br/>
     mov TMOD , #v_tmod         <br/>
     setb EA<br/>
     setb ET0<br/>
     setb TR0<br/><br/>
sjmp $<br/><br/>
timer0:<br/>
push PSW<br/><br/>
     mov TH0 , #v_th<br/>
     mov TL0 , #v_tl<br/>
     inc R0<br/>
     cjne R0 , #count , next<br/>
     mov R0 , #0<br/>
     cpl P1.0<br/>
     next:<br/>
          <br/>
pop PSW<br/>
reti<br/><br/>
end<br/><br/>
程序结构比较清楚<br/><br/>
v_th EQU 0d8h<br/>
v_tl EQU 0efh<br/>
这两个指定计时次数10000<br/>
count EQU 100;100<br/>
这个指定软计数次数100算下来也就是10<sup>6*1/(10<sup>6)</sup></sup> = 1秒一闪<br/>
v_tmod EQU 1h<br/>
这个指定的是工作模式，0号计时器用1号模式，16位计数<br/><br/><font color="#0000ff">总框架是这样的：</font><br/><br/>
org 00h<br/>
ljmp main<br/>
;跳至主函数<br/>
org 0bh<br/>
ljmp timer0<br/>
;跳至0号计时器的中断处理<br/>
org 30h<br/>
main:<br/>
;这里是主函数内容<br/>
sjmp $<br/><br/>
timer0:<br/>
push PSW<br/>
;保护一些现场<br/>
;&#8230;中断处理<br/>
;恢复一些现场<br/>
pop PSW<br/>
reti<br/><br/>
end<br/><br/>
好 ，然后是主函数，先个P1赋值开灯，然后给R0赋初值，<br/>
R0是后面软计数用到的计数器。<br/><br/>
接下来设置工作模式，和T0的计时初值。<br/><br/>
最后三个setb，依次是总中断开关，0号计时器允许开关，0号计时器计时开关<br/><br/>
中断处理，每次增加R0，然后比较是否到了软计数次数，<br/>
到了就令软计数器R0回0，然后翻转P1.0，实现灯的闪烁。。<br/><br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/02/26/%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%9A%E7%94%A8%E8%8A%B1%E5%BC%8F%E6%B5%81%E6%B0%B4%E7%81%AF/">简单的通用花式流水灯</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-02-26T19:18:00+08:00" pubdate data-updated="true">Feb 26<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div forimg="1">(hplonline)2009.2.26<br/><br/>
虽然是汇编，但是实现得简单，用查表法，可以实现花式显示。<br/>
主要目的是练一下KEIL下的汇编。。<br/><br/><br/>
一。电路<br/><br/>
就这个样子。。好像没啥说的。。旁边那个发光管是因为才用proteus，为了验证确实可以这样点亮放的。。再旁边的一排按键暂时还没用到。<br/><br/><img height="423" width="589" border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/a35ddaa2caf1ab8dcaefd074.jpg" small="0" class="blogimg"/><br/><br/>
二。代码<br/><br/>
org 00h <br/><br/>
mov R0 , #0 <br/>
mov R1 , #count<br/><br/>
main:<br/>
mov A , r0<br/>
mov DPTR , #table <br/>
movc A , @A + DPTR <br/>
mov P1 , A<br/>
call delay<br/>
inc R0<br/>
djnz R1 , main<br/><br/>
mov R0 , #0 <br/>
mov R1 , #count <br/><br/>
ljmp main<br/><br/>
ljmp $<br/><br/>
delay:<br/>
mov R5,#10<br/>
D3:<br/>
mov R7,#100<br/>
D1:<br/>
MOV R6,#200<br/>
D2:<br/>
djnz R6,D2<br/>
djnz R7,D1<br/>
djnz R5,D3<br/>
ret<br/><br/>
table: db 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128  ,0ffh , 00h , 0f0h , 0fh<br/>
count EQU $ - table<br/><br/>
END 　　<br/><br/>
首先，在最后有个table，指示的是灯的显示掩码。<br/>
程序运行开始就查这个表，然后依次按样式显示。<br/>
表长是可以任意更改的，<br/>
因为最后是用count这个编译期常量来指定的，所以加入任意的式样掩码就可以了。<br/><br/>
delay:到ret之间就是一般的延时程序，没啥好说的。<br/>
之所以用了三层，是为了所需时间的伸缩性考虑。<br/><br/>
ljmp $这个就是典型的死循环，就是while(1)的意思，在这个程序里面执行不到这里。<br/>
纯粹是作为习惯打在这个地方的，这样，在指定操作完后，死循环，<br/>
避免程序一直执行到底后复位。<br/><br/>
然后是最前面的部分。<br/><br/>
这里用R1来做循环计数，所以有初值#count</div>


<p>这里又丑陋了一次，不小心写成count了（意思为立即寻址。。）<br/><br/>
R0来做table的下标指示，从0开始递增<br/><br/>
mov DPTR , #table 这条貌似是51里面唯一一条16位指令。<br/>
把地址送到DPTR里面去。<br/>
注意如果#table写成了talbe就戳了。。直接编译错误，<br/>
因为把table的值（在ROM里的位置)按照直接寻址来操作，<br/>
都超过可直接寻址的范围了。<br/><br/>
movc A , @A + DPTR  ， 这条的写法很固定。。。<br/>
相当于查table表，把掩码送到A里面，<br/>
注意是MOVC就是了，MOVC这条指令专门用来查ROM里面的值。<br/><br/>
嗯，顺便，与片外RAM传递要用MOVX<br/><br/>
三。花样<br/><br/>
table: db 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128  ,0ffh , 00h , 0f0h , 0fh<br/><br/>
就改这个表就OK 了。。所以说简单。。<br/><br/>
比方说：<br/>
table: db 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128<br/>
按照我这个电路跑出来就是一个一个地依次灭掉<br/><br/>
table: db 0ffh , 00h , 0f0h , 0fh<br/>
这个跑出来就是全灭，全开，下一半开，上一半开<br/><br/>
。。想怎么改就怎么改。。<br/><br/><br/><br/>
其实我就是拿来练汇编的。。所以实现的功能戳一点。。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/02/19/MAP%E6%96%87%E4%BB%B6%E5%92%8C%E8%B0%83%E8%AF%95%EF%BC%88VC%29%28%E4%BB%8E%E5%B4%A9%E6%BA%83%E5%9C%B0%E5%9D%80%E6%89%BE%E5%87%BA%E9%94%99%E6%BA%90%E7%A0%81%E4%BD%8D%E7%BD%AE%29/">MAP文件和调试（VC)(从崩溃地址找出错源码位置)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-02-19T21:55:00+08:00" pubdate data-updated="true">Feb 19<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>也是：一直听说，从未动手。<br/><br/>
所以，用VC生成一下MAP文件，帮助调试。<br/><font color="#0000ff"><br/></font><font color="#0000ff">一.步骤:</font><br/><br/><span style="font-size: 12pt; ">Project Settings</span><span style="font-size: 12pt; ">-&gt;</span></p>

<p> <span style="font-size: 12pt; ">C/C++-&gt;</span></p>

<p> <span style="font-size: 12pt; ">Project Options</span>:<br/>
这里输入</p>

<p> <span style="font-size: 12pt; ">/Zd</span>，将在编译时生成行信息。<br/><br/><span style="font-size: 12pt; ">Project Settings</span><span style="font-size: 12pt; ">-&gt;Link-&gt;</span></p>

<p> <span style="font-size: 12pt; ">Project Options</span>:<span style="font-size: 12pt; "><br/>
/mapinfo:lines</span><br/><span style="font-size: 12pt; ">/map:<font color="#333399">MapFileName</font>.map</span><br/><span style="font-size: 12pt; ">/mapinfo:exports</span><br/><br/><span style="font-size: 12pt; ">MapFileName是生成MAP文件的名字<br/>
第一个是生成行信息，第三个是加入导出信息。<br/><br/>
这样就设置好了,编译出来的就有MAP文件了.<br/><br/><font color="#0000ff">二.MAP文件:</font><br/>
写一个程序,编译出来:<br/><br/></p>

<h1>include &lt;stdio.h&gt;<br/><br/></h1>

<p>int main(){<br/>
     int i = 2;<br/>
     int j ;<br/>
     scanf(&#8220;%d&#8221;,&amp;j);<br/>
     i = 2;<br/>
     i = 3;<br/>
     i = 4;<br/>
     i = 5;<br/>
     i = 6;<br/>
     printf(&#8220;%d&#8221;,i/j);<br/>
     return 0 ;<br/>
}<br/><br/>
然后打开MAP文件.<br/>
里面有各种全局符号,大概在文件的中间位置,有这样的东西:<br/>
Line numbers for .\Debug\4.obj(E:\pro\4\4.cpp) segment .text<br/><br/>
      3 0001:00000010      4 0001:00000024      6 0001:0000002b      7 0001:0000003c<br/>
      8 0001:00000043      9 0001:0000004a     10 0001:00000051     11 0001:00000058<br/><br/>
可以直接Ctrl+F找到程序文件名，我这里是4.cpp<br/>
这些就是代码偏移和对应的行号.<br/><br/><font color="#0000ff">三.调试</font><br/><br/>
就刚才的程序，运行，输个0，过一下出错框就来了，<br/>
我是VISTA，下面的详细信息是：<br/>
问题签名:<br/>
  问题事件名称:     APPCRASH<br/>
  应用程序名:     4.exe<br/>
  应用程序版本:     0.0.0.0<br/>
  应用程序时间戳:     499d5ade<br/>
  故障模块名称:     4.exe<br/>
  故障模块版本:     0.0.0.0<br/>
  故障模块时间戳:     499d5ade<br/>
  异常代码:     c0000094<br/><font color="#ff0000">异常偏移量:     00001063</font><br/>
  OS 版本:     6.0.6001.2.1.0.768.3<br/>
  区域设置 ID:     2052<br/>
  其他信息 1:     38fc<br/>
  其他信息 2:     db4f9c1c160faa4608f429ddffa01d6f<br/>
  其他信息 3:     cb3b<br/>
  其他信息 4:     e8ffb2a21d4a9ed7b258f1866c9d3db8<br/><br/>
这个偏移就是要看的了。减去1000的代码段偏移。<br/>
就是63，再对照上面的行号和地址的列表<br/></span><span style="font-size: 12pt; ">11 0001:00000058<br/>
这个是VC翻译的时候，第11行显然会对应多条指令。<br/>
这一指令群的开始地址是58.<br/>
这个是最接近63且比63小的地址，所以问题应该出在这一行上。<br/>
再看代码：<br/></span><span style="font-size: 12pt; ">printf(&#8220;%d&#8221;,i/j);<br/>
发现这里有个除0错误。<br/><br/>
OK，记到这里，以后用到了来翻<br/></span></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/02/18/ASM%E5%81%9A%E6%A0%87%E5%87%86%E5%BA%93%EF%BC%8CC%E8%B0%83%E7%94%A8%E3%80%90%E5%B0%9D%E9%B2%9C%E5%AE%9E%E9%AA%8C%EF%BC%8C%E6%97%A0%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E3%80%91/">ASM做标准库，C调用【尝鲜实验，无技术含量】</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-02-18T21:10:00+08:00" pubdate data-updated="true">Feb 18<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline) 2009.2.14<br/><br/>
理由，在<font color="#ff0000">效率</font>比较关键的地方，可以选择用汇编来实现，这没啥好说的，<br/>
所以先试一下这个功能，至少知道有这么一回事。<br/><br/><font color="#0000ff">一.环境：</font><br/><br/>
VC6:怎么说也很老了，不过经典，用起将就<br/><br/>
MASMPlus:有Plus字样的自然是多两把刷子，不然怎么能叫Plus呢，对吧<br/>
屏蔽了很多编译链接方面繁琐的操作,并且编辑环境也不错,就用他了<br/><br/><font color="#0000ff">二.练习内容：</font><br/>
1.实现简单地给文件异或加密，<br/>
2.当然是试ASM做标准库，然后C来调用<br/>
3.顺便练习一下C++的文件流，想自己以前老是fprintf地。。很土的样子<br/><br/><font color="#0000ff">三.动手：</font><br/><br/>
1.先来做C这边事情，个人习惯是一桩一桩地做好。所以先不管ASM，直接做一个整的程序<br/><br/></p>

<h1>include &lt;iostream&gt;<br/></h1>

<h1>include &lt;fstream&gt;<br/><br/></h1>

<p>using namespace std;<br/><br/>
const int BUFFERSIZE = 1024 ; <br/><br/>
char buffer[BUFFERSIZE];<br/>
int count ; <br/><br/><font color="#999999">void encode(char <em>buf , int size , unsigned char code){<br/>
     int i;<br/>
     for ( i = 0 ; i &lt; size ; i ++ )buf[i] ^= code ;<br/>
}</font><br/><br/>
int main(int argv , char </em>args[]){<br/>
     int code ; <br/><br/>
     if ( argv != 3 ){<br/>
          cout&lt;&lt;&#8221;parameter wrong!&#8221;&lt;&lt;endl; <br/>
          cout&lt;&lt;&#8221;usage: coder infile outfile&#8221;&lt;&lt;endl;<br/>
          return 1 ; <br/>
     }<br/><br/>
     ifstream infile(args[1] , ios::binary);<br/>
     ofstream outfile(args[2] , ios::binary);<br/>
     <br/>
     cout&lt;&lt;&#8221;input your code[0..255]&#8221;&lt;&lt;endl;<br/>
     cin&gt;&gt;code;<br/>
     if ( code &lt; 0 || code &gt; 255 ){<br/>
          cout&lt;&lt;&#8221;code range error!!&#8221;&lt;&lt;endl;<br/>
          return 2 ;<br/>
     }<br/><br/>
     cout&lt;&lt;&#8221;encoding from &#8220;&lt;&lt;args[1]&lt;&lt;&#8221; to &#8220;&lt;&lt;args[2]&lt;&lt;endl;<br/><br/>
     while ( !infile.eof() ){<br/>
          infile.read(buffer , BUFFERSIZE );<br/>
          count = infile.gcount() ; <br/>
          encode(buffer,count, ( unsigned char )code);<br/>
          outfile.write(buffer , count );<br/>
     }<br/><br/>
     return 0 ;<br/>
}<br/><br/>
这个程序是要从命令行输入加密文件名的，<br/>
为了调试方便<br/>
project-&gt;settings-&gt;debug-&gt;programme arguments<br/>
这里可以设置参数<br/>
比如我写成：1.txt 2.txt<br/>
然后在工程目录下建个1.txt,随便写点东西，就可以运行了，<br/>
输入用来异或的CODE,生成加密后的2.txt<br/><br/>
其实从功能上来说，这样就很好了，不过我这里要练习用ASM做标准库，<br/>
所以把 encode函数给注释掉，换成外部的申明<br/><font color="#ff6600"><br/></p>

<h1>pragma comment(lib,&#8221;encode.Lib&#8221;)<br/></h1>

<p>extern &#8220;C&#8221; void encode(char <em>buf , int size , unsigned char code) ;</font><br/><br/>
其实比较重要的也就是这里<br/><font color="#ff6600">extern &#8220;C&#8221;</font> 一方面是把encode函数申明成外部过程，<br/>
还有就是指定了是C调用约定，因为用C++约定的话。。<br/>
函数名字会被改造成比较复杂的样子，不方便，而在MASM中又没有指定C++约定的项。<br/><br/><font color="#ff6600">#pragma comment(lib,&#8221;encode.Lib&#8221;)       <br/><font color="#000000">这个也是关键地方，意思就是添加encode.lib这个库<br/>
也可以不要这句，而在下面的位置<br/></font></font>project-&gt;settings-&gt;link-&gt;object / library modules<br/>
手动写上encode.lib<br/><br/>
这样C这边就OK了，只等我们把encode 这个库做好，放到工程目录下面，就可以组建了。<br/><br/>
2.MASM<br/><br/>
MASMPlus的方便性很快就体现出来了，直接新建工程，选标准库<br/>
然后选好位置，框架就生成好了。<br/><br/>
不过我们用不了那么臃肿的东西，代码全部删了。<br/>
下面就够了：<br/>
.386<br/><font color="#ff6600">.model flat, C</font><br/>
option casemap :none <br/><br/>
.CODE<br/><br/>
encode proc C uses ecx esi eax ,  lpBuffer:DWORD , lSize:DWORD , ucCode:BYTE<br/>
     mov esi , lpBuffer<br/>
     mov ecx , lSize<br/>
     mov al , ucCode<br/>
     <em>l:<br/>
     xor BYTE PTR[esi] , al<br/>
     inc esi <br/>
     loop </em>l<br/>
     ret<br/>
encode endp<br/><br/>
END<br/><br/>
第二句比较关键，指定C调用约定，这样才好跟我们在VC中编的程序接口<br/>
而函数本身也没啥说的，从C的代码很容易就翻译过来了。<br/><br/>
于是组建这个工程，生成了</em>.lib文件。<br/>
改名encode.lib，复制到开始VC的工程目录下。就可以运行了。<br/><br/><br/>
于是就做完了。。纯粹是因为之前没这样搞过 ，觉得新鲜而已。。<br/>
好吧，下次我们用C编写库，让MASM来调用。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/02/17/%E4%BC%98%E5%85%88%E7%BA%A7%E5%95%8A%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%88C%EF%BC%89/">优先级啊优先级（C）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-02-17T16:34:00+08:00" pubdate data-updated="true">Feb 17<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.1.31</p>


<p>起因那是非常的朴素，实现一个不用条件等语句返回较大数的函数</p>


<p>int max (int a,int b)</p>


<p> </p>


<p>于是就写了个</p>


<p>int max (int a,int b){<br/>
     return ~( ( a - b ) &gt;&gt; 31 ) &amp; ( a - b ) + b ;<br/>
}</p>


<p> </p>


<p>其实是错的。。。</p>


<p>但是我觉得这想法是对的，然后来了个臃肿的：</p>


<p> </p>


<p>int max (int a,int b){<br/>
     int c = ( a - b ) &gt;&gt; 31 ;<br/>
     c = ~c ;<br/>
     c &amp;= a - b ;<br/>
     c += b ; <br/>
     return c;<br/>
}</p>


<p> </p>


<p>发现这个正常了。。。</p>


<p> </p>


<p>一对比两个的汇编代码。。发现对第一种写法居然编译器“偷工减料”了很多。。。</p>


<p>放到下面，其实不用研究他们。。</p>


<p>1.&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;<br/>
     return    ( ~( ( a - b ) &gt;&gt; 31 ) ) &amp; ( a - b ) + b ;<br/><br/>
00401578  |.  8B45 08        mov      eax, dword ptr [ebp+8]<br/>
0040157B  |.  2B45 0C        sub      eax, dword ptr [ebp+C]<br/>
0040157E  |.  C1F8 1F        sar      eax, 1F<br/>
00401581  |.  F7D0           not      eax<br/>
00401583  |.  8B4D 08        mov      ecx, dword ptr [ebp+8]<br/>
00401586  |.  23C1           and      eax, ecx<br/><br/><br/>
2.&#8212;&#8212;&#8212;&#8212;&#8211;<br/>
     int c = ( a - b ) &gt;&gt; 31 ;<br/>
     c = ~c ;<br/>
     c &amp;= a - b ;<br/>
     c += b ; <br/>
     return    c;<br/><br/>
00401578  |.  8B45 08        mov      eax, dword ptr [ebp+8]<br/>
0040157B  |.  2B45 0C        sub      eax, dword ptr [ebp+C]<br/>
0040157E  |.  C1F8 1F        sar      eax, 1F<br/>
00401581  |.  8945 FC        mov      dword ptr [ebp-4], eax<br/>
00401584  |?  8B4D FC        mov      ecx, dword ptr [ebp-4]<br/>
00401587  |?  F7D1           not      ecx<br/>
00401589  |.  894D FC        mov      dword ptr [ebp-4], ecx<br/>
0040158C  |?  8B55 08        mov      edx, dword ptr [ebp+8]<br/>
0040158F       2B55 0C        sub      edx, dword ptr [ebp+C]<br/>
00401592       8B45 FC        mov      eax, dword ptr [ebp-4]<br/>
00401595       23C2           and      eax, edx<br/>
00401597       8945 FC        mov      dword ptr [ebp-4], eax<br/>
0040159A       8B4D FC        mov      ecx, dword ptr [ebp-4]<br/>
0040159D       034D 0C        add      ecx, dword ptr [ebp+C]<br/>
004015A0 &gt; &gt;  894D FC        mov      dword ptr [ebp-4], ecx<br/>
004015A3    .  8B45 FC        mov      eax, dword ptr [ebp-4]</p>


<p> </p>


<p>看了很久，突然想起。。<font color="#ff0000">貌似算术的优先级比位运算高那么一点</font>。。。汗</p>


<p> </p>


<p>然后这样</p>


<p> </p>


<p>int max (int a,int b){<br/>
     return <span style="color: rgb(255, 0, 0);"><span style="background-color: rgb(136, 136, 136);">(</span> </span> ~( ( a - b ) &gt;&gt; 31 ) &amp; ( a - b ) <span style="color: rgb(255, 0, 0);"><span style="background-color: rgb(136, 136, 136);">)</span> </span> + b ;<br/>
}</p>


<p> </p>


<p>就对了。。。</p>


<p> </p>


<p>其实可以这样</p>


<p> </p>


<p>int max (int a,int b){<br/>
     return <span style="background-color: rgb(136, 136, 136); color: rgb(255, 0, 0);">(</span> ~( a - b &gt;&gt; 31 ) &amp; a - b <span style="background-color: rgb(136, 136, 136); color: rgb(255, 0, 0);">)</span> + b ;<br/>
}</p>


<p> </p>


<p>可见一开始可以不用的地方用了，必须用的地方没有用。。。</p>


<p> </p>


<p>相当悲哀啊。。</p>


<p> </p>


<p>其实编译器挺厉害的，翻译得很简洁</p>


<p> </p>


<p> </p>


<p>00401578  |.  8B45 08        mov      eax, dword ptr [ebp+8]<br/>
0040157B  |.  2B45 0C        sub      eax, dword ptr [ebp+C]</p>


<p><span style="color: rgb(255, 0, 0);">eax = a - b</span> <br/>
0040157E  |.  C1F8 1F        sar      eax, 1F</p>


<p><span style="color: rgb(255, 0, 0);">eax = -1 or 0</span> <br/>
00401581  |.  F7D0           not      eax</p>


<p><span style="color: rgb(255, 0, 0);">eax = 0 or -1</span> <br/>
00401583  |.  8B4D 08        mov      ecx, dword ptr [ebp+8]<br/>
00401586  |.  2B4D 0C        sub      ecx, dword ptr [ebp+C]</p>


<p><span style="color: rgb(255, 0, 0);">ecx = a - b</span> <br/>
00401589  |.  23C1           and      eax, ecx</p>


<p><span style="color: rgb(255, 0, 0);">eax = 0 or ecx</span> <br/>
0040158B  |.  0345 0C        add      eax, dword ptr [ebp+C]</p>


<p><span style="color: rgb(255, 0, 0);">eax = b or a</span></p>


<p> </p>


<p>然后这个EAX正好带值返回了。。。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/02/15/%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%AE%E7%82%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%86%E5%BE%AE%E9%97%AE%E9%A2%98%EF%BC%88C%E6%A0%87%E5%87%86%EF%BC%9Aprintf%2Cscanf%29/">格式化输入输出浮点数据的细微问题（C标准：printf,scanf)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-02-15T15:24:00+08:00" pubdate data-updated="true">Feb 15<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.2.15<br/><br/>
刚开始学C语言的时候，看到用<font color="#ff6600">scanf</font>输入浮点数据的对应字符串如下：<br/><font color="#ff0000">float : %f<br/>
double : %lf</font><br/>
而<font color="#ff6600">printf</font>输出的时候却都是统一的：<br/><font color="#ff0000">float / double : %f</font><br/><br/>
你也许曾经跟我一样，用%lf输出过double，<br/>
结果是正常的，因为%lf直接被当作了%f了。<br/><br/>
但是这时候问题就来了，<br/><font color="#ff0000">问题1.</font>C语言也算是强类型的语言，两种不同类型怎么能统一到同一种输出上呢？<br/><font color="#ff0000">问题2.</font>既然输出都可以统一，为什么输入必须用两种不同的格式串呢?<br/><br/><font color="#ff6600">实验一：确定以上结论</font><br/>
int main(){<br/>
          double d;<br/>
          scanf(&#8220;%f&#8221;,&amp;d);<br/>
          printf(&#8220;%f\n&#8221;,d);<br/>
          scanf(&#8220;%lf&#8221;,&amp;d);<br/>
          printf(&#8220;%f\n&#8221;,d);<br/>
          return 0 ;<br/>
}<br/>
两次都输入1，<br/>
我电脑上的输出为：<br/>
-92559604281615349000000000000000000000000000000000000000000000.000000<br/>
1.000000<br/><br/>
可见用%f输入double型是不正确的，还有很多类似实验，就不一一列举了。<br/>
输入两种格式<em>输出两种格式</em>两种类型变量 = 8 组 。<br/><br/><font color="#ff6600">实验二：规范的输入输出，以及汇编分析</font><br/>
int main(){<br/>
          float f;<br/>
          double d;<br/>
          scanf(&#8220;%f&#8221;,&amp;f);<br/>
          scanf(&#8220;%lf&#8221;,&amp;d);<br/>
          printf(&#8220;%f\n&#8221;,f);<br/>
          printf(&#8220;%f\n&#8221;,d);<br/>
          return 0 ;<br/>
}<br/><br/>
这个实验的写法是符合标准的，两次输入1，能够输出正确的结果。<br/>
现在要解决的就是提出的两个问题。<br/>
我把汇编代码放在最后。这里挑关键说明一下。<br/>
截取部分就是四个函数的调用，四块大致上是长这样：<br/><font color="#0000ff">push &#8230;<br/>
push &#8230;<br/>
call &#8230;<br/>
add esp , ?</font><br/>
（关于C调用约定，查一下就清楚了）<br/>
第二个push的是格式字符串的地址，<br/>
所以我们关心的在于第一个push，那里进去的是我们的变量<br/><br/>
第一个：<br/><font color="#0000ff">lea           eax, dword ptr [ebp-4]<br/>
push          eax</font><br/>
先获取变量的有效地址，然后直接push<br/>
第二个：<br/><font color="#0000ff">lea           ecx, dword ptr [ebp-C]<br/>
push          ecx</font><br/>
除了地址外，其他和第一个一样。<br/><br/><font color="#ff0000">既然传给scanf 的都是变量的地址，我们当然就要用不同的格式字符串来区分了。</font><br/><br/>
第四个：先看第四个因为它更简单<br/><font color="#0000ff">mov          edx, dword ptr [ebp-8]<br/>
push         edx<br/>
mov          eax, dword ptr [ebp-C]<br/>
push         eax</font><br/>
ebp-C就是我们d变量的地址，<br/>
这里先让高双字[ebp - 8]入栈，<br/>
然后再是低双字[ebp - C]。<br/>
这些是由平台的字节顺序规定的，我的机器是<font color="#ff0000">小尾顺序</font>，<br/>
而esp的增长方向是向下的，所以这样 push进去的东西依然是小尾的。<br/><br/>
第三个：很猫腻的就在这里了<br/><font color="#0000ff">fld          dword ptr [ebp-4]<br/>
sub          esp, 8<br/>
fstp         qword ptr [esp]</font><br/>
[ebp - 4]是我们的变量f。<br/>
第一条指令，f入浮点栈<br/>
第二条指令，把esp减掉8，相当于在栈顶“腾&#8221;出了8字节的空间<br/>
第三条指令，从浮点栈弹出一个数到指定内存。<br/>
后面的esp由 qword修饰 ， 即8字节。<br/><br/><font color="#ff0000">简要的说 ，就是利用机器本身的浮点指令完成了<br/>
从float到double型的转换<br/>
而我们传给printf的始终是一个double型。</font><br/><br/><font color="#ff0000">既然我们传给函数的都是同一种类型，当然没必要区分格式字符串了！</font><br/><br/>
至此，前面提出的两个问题算是有了一个说法。<br/><br/><font color="#ff0000">问题3：</font><br/>
也许你也跟我一样，想到了既然传给scanf的都是一个地址，<br/>
那我们给了一个double的地址，用了%f输入，<br/>
但是机器不知道那是double的地址啊！一定会正确的输入一个浮点数的！<br/>
就像下面这样<br/>
        double d;<br/>
        scanf(&#8220;%f&#8221;,&amp;d);<br/>
那么输出呢？<br/><br/><font color="#ff6600">实验三：</font><br/>
int main(){<br/>
        double d;<br/>
        scanf(&#8220;%f&#8221;,&amp;d);<br/>
        printf(&#8220;%f\n&#8221;,d);<br/>
        printf(&#8220;%f\n&#8221;,float(d));<br/>
        printf(&#8220;%f\n&#8221;,<em>(float</em>)&amp;d);<br/>
        return 0 ;<br/>
}<br/><br/>
在我电脑上的输出为：<br/>
-92559604281615349000000000000000000000000000000000000000000000.000000<br/>
-92559604281615349000000000000000000000000000000000000000000000.000000<br/>
1.000000<br/><br/>
第一个只是说明这样输出是错的。<br/>
也许有人会说，既然正确输入了一个float，那么我来个强制转换吧。<br/>
这就是第二个结果，其实也是错的。<br/>
因为float(d)将产生double -&gt; float 的类型转换。<br/>
是按值转换，所以还是和上面一样的一个东西。<br/>
那第三个呢？从结果看，显然是对的。<br/>
这句话比较绕口，从右向左看：<br/>
先取了d的地址，这里是double<em>的类型，<br/>
然后指针类型转换，这里就是float</em>的类型了，<br/>
最后脱指针引用，得到的就是一个float类型。<br/><br/>
呵呵，这个玩得稍微大了一点。<br/><font color="#ff0000">只是想说明，虽然用scanf 和printf的格式串有细微的规定，<br/>
但并不是一种八股，只要知道原理怎么来都行。</font><br/><br/>
有兴趣可以试下用%lf输入float，再输出也是可以的。<br/>
不过注意，假设你输入输出用的是变量f，要这样：<br/>
int main(){<br/>
        float fspace;<br/>
        float f;<br/>
       。。。<br/>
试试把fspace去掉，即把float f放在main的第一行会出现什么！<br/>
有意思吧。。。<br/><br/>
========================实验二的汇编代码：<br/>
scanf(&#8220;%f&#8221;,&amp;f);<br/>
00412BA8            8D45 FC             lea           eax, dword ptr [ebp-4]<br/>
00412BAB            50                  push          eax<br/>
00412BAC            68 2C614200         push          0042612C                               ;  ASCII &#8220;%f&#8221;<br/>
00412BB1            E8 7AFFFFFF         call          scanf<br/>
00412BB6            83C4 08             add           esp, 8<br/><br/>
scanf(&#8220;%lf&#8221;,&amp;d);<br/>
00412BB9            8D4D F4             lea           ecx, dword ptr [ebp-C]<br/>
00412BBC            51                  push          ecx<br/>
00412BBD            68 1C604200         push          0042601C                               ;  ASCII &#8220;%lf&#8221;<br/>
00412BC2            E8 69FFFFFF         call          scanf<br/>
00412BC7            83C4 08             add           esp, 8<br/><br/>
printf(&#8220;%f\n&#8221;,f);<br/>
00412BCA            D945 FC             fld           dword ptr [ebp-4]<br/>
00412BCD            83EC 08             sub           esp, 8<br/>
00412BD0            DD1C24              fstp          qword ptr [esp]<br/>
00412BD3            68 08704200         push          00427008                               ;  ASCII &#8220;%f&#8221;,LF<br/>
00412BD8            E8 93E4FEFF         call          printf<br/>
00412BDD            83C4 0C             add           esp, 0C<br/><br/>
printf(&#8220;%f\n&#8221;,d);<br/>
00412BE0            8B55 F8             mov           edx, dword ptr [ebp-8]<br/>
00412BE3            52                  push          edx<br/>
00412BE4            8B45 F4             mov           eax, dword ptr [ebp-C]<br/>
00412BE7            50                  push          eax<br/>
00412BE8            68 08704200         push          00427008                               ;  ASCII &#8220;%f&#8221;,LF<br/>
00412BED            E8 7EE4FEFF         call          printf<br/></p>

<h1>00412BF2            83C4 0C             add           esp, 0C<br/><br/></h1>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/backup-hplonline/blog/page/25/">&larr; Older</a>
    
    <a href="/backup-hplonline/blog/archives">Blog Archives</a>
    
    <a class="next" href="/backup-hplonline/blog/page/23/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/backup-hplonline/blog/2013/05/04/test/">Test</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/04/09/%E5%86%8D%E8%B0%88stl%E7%9A%84rotate/">再谈stl的rotate</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%BA%8C%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、二）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%89%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、三）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%80%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、一）</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - hplonline -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
