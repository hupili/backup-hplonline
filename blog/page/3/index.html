
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>hplonline</title>
  <meta name="author" content="hplonline">

  
  <meta name="description" content="(hplonline)2010.6.17
昨天研究了一个题，于是认识了所谓的placement new。
虽然做几个实验，
从现象上可以确定什么是placement new，
但总对其实现耿耿于怀。
》》代码：（上篇的程序，只贴主要部分）
int main(){
int p ;
cls1 p1 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hupili.github.io/backup-hplonline/blog/page/3">
  <link href="/backup-hplonline/favicon.png" rel="icon">
  <link href="/backup-hplonline/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/backup-hplonline/atom.xml" rel="alternate" title="hplonline" type="application/atom+xml">
  <script src="/backup-hplonline/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/backup-hplonline/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/backup-hplonline/">hplonline</a></h1>
  
    <h2>backup from 2006 to 2012 (original hi.baidu.com/hplonline/)</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/backup-hplonline/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hupili.github.io/backup-hplonline" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/backup-hplonline/">Blog</a></li>
  <li><a href="/backup-hplonline/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/06/17/C%2B%2B%E4%B8%ADplacementnew%E5%9C%A8VC6%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/">C++中placement new在VC6中的实现</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-06-17T10:03:00+08:00" pubdate data-updated="true">Jun 17<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.6.17<br/><br/>
昨天研究了一个题，于是认识了所谓的<a href="http://hi.baidu.com/hplonline/blog/item/0a3fa76e45727fd780cb4ac9.html" target="_blank">placement new</a>。<br/><br/>
虽然做几个实验，<br/>
从现象上可以确定什么是placement new，<br/>
但总对其实现耿耿于怀。<br/><font color="#0000ff"><br/>
》》代码：（上篇的程序，只贴主要部分）</font><br/><br/>
int main(){<br/>
int <em>p ;<br/>
cls1 </em>p1 = new cls1 ;<br/>
p1-&gt;print() ;<br/>
p = (int<em>)p1 ;<br/>
cout&lt;&lt;&#8221;cookie:&#8221;&lt;&lt;p[-4]&lt;&lt;endl ;<br/><br/>
cls2 </em>p2 ;<br/><font color="#ff0000">p2 = new(p1) cls2 ;</font><br/>
p2-&gt;print() ;<br/>
p1-&gt;print() ;<br/>
p = (int*)p2 ;<br/>
cout&lt;&lt;&#8221;cookie:&#8221;&lt;&lt;p[-4]&lt;&lt;endl ;<br/><br/>
return 0 ;<br/>
}<br/><br/>
主要就是想看一些红色这句会产生什么样的目标代码。<br/><br/>
因为通过之前打印cookie的实验，<br/>
可以知道空间并没有重新分配，<br/>
但是当两个类的大小不一样的时候，<br/>
编译器是否会给new传入这个信息呢？<br/><br/><font color="#0000ff">》》debug方式的目标代码</font><br/><br/>
main函数：<br/><br/>
00401658   .  8B55 EC       mov     edx, dword ptr [ebp-14]<br/>
0040165B   .  52            push    edx<br/>
0040165C   .  6A 08       <font color="#ff0000">  push    8</font><br/>
0040165E   .  E8 F2F9FFFF   call    00401055<br/><br/>
可以看到，第二种类的信息是传入了的！！<br/>
那为什么不根据这个重新分配空间呢？<br/><br/>
operator new函数（placement new的版本）：<br/><br/>
00401B90 &gt;/&gt; \55            push    ebp<br/>
00401B91  |.  8BEC          mov     ebp, esp<br/>
00401B93  |.  83EC 40       sub     esp, 40<br/>
00401B96  |.  53            push    ebx<br/>
00401B97  |.  56            push    esi<br/>
00401B98  |.  57            push    edi<br/>
00401B99  |.  8D7D C0       lea     edi, dword ptr [ebp-40]<br/>
00401B9C  |.  B9 10000000   mov     ecx, 10<br/>
00401BA1  |.  B8 CCCCCCCC   mov     eax, CCCCCCCC<br/>
00401BA6  |.  F3:AB         rep     stos dword ptr es:[edi]<br/><font color="#ff0000">00401BA8  |.  8B45 0C       mov     eax, dword ptr [ebp+C]</font><br/>
00401BAB  |.  5F            pop     edi                              ;  0012FF3C<br/>
00401BAC  |.  5E            pop     esi<br/>
00401BAD  |.  5B            pop     ebx<br/>
00401BAE  |.  8BE5          mov     esp, ebp<br/>
00401BB0  |.  5D            pop     ebp<br/>
00401BB1  .  C3            retn<br/><br/>
[epb+C]就是我们push的第一个参数，也就是new括号中的那个指针。<br/>
从红色这句可以看到，程序赤裸裸地把这个指针原样返回了。<br/><br/>
这么大一个过程，其实一个mov就可以解决，怎么会这么扭曲。。<br/><br/><font color="#0000ff">》》release方式编译</font><br/><br/>
怀疑是不是debug方式编译器不知道优化，<br/>
故使用release来看一下。<br/><br/>
main：<br/><br/>
0040165B   .  52            push    edx<br/>
0040165C   .  6A 08         push    8<br/>
0040165E   .  E8 F2F9FFFF   call    00401055<br/><br/>
operator new：<br/><br/>
00401B90 &gt;/&gt; \55            push    ebp<br/>
00401B91  |.  8BEC          mov     ebp, esp<br/>
00401B93  |.  83EC 40       sub     esp, 40<br/>
00401B96  |.  53            push    ebx<br/>
00401B97  |.  56            push    esi<br/>
00401B98  |.  57            push    edi<br/>
00401B99  |.  8D7D C0       lea     edi, dword ptr [ebp-40]<br/>
00401B9C  |.  B9 10000000   mov     ecx, 10<br/>
00401BA1  |.  B8 CCCCCCCC   mov     eax, CCCCCCCC<br/>
00401BA6  |.  F3:AB         rep     stos dword ptr es:[edi]<br/>
00401BA8  |.  8B45 0C       mov     eax, dword ptr [ebp+C]<br/>
00401BAB  |.  5F            pop     edi<br/>
00401BAC  |.  5E            pop     esi<br/>
00401BAD  |.  5B            pop     ebx<br/>
00401BAE  |.  8BE5          mov     esp, ebp<br/>
00401BB0  |.  5D            pop     ebp<br/>
00401BB1  .  C3            retn<br/><br/>
可以看到，简化的只是main函数里面的一些冗余赋值语句。<br/>
本质上的调用<font color="#ff0000">operator new(size , pointer)</font>的框架没有改变。<br/><br/><font color="#ff00ff">附记：</font><br/><br/>
release方式下没有源码信息，故定位比较麻烦，只有手动跟踪。<br/>
从代码入口开始，找到三次特征的压栈操作即可，<br/>
并且main的入口在调用exit之前。<br/><br/>
00422490  |.  8B15 E0D34700 mov     edx, dword ptr [_environ]<br/>
00422496  |.  52          <font color="#ff0000">  push    edx</font><br/>
00422497  |.  A1 D8D34700   mov     eax, dword ptr<font color="#ff0000"> [<strong>argv]</font><br/>
0042249C  |.  50       <font color="#ff0000">     push    eax</font><br/>
0042249D  |.  8B0D D4D34700 mov     ecx, dword ptr<font color="#ff0000"> [</strong>argc]</font><br/>
004224A3  |.  51        <font color="#ff0000">    push    ecx</font><br/>
004224A4  |.  E8 91EDFDFF   call    0040123A<br/>
004224A9  |.  83C4 0C       add     esp, 0C<br/>
004224AC  |.  8945 E4       mov     dword ptr [ebp-1C], eax<br/>
004224AF  |.  8B55 E4       mov     edx, dword ptr [ebp-1C]<br/>
004224B2  |.  52            push    edx                              ; /status<br/>
004224B3  |.  E8 E8400000   <font color="#ff0000">call    exit                             ; \exit</font><br/><br/><font color="#0000ff">》》结论</font><br/><br/>
从表面上看，这个placement new着实有种脱了裤子放屁的感觉。<br/>
不过为什么要这样设计，前人也许有他们自己的原因。<br/>
麻烦知道的同学告诉一声。<br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/06/16/C%2B%2B%E4%B8%AD%E5%B8%A6%E6%8B%AC%E5%8F%B7%E7%9A%84new%E3%80%82%E3%80%82%EF%BC%88placementnew%EF%BC%89/">C++中带括号的new。。（placement New）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-06-16T20:35:00+08:00" pubdate data-updated="true">Jun 16<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.6.16<br/><br/><font color="#0000ff">》》起因</font><br/><br/>
之前有同学做个在线笔试，碰到了这个题：<br/><br/></p>

<h1>include &lt;iostream&gt;<br/></h1>

<p>using std::cout;<br/>
using namespace std ;<br/><br/>
class P<br/>
{<br/>
public:<br/>
virtual void print()<br/>
{<br/>
cout &lt;&lt; &#8220;P&#8221;;<br/>
}<br/>
};<br/><br/>
class Q: public P<br/>
{<br/>
public:<br/>
virtual void print()<br/>
{<br/>
cout &lt;&lt; &#8220;Q&#8221;;<br/>
}<br/>
};<br/><br/>
int main()<br/>
{<br/>
P * p = new P;<br/>
Q * q = static_cast &lt;Q *&gt; (p);<br/>
q-&gt;print();<br/>
delete p;<br/>
cout &lt;&lt; endl;<br/><br/>
q = new Q;<br/>
p = q;<br/>
q-&gt;print();<br/>
p-&gt;print();<br/>
cout &lt;&lt; endl;<br/><br/><font color="#ff0000">p = new (q) P;</font><br/>
q-&gt;print();<br/>
p-&gt;print();<br/>
cout &lt;&lt; endl;<br/><font color="#ff0000">p-&gt;~P();</font><br/>
delete q;<br/><br/>
return 0;<br/>
}<br/><br/>
题目当然是让你判断会出什么结果。<br/><br/>
对于前两个，应该说比较好搞定。<br/>
第一个，static_cast，<br/>
在这里和平时用的强制类型转换是一样的。<br/>
当存在多重继承的时候，会有一些猫腻，<br/>
详情见笔记：<a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/a8f8c2fc9100a4f5fd037fa4.html">C++类型转换(static_cast,reinterpret_cast)</a><br/>
第二个，就是一般的虚函数的问题，<br/>
创建的对象是什么那就调用谁的函数。<br/><br/>
比较诡异的是第三个，<br/>
new(q)P这种用法还真是第一次见到。<br/>
（深刻表示土鳖。。以前就是没看到过。。<br/>
并且这个东西没法构造关键词在网上搜。。）<br/><font color="#0000ff"><br/>
》》new的几种常用写法</font><br/><br/>
new XXX<br/>
这种必须要配合delete 来使用。<br/><br/>
new XXX[]<br/>
这种必须要配合delete[]来使用。<br/><br/>
另外可以用括号来初始化创建的对象，<br/>
括号的位置相当于是构造函数的位置。<br/>
比如：new int(3) ;<br/><br/>
今天遇到的这种形式为：<br/>
new(??) XXX<br/><br/><font color="#0000ff">》》目标代码查看</font><br/><br/>
实验环境：VC6+debug，OD<br/><br/>
其中，main函数的汇编代码如下：<br/><br/>
（有些注释是后面手动加的，<br/>
关键位置标红显示）<br/><br/>
004011A0 &gt; &gt; \55            push    ebp<br/>
004011A1   .  8BEC          mov     ebp, esp<br/>
004011A3   .  6A FF         push    -1<br/>
004011A5   .  68 07FE4100   push    0041FE07                         ;  SE handler installation<br/>
004011AA   .  64:A1 0000000&gt;mov     eax, dword ptr fs:[0]<br/>
004011B0   .  50            push    eax<br/>
004011B1   .  64:8925 00000&gt;mov     dword ptr fs:[0], esp<br/>
004011B8   .  83EC 74       sub     esp, 74<br/>
004011BB   .  53            push    ebx<br/>
004011BC   .  56            push    esi<br/>
004011BD   .  57            push    edi<br/>
004011BE   .  8D7D 80       lea     edi, dword ptr [ebp-80]<br/>
004011C1   .  B9 1D000000   mov     ecx, 1D<br/>
004011C6   .  B8 CCCCCCCC   mov     eax, CCCCCCCC<br/>
004011CB   .  F3:AB         rep     stos dword ptr es:[edi]<br/><br/>
到这里为止，都是一些进入函数的初始化过程。<br/><br/>
004011CD   .  6A 04         push    4<br/><font color="#ff0000">004011CF   .  E8 CC810000   call    operator new</font><br/>
004011D4   .  83C4 04       add     esp, 4<br/><br/>
第一个operator new的调用，申请一片空间<br/><br/>
004011D7   .  8945 E4       mov     dword ptr [ebp-1C], eax<br/>
004011DA   .  C745 FC 00000&gt;mov     dword ptr [ebp-4], 0<br/>
004011E1   .  837D E4 00    cmp     dword ptr [ebp-1C], 0<br/>
004011E5   .  74 0D         je      short 004011F4<br/>
004011E7   .  8B4D E4       mov     ecx, dword ptr [ebp-1C]<br/><font color="#ff0000">004011EA   .  E8 BBFEFFFF   call    004010AA                         ;  P::P</font><br/>
004011EF   .  8945 C8       mov     dword ptr [ebp-38], eax<br/><br/>
调用的是P的构造函数，构造函数返回类的引用（指针）。<br/><br/>
004011F2   .  EB 07         jmp     short 004011FB<br/>
004011F4   &gt;  C745 C8 00000&gt;mov     dword ptr [ebp-38], 0<br/>
004011FB   &gt;  8B45 C8       mov     eax, dword ptr [ebp-38]<br/>
004011FE   .  8945 E8       mov     dword ptr [ebp-18], eax<br/>
00401201   .  C745 FC FFFFF&gt;mov     dword ptr [ebp-4], -1<br/>
00401208   .  8B4D E8       mov     ecx, dword ptr [ebp-18]<br/>
0040120B   .  894D F0       mov     dword ptr [ebp-10], ecx<br/>
0040120E   .  8B55 F0       mov     edx, dword ptr [ebp-10]<br/>
00401211   .  8955 EC       mov     dword ptr [ebp-14], edx<br/><br/>
然后是一些赋值，主要是static_cast那一团的东西。<br/><br/>
00401214   .  8B45 EC       mov    <font color="#ff0000"> eax, dword ptr [ebp-14]</font><br/>
00401217   .  8B10          mov     <font color="#ff0000">edx, dword ptr [eax]</font><br/>
00401219   .  8BF4          mov     esi, esp<br/>
0040121B   .  8B4D EC       mov     ecx, dword ptr [ebp-14]<br/>
0040121E   .  FF12         <font color="#ff0000"> call    dword ptr [edx]</font><br/><br/>
这里就是print函数的调用，代码为虚函数调用的标准长相。<br/>
关于虚函数其他方面的研究，见：<a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/1bacf81f75e4026af724e485.html">虚函数的底层机制</a><br/><font color="#ff0000">（其中关于点调用和箭头调用的不同之处，值得注意）</font><br/><br/>
00401220   .  3BF4          cmp     esi, esp<br/>
00401222   .  E8 69860000   call    <em>chkesp<br/>
00401227   .  8B45 F0       mov     eax, dword ptr [ebp-10]<br/>
0040122A   .  8945 E0       mov     dword ptr [ebp-20], eax<br/>
0040122D   .  8B4D E0       mov     ecx, dword ptr [ebp-20]<br/>
00401230   .  51            push    ecx<br/>
00401231   .  E8 AA3F0000   call    operator delete<br/>
00401236   .  83C4 04       add     esp, 4<br/>
00401239   .  68 32104000   push    00401032                         ;  std::endl<br/>
0040123E   .  B9 28954300   mov     ecx, offset std::cout            ;  ASCII &#8220;4 C&#8221;<br/>
00401243   .  E8 3AFEFFFF   call    00401082                         ;  cout::operator&lt;&lt;<br/>
00401248   .  6A 04         push    4<br/><br/>
第一节的代码完。<br/><br/>
0040124A   .  E8 51810000   call    operator new<br/>
0040124F   .  83C4 04       add     esp, 4<br/>
00401252   .  8945 D8       <font color="#ff0000">mov     dword ptr [ebp-28], eax</font><br/>
00401255   .  C745 FC 01000&gt;mov     dword ptr [ebp-4], 1<br/>
0040125C   .  837D D8 00    cmp     dword ptr [ebp-28], 0<br/>
00401260   .  74 0D         je      short 0040126F<br/>
00401262   .  8B4D D8       <font color="#ff0000">mov     ecx, dword ptr [ebp-28]</font><br/>
00401265   .  E8 B9FDFFFF   call    00401023<br/>
0040126A   .  8945 C4       <font color="#ff0000">mov     dword ptr [ebp-3C], eax</font><br/>
0040126D   .  EB 07         jmp     short 00401276<br/>
0040126F   &gt;  C745 C4 00000&gt;mov     dword ptr [ebp-3C], 0<br/>
00401276   &gt;  8B55 C4      <font color="#ff0000"> mov     edx, dword ptr [ebp-3C]</font><br/>
00401279   .  8955 DC       <font color="#ff0000">mov     dword ptr [ebp-24], edx</font><br/>
0040127C   .  C745 FC FFFFF&gt;mov     dword ptr [ebp-4], -1<br/>
00401283   .  8B45 DC      <font color="#ff0000"> mov     eax, dword ptr [ebp-24]</font><br/>
00401286   .  8945 EC       <font color="#ff0000">mov     dword ptr [ebp-14], eax</font><br/>
00401289   .  8B4D EC       mov     ecx, dword ptr [ebp-14]<br/>
0040128C   .  894D F0       mov     dword ptr [ebp-10], ecx<br/>
0040128F   .  8B55 EC       mov     edx, dword ptr [ebp-14]<br/>
00401292   .  8B02          mov     eax, dword ptr [edx]<br/>
00401294   .  8BF4          mov     esi, esp<br/>
00401296   .  8B4D EC       mov     ecx, dword ptr [ebp-14]<br/>
00401299   .  FF10          call    dword ptr [eax]<br/>
0040129B   .  3BF4          cmp     esi, esp<br/>
0040129D   .  E8 EE850000   call    </em>chkesp<br/>
004012A2   .  8B4D F0       mov     ecx, dword ptr [ebp-10]<br/>
004012A5   .  8B11          mov     edx, dword ptr [ecx]<br/>
004012A7   .  8BF4          mov     esi, esp<br/>
004012A9   .  8B4D F0       mov     ecx, dword ptr [ebp-10]<br/>
004012AC   .  FF12          call    dword ptr [edx]<br/>
004012AE   .  3BF4          cmp     esi, esp<br/>
004012B0   .  E8 DB850000   call    <em>chkesp<br/>
004012B5   .  68 32104000   push    00401032<br/>
004012BA   .  B9 28954300   mov     ecx, offset std::cout            ;  ASCII &#8220;4 C&#8221;<br/>
004012BF   .  E8 BEFDFFFF   call    00401082<br/><br/>
第二节到此完，本节没有什么新的东西。<br/>
中间一系列赋值，不知道VC为什么编得如此复杂。<br/>
不过通过标红的几句，知道<font color="#ff0000">：<br/>
dword ptr [ebp-14]</font>中存的就是new Q后返回的地址。<br/>
通过上下文，知道这个[ebp-14]实际上就是q变量。<br/>
这个很重要，因为下面要用到了。<br/><br/>
004012C4   .  8B45 EC       mov     eax, dword ptr [ebp-14]<br/>
004012C7   .  50            <font color="#ff0000">push    eax                              ;  eax=00360FF0</font><br/>
004012C8   .  6A 04         push    4<br/>
004012CA   .  E8 40FDFFFF   call    0040100F                         ;  operator new<br/><br/>
0040100F 这个位置的函数也叫operator new，<br/>
但它和我们之前看到的operator new不是同一个东西，<br/>
传进去了两个参数，一个是地址值，一个是申请的空间大小。<br/><br/>
004012CF   .  83C4 08      <font color="#ff0000"> add     esp, 8                           ;  eax=00360FF0</font><br/><br/>
从这个operator new的返回值可以看到，得到的地址和之前p的值一样。<br/><br/>
004012D2   .  8945 D0       mov     dword ptr [ebp-30], eax<br/>
004012D5   .  C745 FC 02000&gt;mov     dword ptr [ebp-4], 2<br/>
004012DC   .  837D D0 00    cmp     dword ptr [ebp-30], 0<br/>
004012E0   .  74 0D         je      short 004012EF<br/>
004012E2   .  8B4D D0       mov     ecx, dword ptr [ebp-30]<br/>
004012E5   .  E8 C0FDFFFF  <font color="#ff0000"> call    004010AA                         ;  P::P</font><br/><br/>
并且紧接着就会调用P的构造函数。<br/><br/>
004012EA   .  8945 C0       mov     dword ptr [ebp-40], eax<br/>
004012ED   .  EB 07         jmp     short 004012F6<br/>
004012EF   &gt;  C745 C0 00000&gt;mov     dword ptr [ebp-40], 0<br/>
004012F6   &gt;  8B4D C0       mov     ecx, dword ptr [ebp-40]<br/>
004012F9   .  894D D4       mov     dword ptr [ebp-2C], ecx<br/>
004012FC   .  C745 FC FFFFF&gt;mov     dword ptr [ebp-4], -1<br/>
00401303   .  8B55 D4       mov     edx, dword ptr [ebp-2C]<br/>
00401306   .  8955 F0       mov     dword ptr [ebp-10], edx<br/>
00401309   .  8B45 EC       mov     eax, dword ptr [ebp-14]<br/>
0040130C   .  8B10          mov     edx, dword ptr [eax]<br/>
0040130E   .  8BF4          mov     esi, esp<br/>
00401310   .  8B4D EC       mov     ecx, dword ptr [ebp-14]<br/>
00401313   .  FF12          call    dword ptr [edx]<br/>
00401315   .  3BF4          cmp     esi, esp<br/>
00401317   .  E8 74850000   call    </em>chkesp<br/>
0040131C   .  8B45 F0       mov     eax, dword ptr [ebp-10]<br/>
0040131F   .  8B10          mov     edx, dword ptr [eax]<br/>
00401321   .  8BF4          mov     esi, esp<br/>
00401323   .  8B4D F0       mov     ecx, dword ptr [ebp-10]<br/>
00401326   .  FF12          call    dword ptr [edx]<br/>
00401328   .  3BF4          cmp     esi, esp<br/>
0040132A   .  E8 61850000   call    <em>chkesp<br/><br/>
中间这截也是虚函数的调用，同上。<br/><br/>
0040132F   .  68 32104000   push    00401032                         ;  &#8212;cout&lt;&lt;endl<br/>
00401334   .  B9 28954300   mov     ecx, offset std::cout            ;  ASCII &#8220;4 C&#8221;<br/>
00401339   .  E8 44FDFFFF   call    00401082<br/><br/>
这截是cout&lt;&lt;endl<br/><br/>
0040133E   .  8B45 EC       mov     eax, dword ptr [ebp-14]          ;  &#8212;delete q<br/>
00401341   .  8945 CC       mov     dword ptr [ebp-34], eax<br/>
00401344   .  8B4D CC       mov     ecx, dword ptr [ebp-34]<br/>
00401347   .  51            push    ecx<br/>
00401348   .  E8 933E0000   call    operator delete<br/><br/>
这截是delete q。<br/><br/>
可以看到，之前源码中的<font color="#ff0000">p-&gt;~P();</font>并没有生成任何目标代码。<br/><br/>
0040134D   .  83C4 04       add     esp, 4<br/>
00401350   .  33C0          xor     eax, eax<br/>
00401352   .  8B4D F4       mov     ecx, dword ptr [ebp-C]<br/>
00401355   .  64:890D 00000&gt;mov     dword ptr fs:[0], ecx<br/>
0040135C   .  5F            pop     edi<br/>
0040135D   .  5E            pop     esi<br/>
0040135E   .  5B            pop     ebx<br/>
0040135F   .  81C4 80000000 add     esp, 80<br/>
00401365   .  3BEC          cmp     ebp, esp<br/>
00401367   .  E8 24850000   call    </em>chkesp<br/>
0040136C   .  8BE5          mov     esp, ebp<br/>
0040136E   .  5D            pop     ebp<br/>
0040136F   .  C3            retn<br/><br/>
最后是一些扫尾的工作。<br/><br/><font color="#0000ff">》》观察目标代码的结论</font><br/><br/>
从目标代码来看，p=new(q)P做了以下事情：<br/><font color="#ff0000">1。直接让p的值等于q<br/>
2。以p这个地址为this指针，调用了P的构造函数。</font><br/><br/>
如果觉得看汇编太麻烦，可以用C++写个更简洁点的实验：<br/><br/></p>

<h1>include &lt;iostream&gt;<br/></h1>

<p>using namespace std;<br/><br/>
class cls1{<br/>
public:<br/>
int i ;<br/>
cls1(){<br/>
i = 1 ;<br/>
}<br/>
void print(){<br/>
cout&lt;&lt;i&lt;&lt;endl ;<br/>
}<br/>
} ;<br/><br/>
class cls2{<br/>
public:<br/>
int i1 , i2 ;<br/>
cls2(){<br/>
i1 = 2 ; <br/>
i2 = 2 ;<br/>
}<br/>
void print(){<br/>
cout&lt;&lt;i1&lt;&lt;&#8217;,&#8217;&lt;&lt;i2&lt;&lt;endl ;<br/>
}<br/>
} ;<br/><br/>
int main(){<br/>
int <em>p ;<br/>
cls1 </em>p1 = new cls1 ;<br/>
p1-&gt;print() ;<br/>
cls2 <em>p2 = new(p1) cls2 ;<br/>
p2-&gt;print() ;<br/>
p1-&gt;print() ;<br/>
return 0 ;<br/>
}<br/><br/>
输出：<br/><br/>
1<br/>
2,2<br/>
2<br/><br/>
这个实验也可以证实两个指针的值相同，<br/>
并且后者的构造函数已经被调用了。<br/><br/><font color="#0000ff">》》空间分配的问题</font><br/><br/>
这里，我们又遇到了另一个很矛盾的问题：<br/><font color="#ff0000">new(??) XX是进行简单的指针赋值呢，还是重新分配空间？</font><br/><br/>
如果不重新分配空间的话，<br/>
新类和旧类所占空间不一定是相同的，<br/>
这样，有的数据成员可能就已经存到了无效区域。<br/><br/>
还好，<font color="#ff0000">new出来的东西会有一个cookie，<br/>
在指针前面某地，是存储得有空间大小的。</font><br/>
根据这个，我们可以设计实验来观察。<br/><br/>
实验：<br/><br/>
int main(){<br/>
int </em>p1 , *p2 ;<br/>
p1 = new int[12] ;<br/>
printf(&#8220;%d\n&#8221; , p1[-4]) ;<br/><br/>
p2 = new(p1) int[13] ;<br/>
printf(&#8220;%d\n&#8221; , p2[-4]) ;<br/><br/>
p2 = new int[13] ;<br/>
printf(&#8220;%d\n&#8221; , p2[-4]) ;<br/>
return 0 ;<br/>
}<br/><br/>
输出：<br/><br/>
48<br/><font color="#ff0000">48<br/>
52</font><br/><br/>
可以看到new(p1) int[13] ;出来的cookie，<br/>
标注空间大小为48，和原来一样。<br/>
new int[13] ;出来的coockie，<br/>
则是和新申请的一样，52。<br/><br/>
这说明new(??)XX的形式并没有重新分配空间。<br/>
在上面这个实验中，使用的是基础类型int，<br/>
这种类型具有trivial的dtor和ctor，<br/>
实验中，delete p1或者p2都是正常的。<br/><br/>
但下面的实验将展示出它的一个副作用：<br/><br/></p>

<h1>include &lt;iostream&gt;<br/></h1>

<p>using namespace std;<br/><br/>
class cls1{<br/>
public:<br/>
int i ;<br/>
cls1(){<br/>
i = 1 ;<br/>
}<br/>
void print(){<br/>
cout&lt;&lt;i&lt;&lt;endl ;<br/>
}<br/>
} ;<br/><br/>
class cls2{<br/>
public:<br/>
int i1 , i2 ;<br/>
cls2(){<br/>
i1 = 2 ; <br/>
i2 = 2 ;<br/>
}<br/>
void print(){<br/>
cout&lt;&lt;i1&lt;&lt;&#8217;,&#8217;&lt;&lt;i2&lt;&lt;endl ;<br/>
}<br/>
} ;<br/><br/>
int main(){<br/>
int <em>p ;<br/>
cls1 </em>p1 = new cls1 ;<br/>
p = (int<em>)p1 ;<br/>
cout&lt;&lt;p[0]&lt;&lt;&#8217;,&#8217;&lt;&lt;p[1]&lt;&lt;endl ;<br/>
cls2 </em>p2 = new(p1) cls2 ;<br/>
p = (int<em>)p2 ;<br/>
cout&lt;&lt;p[0]&lt;&lt;&#8217;,&#8217;&lt;&lt;p[1]&lt;&lt;endl ;<br/><font color="#ff0000"><br/>
//delete p1 ;<br/>
//delete p2 ;<br/>
//both will fail here!!</font><br/><br/>
return 0 ;<br/>
}<br/><br/>
在以上语句执行后，<br/>
不管delete哪个指针，<br/>
最后都会出现错误！<br/><br/>
这是由于cls2 </em>p2 = new(p1) cls2 ;没有重新分配空间，<br/>
也就是p2指向的地方只有一个int的位置，<br/>
但是cls2的构造函数很明显地向两个地方写入了数据，<br/>
后者已经在有效空间范围外了。<br/><br/><font color="#0000ff">》》总结</font><br/><br/>
由于没有重新分配空间，<br/>
所以new(??)XXX这样的用法是非常危险的。<br/>
当新对象所占空间小于原分配空间的时候，不会出问题。<br/>
但当新对象所占空间比之大的时候，可能造成对非法区域的改写。<br/><br/>
那是不是就要完全放弃这种写法呢？？<br/><br/>
显然不是！<br/><font color="#ff0000">第一，就像上面分析的，如果能保证新对象的空间更小，则无所谓。</font><br/>
C的哲学不是让我们放弃一切危险的动作，<br/>
而是让我们深入了解每个动作，让危险可控。<br/><br/><font color="#ff0000">第二，这给我们手动调用构造函数提供了一个方法！</font><br/>
其实这个问题也困扰了我很久，如今却无心插柳地发现了玄机。<br/>
从OD中对目标代码的分析，和几个实验，<br/>
可以看到，这个写法仅仅是在原指针位置调用了一下新对象的构造函数。<br/><br/>
我们知道，一般情况下，我们是无法手动调用构造函数的，<br/>
ctor都是在new或者栈变量初始化的时候，由编译器调用的。<br/>
而现在，我们可以通过这种写法来调用ctor，如下：<br/><br/>
int main(){<br/>
cls1 *p = new cls1() ;<br/>
p-&gt;print() ;<br/>
p-&gt;i = 2 ;<br/>
p-&gt;print() ;<br/><font color="#ff0000">p = new(p) cls1() ;</font><br/>
p-&gt;print() ;<br/>
return 0 ;<br/>
}<br/><br/>
输出：<br/><br/>
1<br/>
2<br/>
1<br/><br/>
其实。。。调用构造函数还是可以这么写的：<br/><font color="#ff0000">p-&gt;cls1::cls1() ;</font><br/><br/>
在VC6里面是过了，但应该是不标准的用法。<br/><br/>
又查了些东西，知道了本篇一直讨论的形式原来叫：<font color="#ff0000">placement new</font><br/><br/>
感觉这个东西就是和手动析构联合起来用的：<br/>
先手动调用一个对象的dtor，然后使用placement new调用ctor。<br/>
如果不是同一类对象，使用placement new有潜在的空间分配问题。<br/>
或者是程序员能从某处拿到非new方法（比如malloc分配的空间），<br/>
于是使用placement new来初始化这段空间。<br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/06/13/%E4%B8%80%E4%B8%AAwindows%E4%B8%8B%E7%9A%84%E7%AE%A1%E9%81%93%E7%B1%BB%E3%80%82%EF%BC%88%E4%BA%92%E6%96%A5%E9%87%8F%EF%BC%8C%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%8C%E6%AD%BB%E9%94%81%EF%BC%8C%E6%8E%A7%E5%88%B6%E5%8F%B0IO%EF%BC%89/">一个windows下的管道类。（互斥量，信号量，死锁，控制台IO）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-06-13T14:31:00+08:00" pubdate data-updated="true">Jun 13<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.6.13<br/><br/><font color="#0000ff">一。起因</font><br/><br/>
之前做了个字符串协议的<a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/a23496824285c8b26d8119b0.html">引擎</a>，<br/>
后来基于这个引擎做点协议设计的实验。<br/><br/>
考虑了一下，引擎和上层协议之间用什么东西交互呢？<br/>
发送windows消息？<br/>
但是控制台程序，还要去获得句柄，并且改写窗口过程，<br/>
感觉比较麻烦，虽然也有办法得到控制台窗口句柄。（见<a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/e9f38c18ddd9cbbd4bedbcf3.html">这里</a>）<br/><br/>
想到以前也接触过进线程同步的理论，<br/>
但没有实践过，于是顺便写个管道类备用。<br/><br/><font color="#0000ff">二。信号量(semaphore)</font><br/><br/>
以前粗略了解过<a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/7a8a06336903a0f11b4cff5f.html">互斥量，信号量，事件，临界区</a>等几种同步机制。<br/>
对于信号量的认识比较浅，只认识到其用来做互斥之用。<br/><font color="#ff0000">其实信号量的关键在于，其含有一个当前计数，和最大计数。</font><br/>
利用这个特点，就可以实现有限数量资源的访问控制了。<br/><br/>
从MSDN上摘抄一下对semaphore的介绍，每段只记录大意。<br/><br/>
Semaphore Objects<br/>
A semaphore object is a synchronization object that maintains a count between zero and a specified maximum value. The count is decremented each time a thread completes a wait for the semaphore object and incremented each time a thread releases the semaphore. When the count reaches zero, no more threads can successfully wait for the semaphore object state to become signaled. The state of a semaphore is set to signaled when its count is greater than zero, and nonsignaled when its count is zero.<br/><br/><font color="#ff00ff">信号量的值可以在0和max之间。<br/>
当信号量的值为0的时候，为无信号状态。</font><br/><br/>
The semaphore object is useful in controlling a shared resource that can support a limited number of users. It acts as a gate that limits the number of threads sharing the resource to a specified maximum number. For example, an application might place a limit on the number of windows that it creates. It uses a semaphore with a maximum count equal to the window limit, decrementing the count whenever a window is created and incrementing it whenever a window is closed. The application specifies the semaphore object in call to one of the wait functions before each window is created. When the count is zero — indicating that the window limit has been reached — the wait function blocks execution of the window-creation code.<br/><br/>
A thread uses the CreateSemaphore or CreateSemaphoreEx function to create a semaphore object. The creating thread specifies the initial count and the maximum value of the count for the object. The initial count must be neither less than zero nor greater than the maximum value. The creating thread can also specify a name for the semaphore object. Threads in other processes can open a handle to an existing semaphore object by specifying its name in a call to the OpenSemaphore function. For additional information about names for mutex, event, semaphore, and timer objects, see Interprocess Synchronization.<br/><br/><font color="#ff00ff">使用CreateSemaphore创建信号量，可以指定一个名称，用于进程间同步。</font><br/><br/>
If more than one thread is waiting on a semaphore, a waiting thread is selected. Do not assume a first-in, first-out (FIFO) order. External events such as kernel-mode APCs can change the wait order.<br/><br/><font color="#ff00ff">等待同一信号量的多个线程不一定按照FIFO顺序得到信号量。</font><br/><br/>
Each time one of the wait functions returns because the state of a semaphore was set to signaled, the count of the semaphore is decreased by one. The ReleaseSemaphore function increases a semaphore&#8217;s count by a specified amount. The count can never be less than zero or greater than the maximum value.<br/><br/><font color="#ff00ff">当wait函数返回的时候，信号量的值会减少1。<br/>
ReleaseSemaphore调用会使得信号量的值增加1。<br/>
计数值不会小于0，也不会比max更大。</font><br/><br/>
The initial count of a semaphore is typically set to the maximum value. The count is then decremented from that level as the protected resource is consumed. Alternatively, you can create a semaphore with an initial count of zero to block access to the protected resource while the application is being initialized. After initialization, you can use ReleaseSemaphore to increment the count to the maximum value.<br/><br/><font color="#ff00ff">初始值一般都被设置为max。<br/>
也可以先设置为0，然后程序进行初始化。<br/>
之后多次使用ReleaseSemaphore使计数值达到max。</font><br/><br/>
A thread that owns a mutex object can wait repeatedly for the same mutex object to become signaled without its execution becoming blocked. A thread that waits repeatedly for the same semaphore object, however, decrements the semaphore&#8217;s count each time a wait operation is completed; the thread is blocked when the count gets to zero. Similarly, only the thread that owns a mutex can successfully call the ReleaseMutex function, though any thread can use ReleaseSemaphore to increase the count of a semaphore object.<br/><br/><font color="#ff00ff">线程可以重复地wait一个信号量，而且每次都减少其值。<br/>
对于互斥量（Mutex），只有拥有它的线程能够调用ReleaseMutex。<br/>
对于信号量（Semaphore），每个线程都可以使用ReleaseSemaphore。</font><br/><br/>
A thread can decrement a semaphore&#8217;s count more than once by repeatedly specifying the same semaphore object in calls to any of the wait functions. However, calling one of the multiple-object wait functions with an array that contains multiple handles of the same semaphore does not result in multiple decrements.<br/><br/><font color="#ff00ff">线程重复wait，可以重复减少信号量的值。<br/>
但使用multi-wait函数，数组中重复放置该信号量，<br/>
不会产生多次减少的动作。</font><br/><br/>
可见，即使是把max和init计数都置为1的信号量，<br/>
与互斥量之间还是有着细微的区别的。<br/><br/><font color="#0000ff">三。管道的总体结构</font><br/><br/>
首先考虑的是存储问题。<br/>
由于管道中不断有东西进出，<br/>
并且同时存在管道中的内容有上限，<br/>
那么可以使用一个循环队列来实现。<br/><br/>
在管道的ctor中开启相关的空间，<br/>
在管道的dtor中销毁相关的空间即可。<br/><br/>
然后是同步机制的设计。<br/><br/>
对循环队列的访问是必须互斥的，<br/>
否则可能会出现操作结果不一致的情况。<br/>
比如两个线程同时对管道进行输入，<br/>
那么可能有这么一句话：<br/>
rear = rear + 1 ;<br/>
两个线程如果“一起”执行到这里，<br/>
最后可能出现rear只加了1，而非2的情况。<br/>
这样，就需要设置一个互斥量mutexLock，<br/>
用来控制对循环队列这种临界资源的访问。<br/><br/>
由于队列是有容量上限的，<br/>
所以需要有手段来记录已经消耗的存储空间。<br/>
开设一个semaphoreIn，初始的时候为容量上限，<br/>
每当要向管道输入的时候，需要等待这个信号量，<br/>
如果信号量为0，那么线程就阻塞。<br/>
这样就保证了不会超过队列的容量。<br/>
而从队列输出数据也是类似的，<br/>
当队列里面没有东西的时候，也不能操作。<br/>
开设一个semaphoreOut，初始的时候为0。<br/>
当放入一个数据，semaphoreOut增加，<br/>
取走一个数据，semaphoreOut减少。<br/>
如果semaphoreOut为0，那么线程阻塞，直到有数据输入。<br/><br/>
最后是两个关键操作：Input和Output。<br/>
两个操作的大体过程都是：<br/><font color="#ff0000">等待信号量、互斥量<br/>
操作<br/>
释放信号量、互斥量</font><br/><br/><font color="#0000ff">四。I/O流程和死锁</font><br/><br/>
先来看我最初流程：<br/><font color="#ff00ff"><br/>
输入：</font><br/>
wait for mutexLock<br/>
wait for semaphoreIn<br/>
input some data<br/>
release semaphoreOut<br/>
release mutexLock<br/><font color="#ff00ff">输出：</font><br/>
wait for mutexLock<br/>
wait for semaphoreOut<br/>
ouput some data<br/>
release semaphoreIn<br/>
release mutexLock<br/><br/>
乍看起来还像那么回事，<br/>
结果第一次跑就卡起来了。<br/><br/>
想了很久，才意识到同步顺序上存在问题，<br/>
所以搞出了可耻的死锁。。<br/><br/>
以上面的流程为例。<br/>
假设管道位于初始状态，则里面没有任何内容。<br/>
现在一个线程开始要求输出，<br/>
首先，该线程对mutexLock的等待会立即返回。<br/>
然后，该线程开始等待semaphoreOut。<br/>
由于semaphoreOut还是0，于是阻塞起了。<br/>
这个时候，有另外一个线程准备对管道进行输入。<br/>
本来的设想是，一旦有了输入，之前的线程就可以继续工作。<br/>
但实际情况是，这个输入线程对mutexLock的等待会阻塞。<br/>
这样，两边都卡起了，既不能输入，也不能输出。<br/><br/>
所以需要对流程顺序作出调整，<br/>
先对信号量进行等待，<br/>
得到信号量表示输入或者输出操作是可行的，<br/>
然后才对循环队列的锁进行等待。<br/><br/>
改正过后的流程为：<br/><br/><font color="#ff00ff">输入：</font><br/><br/>
wait for semaphoreIn<br/><font color="#ff0000">wait for mutexLock</font><br/>
input some data<br/><font color="#ff0000">release mutexLock</font><br/>
release semaphoreOut<br/><br/><font color="#ff00ff">输出：</font><br/><br/>
wait for semaphoreOut<br/><font color="#ff0000">wait for mutexLock</font><br/>
ouput some data<br/><font color="#ff0000">release mutexLock</font><br/>
release semaphoreIn<br/><br/>
对这个教训进行一点归纳，可以提升到方法论的层面：<br/><font color="#ff0000">对互斥量的等待和释放操作应该紧包对互斥资源访问的代码段。</font><br/>
（如同改正后流程中标红所示的内容）<br/><br/>
最后，就像WaitForSingleObject的参数所示，<br/>
对于等待操作，我们可以指定一个时间。<br/>
由于上层的阻塞与否，是取决于信号量的，<br/>
所以对信号量的等待，应该交由上层来指定超时时间。<br/>
而对互斥量的等待，是用于同步对循环队列的访问，<br/>
其中包含的代码段是我们已知和可控的。<br/>
一般来说，如果不出现正在访问队列的线程时间片用完，<br/>
那么这个操作都是可以瞬间完成的。<br/>
所以对于mutexLock的等待就使用INFINITE（-1）的超时值。<br/><br/><font color="#0000ff">五。delete和delete[]</font><br/><br/>
可以说，这又是一个极其惨痛的教训。<br/>
由于写C++的时间变少了，<br/>
没有注意到这两者还有区别，<br/>
导致开始运行的时候出现了奇怪的现象。<br/><br/>
基本原则倒是很简单：<br/><font color="#ff0000">使用new的用delete销毁，<br/>
使用new xx[]的用delete[]销毁。</font><br/><br/>
不过我这里还是对现象的调试过程记录下，<br/>
其中有不少可以沿用到其他地方的经验。<br/><br/>
由于创建的时候，要存储一堆数据，肯定用的是new xx[]的形式。<br/>
在销毁的时候，没有注意到，直接写了个delete。<br/><br/>
第一个现象就是，程序运行完后，发现没有自动结束。<br/>
（由输出可以判断，自己写的流程已经走完）<br/>
在vs2008下试的时候，就一直卡在那里，感觉很奇怪。<br/><br/>
开始怀疑是不是main函数没有结束，<br/>
于是在自身逻辑完的时候，手动调用exit。<br/>
当然，现象还是一样的。<br/><br/>
遂注释掉原来的main函数，<br/>
自己手写了一个空的main函数，<br/>
结果是程序依然会卡住。<br/><br/>
之后换回VC6进行调试，发现在卡了几秒后会有ASSERTION错误。<br/>
看下信息，应该是debug模式对堆进行检查时所报的错。<br/><br/>
没有想明白，开始散弹枪调试了。。<br/>
依次把各个部分注释掉，<br/>
发现一旦没有用我的管道类就不会出这个问题。。。<br/><br/>
检查管道类，没有看出问题，再次散弹枪调试。<br/>
管道类中，原来使用的是<br/>
CPipe&lt;string , 3&gt; pipe;<br/>
内含的是一组string对象，改成其他类型试试。<br/>
发现一旦改成int这些基本类型，就不会出错。<br/><br/>
而这些基本类型和string和区别就在于其构造和析构。<br/>
基本类型是有trivial constructor的，而string不行。<br/>
故又检查了对象的创建与销毁，但还是没有发现delete[]的问题。<br/><br/>
最后又是一次散弹枪调试，<br/>
把管道类中的各个部分依次注释了看，<br/>
发现不析构居然就不会有任何问题，<br/>
看来bug一定就在析构函数里面。<br/>
这个时候，再仔细看，终于发现了可耻的delete。。。<br/><br/><font color="#ff0000">散弹枪调试是很暴力、很终极的调试手段，<br/>
但使用它的时候，往往意味着我们已经失去分析问题的理智。。</font><br/><br/>
在这个问题上花了近一个小时之后，<br/>
好生想了一下，其实合格的debug过程应该是这样的：<br/><font color="#ff0000">1。发现自身逻辑完了，程序还没结束。<br/>
2。肯定是有代码还在运行，不管是自己写的还是系统的。<br/>
3。断到main的结束，发现确实运行过了return。<br/>
4。能够在main之后运行的代码一般只有onexit指定的函数或者全局对象的dtor。<br/>
5。我没有onexit过，所以肯定是的dtor中出的问题。<br/>
6。detor中的一般操作是对资源的释放。<br/>
7。内存管理的时候，delete和new存在配对问题，着重检查。<br/>
8。debug结束。</font><br/><br/>
只有清晰的思路才能指导清晰的行动。<br/>
乱枪打鸟就是典型的土鳖表现。<br/>
为了避免经常土鳖，<br/>
多睡一小时觉其实比多debug两个小时还有效。<br/><br/><font color="#0000ff">六。控制台IO</font><br/><br/>
管道类到这里算是折腾完了，<br/>
结果写测试程序的时候又被囧了一下。<br/>
弄了个生产者和消费者的模型，<br/>
最先写出来的运行效果犹如这样：<br/><br/>
get stuff 81<br/><font color="#ff0000">Produce &#8216;product 81&#8217;<br/>
Produce &#8216;product 81&#8217;</font><br/>
Consume &#8216;product 81&#8217;<br/>
get stuff 82<br/><br/>
可以看到，有两个Procude xxxx。<br/>
在有的地方又可以观察到两个Consume xxx。<br/>
但通过对代码的跟踪，和打印一些中间结果，<br/>
可以确定，对管道的输入输出一个产品只对应了一个操作。<br/><br/>
这就让人觉得很诡异，无法弄清楚究竟是哪里出的毛病。<br/>
对控制台IO函数进行检查，<br/>
也会发现其实只调用了一次。。<br/><br/>
今天中午再来看这个问题，<br/>
突然意识到：<br/><font color="#ff0000">控制台在这里也是个临界资源，需要进行互斥访问。。</font><br/><br/>
于是速度写个控制台的类：<br/>
class CConsole{<br/>
private:<br/>
HANDLE mutexLock ;<br/>
public:<br/>
CConsole(){<br/>
mutexLock = CreateMutex(NULL , FALSE , NULL) ;<br/>
}<br/><font color="#ff0000">void Write(char *p){<br/>
WaitForSingleObject(mutexLock , INFINITE) ;<br/>
printf(&#8220;%s&#8221; , p) ;<br/>
ReleaseMutex(mutexLock) ;<br/>
}</font><br/>
} ;<br/><br/>
对控制台的输出就通过Write成员函数进行。<br/><br/>
没想到一加上这个，输出就变正常了。<br/><font color="#ff0000">但之前为什么不是输出内容交错，<br/>
而是输出内容重复呢？</font><br/>
这个问题暂时还没解决。。<br/><br/><font color="#0000ff">七。相关代码下载</font><br/><br/>
pipe.h，管道类，包含可用。<br/>
pipetest.cpp，正常的测试样例。<br/>
pipetest2.cpp，没有考虑控制台问题的测试代码。<br/><br/><a target="_blank" href="http://www.box.net/shared/cv73fe113q">下载地址</a><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/06/06/MapReduce--SimplifiedModelingofThePhisicalWorld/">MapReduce&#8211;Simplified Modeling of the Phisical World</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-06-06T15:25:00+08:00" pubdate data-updated="true">Jun 6<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.6.6<br/><br/>
讲解MapReduce的原文：<a href="http://labs.google.com/papers/mapreduce.html" target="_blank">下载</a><br/><br/>
原来的题目是：<strong>MapReduce: Simplified Data Processing on Large Clusters </strong><br/><br/>
草草阅读之后，有点感悟，<br/>
觉得MapReduce的关键在于提出了一个简易的建模方法，<br/>
也就是本篇的题目了。。<br/><br/><font color="#0000ff">》》精髓</font><br/><br/>
MapReduce的关键在于，<br/>
它对现实世界中的问题进行了归纳，<br/>
发现<font color="#ff0000">有一大类问题可以用Map和Reduce两个过程</font>来表达。<br/>
当然，有的问题只需要Map就可以表达，<br/>
而另一些问题只需要Reduce就可以表达，<br/>
这两类都是MapReduce的子集。<br/><br/>
通过这样的建模之后，<br/>
并行计算的过程就只有两步：<br/><font color="#ff0000">1。在一个集群上，实现Map和Reduce之间关联的机制，也就是引擎。<br/>
2。把原问题用Map和Reduce两个过程来表达。</font><br/><br/><font color="#0000ff">》》适用的问题类型</font><br/><br/>
能够用MapReduce来表达的问题，往往都这样的特点：<br/><font color="#ff0000">(1)可以用简单而暴力的语言来书写；<br/>
(2)往往涉及到“遍历”这样的操作；<br/>
(3)遍历的往往是个“集合”，也就是遍历动作可交换，可结合；<br/>
(4)输入变量，中间变量，输出变量，一般都具有&lt;key,value&gt;的形式。</font><br/><br/><font color="#ff00ff">例1：</font>数组中的所有元素都加1<br/>
for ( i = 0 ; i &lt; n ; i ++ )<br/>
{<br/>
a[i]++;<br/>
}<br/>
（算法大意）<br/><br/><font color="#ff00ff">例2：</font>实现从离散概率密度函数（pdf）到离散概率分布函数（cdf）的计算<br/>
for ( i = 1 ; i &lt; n ; i ++ )<br/>
{<br/>
cdf[i]=cdf[i-1]+pdf[i] ;<br/>
}<br/>
（算法大意）<br/><br/>
其中，例1就满足各个条件，在后面可以看到，能够用MapReduce来解决。<br/><br/>
例2虽然也有遍历动作，但不满足条件（3）。<br/>
对于cdf，我们必须处理了cdf[i-1]，才能推知cdf[i]。<br/>
后面可以看到，虽然通过对问题转化，<br/>
可以实现MapReduce，<br/>
但那样的并发没有提高任何效率。<br/><br/><font color="#ff00ff">例3：</font>统计url的访问次数。<br/>
输入：一堆log，每有一次访问，就写一条url在里面<br/>
输出：每个url，后面带一个数字，表示访问次数<br/>
暴力算法如下：<br/>
把log一条条读进来，<font color="#ff9900">是a就给a加上1，是b就给b加上1</font>。<br/><br/><font color="#ff00ff">例3</font>也具有很好的“MapReduce形态”：<br/>
（1）我们很容易得到一个简易而暴力的算法。<br/>
（2）输入的log文件具有&lt;文件名，文件内容&gt;的形式<br/>
（3）中间变量具有&lt;url，1&gt;的形式（上面标黄的那句话即是这个意思）<br/>
（4）输出变量有&lt;url，次数&gt;这样的形式<br/>
（5）我先读哪个log文件，不影响最后的结果。<br/>
（6）对每个log文件，我先处理最后一行，还是第一行，不影响最后的结果。<br/><br/><font color="#0000ff">》》什么是Map，什么是Reduce？</font><br/><br/>
首先引用官方的说法：<br/>
Map接手一个&lt;key,value&gt;的数据对，输出一个&lt;key,<font color="#ff0000">value</font>&gt;的中间数据。<br/>
MapReduce引擎负责搜集所有中间的&lt;key,value&gt;数据，<br/>
按照key把他们组合起来，然后把&lt;key,<font color="#ff0000">values</font>&gt;传递给Reduce过程。<br/>
Reduce接收&lt;key,values&gt;这样的中间数据，把values进行约化（合并）。<br/><br/>
为了直观地理解Map，先来看看普通方法对例3的实现。<br/>
通过上面对例三的分析，我们最容易想到的是用STL的map来做存储结构。<br/>
那么整个算法过程如下：<br/><font color="#ff9900"><br/>
input(documents)<br/><br/>
for (each d in documents)<br/>
{<br/>
for (each line in d.content)<br/>
{<br/><font color="#ff0000">map[line] = map[line] + 1 ;</font><br/>
}<br/>
}<br/><br/>
for (each element in map)<br/>
{<br/>
output(element.key,element.value) ;<br/>
}</font><br/><br/>
其中，标红的这句是整个计算任务的核心。<br/>
由于在问题的表述过程中，<br/>
中间变量存在明显的&lt;key,value&gt;这样的形式，<br/>
所以我们很容易想到STL里面的map。<br/><br/>
在上例中，Map函数的任务是产生<br/>
&lt;line,1&gt;这样的一个数据对，这和STL中map存储的pair是类似的。<br/><br/>
再来看Reduce。<br/><br/>
根据官方定义，Reduce函数得到的应该这样的东西<br/>
&lt;url1,{1,1,1,1,1}&gt;<br/>
&lt;url2,{1,1,1,1,1,1,1,1,1}&gt;<br/>
这里的<font color="#ff0000">values</font>是由map函数产生的多个中间数据的列表。<br/>
而Reduce输出的是这样的：<br/>
&lt;url1,5&gt;<br/>
&lt;url2,9&gt;<br/>
可以明显地看到输入列表被结合起来了，成为了一个单个的数值。<br/><font color="#ff0000">Reduce的输出往往是1个或者0个，（原文2节1段）<br/>
从效果上看，就好像输入数据被Reduce了一样。</font><br/><br/><font color="#0000ff">》》建模</font><br/><br/>
上一节对Map和Reduce进行认识的时候，<br/>
已经用Map和Reduce来表达例3这个问题了，<br/>
并且这是原文中的经典例子，<br/>
所以下面来看下例1和例2的建模方法。<br/><br/><font color="#ff00ff">例1：</font>数组中的所有元素都加1<br/>
for ( i = 0 ; i &lt; n ; i ++ )<br/>
{<br/>
a[i]++;<br/>
}<br/><br/>
MapReduce模型：<br/>
Map(数组下标，数组元素)<br/>
{<br/>
EmitIntermediate(数组下标，数组元素)<br/>
}<br/>
Reduce(数组下标，数组元素)<br/>
{<br/>
Emit(数组下标，数组元素+1)<br/>
}<br/><br/>
这里的Map函数相当于是一个Identity函数，<br/>
它输出的是输入本身。<br/>
这样情况出现在使用Map或者Reduce单个即足以建模的情况，<br/>
则另外一个可以使用Identity函数。<br/><font color="#0000ff"><br/>
》》带问题转化的建模</font><br/><br/><font color="#ff00ff">例2：</font>实现从离散概率密度函数（pdf）到离散概率分布函数（cdf）的计算<br/><font color="#ff9900">for ( i = 1 ; i &lt; n ; i ++ )<br/>
{<br/>
cdf[i]=cdf[i-1]+pdf[i] ;<br/>
}</font><br/><font color="#ff00ff">（写法1）</font><br/><br/>
上面分析过，例2并不适合用MapReduce来建模，<br/>
但通过改变我们对问题的基本认识，也是可以办到的。<br/>
改写算法如下：<br/><font color="#ff9900">for ( i = 1 ; i &lt; n ; i ++ )<br/>
{<br/>
for ( j=0 ; j &lt;=i ; j++ )<br/>
{<br/>
cdf[i] = cdf[i] + pdf[j] ;<br/>
}<br/>
}</font><br/><font color="#ff00ff">（写法2）</font><br/><br/>
改写后的关键区别在于，<br/><font color="#ff0000">计算的输出结果cdf[]前后元素之间的耦合关系被去除了。</font><br/>
每个cdf[i]都是可以独立计算的，而不依赖以前的结果。<br/><br/>
这时，可以构造MapReduce框架如下：<br/><br/>
Map(pdf的下标，pdf的元素)<br/>
{<br/>
for ( i = pdf的下标 ;<font color="#ff0000"> i &lt;= n</font> ; i ++ )<br/>
{<br/>
EmitIntermediate(i，pdf的元素)<br/>
}<br/>
}<br/><br/>
Reduce(cdf的下标，{一个数值列表} l )<br/>
{<br/>
total = 0 ;<br/>
for ( i = 0 ; i &lt; l的长度 ; i ++ )<br/>
{<br/>
total = total + l[i] ;<br/>
}<br/>
Emit(cdf的下标，total)<br/>
}<br/><br/>
这里的Reduce函数看起来问题不大，<br/>
但Map函数里面的i&lt;=n的实现就有点困惑了。<br/>
由于对pdf[i]我们要把它的值加到cdf[i..n]的元素中，<br/>
所以这是个必要的过程，但这个n要怎么传进去呢？<br/><br/>
其实各种变通的方法还是挺多的。<br/>
如果引擎支持对全局参数设定，那么n就放在一个全局位置。<br/>
不过这样的解法有点破坏完美主义，因为我们给了Map额外的信息。<br/>
还有个办法就是先把pdf数组做个reverse操作，<br/>
这样我们发送的中间变量为&lt;0..i,pdf[i]&gt;，<br/>
得到的cdf显然也是反的，最后再reverse一下即可。<br/><br/>
为了讨论问题叙述简单，就假设上面的Map在实现上没有问题。<br/><br/>
这里，我们可以看到，<br/>
有些表面上<font color="#ff0000">不适合MapReduce的问题</font>也可以转化过来。<br/>
现在的遗留问题是，<font color="#ff0000">这样的转化在多大程度上是有意义的呢</font>？<br/><br/>
由于并行计算中，耗时取决于最长通路，<br/>
所以我们主要考察最长的Map到Reduce的途径。<br/>
先看Map，每个Map发射中间值&lt;i..n，pdf[i]&gt;。<br/>
最慢的Map肯定是第一个元素，发射了n次。<br/>
再看Reduce，每个Reduce要累加收到的所有数值，<br/>
最多的一个，cdf[n]=pdf[0]+pdf[1]&#8230;+pdf[n]。<br/><br/>
也就是说，在这个框架下，计算效率是O(n)的。<br/>
再看下我们的<font color="#ff00ff">（写法1）</font>，很明显，也就是O(n)的。。。<br/><br/>
从绝对效果来看，这样的并行化并没有起到作用。<br/>
那是不是意味着MapReduce在这里失去意义了呢？<br/><br/>
其实也不尽然，<font color="#ff0000">关键在于我们是如何对原始问题进行第一表达的</font>。<br/>
在pdf转cdf这个问题中，我们也许可以很容易地写出O(n)的解法。<br/>
但是如果有个类似问题，我们拿到的时候只写出了<font color="#ff00ff">（写法2）</font>，<br/>
那么我们将花费n方的时间，而我们手里有MapReduce这样的工具，<br/>
并且转化很明显，于是问题在n的时间内得到的解决。<br/><br/>
再思考为什么写法1并不适合MapReduce化，<br/>
我们可以发现，他利用了输出结果间的相关性。<br/>
从本质上来说，这里原来就已经是一个效率的提升了。<br/><font color="#ff0000">而不适合MapReduce的问题，很多时候可能就是由于这种相关性。<br/>
所以我们在解除相关性的同时，一般来说会增加计算开销。<br/>
再由MapReduce的并行化来提高效率，整个过程走了一点弯路。</font><br/><br/>
所以根据对问题的第一表达：<br/>
如果有很好的MapReduce形态，那就用吧；<br/>
如果不是很明显的MapReduce形态，大多数情况下应该可以不用了。<br/><br/><font color="#0000ff">》》实现关键</font><br/><br/>
在整个系统中，引擎实际上是很关键的。<br/>
用自然语言描述一下：<br/>
MapReduce引擎负责搜集所有中间的&lt;key,value&gt;数据，<br/>
按照key把他们组合起来，然后把&lt;key,<font color="#ff0000">values</font>&gt;传递给Reduce过程。<br/><br/>
其实这个动作很明显就是一个map，或者说一个hashtable。<br/>
那么整个引擎的底层可以概括地认为是一个<font color="#ff0000">分布式的map（hashtable）</font>。<br/>
当然，最容易实现的就是hashtable了。<br/><br/>
假设我们有许多的运行map过程的mapper机器，<br/>
有许多运行reduce过程的reducer机器，<br/>
此外，还有一个负责控制的master机器，相当于引擎。<br/>
那么整个过程为：<br/>
master对任务进行划分，传给各个mapper，<br/>
mapper把计算到的中间结果&lt;key,value&gt;传给master，<br/>
master对key调用确定的hash算法，可以得到负责该key的reducer是谁，<br/>
master把这个中间结果交给这个reducer，<br/>
最后master收集reducer的处理结果，整理输出（比如可以按照key进行排序。。。）<br/><br/>
其中有些过程只是表述模型所用，在实现上可以另辟蹊径的。<br/>
比如mapper不用把中间结果交给master，而是自己去找reducer，<br/>
只要所有mapper运行的hash算法是一样的，<br/>
那么&lt;key,value&gt;对总是会交到正确的reducer手上。<br/><br/>
当然，都通过master有个好处，<br/>
就是master可以把握各个机器的进度，<br/>
对于出了问题的mapper，可能很久都收不到中间值，<br/>
那么master可以重新启动一个mapper，而忽略以前的结果。<br/><br/>
妄想一下，如果有个超人在全球的PC上实现了这套引擎，<br/>
那么将实现多么强大的计算能力。<br/><br/>
但这套底层机制的实现是很困难的，<br/>
一些比较明显想到的问题有：<br/><font color="#ff0000">master的单点故障，<br/>
网络传输带宽的问题，<br/>
文件存储的问题。<br/></font><br/>
master的单点故障是系统结构固有的，<br/>
从它交master这个名字就会得知了。<br/>
在我们遇到的各种系统中都会有这个问题，<br/>
一般考虑多机备份等手段。<br/><br/>
网络传输带宽对于全球化来说，是个超级问题。<br/>
因为地区发展的不平衡，网管策略的不同，<br/>
很难协调各个机器的工作。<br/>
所以一般是在机房里面，<br/>
在高性能交换机连接的集群上实现这个引擎。<br/><br/>
文件存储就是一个更伤脑经的问题了。<br/>
我们先把输入和输出都用“文件”这个概念来表达，<br/>
那么master一开始将分割输入文件，再递交给各个mapper。<br/>
如果输入文件一开始是只存在于master上的，<br/>
那么master的网络传送负担将相当的重。<br/>
也许一个报文从UESTC穿越GFW到达米国的的时间就远大于本地计算开销。<br/>
即使对于一个机房中的集群来说也是如此，<br/>
master还没来得及把文件传给后面的mapper，<br/>
前面的mapper就在纷纷递交结果了。。<br/>
而google这套机制的优势在于，<br/>
他们早就有了分布式的GFS文件系统。<br/>
文件本来就在各个mapper手上，<br/>
而且往往一份文件会在3个机器上有备份。<br/>
那么master在分配任务的时候，<br/>
可以尽量把各个机器本地持有的文件输入给相应的mapper。<br/>
再高级一点，master可以掌握机房的交换线路图，<br/>
当机器非本地持有文件的时候，<br/>
尽量让临近节点间进行文件交互（比如同一个交换机下）。<br/><br/>
===<br/><br/>
ORZ，出来这么久的东西杂现在才知道喃。。<br/><img src="http://img.baidu.com/hi/jx2/j_0025.gif"/><br/>
看来还得继续在土鳖阵营里待一段时间了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/06/05/%E7%AE%80%E6%98%93%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8D%8F%E8%AE%AE%E7%9A%84CS%E6%A1%86%E6%9E%B6%EF%BC%88SOCKETselect%EF%BC%89/">简易字符串协议的C/S框架（SOCKET Select）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-06-05T21:15:00+08:00" pubdate data-updated="true">Jun 5<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.6.5<br/><br/><a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/181d9a52a8158f020df3e34a.html">上一篇</a>做了服务端引擎，这篇把客户端引擎也弄好了。<br/><br/>
下载地址：<br/><a target="_blank" href="http://www.box.net/shared/2gvt846unl">ThunderCS2010.6.5</a>。<br/>
SAMPLE中是一个交互式聊天的示例。<br/><br/>
运行效果：<br/><br/><span><img border="0" class="blogimg" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/c022ad869226300266096e33.jpg"/></span><br/><br/><br/>
完成客户端编程框架。<br/>
由于引擎的主要难点在于底层的组装机制，<br/>
所以可以沿用服务器的代码。<br/>
而且客户端避免了管理多个套接字的麻烦，<br/>
从服务端代码简化即可得到。<br/><br/>
上层代码构建方式也类似服务端，<br/>
首先派生ThunderClient类，<br/>
然后对Process和Run进行定制。<br/><br/>
同样的，Process也会收到下层递交过来的完整PDU。<br/><br/>
客户端向服务端发送PDU使用函数：Request。<br/>
跟服务端的函数在名字上对偶：Request/Respond。<br/><br/>
服务端在编程的时候，一般不考虑退出的问题。<br/>
所以在最简框架中也没提供相关的机制。<br/>
如果检测到套接字失效，直接删除即可。<br/><br/>
客户端不同，根据用户的需要应该可以主动退出。<br/>
并且客户端检测到套接字失效的时候也需要有机制通知上层。<br/>
于是提供了两个额外的函数：<br/>
Exit()，先关闭套接字，然后转换为退出状态；<br/>
Exited()，可以检测当前是否为退出状态。<br/><br/>
于是客户端的循环框架可以变为：while ( !Exited() )<br/><br/>
服务器端一般只处理与网络有关事件，<br/>
故在大多数情况下，可以不重载Run函数。<br/><br/>
客户端除了处理网络事件外，<br/>
还需要处理用户的一些操作所产生的事件，<br/>
所以往往需要重载Run函数。<br/><br/><font color="#0000ff">》》样例代码：</font><br/><br/>
Proces函数直接显示收到的字符串。<br/><br/>
重载了Run函数。<br/>
使用kbhit来判断是否按键，然后进行处理。<br/>
这样不会因为等待SOCKET或者键盘事件而阻塞了。<br/><br/>
一般情况下，需要编写的仅为红色的部分。<br/><br/>
class MyClient : public ThunderClient{<br/>
public:<br/>
MyClient(std::string ipAddress , unsigned short uPort , int maxcheck)<br/>
:ThunderClient(ipAddress , uPort , maxcheck){} ;<br/><br/><font color="#ff0000">    int Process(std::string &amp;str){<br/>
printf(&#8220;%s\n&#8221; , str.c_str()) ;<br/>
return 0 ;<br/>
}<br/><br/>
void Run(){<br/>
std::string str = &#8220;&#8221; ;<br/>
while ( !Exited() ){<br/>
MakeReadList() ;<br/>
MakeWriteList() ;<br/>
MakeExceptList() ;<br/>
Select(0 , 10000) ;<br/>
LaunchEvent() ;<br/>
if ( kbhit() ){<br/>
char ch = getch() ;<br/>
printf(&#8220;%c&#8221; , ch) ;<br/>
if ( ch == &#8216;\n&#8217; || ch == &#8216;\r&#8217;){<br/>
printf(&#8220;\n&#8221;) ;<br/>
Request(str) ;<br/>
if ( str == &#8220;exit&#8221; ){<br/>
Exit() ;<br/>
}<br/>
fflush(stdin) ;<br/>
str = &#8220;&#8221; ;<br/>
} else {<br/>
str += ch ;<br/>
}<br/>
}<br/>
}<br/>
}</font><br/>
} ;<br/><br/><br/>
int main(){<br/><br/>
WORD wVersionRequested;<br/>
WSADATA wsaData;<br/>
int err;<br/><br/>
wVersionRequested = MAKEWORD( 1, 1 );<br/><br/>
err = WSAStartup( wVersionRequested, &amp;wsaData);<br/>
if (err!=0){<br/>
return err;<br/>
}<br/><br/>
if (LOBYTE ( wsaData.wVersion) != 1 ||<br/>
HIBYTE ( wsaData.wVersion) != 1){<br/>
WSACleanup();<br/>
return 0;<br/>
}<br/><br/><font color="#ff0000">    char buf[MaxBuf] ;<br/>
puts(&#8220;input server&#8217;s ip:&#8221;) ;<br/>
gets(buf) ;<br/>
MyClient mc(buf , SERVER_PORT , 500) ;<br/>
mc.Connect() ;<br/>
mc.Run() ;</font><br/><br/><br/>
WSACleanup();<br/>
return 0 ;<br/>
}<br/><font color="#0000ff"><br/>
》》其他改进</font><br/><br/>
对服务端引擎也进行了一定改造。<br/>
提供FirstPeer()和NextPeer()组合函数，<br/>
用于对从套接字进行遍历。<br/><br/><font color="#ff0000">(2010.6.10)<br/><br/>
补充编写文档。</font><br/><br/>
含编写文档的ThunderCS2010.6.5<a href="http://www.box.net/shared/2oux4qshg5" target="_blank">：下载</a>。<br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/06/03/%E7%AE%80%E6%98%93%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6%EF%BC%88SOCKETselect%EF%BC%89/">简易字符串服务器框架（SOCKET Select）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-06-03T21:25:00+08:00" pubdate data-updated="true">Jun 3<span>rd</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.6.3<br/><br/><font color="#0000ff">》》需求</font><br/><br/>
做一套字符串的协议，为简化上层开发，先做一个服务器的框架。<br/><br/>
这里的字符串还是C风格的标准，使用&#8217;\0&#8217;结尾。<br/>
既然是基于字符串的协议，那么一个完整的字符串即可作为一个PDU。<br/>
一个完整PDU联合服务器记录的状态信息，应该是可以进行解释的。<br/><br/>
而SOCKET层的收发是不能保证一次性整字符串的传输 。<br/>
对于接收动作来说，可能对方的PDU被分片，<br/>
或者己方给recv函数的接受缓存过小 ，需多次接收。<br/>
对于发送动作来说，可能系统准备的缓冲区有限，<br/>
一个PDU还没有发完，send就会引发WSAEWOULDBLOCK错误，<br/>
这就要求在下一次继续发送。<br/><br/>
当我们在编写高层逻辑的时候，还得随时将这些装在脑子里，会比较累。<br/>
做的这个引擎和高层使用STL的string进行交互：<br/>
递交高层处理的是完整字符串，为一个独立的语义单元；<br/>
高层向引擎直接派发完整字符串，不会阻塞，由引擎负责发送。<br/><br/>
框架和样例：<a href="http://www.box.net/shared/0t2ibv9udj" target="_blank">下载地址</a><br/>
sample中的server使用该框架编写。<br/><br/><font color="#0000ff">》》使用方法</font><br/><br/>
1。包含头文件ThunderCS.h<br/><br/>
2。从类ThunderServer派生出MyServer<br/>
3。编写Process虚函数<br/>
4。如果有必要可以编写Run虚函数<br/><br/>
5。初始化环境（比如windows下的WSAStartup之类）<br/>
6。MyServer.Initialize()<br/>
7。Myserver.Run()<br/><br/><font color="#0000ff">》》Process编写方法</font><br/><br/>
int Process(std::string &amp;str , SOCKET sock)<br/>
从str可以得到一个完整的字符串，也就是PDU，可以进行解读并决定下一步操作。<br/>
sock是收到该字符串套接字，用于更复杂编写时关联状态信息。<br/><br/>
GetAddress()函数可以得到与套接字相关的地址<br/>
Respond()函数可以向客户发送字符串，非阻塞<br/>
RemovePeerSocket()函数用于结束对某套接字的服务<br/><br/><font color="#0000ff">》》样例代码</font><br/><br/>
需要手写的部分用红色标注。<br/>
详情见下载文件中的sample，有详细注释。<br/><br/>
class MyServer : public ThunderServer{<br/>
public:<br/>
MyServer(int BackLog , unsigned short ListeningPort)<br/>
: ThunderServer(BackLog , ListeningPort){}<br/>
int Process(std::string &amp;str , SOCKET sock){<br/><font color="#ff0000">        std::string ServerResponse = &#8220;&#8221; ;<br/>
ServerResponse = &#8220;I received your &#34;&#8221; + str + &#8220;&#34;&#8221; ;<br/>
Respond(ServerResponse , sock) ;<br/>
SOCKADDR_IN addr ;<br/>
addr = GetAddress(sock) ;<br/>
printf(&#8220;(%s:%u):%s\n&#8221; , inet_ntoa(addr.sin_addr) , ntohs(addr.sin_port) , str.c_str()) ;<br/>
if ( str == &#8220;exit&#8221; ){<br/>
RemovePeerSocket(sock) ;<br/>
}</font><br/>
return 0 ;<br/>
}<br/>
} ;<br/><br/>
int main(){<br/><br/>
WORD wVersionRequested;<br/>
WSADATA wsaData;<br/>
int err;<br/><br/>
wVersionRequested = MAKEWORD( 1, 1 );<br/><br/>
err = WSAStartup( wVersionRequested, &amp;wsaData);<br/>
if (err!=0){<br/>
return err;<br/>
}<br/><br/>
if (LOBYTE ( wsaData.wVersion) != 1 ||<br/>
HIBYTE ( wsaData.wVersion) != 1){<br/>
WSACleanup();<br/>
return 0;<br/>
}<br/><font color="#ff0000"><br/>
MyServer ms(5 , SERVER_PORT) ;<br/>
ms.Initialize() ;<br/>
ms.Run() ;</font><br/><br/>
WSACleanup();<br/>
return 0 ;<br/>
}<br/><br/>
运行效果：<br/><br/><span><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/ea07a164c9c462ccf63654d5.jpg" small="0" class="blogimg"/></span><br/><br/><br/><font color="#0000ff">》》设计大体思路</font><br/><br/>
使用select来做事件引擎。<br/><br/>
接收缓存：<br/>
std::map&lt;SOCKET , std::string&gt; mRecvBuf ;<br/>
使用map来关联和特定套接字相关的string。<br/>
在select触发的read事件中，向该string中拼接收到的内容。<br/>
如果发现已经收到一个完整的字符串（发现&#8217;\0&#8217;），<br/>
则递交Process处理。<br/><br/>
发送缓存：<br/>
std::map&lt;SOCKET , std::list&lt;std::string&gt; &gt; mSendBuf ;<br/>
上层调用Respond的时候，将PDU（即一字符串）插入到关联的list最后。<br/>
每一轮select会先将mSendBuf中，list不为空的套接字放发writefds里面。<br/>
一旦某套接字可以进行发送，则会触发write事件。<br/>
在write事件中，提取list中的第一条字符串。<br/>
尽力发送该字符串，如果发送完，则删除该字符串，<br/>
如果没有发送完，则将残余字符串放到list首部。<br/><br/><font color="#0000ff">》》下一步</font><br/><br/>
sample里的client写得很土，而且是非多路复用的，<br/>
client只能一收一发，而无法应对多次接收的情况。<br/><br/>
有时间也整个字符串客户机的框架。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/06/03/802.1X%E7%9A%84%E4%B8%BB%E5%8A%A8%E5%92%8C%E8%A2%AB%E5%8A%A8%E6%A8%A1%E5%BC%8F/">802.1X的主动和被动模式</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-06-03T15:50:00+08:00" pubdate data-updated="true">Jun 3<span>rd</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.6.3<br/><br/>
今天接入网实验又弄了一次802.1X，<br/>
比较了主动和被动的一点区别。<br/><br/>
从客户端的现象上来说，应该都是一样的；<br/>
交换机和RADIUS服务器之间的交互没法抓包，故没研究；<br/>
所以主要是从客户端抓包，看下区别。<br/><br/><font color="#0000ff">》》环境</font><br/><br/>
交换机：RG-S2026F<br/>
PC：XP<br/>
认证方式：MD5质询<br/><br/><font color="#0000ff">》》认证模型简述：</font><br/><br/>
客户&lt;&#8211;&gt;交换机&lt;&#8211;&gt;RADIUS服务器<br/><br/>
802.1X是跑在客户和交换机这一段。<br/><br/>
理论上，客户主动发起的认证过程为：<br/>
&#8211;&gt;EAPOL-start<br/>
&lt;&#8211;EAP-identity-request<br/>
&#8211;&gt;EAP-identity-response<br/>
&lt;&#8211;EAP-MD5-Challenge-request<br/>
&#8211;&gt;EAP-MD5-Challenge-respone<br/>
&lt;&#8211;EAP-Success<br/><br/>
理论上，由认证PAE（交换机）发起的认证为：<br/>
&lt;&#8211;EAP-identity-request<br/>
&#8211;&gt;EAP-identity-response<br/>
&lt;&#8211;EAP-MD5-Challenge-request<br/>
&#8211;&gt;EAP-MD5-Challenge-respone<br/>
&lt;&#8211;EAP-Success<br/><br/><font color="#0000ff">》》交换机被动模式的交互序列（默认配置）</font><br/><br/><span><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/ab4bc711d1b8552cb8127b3d.jpg" small="0" class="blogimg"/></span><br/><br/>
和理论上的过程是一致的。<br/><br/><font color="#0000ff">》》交换机主动模式的交互序列</font><br/><br/><span><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/c14806f47e9ed9d37709d73d.jpg" small="0" class="blogimg"/></span><br/><br/>
因为有一些其他的干扰报文，只关注类型为EAP几个。<br/><br/>
在交换机主动模式下，查找前后报文，看不到EAPOL-start。<br/>
而这几个比较集中的报文中，初看起来，缺少了EAP-identity-request。<br/>
如果再向前面找一下，<font color="#ff0000">有的时候</font>是可以发现一个EAP-identity-request的，<br/>
如果有该报文，一般可能与集中的部分都隔得比较远。<br/><br/><font color="#0000ff">》》现象总结</font><br/><br/>
从抓包的结果来看，EAPOL-start这个包是没有看到的。<br/>
而不管在主动模式和被动模式下，抓下来的都是同样的5个报文。<br/>
区别在于交换机主动模式下，EAP-identity-request会在认证报文集中位置的前面。<br/><br/><font color="#0000ff">》》分析</font><br/><br/>
在被动模式下，当客户需要认证的时候，会触发交换机的认证。<br/>
具体来说，就是在XP中输入用户名和密码，点确定，<br/>
之后交换机用一个EAP-identity-request开启认证过程。<br/>
这里肯定是有触发的机制的，既然不是EAPOL-start，<br/>
肯定是有其他东西的，这个还得再细看。<br/><br/>
在主动模式下，交换机检测到链路有效，则开始认证。<br/>
为了触发XP中输入认证信息的气泡框，<br/>
我们的操作是先禁用网卡，然后启用。<br/>
而网卡要启用后，在Wireshark中才会看到 ，进而开始抓包。<br/>
网卡一启用，交换机立即检测到，并且发送EAP-identity-request准备开始认证。<br/>
这个时候，Wireshark上可能还没有开始抓包，<br/>
于是出现了看不到EAP-identity-request的情况。<br/>
有的时候，操作比较快，当然就看到了EAP-identity-request。<br/><br/>
在用户输入账户信息之前，XP收到EAP-identity-request，<br/>
于是状态发生转换，所以输入账户之后，<br/>
可以直接从EAP-identity-response开始认证交互。<br/><br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/05/19/matlab%E9%A5%BC%E5%9B%BE%EF%BC%88pie%EF%BC%89%E8%87%AA%E5%8A%A8%E5%BF%BD%E7%95%A50%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/">Matlab饼图（pie）自动忽略0值的问题</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-05-19T20:22:00+08:00" pubdate data-updated="true">May 19<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.5.19<br/><br/>
比如我们现在用pie画饼图，用legend添加标签：<br/><br/><font color="#ff9900">a = [ 1 0 2] ;<br/>
b = {&#8216;l1&#8217; , &#8216;l2&#8217; , &#8216;l3&#8217;} ;<br/>
pie(a) ;<br/>
legend(b) ;</font><br/><br/>
效果如下：<br/><span><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/c0b2c6bfb5ba403018d81f04.jpg" small="0" class="blogimg"/></span><br/>
其实明明是第2项没有值，但最后结果是l3这个标签不见了。。<br/><br/>
这个时候，matlab的命令行里面有警告：<br/>
Warning:<font color="#ff0000"> Ignoring non-positive </font>data in pie chart. <br/>
&gt; In pie at 41<br/>
In myplots at 27<br/>
Warning: Ignoring extra legend entries. <br/>
&gt; In legend at 294<br/>
In myplots at 28<br/><br/>
就是这样，非正数被忽略掉了。。。<br/><br/>
没其他的办法，用个比较投机的：<br/><br/><font color="#ff9900">a = [ 1 0.000001 2] ;<br/>
b = {&#8216;l1&#8217; , &#8216;l2&#8217; , &#8216;l3&#8217;} ;<br/>
pie(a) ;<br/>
legend(b) ;</font><br/><br/>
结果：<br/><span><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/81b892221c32ccc9d6cae205.jpg" small="0" class="blogimg"/></span><br/>
会多出一个&#8221;&lt;1%&#8221;的项，不过这样还行了，至少能把图例和图对应。<br/><br/><br/><br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/05/16/%E5%A4%8D%E6%95%B0%E4%B9%98%E6%B3%95%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%EF%BC%8842%EF%BC%8C33%EF%BC%89/">复数乘法的两种实现（4/2，3/3）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-05-16T10:58:00+08:00" pubdate data-updated="true">May 16<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.5.16<br/><br/>
我们的计算平台一般都是实数运算，<br/>
所以做复数乘法的时候，转换为实数乘法和加法。<br/><font color="#ff0000">设所用乘法n次，加法m次，则记这种实现法为n/m。</font><br/><br/>
有两个复数：a+bi，c+di<br/>
设结果为：x+yi<br/><br/><font color="#0000ff">一。4/2</font><br/><br/>
直接展开，根据定义即可求得：<br/>
x+yi=ac-bd+(bc+ad)i<br/>
故，<br/>
x=ac-bd<br/>
y=bc+ad<br/><br/>
总共使用四次实数乘法和两次实数加法。<br/><br/>
这种实现法是通用的。<br/><br/><font color="#0000ff">二。3/3</font><br/><br/>
这种实现的应用有限制，<br/><font color="#ff0000">适合在其中一个数为定值的时候使用。</font><br/><br/>
设a+bi是那个已经确定的数，<br/>
预处理得，<br/>
p=a+b<br/>
q=a-b<br/><br/>
计算：<br/><font color="#ff0000">w=a(c+d)</font><br/><font color="#ff0000">x=w-pd</font>=ac+ad-ad-bd=ac-bd<br/><font color="#ff0000">y=w-qc</font>=ac+ad-ac+bc=ad+bc<br/><br/>
红字为计算部分，后面是简要证明。<br/>
可以看到总共需要实数乘法3次，实数加法3次。<br/><br/><font color="#0000ff">三。小节</font><br/><br/>
3/3法比4/2法在实现上应该会快一些，<br/>
因为它增加了一次加法，而减少了一次乘法。<br/>
至少在我们目前的平台上，加法会比乘法快。<br/><br/>
这种效率的提升有基本前提，<br/>
即是其中的一个数必须是已知的，<br/>
这样才能预处理出p和q。<br/><br/>
这个基本前提使得3/3法不是通用的。<br/>
但在诸如FFT的计算中，<br/>
旋转因子是已知的，<br/>
可以在蝶形运算开始之前预处理出来。<br/>
在这样的情形下，3/3法就有不少的价值了。<br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/05/14/%E5%88%9D%E5%A7%8B%E5%8C%96%E7%B1%BB%E4%B8%AD%E5%BC%95%E7%94%A8%E5%9E%8B%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%88VC6.C2758%EF%BC%89/">初始化类中引用型的成员变量（VC6.C2758）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-05-14T11:13:00+08:00" pubdate data-updated="true">May 14<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.5.14<br/><br/>
昨天跟T哥讨论实现传递类成员函数指针，<br/>
T哥有份一直没编译通，<br/>
最后发现是这个问题。<br/>
遂试了下，仔细想想很合逻辑，但之前还真没注意到过。<br/><br/>
例子：<br/><br/><font color="#ff9900">class mycls<br/>
{<br/>
int &amp;i ;<br/>
mycls(int &amp;i_in){<br/>
i = i_in ;<br/>
}<br/>
} ;</font><br/><br/>
报错为：<br/><br/><font color="#ff0000">error C2758: &#8216;i&#8217; : must be initialized in constructor base/member initializer list</font><br/><br/>
这段代码看上去很逼真，为什么要报错呢。<br/><br/>
其实只要知道引用是由编译器用指针实现的，<br/>
而我们把引用转化为指针一般只有下面几个步骤：<br/><br/><font color="#ff0000">1.定义的地方换成指针（比如int &amp;i换成int <em>i）<br/>
2.函数形参，把引用也换成指针<br/>
3.函数实参，加取地址符<br/>
4.初始化引用的地方右值取地址<br/>
5.其他代码块中凡是遇到引用变量的表达式，换成脱指针（比如i=1换成</em>i=1）</font><br/><br/>
例子：<br/><br/>
void f(int &amp;i){}<br/>
int main(){<br/>
int i = 0 ;<br/>
int &amp;r = i;<br/>
f(r) ;<br/>
return 0;<br/>
}<br/><br/>
根据第1、2条：<br/><br/>
void f(int <font color="#ff0000"><em>i</font>){}<br/>
int main(){<br/>
int i = 0 ;<br/>
int <font color="#ff0000"></em>r</font> = i;<br/>
f(r) ;<br/>
return 0;<br/>
}<br/><br/>
第4条：<br/><br/>
void f(int <em>i){}<br/>
int main(){<br/>
int i = 0 ;<br/>
int </em>r =<font color="#ff0000"> &amp;i;</font><br/>
f(r) ;<br/>
return 0;<br/>
}<br/><br/>
第3、5条：<br/><br/>
void f(int <em>i){}<br/>
int main(){<br/>
int i = 0 ;<br/>
int </em>r = &amp;i;<br/>
f(<font color="#ff0000">&amp;<em>r</font>) ;<br/>
return 0;<br/>
}<br/><br/>
当然，上面的函数部分会被优化一下：<br/><br/>
void f(int </em>i){}<br/>
int main(){<br/>
int i = 0 ;<br/>
int <em>r = &amp;i;<br/>
f(r) ;<br/>
return 0;<br/>
}<br/><br/>
改过之后是下面这个样子：<br/><br/><font color="#ff9900">class mycls<br/>
{<br/>
int </em>i ;<br/>
mycls(int <em>i_in){<br/>
</em>i = <em>i_in ;<br/>
}<br/>
} ;</font><br/><br/>
这段代码可以编过了，但我们一眼就看出问题在哪了。<br/>
i这个指针现在的值根本就没有确定，<br/>
直接脱指针肯定会出问题的。<br/><br/>
但实际上，上面那段引用所想表达的本来意思是：<br/><font color="#ff9900"><br/>
class mycls<br/>
{<br/>
int </em>i ;<br/>
mycls(int <em>i_in){<br/>
i = i_in ;<br/>
}<br/>
} ;</font><br/><br/>
这里就是<font color="#ff0000">易用性和灵活性</font>的一个矛盾了。<br/>
引用使我们不用在使用的时候打上&amp;或者</em>这样的符号，<br/>
这是易用的一面，但同时降低了灵活性，<br/>
每当遇到引用类型的变量名时，<br/>
都是按照脱指针来处理的，<br/>
这样我们想使用该变量内含的地址都没办法了。<br/><br/>
根据C2758后面的提示信息，最前面的代码修改为：<br/><br/><font color="#ff9900">class mycls<br/>
{<br/>
int &amp;i ;<br/>
mycls(int &amp;i_in):i(i_in)<br/>
{<br/>
}<br/>
} ;</font><br/><br/>
就是把引用类型的初始化放到初始化列表中去。<br/><br/></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/backup-hplonline/blog/page/4/">&larr; Older</a>
    
    <a href="/backup-hplonline/blog/archives">Blog Archives</a>
    
    <a class="next" href="/backup-hplonline/blog/page/2/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/backup-hplonline/blog/2013/05/04/test/">Test</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/04/09/%E5%86%8D%E8%B0%88stl%E7%9A%84rotate/">再谈stl的rotate</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%BA%8C%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、二）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%89%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、三）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%80%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、一）</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - hplonline -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
