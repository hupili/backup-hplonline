
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>hplonline</title>
  <meta name="author" content="hplonline">

  
  <meta name="description" content="(hplonline)2010.2.20
这几天本来不该写东西的，
但是不小心看到好东西，
没时间做，还是记几点想法。
在matrix67这里看到的文章。1.目的
把不可导的max函数近似成为可导的指数对数函数，
是个很不错的事情。
用处是很显然的，
本来需要耗时的数值算法的地方， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hupili.github.io/backup-hplonline/blog/page/6">
  <link href="/backup-hplonline/favicon.png" rel="icon">
  <link href="/backup-hplonline/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/backup-hplonline/atom.xml" rel="alternate" title="hplonline" type="application/atom+xml">
  <script src="/backup-hplonline/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/backup-hplonline/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/backup-hplonline/">hplonline</a></h1>
  
    <h2>backup from 2006 to 2012 (original hi.baidu.com/hplonline/)</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/backup-hplonline/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hupili.github.io/backup-hplonline" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/backup-hplonline/">Blog</a></li>
  <li><a href="/backup-hplonline/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/02/20/%E7%AE%80%E8%AE%B0%EF%BC%8Csoftmaximum%EF%BC%8C/">简记，soft Maximum，</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-02-20T14:00:00+08:00" pubdate data-updated="true">Feb 20<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.2.20<br/><br/>
这几天本来不该写东西的，<br/>
但是不小心看到好东西，<br/>
没时间做，还是记几点想法。<br/><br/>
在matrix67这里看到的<a href="http://www.matrix67.com/blog/archives/2830" target="_blank">文章</a>。<br/><br/><font color="#0000ff">1.目的<br/></font><br/>
把不可导的max函数近似成为可导的指数对数函数，<br/>
是个很不错的事情。<br/>
用处是很显然的，<br/>
本来需要耗时的数值算法的地方，<br/>
可能直接推导出闭合的表达式。<br/>
在一些实际问题中，<br/>
满足一定精度就行了。<br/><br/><font color="#0000ff">2.改进精度调整<br/></font><br/>
想法是看到了地核maa04的留言后出来的。<br/>
“abs(0)的值和ln(exp(0)+exp(0))的距离有点远……”<br/><br/>
仿照原文中用k去调整精度的方法，<br/>
可以先对x、y加上某个大常数，最后再减去这个常数。<br/>
如果把原文的乘k视作正比放大，<br/>
这个改进的调整算是<font color="#ff0000">线性变换</font>。<br/><br/>
因为指数函数的目的在于放大差异，<br/>
所以想办法把指数部分弄大就行了。<br/>
当指数部分经过0的附近的时候，<br/>
通过找个大正数，总可以偏移到足够大的地方。<br/><br/>
反正就是想办法把x换成 k<em>x+b，<br/>
使得k</em>x+b是个很大的正数就行了。<br/><br/>
具体的效果有待以后在实践中绘图看看，这里就打住了。<br/><br/><font color="#0000ff">3.其他近似函数</font><br/><br/>
瞟了下<a href="http://www.johndcook.com/blog/2010/01/13/soft-maximum/" target="_blank">原文</a>，和下面的留言。<br/>
从wiki上得到了一点启示。<br/><br/>
用p-范数(p-norm)来说这个问题。<br/>
对于一个向量x，<br/>
2-norm(x)是它的模，<br/>
∞-norm(x)是它最大的分量的绝对值。<br/>
微积分里面也证过这个结论。<br/><br/>
于是可以用p-norm来提取最大的一个分量，让p足够大即可。<br/><br/>
注意到norm的表达式里面是有绝对值的，<br/>
这样使得近似max(,)以求可导的本意被破坏了。<br/><br/>
所以可以考虑给各个分量加上一个正大常数C，<br/>
这样就可以甩掉绝对值，<br/>
开了p次方之后再减去这个C即可。<br/><br/>
这里的p和C是经验性选取的，<br/>
如同前一条的k和b一样。<br/><br/><font color="#ff0000">未验证效果。</font><br/><br/><font color="#0000ff">4.理论比较</font><br/><br/>
这两个方法的核心思想在于扩大原各个比较项的差异，<br/>
使得在加法意义下，小项被忽略掉。<br/><br/>
而指数函数比幂函数更陡，<br/>
所以原文的指数函数应该比后面p-norm这方法逼近。<br/><br/>
p-norm这种方法在接近各项接近0的时候一样会有问题，<br/>
所以也需要对各项在处理前后调整下。<br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/02/18/vista%E4%BD%BF%E7%94%A8showwindow%E7%9A%84%E4%B8%80%E7%82%B9%E9%97%AE%E9%A2%98/">Vista使用showwindow的一点问题</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-02-18T14:58:00+08:00" pubdate data-updated="true">Feb 18<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.2.18<br/><br/>
目的就是当某人打开某窗口的时候，<br/>
就把该窗口关掉，防止乱操作。<br/><br/>
代码如下：<br/><br/>
HWND hwnd = ::GetForegroundWindow() ;<br/>
const MAX_BUF = 100 ;<br/>
char buf[MAX_BUF] ;<br/>
::GetWindowText(hwnd , buf , MAX_BUF) ;<br/>
if ( strstr(buf , &#8220;CCProxy&#8221;) ){<br/>
//MessageBox(buf) ;<br/>
::ShowWindow(hwnd , SW_HIDE) ;<br/>
//::CloseWindow(hwnd) ;<br/>
//::SendMessage(hwnd , WM_CLOSE , 0 , 0) ;<br/>
//::SendMessage(hwnd , WM_SHOWWINDOW , FALSE , SW_OTHERUNZOOM) ;<br/>
}<br/><br/>
把这段放到一个timer的处理函数中就可以反复地检测执行了。<br/><br/>
结果试了很久发现MessageBox都报出窗口名，<br/>
但CCProxy的窗口一直不被隐藏掉。<br/><br/>
最后发现的原因是之前CCProxy是用管理员打开的，<br/>
而这个隐藏程序是用普通权限执行的。<br/>
换成管理员后就有效果了。<br/><br/>
有几个函数有类似的现象，在if块的注释中。<br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/02/15/severaldemonstrationsofdimensionreduction/">Several Demonstrations of Dimension Reduction</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-02-15T13:59:00+08:00" pubdate data-updated="true">Feb 15<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.2.15<br/><br/>
toolbox is obtained from a computer vision scientist&#8217;s homepage,<br/>
once suggested in <a href="http://hi.baidu.com/hplonline/blog/item/39d21530668cc392a8018efa.html" target="_blank">this log</a>.<br/><br/>
for introduction of dimesion reduction, see wiki&#8217;s <br/><a href="http://en.wikipedia.org/wiki/Dimension_reduction" target="_blank"><strong>dimension reduction</strong></a><br/><a href="http://en.wikipedia.org/wiki/Nonlinear_dimensionality_reduction" target="_blank"><strong>nonlinear dimensionality reduction</strong></a><br/><br/>
the original swissroll manifold in 3D space(left),<br/>
and the sampled version of swissroll in 3D space(right).<br/><br/><span><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/01d259435a9103229213c6e5.jpg" small="0" class="blogimg"/></span><br/><br/>
the following images all shows the manifold reduced to 2D space.<br/>
The name of the techniques are put in the title.<br/><br/><br/><span><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/6a210046707f0f3a6a63e51a.jpg" small="0" class="blogimg"/></span><br/><span><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/4868b8b77ec2bdc730add11a.jpg" small="0" class="blogimg"/></span><br/><span><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/63614d10bf7379cfc2ce791a.jpg" small="0" class="blogimg"/></span><br/><span><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/3695942f5169990b1e30891b.jpg" small="0" class="blogimg"/></span><br/><span><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/314e4c23739621619922ed1b.jpg" small="0" class="blogimg"/></span><br/><span><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/8504fa1fee489cc6e1fe0b1b.jpg" small="0" class="blogimg"/></span><br/><span><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/7d6b8a0af3ba0d0db0351de4.jpg" small="0" class="blogimg"/></span><br/><span><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/ba8e094f4c934605aec3abe5.jpg" small="0" class="blogimg"/></span><br/><span><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/a31149161b41fe7921a4e9e5.jpg" small="0" class="blogimg"/></span><br/><span><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/4411b8fb3675dc114e4aeae5.jpg" small="0" class="blogimg"/></span><br/><span><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/76e3c33d8dac8af49e3d62e5.jpg" small="0" class="blogimg"/></span><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/02/07/BFS%2BHASH%E5%88%A4%E9%87%8D%E7%9A%84%E5%87%A0%E7%82%B9%E8%AE%B0%E5%BD%95%EF%BC%88POJ2946%EF%BC%89/">BFS+HASH判重的几点记录（POJ2946）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-02-07T23:28:00+08:00" pubdate data-updated="true">Feb 7<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.2.7<br/><br/>
前天的昨天，有个小朋友问这个题。<br/>
他的主要问题在于模仿一般的BFS寻路的那些题，<br/>
开一个flag[][]去记录一个点访问过没有。<br/>
而推倒箱子后，地图的结构就会变化，<br/>
一个(i,j)完全可能去两次，但第二次flag[i][j]已经标记了，就出问题了。<br/><br/>
为了解释BFS里面的节点不是图上的点，<br/>
而是包含图上点的某种集合，<br/>
只好写一个拿去看看。。<br/><br/>
由于第一盘交的时候，实在是太慢，<br/>
于是后面找了很久的原因，改了又交了好多盘，<br/>
终于从约900ms弄到32ms。。<br/>
记录一些细节问题。<br/><br/><font color="#0000ff">1.按照调试方式编写的段落记得还原</font><br/><br/>
一种是freopen这样的问题，交到POJ上可能WA也可能TLE。<br/>
这个问题比较常见了，也有各种解决方案，<br/>
不过现在不常刷题了，也就没这样弄，想着不会怎么反复调试的。<br/><br/>
我这里还囧了一次，就是hash函数的位置。<br/>
为了分块调试，我的hash函数首先是全返回的0的。<br/>
这样相当于就在0的位置拉一个链表，<br/>
可以先排除hash算法本身的影响。<br/>
结果写完了搞忘改这句就交上去了。<br/>
神奇的是没有TLE，还卡着时间过了。<br/><br/>
我动了下hash表的大小，时间也没变，<br/>
还纳闷是为什么，后来才发现是这个return 0 的问题。<br/><br/><font color="#0000ff">2.hash表的大小问题</font><br/><br/>
在修改了很多细节之后，时间都只是一点点改进，<br/>
于是我把hash表调小了，一下就减少了约300ms。。<br/><br/>
所以这个问题也应该注意。<br/>
hash表太小当然容易冲突，链表一拉长，效率就降下来了。<br/>
hash表太大，虽然冲突可能没啥了，<br/>
但是光用memset初始化一下都得很久。<br/><br/><font color="#0000ff">3.hash函数的选取</font><br/><br/>
这个点上的研究应该是无穷无尽的，<br/>
不同的应用构造不同的hash函数，效果肯定不同。<br/>
我也试过好几个，结果网上找到的这个效果很好：<br/><br/>
int hash(char <em>s)<br/>
{<br/>
int count = sz ;<br/>
unsigned int h=0;<br/>
while ( &#8211;count &gt;= 0 )<br/>
{<br/>
h = h * 31 + </em>s++;<br/>
}<br/>
return h % MAXH;<br/>
}<br/><br/><font color="#0000ff">4.节点的设置</font><br/><br/>
最初的定义：<br/>
typedef struct node_type{<br/>
int i , j ;<br/>
char grids[MAXN][MAXN] ;<br/>
int step ;<br/>
} NODE ;<br/><br/>
最后的定义：<br/>
typedef struct node_type{<br/>
char i , j ;<br/>
char grids[MAXN * MAXN] ;<br/>
} NODE ;<br/><br/>
首先，定义一个二维数组，然后grids[i][j]这样寻址，<br/>
与定义一维数组grids[i * n + j]这样编出来的东西是类似的。<br/>
（二维的话，因为数组尺寸是常量，<br/>
所以可能直接用移位来优化，比如这里的数组是8<em>8的，<br/>
grids[i][j] = (char</em>)grids + ( i &lt;&lt; 3 ) + j ）<br/><br/>
单纯访问地图信息来说，两种定义都差不多，<br/>
但一维的定义更能适应hash上面的hash函数。<br/>
因为hash函数是很频繁调用的，<br/>
所以这样搞可以使得关键地方的寻址变简洁：<br/>
while ( &#8211;count &gt;= 0 )<br/>
{<br/>
h = h * 31 +<font color="#ff0000"> <em>s++;</font><br/>
}<br/><br/>
第二处是把step信息移除了，在外面开一个和队列平行的数组：<br/>
NODE q[MAXQ] ;<br/>
int step[MAXQ] ;<br/><br/>
这样的效果在于<font color="#ff0000">NODE节点包含了确定一个局面所必须且只须的信息</font>。<br/>
最明显的是比较两个节点是否相等的函数，可以直接缩成一句：<br/>
return !memcmp(&amp;n1 , &amp;n2 , sz) ;<br/>
直接库函数比较内存，就比最初定义先比较i，j，再二重循环比较地图好多了。<br/>
对于节点比较这样频繁的操作，细算到这里也是值得的。<br/><br/>
第三处是把i，j定义成char了。<br/>
倒不是为了省空间，主要是统一整个节点的表达。<br/>
i，j的范围本身就很小，用不着int，char就足够。<br/>
然后布局也比较trick，先i，j再放地图。<br/>
再加上地图已经一维化了，<br/>
这样，整个结构中只有前面 n</em>n+2 个字节是有效的。<br/>
于是不管hash还是赋值，都可以直接当成是 n<em>n+2 的字符串。<br/>
这种处理可以使得操作的内存数量减少不少。<br/><br/><font color="#0000ff">5.hash表存储</font><br/><br/>
我比较习惯的定义是：<br/>
HNODE space[MAXQ] , </em>spacehead ;<br/>
HNODE *table[MAXH] ;<br/><br/>
space 为节点本身的空间，<br/>
spacehead用来不重复地取得节点空间。<br/>
每处理完一个case，spacehead=space即可复位，<br/>
不用像动态分配那样去挨个元素释放。<br/><br/>
table用来存储每个key对应的链表表头，<br/>
使用链表头插法来维护。<br/><br/>
最初比较喜欢这种指针定义的table，<br/>
从直觉上来说，貌似比下标定义的要好：<br/>
int table[MAXH];<br/>
相应的hash节点的next域也从指针换成int的下标。<br/><br/>
但实际上，两种定义翻译出来的东西都是类似的。<br/>
比方说从next域取得了值放在eax。<br/>
指针定义的下一步是<br/>
mov xxx,[eax + field_offset] ;<br/>
下标定义的是<br/>
mov xxx,[eax * elem_size + array_offset + field_offset] ;<br/>
array_offset + field_offset能用一个32位的常数偏移量表达。<br/>
关键在于elem_size，如果是2、4、8的话，<br/>
在IA-32指令里面，就可以用一句话表达这个意思，<br/>
否则要多一句话算出eax * elem_size。<br/><br/><br/><br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/01/22/%E5%88%B7%E9%A2%98%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8E%86%E5%8F%B2%EF%BC%88%E9%99%84%E4%B8%80%E4%B8%AAlinux%E5%88%B7%E9%A2%98%E7%94%A8%E8%84%9A%E6%9C%AC%EF%BC%89/">刷题测试的历史（附一个linux刷题用脚本）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-01-22T21:13:00+08:00" pubdate data-updated="true">Jan 22<span>nd</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.1.22<br/><br/>
从最初在OJ上刷题开始，<br/>
我就在关注怎么提高测试效率。<br/>
现在回想起一些以前的行为，<br/>
感觉啼笑皆非。<br/><br/><font color="#0000ff">1.win+TP时代</font><br/><br/>
当时看到过有人写的一个bat，<br/>
比较自动化，依次测试10组数据，<br/>
利用了重定向。<br/>
使用time命令获得程序程序时间。<br/><br/>
而windows下的这个time很戳，<br/>
需要再手动输入一个更新的时间，<br/>
不输入代表不更新。<br/>
于是需要发一个回车键给他。<br/>
一般是在一个文件里面写个 char(13)，<br/>
然后使用time &lt;enter这样的形式解决。<br/><br/><font color="#0000ff">2.win+FP时代</font><br/><br/>
这时候比较傻，除了写点简单题，<br/>
对系统编程，对FP本身的一些支持完全不了解。<br/><br/>
于是我们会在程序开始assign一团文件，<br/>
下面也是writeln(fout,&#8230;)。<br/>
等到该交到OJ上的时候，手动把所有fout去掉。。<br/><br/>
后来想了下也太笨了点，<br/>
至少可以用记事本来个替换也好嘛。<br/><br/><font color="#0000ff">3.win+TC时代</font><br/><br/>
这个时候，沿用了以前FP的方法。<br/>
直到有一天，看到有人直接在控制台下粘贴，<br/>
才知道原来还可以这么玩。。<br/><br/>
发现一般的小数据，粘贴起来很方便。<br/>
对于1写1编1A的情况来说，比较省时。<br/><br/><font color="#0000ff">4.win+VC时代</font><br/><br/>
这个时候，知道了C里面一个好用的东西，<br/>
就是freopen。。<br/><br/>
不过由于不少时候会搞忘注释掉，<br/>
结果会很悲剧。<br/>
有的OJ报个RE之类还看得出来，<br/>
有的OJ直接报个WA，<br/>
结果在自己电脑上看，怎么都像对的。<br/><br/><font color="#0000ff">5.后VC时代1</font><br/><br/>
发现POJ上原来有个<a href="http://hi.baidu.com/hplonline/blog/item/bd4524dd0463bcd18c1029c6.html" target="_blank">ONLINE_JUDGE宏</a>（文章末尾）。<br/>
配合条件编译，似乎是个很不错的东西。<br/><br/>
但是会出现一种囧况，<br/>
就是手抖把ONLINE_JUDGE打错了，<br/>
反正在本机上是未定义的，于是运行正常，<br/>
但是拿到OJ上，一样未定义。<br/>
于是那句freopen就成功把程序搞死了 。<br/><font color="#0000ff"><br/>
6.后VC时代2</font><br/><br/>
采取与ONLINE_JUDGE相反的思路，<br/>
定义LOCAL宏。<br/><br/>
VC的添加位置为：<br/><font color="#ff9900">project-&gt;settings-&gt;C/C++-&gt;options</font><br/>
在里面写上：<br/><font color="#ff9900">/D &#8220;LOCAL&#8221;</font><br/>
就可以了。<br/><br/>
这个宏用起来要安全一点，<br/>
不过编译选项是在工程中指定的，<br/>
这意味着，要保存成果的话，可能需要保存整个工程。<br/><br/>
而我们刷题往往就一个c文件，<br/>
屁股后面还带一堆杂项就显得臃肿了。<br/><br/><font color="#0000ff">7.linux时代</font><br/><br/>
除了前面I/O问题之外，还有时间问题。<br/>
如果在程序里面用clock之类的获得时间，<br/>
交题之前也要记得注释。。<br/>
如果在程序外面 ，由系统命令来搞的话，<br/>
会比较繁琐一点，见【1】。<br/><br/>
后来发现，在linux下，<br/>
很容易就扩展出自己需求的这些功能。<br/><br/>
比如我做一个脚本。<br/>
编译方式选择（要不要调试信息），<br/>
重定向选择（各种I/O组合，选择是否与标准输出对比），<br/>
运行方式选择（直接运行，或者gdb）。<br/>
这些都列一个菜单出来，<br/>
选一下就行了。<br/><br/>
另外使用linux的time来测时间很方便，<br/>
不会受到后面程序重定向的影响。<br/><br/>
于是我现在可以这样操作。<br/>
拿到一个题，把输入放到in.txt里面<br/>
把标准输出放到std.txt里面。<br/>
然后：<br/>
vi hello.c<br/>
&#8230;.<br/>
:w<br/>
:!run hello<br/>
3<br/>
如果数据一致的话，就出现：<br/>
there is no difference, congratulations!!<br/><br/>
然后就可以拿去交了。。<br/>
不过一样可能WA，<br/>
那么我再选5方式运行，<br/>
进入gdb，跟一下。。<br/><br/><font color="#0000ff">程序：/usr/bin/run</font><br/><br/></p>

<h1>!/bin/bash<br/></h1>

<h1>created by hpl<br/></h1>

<h1>2010.1.22<br/></h1>

<h1>to make , run , debug a program automatically<br/><br/></h1>

<p>echo &#8220;select your mode&#8221;<br/>
echo &#8220;1.make,run,with redirected Input&#8221;<br/>
echo &#8220;2.make,run,with redirected Input/Output&#8221;<br/>
echo &#8220;3.make,run,with redirected I/O and compare&#8221;<br/>
echo &#8220;4.make,run,with console I/O&#8221;<br/>
echo &#8220;5.make,debug,with redirected Input&#8221;<br/>
echo &#8220;6.make,debug,with consol Input/Output&#8221;<br/>
echo &#8220;when files are required&#8221;<br/>
echo &#8220;&#8216;in.txt&#8217; is for input&#8221;<br/>
echo &#8220;&#8216;out.txt&#8217; is for output&#8221;<br/>
echo &#8220;&#8216;std.txt&#8217; is for standard output&#8221;<br/><br/>
read mode<br/>
mode=${mode:-&#8220;4&#8221;}<br/><br/>
case $mode in <br/>
&#8220;1&#8221;)<br/>
gcc -o $1 $1.c<br/>
time ./$1 &lt;in.txt<br/>
;;<br/><br/>
&#8220;2&#8221;)<br/>
gcc -o $1 $1.c<br/>
time ./$1 &lt;in.txt &gt;out.txt<br/>
;;<br/><br/>
&#8220;3&#8221;)<br/>
gcc -o $1 $1.c<br/>
time ./$1 &lt;in.txt &gt;out.txt<br/>
re=<code>diff out.txt std.txt</code><br/>
re=${re:-&#8220;there is no difference, congratulations!!&#8221;}<br/>
echo $re<br/>
;;<br/>
&#8220;4&#8221;)<br/>
gcc -o $1 $1.c<br/>
time ./$1 <br/>
;;<br/>
&#8220;5&#8221;)<br/>
gcc -g -o $1 $1.c<br/>
gdb &#8211;args $1 &#8220;&lt;in.txt&#8221;<br/>
;;<br/>
&#8220;6&#8221;)<br/>
gcc -g -o $1 $1.c<br/>
gdb $1<br/>
;;<br/>
*)<br/>
echo &#8220;type mode between 1 and 6 ,please!!&#8221;<br/>
esac<br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/01/21/%E5%90%84%E7%A7%8D%E7%89%88%E6%9C%AC%E7%9A%84memcpy%EF%BC%88%E5%BA%95%E5%B1%82%E4%BC%98%E5%8C%96%EF%BC%89/">各种版本的memcpy（底层优化）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-01-21T15:06:00+08:00" pubdate data-updated="true">Jan 21<span>st</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.1.21</p>


<p>今天无意中看到了一个写法很geek的memcpy：</p>


<p>void duff_memcpy( char* to, char* from, int count ) {<br/>
     size_t n = (count+7)/8;<br/>
     switch( count%8 ) {<br/>
     case 0: do{ *to++ = *from++;<br/>
     case 7:      *to++ = *from++;<br/>
     case 6:      *to++ = *from++;<br/>
     case 5:      *to++ = *from++;<br/>
     case 4:      *to++ = *from++;<br/>
     case 3:      *to++ = *from++;<br/>
     case 2:      *to++ = *from++;<br/>
     case 1:      *to++ = *from++;<br/>
             }while(&#8211;n&gt;0);<br/>
     }<br/>
}</p>


<p>开始觉得很无聊。。把语法搞这么奇怪还没什么实际作用。<br/>
毕竟像这类函数在库中都从底层进行过优化的，<br/>
可以参考去年这几天收藏的memset源码。</p>


<p>后来仔细想了下，觉得有点意思了。<br/>
于是又做了另外的4个版本来进行测试。<br/>
有几个在count为0的时候逻辑上会出错，<br/>
这种细节就没有管了，<br/>
重要通过这几个例子记录一下底层优化的一点手段。</p>


<p><font color="#0000ff">一。实验环境：</font></p>


<p>intel DUO P7350 , VISTA , VC6 ，.C</p>


<p><font color="#ff0000">这里的底层优化是在对底层有所了解的情况下，<br/>
使用纯C的技术进行的优化，</font><br/>
不同于使用内联汇编，<br/>
这些代码应该能在支持标准C的各种地方编译。</p>


<p><font color="#0000ff">二。对原版duff_memcpy的分析</font></p>


<p>void duff_memcpy( char* to, char* from, int count ) {<br/>
     size_t n = (count+7)/8;<br/>
     switch( count%8 ) {<br/>
     case 0: do{ *to++ = *from++;<br/>
     case 7:      *to++ = *from++;<br/>
     case 6:      *to++ = *from++;<br/>
     case 5:      *to++ = *from++;<br/>
     case 4:      *to++ = *from++;<br/>
     case 3:      *to++ = *from++;<br/>
     case 2:      *to++ = *from++;<br/>
     case 1:      *to++ = *from++;<br/>
             }while(&#8211;n&gt;0);<br/>
     }<br/>
}</p>


<p>先不用管那个switch，只管do循环，<br/>
那么每一轮，将赋值8个BYTE的数据。<br/>
而n是对count按8向上取整的值。<br/>
其中的第一次实际上达不到8个，<br/>
这个时候就需要switch的跳转作用，<br/>
余下的是多少次，就跳到多少的case处。</p>


<p>不过大家也看出来了，当count==0时，<br/>
还会至少do一次，实际上是错误的操作。</p>


<p><font color="#0000ff">三。朴素版的memcpy</font></p>


<p>void memcpy1(char *to , char *from , int count){<br/>
     do{<br/>
         *to++ = *from ++ ;<br/>
     }while ( &#8211;count != 0 ) ;<br/>
}</p>


<p>为了和那种do结构照应，也没管count为0的情况。</p>


<p>对比前两个版本，<br/>
即可想象duff版可能有的作用了。<br/>
因为每一轮处理8个数，<br/>
那么，除了余数部分外，<br/>
是1次比较8次赋值。</p>


<p>而朴素版是1次比较1次赋值。</p>


<p>因为<font color="#ff0000">条件跳转对流水线会造成很大的损坏</font>，<br/>
所以减少条件跳转，对效率提高很有意义。<br/>
不过由于现在CPU都有分支预测，<br/>
而对于循环来说，条件会满足N次，<br/>
只有最后一次不满足，于是跳出。<br/>
只要预测机制够强大的话，<br/>
流水线损坏所带来的负面影响可以不用考虑。</p>


<p>尽管如此，多出的7条比较加跳转语句也会有额外开销。</p>


<p><font color="#ff0000">四。利用CPU内在并发性，两路赋值，进行优化</font></p>


<p>void memcpy2(char *to , char *from , int count){<br/>
     char *to0 = to ;<br/>
     char *from0 = from ;<br/>
     char *to1 = to + 1 ;<br/>
     char *from1 = from + 1 ;<br/>
     int n = (count + 1) / 2 ;<br/>
     <br/>
     switch (count &amp; 1){<br/>
     case 0: do{  *to1 = *from1 ; to1 += 2 ; from1 += 2 ;<br/>
     case 1:      *to0 = *from0 ; to0 += 2 ; from0 += 2 ;<br/>
             }while(&#8211;n&gt;0);<br/>
     }<br/>
}</p>


<p>代码的意思实际上是很显然的，<br/>
借鉴了一下duff版的写法。</p>


<p>重要区别在于duff版的8个case只能级联执行，<br/>
前面to和from执行得到的结果讲影响后面的执行。<br/>
而这个2版氛围0和1两个支路，<br/>
即使其中一个支路完全暂停，<br/>
另外一个支路也可以执行并得到正确的结果。<br/>
这就给了CPU发挥其特长的机会，<br/>
把这<font color="#ff0000">两路无耦合的指令并发执行</font>。</p>


<p><font color="#0000ff">五。玩大一点，8路并发</font></p>


<p>基本原理与两路并发是一致的，<br/>
只是如果一来就放8路的代码，<br/>
会把人看晕的，<br/>
所以用两路并发做个原理性的铺垫。</p>


<p>void memcpy3(char *to , char *from , int count){<br/>
#define DEF(x) char*to##x=to+x;char*from##x=from+x <br/>
#define EXEC(x) *to##x=*from##x;to##x+=8;from##x+=8;<br/>
     DEF(0) ;DEF(1) ;DEF(2) ;DEF(3) ;DEF(4) ;DEF(5) ;DEF(6) ;DEF(7) ;<br/>
     size_t n = (count+7)/8;<br/>
     switch( count%8 ) {<br/>
     case 0: do{ EXEC(7) ;<br/>
     case 7:      EXEC(6) ;<br/>
     case 6:      EXEC(5) ;<br/>
     case 5:      EXEC(4) ;<br/>
     case 4:      EXEC(3) ;<br/>
     case 3:      EXEC(2) ;<br/>
     case 2:      EXEC(1) ;<br/>
     case 1:      EXEC(0) ;<br/>
             }while(&#8211;n&gt;0);<br/>
     }     <br/>
#undef DEF<br/>
#undef EXEC<br/>
}</p>


<p><font color="#ff0000">其中用到了宏的连接符“##”。</font><br/>
这样只是为了减少书写的代码量。</p>


<p>从后面的测试中是可以看到，<br/>
3版比2版更快。<br/>
不过并非路数越多越快，<br/>
就像不是越多核的CPU越好一样，<br/>
核间通信的代价会迅速增长。<br/>
所以就不更多路数进行测试了。</p>


<p>该版与duff版比较，效果也是明显的。<br/>
同样的循环次数，不同只在于变量间的耦合关系。<br/>
3版由于解耦合，比duff版快了不少。</p>


<p><font color="#0000ff">六。利用字长，32比特整体赋值</font></p>


<p>如果3版能够看懂，这个版本应该就没啥问题。<br/>
不一样的仅仅在于，按照32bit进行赋值，<br/>
这样可以充分利用CPU的字长，<br/>
再次减少循环的数量。</p>


<p>void memcpy4(char *to , char *from , int count){<br/>
#define DEF(x) int*to##x=(int*)to+x;int*from##x=(int*)from+x <br/>
#define EXEC(x) *to##x=*from##x;to##x+=8;from##x+=8;<br/>
     DEF(0) ;DEF(1) ;DEF(2) ;DEF(3) ;DEF(4) ;DEF(5) ;DEF(6) ;DEF(7) ;<br/>
     int rem = count % 32 ;<br/>
     int n = (count)/32;<br/>
     switch( (count / 4)%8 ) {<br/>
     case 0: do{ EXEC(7) ;<br/>
     case 7:      EXEC(6) ;<br/>
     case 6:      EXEC(5) ;<br/>
     case 5:      EXEC(4) ;<br/>
     case 4:      EXEC(3) ;<br/>
     case 3:      EXEC(2) ;<br/>
     case 2:      EXEC(1) ;<br/>
     case 1:      EXEC(0) ;<br/>
             }while(&#8211;n&gt;0);<br/>
     }     <br/>
     to = (char*)to0 ;<br/>
     from = (char*)from0 ;<br/>
     while ( rem &#8211; != 0 ) {<br/>
         *to ++ = *from ++ ;<br/>
     }<br/>
#undef DEF<br/>
#undef EXEC<br/>
}</p>


<p><font color="#0000ff">七。测试函数</font></p>


<p>5个版本的memcpy都有相同的接口，<br/>
可以编个函数来统一测试。</p>


<p>而这里面的宏，自我感觉比较有味道。<br/>
第一次在实践中体会了这种精简代码的手段。</p>


<p>如果是以前我可能会：<br/>
_judge(memcpy1 , &#8220;memcpy1&#8221;)<br/>
这样句调用。<br/>
而有宏来中转一次之后，只需要：<br/>
judge(memcpy1)<br/>
就可以了。</p>


<p>之所以要传进个字符串，<br/>
是为了在console上打出函数名，<br/>
更方便观察。</p>


<p>typedef void(*FUNC)(char * , char * , int) ;<br/>
#define judge(x) _judge(x , #x) <br/>
#define TEST_LEN 577 <br/>
void _judge(FUNC f , char *name){<br/>
     int i ;<br/>
     char from[TEST_LEN] ;<br/>
     char to[TEST_LEN] ;<br/>
     for ( i = 0 ; i &lt; TEST_LEN ; i ++ ){<br/>
         from[i] = rand() % 1000 ;<br/>
     }<br/>
     printf(&#8220;judging %s\n&#8221; , name) ;<br/>
     (*f)(to , from , TEST_LEN) ;<br/>
     for ( i = 0 ;i &lt; TEST_LEN ; i ++ ){<br/>
         if ( from[i] != to[i] ) break ;<br/>
     }<br/>
     if ( i != TEST_LEN ){<br/>
         printf(&#8220;wrong!\n&#8221;) ;<br/>
     }else{<br/>
         printf(&#8220;right!\n&#8221;) ;<br/>
     }<br/>
}<br/>
#undef TEST_LEN</p>


<p>这个测试关注的是正确性方面的。<br/>
时间测试的话用clock()弄下就行了，<br/>
也可以直接加到这个judge里面来。</p>


<p><font color="#0000ff">八。测试结果</font></p>


<p>对40000000的数据，测试10组求平均的结果：</p>


<p>duff：<br/>
161.3000  <br/>
1：<br/>
238.1000  <br/>
2：<br/>
141.4000  <br/>
3：<br/>
122.4000    <br/>
4：<br/>
38.9000</p>


<p>根据电脑当前的状况，<br/>
测试结果会有所不同，<br/>
但定性的关系仍然是满足的。</p>


<p>第一部分已经对这里的“底层”进行了诠释，就不跟汇编对比了。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/01/20/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%EF%BC%88C%2CC%2B%2B%2Cstdarg.h%2C%E5%85%A8%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%9E%E7%8E%B0%29/">可变参数（C,C++,stdarg.h,全可变参数实现)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-01-20T14:09:00+08:00" pubdate data-updated="true">Jan 20<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.1.20</p>


<p>今天看到湖哥在校内上讨论技术问题。<br/>
隐约对三个点有点印象，于是又细看了一遍。<br/>
简单记几个例子，以后翻来瞟一下就知道啥意思了。</p>


<p>以下都是VC6的结论。<br/>
C表示后缀以.c存储代码，<br/>
C++表示后缀以.cpp存储代码。<br/>
IDE根据后缀来决定调用哪种编译器。</p>


<p><br/><font color="#0000ff">一。C和C++里的可变参数：</font></p>


<p>#include &lt;stdio.h&gt;</p>


<p>void print(int n , &#8230;){<br/>
     int i ;<br/>
     int *p = &amp;n ;<br/>
     p ++ ;<br/>
     for ( i = 0 ; i &lt; n ; i ++ ){<br/>
         printf(&#8220;%d\n&#8221; , *p) ;<br/>
         p ++ ;<br/>
     }<br/>
}</p>


<p>int main(){<br/>
     print(3 , 1 , 2 , 3) ;<br/>
     return 0 ;<br/>
}</p>


<p>这里至少有一个参数，<br/><font color="#ff0000">主要是从这个参数，可以推知后面参数的地址。</font></p>


<p><font color="#0000ff">二。C++支持的写法：</font></p>


<p>void print(&#8230;)<br/>
这样所有参数都是可有可无的了，<br/>
可以通过编译，<br/>
至于怎么索引参数后面再说。</p>


<p>C直接三个点的话，不让编译。</p>


<p><font color="#0000ff">三。C支持的写法：</font></p>


<p>void print(int n){<br/>
     int i ;<br/>
     int *p = &amp;n ;<br/>
     p ++ ;<br/>
     for ( i = 0 ; i &lt; n ; i ++ ){<br/>
         printf(&#8220;%d\n&#8221; , *p) ;<br/>
         p ++ ;<br/>
     }<br/>
}</p>


<p>int main(){<br/>
     print(3 , 1 , 2 , 3) ;<br/>
     return 0 ;<br/>
}</p>


<p>和前面相比，就是把后面三个点给去掉了。<br/>
C是允许函数没有定义就使用的，<br/>
他会假装是个返回int的函数。<br/>
而调用方式和现有定义不一致的时候，<br/>
也是会通过的，比如下面这样都行：<br/>
     print((float)(3) , 1 , 2 , 3) ;</p>


<p>不过上面那段程序编译后，<br/>
编译器会给出警告：<br/>
 warning C4020: &#8216;print&#8217; : too many actual parameters</p>


<p>而实际上，C可以把所有东西都省掉：<br/>
void print()<br/>
至于这样该怎么获得参数，也放在后面说。</p>


<p><font color="#0000ff">四。使用&lt;stdarg.h&gt;来标准化可变参数的操作：</font></p>


<p>#include &lt;stdio.h&gt;<br/>
//#include &lt;varargs.h&gt;<br/>
#include &lt;stdarg.h&gt;</p>


<p>void print(int n , &#8230;){<br/>
     va_list l ;<br/>
     va_start(l , n) ;<br/>
     while ( n &#8211; ){<br/>
         int num = va_arg(l , int) ;<br/>
         printf(&#8220;%d\n&#8221; , num) ;<br/>
     }<br/>
     va_end(l) ;<br/>
}</p>


<p>int main(){<br/>
     print(5 , 1 , 2 , 3 , 4 , 5) ;<br/>
     return 0 ;<br/>
}</p>


<p><font color="#ff9900">va_list是参数列表定义。<br/>
va_start（参数列表，最后一个固定参数）<br/>
&#8211;在开始的时候调用<br/>
va_arg（参数列表，类型）<br/>
&#8211;将参数列表移动向下一个参数位置，并返回“类型”所指定的参数<br/>
va_end（参数列表）<br/>
&#8211;在结束的时候调用</font></p>


<p>其中，varargs.h里面也有几个名字相同的宏。<br/>
不过他的va_start没第二个参数，感觉很奇怪，<br/>
暂时没有时间深入研究，以后再看。</p>


<p><font color="#0000ff">五。stdarg中宏的定义：</font></p>


<p>这个头文件中有若干条件编译，<br/>
跟我平台上对应的是：</p>


<p>#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1) )<br/>
#define va_start(ap,v)  ( ap = (va_list)&amp;v + _INTSIZEOF(v) )<br/>
#define va_arg(ap,t)     ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )<br/>
#define va_end(ap)       ( ap = (va_list)0 )</p>


<p>_INTSIZEOF这个宏用来取得某个类型按照int对齐后的尺寸。<br/>
由于在各个平台上int的定义有所不同，<br/>
另外一般对栈的push和pop操作都是以CPU字长为单位的，<br/>
所以需要这样一个宏，来取得该类型实际所占的空间。<br/>
仔细体会一下他是怎么办到的，其实很有意思。</p>


<p>n按照m向上取整的一般写法为：<br/><font color="#ff0000">(n+m-1) / m * n</font> <br/>
而当m是二的方冪的时候，可以直接把低位清零而得到，<br/>
就形成了这个宏的写法。其实这样是等效的：<br/>
-sizeof(int)<br/>
“-”在补码中的定义本身就是取反加1.</p>


<p>va_start(ap,v)  ( ap = (va_list)&amp;v + _INTSIZEOF(v) )<br/>
v是最后一个固定参数，<br/>
那么将参数列表指针ap赋为他的下一个位置即可。</p>


<p>va_arg(ap,t)     ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )<br/>
这个比较普通，把指针向后移了再返回来取这个出类型为t的一个参数。</p>


<p>我一开始有个问题就是，<br/>
为什么不一开始就让表指针指向参数前一个单元，<br/>
每次取参数的时候，先移动指针，再返回那个位置上的值。<br/>
类似于这样：<br/>
*(t*)(ap += ???)</p>


<p>这里的毛病就在于，<br/>
移动指针需要知道前一个元素的类型，<br/>
这样才能确定需要动多少；<br/>
而返回参数需要知道当前元素的类型。<br/>
于是一个可能的宏会这样定义：<br/>
va_arg(ap , prev_t , cur_t)</p>


<p>这样写起来显然不是很爽。<br/>
程序员需要记忆前一个和当前元素的类型。<br/>
后面将实现消耗一定存储空间，<br/>
让电脑来记忆的写法。</p>


<p><font color="#0000ff">六。全可变参数的写法（C内联汇编)：</font></p>


<p>上面的stdarg给出的解决方案，<br/>
从几个宏就可以明显地看出，<br/>
必须得有至少一个固定参数，<br/>
否则va_start就没法调用。</p>


<p>又如，我想实现这样的功能，<br/>
把传进去的参数都累加起来，<br/>
参数以0表示结束。<br/>
（类似C字符串的思想）<br/>
因为当数很多的时候，<br/>
我不想去数我要加多少个数。<br/>
或者当加数个数改变的时候，<br/>
我直接插到中间就行了，<br/>
只要保证最后一个0。</p>


<p>这两点都刺激我们寻找一种全可变参数的写法。<br/>
在前面的例子中，已经手动遍历过参数列表了，<br/>
但这里的问题在于如何得到第一个参数的位置：</p>


<p>#include &lt;stdio.h&gt;<br/>
int add(){<br/>
     int sum = 0 ;</p>


<p>     int *p ;<br/>
     __asm{<br/>
         lea eax , [ebp + 08h] ;<br/>
         mov p , eax ;<br/>
     }</p>


<p>     while ( *p ){<br/>
         sum += *p ;<br/>
         p ++ ;<br/>
     }</p>


<p>     return sum ;<br/>
}</p>


<p>int main(){<br/>
     printf(&#8220;%d&#8221; , add(7 , 2 , 1 , 3 , 4 , 0)) ;<br/>
     return 0 ;<br/>
}</p>


<p>这段代码显然不是各种环境通用的。<br/>
只要知道了VC编译出来的函数怎么布局内存，<br/>
自然就能想到该怎么办。<br/>
栈中的结构一般来说是<br/>
[ebp + ???h]&#8211;参数n<br/>
[ebp + ???h]&#8211;参数n-1<br/>
[ebp + ???h]&#8211;。。。<br/>
[ebp + 008h]&#8211;参数0<br/>
[ebp + 004h]&#8211;返回地址<br/>
[ebp + 000h]&#8211;ebp<br/>
[ebp - 004h]&#8211;局部变量0<br/>
[ebp - 008h]&#8211;局部变量1<br/>
[ebp + ???h]&#8211;。。。<br/>
[ebp + ???h]&#8211;局部变量n<br/>
[ebp + ???h]&#8211;保护寄存器</p>


<p>（有时候好像还会保存一个框架下界的指针，<br/>
与保存的ebp对应，便于退出函数时进行检查。<br/>
这时候的参数0位置是[ebp + 0ch]，<br/>
具体情况看就行了。）</p>


<p><font color="#0000ff">七。全可变参数（纯C)：</font></p>


<p>有了上面对栈结构的认识之后，<br/>
不用内联汇编，也可以找到这个地址。<br/>
只是这个时候需要借助至少一个局部变量进行界定。</p>


<p>int add(){<br/>
     int sum = 0 ;<br/>
     <br/>
     int *p ;<br/>
     p = &amp;sum + 3 ;</p>


<p>     while ( *p ){<br/>
         sum += *p ;<br/>
         p ++ ;<br/>
     }</p>


<p>     return sum ;<br/>
}</p>


<p><font color="#0000ff">八。stdarg宏的变换写法：</font></p>


<p>int __prev_length ;<br/>
#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1) )<br/>
#define va_start(ap,v)  ( ap = (va_list)&amp;v + _INTSIZEOF(v) ) , __prev_length = 0 <br/>
#define va_arg(ap,t)     ((ap += __prev_length) , __prev_length = _INTSIZEOF(t) , *(t *)ap)<br/>
#define va_cur(ap,t)     (*(t *)ap)<br/>
#define va_end(ap)       ( ap = (va_list)0 )</p>


<p>首先开一个变量记录上一个参数的尺寸。<br/>
在初始化的时候给这个参数置零。<br/>
每次取参数可以先移动，<br/>
再保存当前变量的尺寸，<br/>
最后再返回当前参数。</p>


<p>以前有很长段时间觉得逗号表达式没什么用。<br/>
因为一般用逗号表达式的地方，<br/>
直接用分号都可以拆开成好几个表达式。<br/>
但是在这种类似的单行宏里面就有用了，<br/>
语句可以依次执行，并且最后一个表示为整个逗号表达式的返回值。<br/>
当va_arg(ap,t)单独成一句话的时候，<br/>
用分号和逗号分割倒是问题不大。<br/>
但是可能出现 if ( va_arg(ap , t) ){&#8230;}<br/>
如果是分号的话，就会把客户端的语句给切开，<br/>
最后导致编译错误。</p>


<p><br/></p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/01/19/%E8%A1%A8%E9%A9%B1%E5%8A%A8CRC%EF%BC%8CCRC24A%2CCRC24B%E7%9A%84%E8%AE%A1%E7%AE%97%E7%A8%8B%E5%BA%8F/">表驱动CRC，CRC24A,CRC24B的计算程序</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-01-19T17:31:00+08:00" pubdate data-updated="true">Jan 19<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.1.19<br/><br/>
&#8212;<br/>
简单的CRC。。<br/>
UESTC.SCIE.P2P之用。<br/>
前几期觉得时间紧，不想动手，<br/>
后来发现地球人都在加这分，于是动一下。<br/>
把分刷爆是个不正常的心理，<br/>
但是有这么个不正常的环境，<br/>
才会给这种不正常的机会。<br/>
我始终认为，葡萄本来就是酸的，<br/>
但是我要先吃到了再告诉别人。<br/>
不过下盘究竟还用得上这分没有是个问号了。<br/>
&#8212;<br/><br/><a href="http://www.box.net/shared/yojyvxn8na" target="_blank">资料和程序下载</a><br/><br/>
计算多项式为：<br/><font color="#ff9900">CRC24A:{0 , 1 , 3 , 4 , 5 , 6 , 7 , 10 , 11 , 14 , 17 , 18 , 23}<br/>
CRC24B:{0 , 1 , 5 , 6 , 23 }</font><br/><font color="#0000ff"><br/>
基本原理：</font><br/><br/>
CRC这个东西因为用得特别多，<br/>
很多地方都有讲，比如之前的计通网这样的课。<br/><br/>
原理上就是两个01序列按位相除。<br/>
只是加法的定义为模2加，即异或。<br/>
用数据序列除以生成多项式，<br/>
所得的余数就是CRC的校验序列，<br/>
发送端把这个序列附加在原序列末尾。<br/>
接收端用收到的序列除以生成多项式，<br/>
如果为0的话，即认为没有出错。<br/><br/><font color="#0000ff">表驱动原理：</font><br/><br/>
长期以来，只知其基本原理，没有深入地想过实现的问题。<br/>
最近这个东西是从LTE的模块中分离出来的，<br/>
也就是说不定以后大家的手机中都会有这个，<br/>
因为我们不断收发信息，效率当然要考虑上。<br/><br/>
以24位的生成多项式为例，<br/>
每试除一位，就会影响后面的24位。<br/>
（具体说是可能会跟生成多项式进行异或）<br/>
而异或有个性质，就是满足结合率。<br/>
我按照8个bit进行分组，<br/>
每一组试除完的余数记下来，<br/>
这个余数与后面的24位进行异或是等效的。<br/>
而在计算机实现中，往往字节是最小单位，<br/>
这样做不仅程序上写起来好看，<br/>
而且效率比一个bit一个bit计算要好多了。<br/><br/>
如果是取8bit为一个单位，<br/>
那么总共的情况就是256种。<br/>
可以先预处理，把这张表算出来，<br/>
用到的时候，直接查表就行了，<br/>
所以叫表驱动法。。<br/><br/>
可以考虑的是，增加表的大小。<br/>
比如空间允许的话，可以开个65536的表，<br/>
这样就可以两字节一个单位地运算了。<br/><br/>
另外，CRC查表计算的循环是主要开销，<br/>
可以考虑用内嵌汇编进行优化。<br/><br/>
在VISTA.VC.DEBUG下一次测试结果为：<br/>
未压缩的普通CRC:1165<br/>
8bit压缩的表驱动：23<br/>
8bit压缩表驱动加汇编：16<br/><br/>
更深入的研究还是看下上面的资料看吧，<br/>
英文的，不过写得非常详细。。<br/>
（我还没来得及看。。感觉很详细）<br/><br/><font color="#0000ff">我写戳瓢过的地方：</font><br/><br/><font color="#ff9900">1.signed和unsigned的区别</font><br/><br/>
由于本来该unsigned的东西，用成signed了，<br/>
则可能会出现负值，然后读取到范围外的内存了。<br/>
很囧的是在我做的过程中，<br/>
一直读的都是可行区域，<br/>
所以没有出现access violation，找了很久。<br/><br/>
char在VC里面默认是signed的。<br/><br/>
发现这个问题是因为我后来检查了一下整张CRC字节表，<br/>
发现前127号都是正确的，从128号开始就错了。<br/>
所以意识到可能是这个问题。<br/>
128开始，符号位就取反了，<br/>
signed就会造成不同现象。<br/><font color="#ff9900"><br/>
2.8比特压缩和解压</font><br/><br/>
解压前是1个字节存8个比特，<br/>
解压后是1个字节存1个比特，<br/>
我居然写出了下面这句话来解压。。<br/>
tmp.data[i * 8 + j] = cd.data[i] &amp; ( 1 &lt;&lt; j )<br/><br/>
cd.data[i] &amp; ( 1 &lt;&lt; j ) 确实可以用来提取第j位，<br/>
但是表达式返回的是1，2，4，8&#8230;这样的。<br/>
而解压后的数据应该存为0，1两种。。<br/><br/>
如果把解压后的数据定义成bool型，<br/>
那么C++编译器可以解决这个问题，<br/>
任何非0的数都会被转成1进行存储。<br/><br/>
可是C里面又没有bool这个东西。<br/>
（自己定义的typedef int BOOL ;这种不行）<br/>
关键不在于要多少bit来存，和他的逻辑意义，<br/>
在于编译器的实际操作上。<br/>
比如<br/>
a=1;<br/>
b=2;<br/>
c=a&amp;b;<br/>
对三个int来说，就是0.<br/>
对三个bool来说，就是1.<br/><br/>
所以写的时候得格外小心了。<br/><font color="#ff9900"><br/>
3.汇编寻址不同于C的指针滑动</font><br/><br/>
最初写的是一句：<br/>
mov edx , DWORD PTR code_array[eax] ;<br/><br/>
其中code_array是函数的参数，定义为：<br/>
unsigned int * code_array。<br/><br/>
那句汇编完全是受C指针的影响：<br/>
j = code_array[i] ;这种意思。<br/><br/>
因为C里面已经很方便地处理了指针，<br/>
按照指向的数据类型的长度进行滑动。<br/>
在汇编里面就要自己乘上个尺度因子。<br/><br/>
想到这点后，立刻有了第二版:<br/>
mov edx , DWORD PTR code_array[eax * 4]<br/><br/>
结果依然不对。<br/>
其原因在于，汇编里面只有标号这一说，<br/>
大部分时候，用起来如同变量，但实质不同。<br/>
比如这里的code_array，因为C里定义的是函数参数，<br/>
所以实际上是个标号，标记的是栈上的一个位置。<br/>
VC的编译器选择使用ebp做框架指针，<br/>
所以这个标号的实际地址是类似于：<br/>
ebp+0ch这样。<br/><br/>
比如：<br/>
mov edx , code_array<br/>
相当于：<br/>
mov edx , [ebp+0ch]<br/>
要是让edx代表那个地址应该写成：<br/>
lea edx , code_array<br/><br/>
于是我程序里面的查表本质上应该是这样：<br/>
mov edi , code_array ;<br/>
mov edx , DWORD PTR [edi + 4 * eax] ;<br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/01/16/linuxshell%2BC%2B%2B%E6%9A%B4%E5%8A%9B24%E7%82%B9/">Linux shell+C++暴力24点</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-01-16T19:01:00+08:00" pubdate data-updated="true">Jan 16<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.1.16</p>


<p>24点的程序可以说很多人都写过，<br/>
用不同的语言，不同的思路。<br/>
即使都是全枚举，很多细节也会不一样。</p>


<p>写了一天的文档，累得不行了。。<br/>
以前没写过，正好最近搞linux，就用SHELL和C++来暴力一个24点。</p>


<p><font color="#0000ff">思路：</font></p>


<p>linux的shell有个好处就是可以直接按整形算符计算表达式。<br/>
于是可以把表达式构造好，然后交给shell就行了。<br/>
虽然直接用shell也可以构造表达式，<br/>
但毕竟对C熟悉一点，觉得shell的语法很别扭，<br/>
故就用C++来产生表达式。</p>


<p>我用的方法会产生出重复的，<br/>
但实际上是<font color="#ff0000">交换律、结合律、括号法则等意义下的重复</font>，<br/>
比如，3+4，4+3在我这里就认为是两个表达式。<br/>
要达到绝对化的不重复，写起来就很烦了。<br/>
再说，所有合法的表达式都是在四则运算意义下的重复。<br/>
24=(4-2)*(3+9)<br/>
24=((2*4)*9)/3<br/>
就像上面两个式子整体看上去都是一个意思，怎么能说没重复呢？<br/>
如果我用手把他们的细节遮住，你只可能看到两个24。</p>


<p>首先，对四个数进行全排列。<br/>
1 2 3 4 <br/>
1 2 4 3 <br/>
&#8230;.<br/>
4 3 2 1 <br/>
这个用<font color="#ff0000">next_permutation</font>就出来了。</p>


<p>然后归纳模式，我觉得应该只有下面这几种吧：<br/><font color="#ff9900">     &#8220;((%d%c%d)%c%d)%c%d&#8221; ,<br/>
     &#8220;(%d%c%d)%c(%d%c%d)&#8221; ,<br/>
     &#8220;(%d%c(%d%c%d))%c%d&#8221; ,<br/>
     &#8220;%d%c((%d%c%d)%c%d)&#8221; ,<br/>
     &#8220;%d%c(%d%c(%d%c%d))&#8221; ,</font><br/>
在四个%d的地方，依次填上四个数。<br/>
在有%c的地方填上运算符。<br/>
只考虑了+-*/四种，就依次带入就行了。</p>


<p>够暴力吧，哈哈。</p>


<p><font color="#0000ff">用来计算表达式的shell脚本：cal24.sh</font></p>


<p>#!/bin/bash<br/>
#created by hpl<br/>
#2010.1.16<br/>
#take advantage of linux shell to caculate 24 points</p>


<p>function eval_exp(){<br/>
#     echo $1<br/>
declare -i re=$1<br/>
if [ &#8220;$re&#8221; == &#8220;24&#8221; ] ; then<br/>
echo &#8220;24=$1&#8221;<br/>
fi<br/>
}</p>


<p>eval_exp $1</p>


<p><font color="#0000ff">生成表达式的C++程序：</font></p>


<p><br/>
#include &lt;iostream&gt;<br/>
#include &lt;algorithm&gt;<br/>
#include &lt;stdio.h&gt;</p>


<p>using namespace std ;</p>


<p>char *patterns[] = {<br/>
     &#8220;((%d%c%d)%c%d)%c%d&#8221; ,<br/>
     &#8220;(%d%c%d)%c(%d%c%d)&#8221; ,<br/>
     &#8220;(%d%c(%d%c%d))%c%d&#8221; ,<br/>
     &#8220;%d%c((%d%c%d)%c%d)&#8221; ,<br/>
     &#8220;%d%c(%d%c(%d%c%d))&#8221; ,<br/>
} ;<br/>
const int P_NUM = 5 ;</p>


<p>void brute_force(int *a){<br/>
     const char c[] = &#8220;+-*/&#8221; ;<br/>
     char i[3] , j ;<br/>
     char buffer[100] , cmd[150] ;<br/>
     <br/>
     for ( i[0] = 0 ; i[0] &lt; 4 ; i[0] ++ ){<br/>
         for ( i[1] = 0 ; i[1] &lt; 4 ; i[1] ++){<br/>
             for ( i[2] = 0 ; i[2] &lt; 4 ; i[2] ++){<br/>
                 for ( j = 0 ; j &lt; P_NUM ; j ++ ) {<br/>
                     sprintf(buffer , patterns[j] , a[0] , c[i[0]] ,<br/>
                         a[1] , c[i[1]] , a[2] , c[i[2]] , a[3] , c[i[3]]) ;<br/>
                     sprintf(cmd , &#8220;./cal24.sh &#34;%s&#34; 2&gt; /dev/null&#8221; , buffer) ;<br/>
                     //printf(cmd) ;<br/>
                     system(cmd) ;<br/>
                 }                <br/>
             }<br/>
         }<br/>
     }<br/>
}</p>


<p>int main(){<br/>
     int a[4] ;<br/>
     int i ;<br/>
     printf(&#8220;please input 4 numbers , seperate by blanks:\n&#8221;) ;<br/>
     for ( i = 0 ; i &lt; 4 ; i ++ ){<br/>
         scanf(&#8220;%d&#8221; , &amp;a[i]) ;<br/>
     }<br/>
     sort(a , a + 4) ;<br/>
     do{<br/>
         brute_force(a) ;        <br/>
         /*     for ( i = 0 ; i &lt; 4 ; i ++ ){<br/>
         printf(&#8220;%d &#8221; , a[i]) ;<br/>
         }<br/>
         printf(&#8220;\n&#8221;) ;<br/>
         */<br/>
     }while ( next_permutation(a , a+4)) ;<br/>
     return 0 ;<br/>
}</p>


<p><br/><font color="#0000ff">运行示例：</font></p>


<p>please input 4 numbers , seperate by blanks:<br/>
4 2 3 9<br/>
24=((2*4)*9)/3<br/>
24=(2*4)*(9/3)<br/>
24=(2*(4*9))/3<br/>
24=2*((4*9)/3)<br/>
24=2*(4*(9/3))<br/>
24=((2*9)/3)*4<br/>
24=(2*(9/3))*4<br/>
24=2*((9/3)*4)<br/>
24=((2*9)*4)/3<br/>
24=(2*(9*4))/3<br/>
24=2*((9*4)/3)<br/>
24=3*(4+(9/2))<br/>
24=((3+9)/2)*4<br/>
24=3*((9/2)+4)<br/>
24=(3+9)*(4-2)<br/>
24=((3+9)*4)/2<br/>
24=(3+9)*(4/2)<br/>
24=(4-2)*(3+9)<br/>
24=(4/2)*(3+9)<br/>
24=(4-2)*(9+3)<br/>
24=((4*2)*9)/3<br/>
24=(4*2)*(9/3)<br/>
24=(4*(2*9))/3<br/>
24=4*((2*9)/3)<br/>
24=4*(2*(9/3))<br/>
24=(4/2)*(9+3)<br/>
24=(4*(3+9))/2<br/>
24=4*((3+9)/2)<br/>
24=(4+(9/2))*3<br/>
24=((4*9)*2)/3<br/>
24=(4*(9*2))/3<br/>
24=4*((9*2)/3)<br/>
24=(4*(9+3))/2<br/>
24=4*((9+3)/2)<br/>
24=((4*9)/3)*2<br/>
24=(4*(9/3))*2<br/>
24=4*((9/3)*2)<br/>
24=((9*2)/3)*4<br/>
24=((9*2)*4)/3<br/>
24=(9*(2*4))/3<br/>
24=((9/2)+4)*3<br/>
24=((9+3)/2)*4<br/>
24=((9/3)*2)*4<br/>
24=(9/3)*(2*4)<br/>
24=(9+3)*(4-2)<br/>
24=((9+3)*4)/2<br/>
24=(9+3)*(4/2)<br/>
24=((9/3)*4)*2<br/>
24=(9/3)*(4*2)<br/>
24=((9*4)*2)/3<br/>
24=(9*(4*2))/3<br/>
24=((9*4)/3)*2</p>


<p><font color="#0000ff">遗留问题：</font></p>


<p>由C程序产生的表达式，有不少是可能出现错误的。像<br/><font color="#ff0000">declare -i k=&#8221;1/(1-1)&#8221;</font><br/>
执行时就会报一个除0错误。</p>


<p>由于没有找到容错的方法，<br/>
只有在调用的时候来个 <font color="#ff0000">2&gt; /dev/null</font><br/>
。。。</p>


<p>还是vb系列的很好用。。<br/>
不管啥错误，<br/>
一句on error resume next 。<br/>
或者on error goto就解决了。</p>


<p>另外，这个程序会跑比较久才有结果，<br/>
毕竟写起来方便，用起来就慢了。。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2010/01/14/%E4%BF%A1%E9%81%93%E5%9D%87%E8%A1%A1%E7%9A%84%E4%B8%80%E4%B8%AAMATLAB%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/">信道均衡的一个MATLAB仿真实验</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-01-14T15:53:00+08:00" pubdate data-updated="true">Jan 14<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2010.1.14<br/><br/>
这学期学了通原，<br/>
虽然知道点基本概念，<br/>
不过大多会在数日之后搞忘。<br/>
想起前天居然没考信道均衡，<br/>
相当不解。。<br/>
毕竟信道均衡是我们这次新教材添加进的内容。<br/><br/>
再想下平时上课看的课件也有很多老教材的影子，<br/>
可见整个事情就是新瓶旧酒。<br/>
一样的老师，一样的课件，一样的实验，一样的考试，<br/>
就换了本书。<br/><br/>
好不容易所有试都考完了，<br/>
蛋疼一下，做个信道均衡的实验。<br/>
用的就是最简单的迫零均衡，<br/>
不过效果似乎没有想象中的那么好，<br/>
均衡前后听着都是嗡嗡的。<br/>
主要在通过2N+1抽头的均衡器后，<br/>
整个系统响应中间的2N+1个系数满足要求了，<br/>
但之外的系数反而会由零变成有值的，<br/>
同样引入ISI。<br/><br/>
示例程序和音乐<a href="http://www.box.net/shared/jkdz1vpt32" target="_blank">下载</a>。<br/><br/><font color="#0000ff">程序：</font><br/><br/>
（请不要使用太长的音乐，否则会filter很久）<br/><br/>
function main<br/>
[y fs nbits] = wavread(&#8216;origin.wav&#8217;) ;<br/><br/>
% wavplay(y , fs) ;<br/><br/>
N = 100 ;<br/>
h = rand(1 , 2 * N + 1) ;<br/>
yy = filter(h , [1] , y) ;<br/>
wavplay(yy , fs) ;<br/><br/>
c = get_equiv(h) ;<br/>
yyy = filter(c , [1] , yy) ;<br/>
wavplay(yyy , fs) ;<br/><br/>
return ;<br/><br/>
%forcing to zero algorithm<br/>
function c = get_equiv(h)<br/>
M = length(h) ;<br/>
N = (length(h) - 1) / 2 ;<br/>
h = fliplr(h) ;<br/>
H = [] ;<br/>
for ii = 1:N<br/>
tmp = h(N - ii + 2 : M) ;<br/>
tmp = [tmp , zeros(1 , N + 1 - ii)] ;<br/>
H = [H ; tmp] ;<br/>
end<br/>
H = [H ; h] ;<br/>
for ii = 1:N<br/>
tmp = zeros(1 , ii) ;<br/>
tmp = [tmp , h(1:M-ii)] ;<br/>
H = [H ; tmp] ;<br/>
end    <br/>
%hE = H * c<br/>
hE = [zeros(N , 1) ; 1 ; zeros(N , 1)] ;<br/>
c = H \ hE ;<br/>
return ;</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/backup-hplonline/blog/page/7/">&larr; Older</a>
    
    <a href="/backup-hplonline/blog/archives">Blog Archives</a>
    
    <a class="next" href="/backup-hplonline/blog/page/5/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/backup-hplonline/blog/2013/05/04/test/">Test</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/04/09/%E5%86%8D%E8%B0%88stl%E7%9A%84rotate/">再谈stl的rotate</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%BA%8C%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、二）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%89%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、三）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%80%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、一）</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - hplonline -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
