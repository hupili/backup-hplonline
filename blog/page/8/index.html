
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>hplonline</title>
  <meta name="author" content="hplonline">

  
  <meta name="description" content="(hplonline)2009.12.29 三个星期前做微机原理实验的时候，
问某牛应该怎么查看文件属性。
感觉相当惭愧啊。。
都大三的人了，连linux都不会用。 最近偷点闲，看了下鸟哥的那本书。
还不错。。知道点基本的东西了。
就写这么个查看文件属性的脚本来练练手。 主要是if,for, &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hupili.github.io/backup-hplonline/blog/page/8">
  <link href="/backup-hplonline/favicon.png" rel="icon">
  <link href="/backup-hplonline/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/backup-hplonline/atom.xml" rel="alternate" title="hplonline" type="application/atom+xml">
  <script src="/backup-hplonline/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/backup-hplonline/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/backup-hplonline/">hplonline</a></h1>
  
    <h2>backup from 2006 to 2012 (original hi.baidu.com/hplonline/)</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/backup-hplonline/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hupili.github.io/backup-hplonline" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/backup-hplonline/">Blog</a></li>
  <li><a href="/backup-hplonline/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/12/29/%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E7%9A%84%E8%84%9A%E6%9C%AC/">显示文件属性的脚本</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-12-29T15:47:00+08:00" pubdate data-updated="true">Dec 29<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.12.29</p>


<p>三个星期前做微机原理实验的时候，<br/>
问某牛应该怎么查看文件属性。<br/>
感觉相当惭愧啊。。<br/>
都大三的人了，连linux都不会用。</p>


<p>最近偷点闲，看了下鸟哥的那本书。<br/>
还不错。。知道点基本的东西了。<br/>
就写这么个查看文件属性的脚本来练练手。</p>


<p>主要是if,for,array，ls,cut的用法</p>


<p>另外对vi还是很手生，用起来特慢。<br/>
估计得啥时候刷几场比赛来刺激一下熟练程度。<br/>
不过在那之前貌似还要学下makefile和gdb，<br/>
就可以甩掉IDE在linux下工作了。。</p>


<p><font color="#0000ff">脚本“/usr/bin/attr”：</font></p>


<p>#!/bin/bash<br/>
#created by hpl<br/>
#2009/12/28<br/>
#test the attributes of a file</p>


<p>if [ &#8220;$1&#8221; = &#8220;&#8221; ] ; then <br/>
     echo &#8220;usage: attr &lt;filename&gt;&#8221;<br/>
     exit 1<br/>
fi<br/>
if [ ! -e $1 ] ; then<br/>
     echo &#8220;file &#34;$1&#34; not exist!!&#8221;<br/>
     exit 2<br/>
fi</p>


<p>echo &#8220;analyzing file:&#34;$1&#34;&#8221;</p>


<p>if [ -d $1 ] ; then<br/>
     echo &#8220;it&#8217;s a directory&#8221;<br/>
     exit 0<br/>
fi</p>


<p>declare -a usr=(owner group other)<br/>
declare -a rt=(read write execute)</p>


<p>for (( i=0 ; i&lt;=2 ; i=i+1 ))<br/>
do<br/>
     echo &#8220;${usr[$i]}:&#8221;<br/>
     for (( j=0 ; j&lt;=2 ; j=j+1))<br/>
     do<br/>
         declare -i k=i*3+j+2<br/>
         ex=`ls -l $1 | cut -c $k`<br/>
         if [ &#8220;$ex&#8221; = &#8220;-&#8221; ] ; then<br/>
             echo &#8220;     can&#8217;t ${rt[$j]}&#8221;<br/>
         else<br/>
             echo &#8220;     can ${rt[$j]}&#8221;<br/>
         fi<br/>
     done<br/>
done</p>


<p><font color="#0000ff">执行结果：（显示部分标红）</font></p>


<p>hpl@ubuntu:~/Desktop/myfirstbash$ ls -l<br/>
total 8<br/>
-rwxr&#8211;r&#8211; 1 hpl hpl  686 2009-12-28 23:24 attr<br/>
-rw-r&#8211;r&#8211; 1 hpl hpl     0 2009-12-28 23:26 new file<br/>
drwxr-xr-x 2 hpl hpl 4096 2009-12-28 23:26 testdir<br/>
-rw-r&#8211;r&#8211; 1 hpl hpl     0 2009-12-28 23:26 testfile<br/>
hpl@ubuntu:~/Desktop/myfirstbash$ touch testscript<br/>
hpl@ubuntu:~/Desktop/myfirstbash$ chmod 744 testscript<br/>
hpl@ubuntu:~/Desktop/myfirstbash$ ls<br/>
attr  new file  testdir  testfile  testscript<br/>
hpl@ubuntu:~/Desktop/myfirstbash$ ls -l<br/>
total 8<br/>
-rwxr&#8211;r&#8211; 1 hpl hpl  686 2009-12-28 23:24 attr<br/>
-rw-r&#8211;r&#8211; 1 hpl hpl     0 2009-12-28 23:26 new file<br/>
drwxr-xr-x 2 hpl hpl 4096 2009-12-28 23:26 testdir<br/>
-rw-r&#8211;r&#8211; 1 hpl hpl     0 2009-12-28 23:26 testfile<br/>
-rwxr&#8211;r&#8211; 1 hpl hpl     0 2009-12-28 23:27 testscript<br/>
hpl@ubuntu:~/Desktop/myfirstbash$ attr kkk<br/><font color="#ff0000">file &#8220;kkk&#8221; not exist!!</font><br/>
hpl@ubuntu:~/Desktop/myfirstbash$ attr testdir<br/><font color="#ff0000">analyzing file:&#8221;testdir&#8221;<br/>
it&#8217;s a directory</font><br/>
hpl@ubuntu:~/Desktop/myfirstbash$ attr testfile<br/><font color="#ff0000">analyzing file:&#8221;testfile&#8221;<br/>
owner:<br/>
     can read<br/>
     can write<br/>
     can&#8217;t execute<br/>
group:<br/>
     can read<br/>
     can&#8217;t write<br/>
     can&#8217;t execute<br/>
other:<br/>
     can read<br/>
     can&#8217;t write<br/>
     can&#8217;t execute<br/></font>hpl@ubuntu:~/Desktop/myfirstbash$ attr testscript<br/><font color="#ff0000">analyzing file:&#8221;testscript&#8221;<br/>
owner:<br/>
     can read<br/>
     can write<br/>
     can execute<br/>
group:<br/>
     can read<br/>
     can&#8217;t write<br/>
     can&#8217;t execute<br/>
other:<br/>
     can read<br/>
     can&#8217;t write<br/>
     can&#8217;t execute</font></p>


<p> </p>


<p>其实这东西也就是玩玩，正常人不会用的。</p>


<p>直接一个ls -l 瞟一眼就知道是啥属性了。。<br/></p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/12/29/%E5%88%86%E7%A6%BB%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BC%A6%E4%BF%A1%E5%8F%B7%E3%80%82%EF%BC%88MATLAB%E6%A8%A1%E6%8B%9F%EF%BC%89/">分离两个正弦信号。（MATLAB模拟）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-12-29T14:03:00+08:00" pubdate data-updated="true">Dec 29<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.12.29</p>


<p><font color="#0000ff">条件：</font></p>


<p>1.次信号的频率离主信号有10%的差异<br/>
2.次信号的幅值为主信号的1/5左右</p>


<p><font color="#0000ff">原理概述：</font></p>


<p>对混合信号进行采样，<br/>
做FFT，在频谱上能看到分离的两簇。<br/>
从频谱上将信号分离，<br/>
再做IFFT，即可得到两信号的离散序列。</p>


<p>从离散序列到模拟信号，<br/>
有两种思路：<br/>
一是做D/A，然后低通滤波。<br/>
二是得到幅值和频率等参数，交给两个VCO来输出信号。</p>


<p>不过本模拟是纯粹原理上的，<br/>
就不做具体的恢复部分了。<br/>
仅仅关注如何在频谱上鉴别两个信号。</p>


<p><font color="#0000ff">分离算法：</font></p>


<p>原主次信号如图</p>


<p><span><img class="blogimg" border="0" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/30d5b20efb4cbad737d122df.jpg"/><br/></span></p>


<p>FFT变换后的频谱（已经在集中位置进行了放大，对称位置忽略了）</p>


<p><span><img class="blogimg" border="0" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/8ed7f2dc15a15491cc1166d8.jpg"/><br/></span></p>


<p>可以明显看到有两簇频谱。<br/>
但除了两个主峰外，还有若干小的旁瓣。</p>


<p>这里采用的是一个简单的三点鉴峰算法。<br/>
即如果一点比左右两点的幅值高，那么就认为他是一个峰。</p>


<p>先把所有的峰都提取出来，<br/>
这个序列可以想象成原频谱的一个“包络”。<br/>
绘制出的形状如下：</p>


<p><span><img class="blogimg" border="0" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/76e3c33db06cd5f79e3d62da.jpg"/><br/></span></p>


<p>这样就可以排除旁瓣纹波的干扰，<br/>
看到两个更独立的峰。<br/>
对这个峰的序列继续使用三点鉴峰算法，<br/>
即可提取出主次信号的峰值频率位置p1和p2。</p>


<p>分离操作也是从简的，<br/>
直接取pmid=(p1+p2)/2，<br/>
然后以pmid把频谱分成两段。<br/>
效果如下图：</p>


<p><span><img class="blogimg" border="0" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/83afdc88049969a4a5c272a5.jpg"/><br/></span></p>


<p><font color="#0000ff">信号恢复效果的讨论：</font></p>


<p>由于为了提高频谱分辨率，<br/>
对N点的信号做的是M点的fft（M&gt;N)。<br/>
对上面分离的频谱做IFFT后，<br/>
得到的也应该是M点的序列。<br/>
这个序列应该是原序列在后面补零所产生的，<br/>
我们只取前面的N点就可以了。</p>


<p>具体效果如下图</p>


<p><span><img class="blogimg" border="0" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/1d1e3badbf4898394a36d6a6.jpg"/><br/></span></p>


<p>可以看到信号的整体形状比较怪异，<br/>
但中间部分貌似还行。<br/>
在中部放大后的效果如图</p>


<p><span><img class="blogimg" border="0" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/a71758660eb1e714aa184ca6.jpg"/><br/></span></p>


<p>经过与原主次信号对比，<br/>
发现幅值和频率基本上是一致的。</p>


<p><font color="#0000ff">遗留问题：</font></p>


<p>1.相关参数需要根据实际使用的器件来定，再次仿真</p>


<p>2.当采样率相对主信号很高的时候，两个信号的频谱会压在一起<br/>
所以需要考虑根据实际情况调整采样率。<br/>
或者调整其他相关参数，如一帧的点数（N)，变换的点数（M)</p>


<p>程序文件<a target="_blank" href="http://www.box.net/shared/k8dmu7e316">下载</a></p>


<p> </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/12/28/FFT%E7%9B%B8%E5%85%B3%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%88MATLAB%EF%BC%89%EF%BC%88%E4%BB%BB%E6%84%8F%E5%9F%BADIT%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%29/">FFT相关（三）（MATLAB）（任意基DIT递归实现)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-12-28T20:22:00+08:00" pubdate data-updated="true">Dec 28<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.12.28</p>


<p>其实有了前面基2，基4的原理。。。<br/>
任意基的FFT也就是那个样子。</p>


<p>详细推导和程序文件<a target="_blank" href="http://www.box.net/shared/s4tcp5rpvg">下载</a>。</p>


<p><font color="#0000ff">简要说明：</font></p>


<p>任意基就是把长度作因子分解：<br/>
N=a*b<br/>
于是可以通过计算a个长度为b的子序列，<br/>
然后再把结果整合得到N点的DFT。<br/>
（话说虽然DSP的期末貌似不考FFT，<br/>
但是这个任意基的原理在某课后题出现过，<br/>
只是没有点名可以用来做FFT而已）</p>


<p>这个过程可以递归下去，<br/>
直到b=1，就可以直接算得X=x。</p>


<p>详细的推导还是见下载的包吧。</p>


<p>另外，作为原理模拟，<br/>
像分解因数等部分写得就很土鳖了，<br/>
反正意思是到了。</p>


<p><font color="#0000ff">关键程序段：</font></p>


<p>function X = ditany(x)<br/>
     N = length(x) ;<br/>
     if N == 1<br/>
         X = x ;<br/>
     else <br/>
         %factorize N = a * b<br/>
         flag = 0 ;<br/>
         for a = 2:fix(sqrt(N))<br/>
             if fix(N / a) == N / a<br/>
                flag = 1 ;<br/>
                break ;<br/>
             end<br/>
         end<br/>
         if ~flag<br/>
            a = N ; <br/>
         end<br/>
         b = N / a ;<br/>
         %start caculation of length b dft <br/>
         %and assemble the a sequences<br/>
         W = exp(-1j * 2 * pi / N * (0:a-1)&#8217;*(0:b-1)) ;<br/>
         %preallocation of space will be needed here<br/>
         %to accelerate the programme<br/>
         XX = [] ;<br/>
         for ii = 1:a<br/>
            XX = [XX ; ditany(x(ii:a:N))] ; <br/>
         end<br/>
         X = [] ;<br/>
         XX = XX .* W ;<br/>
         for jj = 1:a<br/>
             tmp = exp(-j * 2 * pi / N * (0:a-1) * b * (jj - 1)) * XX ;<br/>
             X = [X , tmp] ;<br/>
         end<br/>
     end<br/>
return ;</p>


<p><font color="#0000ff">一些比较:</font></p>


<p>其实我们比较关心的是这个任意基的算法究竟能改进多少时间。<br/>
基准采用的是矩阵定义的DFT变换：<br/>
X1 = x * exp(-j * 2 * pi / N * (0:N-1)&#8217;*(0:N-1)) ;</p>


<p>以点数为横坐标，<br/>
加速比为纵坐标。<br/>
加速比的定义为DIT_any的耗时比上矩阵DFT的耗时。<br/>
画出散点图，并标注基准线y=1来观察。</p>


<p>首先来看从1到200点的散点图。</p>


<p><span><img class="blogimg" border="0" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/83afdc8802b56fa4a5c272c1.jpg"/></span><br/>
再看以2的方冪为点数的散点图。</p>


<p><span><img class="blogimg" border="0" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/46c61bdf99666223622798c1.jpg"/><br/></span><br/>
在观察各种自然数的时候，<br/>
发现这个任意基的算法大部分时候反而更戳。</p>


<p>专门把2的方冪提取出来观察，<br/>
发现效率有所改进，<br/>
但似乎并不是很明显的样子。</p>


<p>要仔细观察其中的差异，<br/>
还得用C来实现一下。<br/>
因为MATLAB隐藏了太多的细节，<br/>
让我们无法把握每一个消耗时间的地方。<br/>
不过作为粗糙的原理模拟，<br/>
以及简易对比来说是可以的。</p>


<p>出现这种现象也比较好理解，<br/>
因为任意基的算法的精华在于分解。<br/>
把大的序列分解成若干小的序列，分别计算。<br/>
随便选一个数，如果是质数，<br/>
则无法发挥任意基的能力，<br/>
甚至由于其他操作引入更多的时间。<br/>
即使不是质数，<br/>
如果其中有较大的质数因子也会导致耗时较多。</p>


<p>由于是任意基，exp(2 * pi / N * k)的计算是逃不掉的。<br/>
不像基2基4基8，出来的是如1,j,1+j这类比较好看的数字。</p>


<p> </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/12/27/FFT%E7%9B%B8%E5%85%B3%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%88MATLAB%EF%BC%89%EF%BC%88DIT4%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%29/">FFT相关（二）（MATLAB）（DIT4递归实现)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-12-27T13:01:00+08:00" pubdate data-updated="true">Dec 27<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.12.27<br/><br/>
考了几天试，差点搞忘整这个了。<br/>
有了之前<a href="http://hi.baidu.com/hplonline/blog/item/6ed46d09534963c43ac7630d.html" target="_blank">基2的原理</a>，基4的算法可以顺便推出。<br/><font color="#0000ff"><br/>
程序：</font><br/><br/>
function test<br/>
x = rand(1 , 4 .^ 6) ;<br/>
tic<br/>
X1 = fft(x) ;<br/>
toc<br/>
tic<br/>
X2 = dit4(x) ;<br/>
toc<br/>
tic<br/>
X3 = dit2(x) ;<br/>
toc<br/>
max(abs(X1 - X2)) <br/>
max(abs(X1 - X3)) <br/>
return ;<br/><br/>
%precondition:<br/>
%length of x should be (4.<sup>n)</sup> where n is an integer<br/>
function X = dit4(x)<br/>
N = length(x) ;<br/>
if N == 1<br/>
X = x ;<br/>
else <br/>
X1 = dit4(x(1:4:N)) ;<br/>
X2 = dit4(x(2:4:N)) ;<br/>
X3 = dit4(x(3:4:N)) ;<br/>
X4 = dit4(x(4:4:N)) ;<br/>
W2 = exp(-1j * 2 * pi / N * (0:(N/4-1))) ;<br/>
W3 = exp(-2j * 2 * pi / N * (0:(N/4-1))) ;<br/>
W4 = exp(-3j * 2 * pi / N * (0:(N/4-1))) ;<br/>
XX1 = X1 + 1 * W2 .<em> X2 + 1 * W3 .</em> X3 + 1 * W4 .<em> X4 ;<br/>
XX2 = X1 - j * W2 .</em> X2 - 1 * W3 .<em> X3 + j * W4 .</em> X4 ;<br/>
XX3 = X1 - 1 * W2 .<em> X2 + 1 * W3 .</em> X3 - 1 * W4 .<em> X4 ;<br/>
XX4 = X1 + j * W2 .</em> X2 - 1 * W3 .<em> X3 - j * W4 .</em> X4 ;<br/>
X = [XX1 , XX2 , XX3 , XX4] ;<br/>
end<br/>
return ;<br/><br/>
%precondition:<br/>
%length of x should be (2.<sup>n)</sup> where n is an integer<br/>
function X = dit2(x)<br/>
N = length(x) ;<br/>
if N == 1<br/>
X = x ;<br/>
else <br/>
X1 = dit2(x(1:2:(N-1))) ;<br/>
X2 = dit2(x(2:2:N)) ;<br/>
W = exp(-1i * 2 * pi / N * (0:(N/2-1))) ;<br/>
X = [X1 + W .<em> X2 , X1 - W .</em> X2] ;<br/>
end<br/>
return ;<br/><font color="#0000ff"><br/>
结果：</font><br/><br/>
Elapsed time is 0.000149 seconds.<br/>
Elapsed time is 0.125514 seconds.<br/>
Elapsed time is 0.183247 seconds.<br/>
ans =<br/>
1.1369e-013<br/>
ans =<br/>
3.5527e-014<br/><br/><font color="#0000ff">小结：</font><br/><br/>
从理论上说基4的算法递归层数是基2的一半。<br/><font color="#ff0000">可以看到效率有所提高，但并没有到两倍。</font><br/>
主要原因在于每一层整合上层结果的消耗变大了。<br/><br/>
在用C实现的时候，即使还是用递归，<br/>
整合这一步仍然有提高的余地。<br/>
因为基4的算法中，旋转系数是0,-j,-1,j。<br/>
而与这几个特殊数字相乘，<br/>
可以直接用取反、交换虚实部等手段完成（最多两次MUL(与-1)及MOV），<br/>
而不是普通复数乘法（消耗4次MUL与2次ADD）。<br/><br/>
而再升基的话，在整合上就会出现麻烦了，<br/>
因为可能很难简化复数乘法。<br/>
（基2的W(N,N/2)为-1，可以只接取反相加）<br/><br/>
不过基8的时候还是有可能改进的，<br/>
相比基4的时候，多出来的为sqrt(2)/2*(1+j,1-j,-1+j,-1-j)等因子。<br/>
最多的时候，可能出现三次与-1相乘，一次与sqrt(2)/2相乘，<br/>
如果硬件上直接支持浮点取反，这里就可以改进不少。<br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/12/24/%E5%88%A0%E9%99%A4VC%E5%B7%A5%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%97%A0%E7%94%A8%E6%96%87%E4%BB%B6%EF%BC%88BAT%29/">删除VC工程中的一些无用文件（BAT)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-12-24T10:22:00+08:00" pubdate data-updated="true">Dec 24<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.12.24<br/><br/>
由于存在就是合理，<br/>
所以每个文件都是有用的。<br/><br/>
所谓无用，只是指可以由编译器根据仅存文件再次生成的那些东西。<br/><br/>
当然，有人要说给他一个编译器和notepad，<br/>
他可以重新把所有东西搞出来。<br/>
这是显然的，只是时间的问题。<br/>
要不给人一堆晶体管，把windows用硬件实现也是逻辑可能的。<br/><br/>
不确定除了这些文件外还有哪些，<br/>
不过可以自己添加，就在for的括号里面。<br/><br/><font color="#0000ff">BAT文件：</font><br/><br/>
@echo off<br/>
for /r . %%f in (<em>.ncb </em>.obj <em>.pch </em>.pdb <em>.lik </em>.res *.ilb) <br/>
do (<br/>
del /f /q %%f<br/>
echo &#8220;%%f&#8221; deleted<br/>
)<br/>
echo done!<br/>
pause<br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/12/20/FFT%E7%9B%B8%E5%85%B3%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%88MATLAB%EF%BC%89%EF%BC%88DIT2%2CDIF2%E7%9A%84%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%AE%9E%E5%BA%8F%E5%88%97fft%E8%AE%A1%E7%AE%97%29/">FFT相关（一）（MATLAB）（DIT2,DIF2的递归实现，实序列fft计算)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-12-20T13:30:00+08:00" pubdate data-updated="true">Dec 20<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.12.20<br/><br/>
虽然之前用C写过，<br/>
不过一直没有对原理进行比较好的把握，<br/>
正好最近的实验指导书上写得还行，<br/>
于是用递归实现了一下基2的运算。<br/><br/>
关于基2时间抽取和频率抽取在指导书里面讲得比较详细了。<br/><a href="http://www.box.net/shared/cleppvpyx2" target="_blank">指导书和m文件下载</a><br/><br/>
这里讨论另外两个主题：递归实现和实序列计算。<br/><font color="#0000ff"><br/>
递归实现：</font><br/><br/>
使用递归实现的话，只需要把原理部分读懂就行了，<br/>
至于蝶形运算，同址运算，位反序等高级操作则不用管了。<br/>
毕竟用matlab写东西往往关注的是一个算法的正确性，<br/>
需要大量使用之前再用C写出来 ，并大加优化。<br/><br/>
既然是递归，则有一个终止条件的问题，<br/>
实际上，可以递归到序列长度为1的时候：<br/>
X = x;则可<br/>
但不知道为啥看到好几个人写的都是递归到长度为2的时候。。<br/>
难道是老师这么说的。。<br/><br/>
用递归写出来了之后，<br/>
我也觉得很惊悚，<br/>
没想到用matlab可以做得这么短。。。<br/>
（代码见后，<font color="#ff0000">只能对2的次方的长度计算）</font><br/><br/><font color="#0000ff">实序列DFT：</font><br/><br/>
上面讨论的dit，dif都是处理复序列的。<br/>
而实序列本身就少一半的信息，<br/>
居然还要用同样多的运算量，<br/>
这就有点不合理了。<br/><br/>
关于DFT有如下结论：<br/><font color="#ff0000">x的实部的DFT是X的共轭对称部分(Xcs)<br/>
x的虚部的DFT是X的共轭反称部分(Xca)</font><br/><br/>
对于实序列来说，共轭反称部分为0，这就是很大的浪费。<br/><br/>
计算两个实序列的话，都知道可以组装起来。<br/>
x = x1 + 1i * x2；<br/>
得到X后再分离出Xcs和Xca，则对应X1和X2。<br/><br/>
计算一个实序列的话，方法类似。<br/><font color="#ff0000">唯一要考虑的是怎样拆成两个序列，<br/>
又怎样组装回原序列。</font><br/><br/>
答案也很显然，借用DIT或者DIF的思想就可以了。<br/>
比如我下面的实现中，按奇偶分裂原序列。<br/>
组装成新序列，并且调用任何一种DFT算法得到频域的序列。<br/>
根据共轭对称和反称关系得到奇偶序列对应的变换，<br/>
再用类似DIT的方法组装起来就行了。<br/><br/>
（代码见后，<font color="#ff0000">只能处理原序列是偶数的情况）</font><br/><br/><font color="#0000ff">代码：</font>（如果缩进有问题，那肯定是百度的问题。。）<br/><br/>
function test<br/>
x = rand(1 , 2 .^ 13) ;<br/>
tic<br/>
X1 = fft(x) ;<br/>
toc<br/>
tic<br/>
X2 = dit2(x) ;<br/>
toc<br/>
tic<br/>
X3 = dif2(x) ;<br/>
toc<br/>
tic<br/>
X4 = real_fft(x) ;<br/>
toc<br/>
max(abs(X1 - X2)) <br/>
max(abs(X1 - X3))<br/>
max(abs(X1 - X4))<br/>
return ;<br/><br/>
function X = dit2(x)<br/>
N = length(x) ;<br/>
if N == 1<br/>
X = x ;<br/>
else <br/>
X1 = dit2(x(1:2:(N-1))) ;<br/>
X2 = dit2(x(2:2:N)) ;<br/>
W = exp(-1i * 2 * pi / N * (0:(N/2-1))) ;<br/>
X = [X1 + W .<em> X2 , X1 - W .</em> X2] ;<br/>
end<br/>
return ;<br/><br/>
function X = dif2(x)<br/>
N = length(x) ;<br/>
if N == 1<br/>
X = x ;<br/>
else<br/>
x1 = x(1:N/2) ;<br/>
x2 = x(N/2+1:N) ;<br/>
W = exp(-1i * 2 * pi / N * (0:(N/2-1))) ;<br/>
X = zeros(1 , N) ;<br/>
X(1:2:N-1) = dif2(x1 + x2) ;<br/>
X(2:2:N) = dif2((x1 - x2) .<em> W) ;<br/>
end<br/>
return ;<br/><br/>
function X = real_fft(x)<br/>
N = length(x) ;<br/>
xx = x(1:2:N) + 1j * x(2:2:N) ;<br/>
XX = dit2(xx) ; %can be changed to other realization of fft<br/>
XX_conj_rev = conj([XX(1) , fliplr(XX(2:end))]);<br/>
Xcs = (XX + XX_conj_rev) / 2 ;<br/>
Xca = (XX - XX_conj_rev) / 2 ;<br/>
W = exp(-1i * 2 * pi / N * (0:(N/2-1))) ;<br/>
X = [Xcs + W .</em> Xca / 1j , Xcs - W .* Xca / 1j] ;<br/>
return ;<br/><br/><font color="#0000ff">结果：</font><br/><br/>
Elapsed time is 0.000225 seconds.<br/>
Elapsed time is 0.349320 seconds.<br/>
Elapsed time is 0.326117 seconds.<br/>
Elapsed time is 0.154730 seconds.<br/><br/>
ans =<br/>
6.7032e-014<br/>
ans =<br/>
5.5153e-014<br/>
ans =<br/>
6.0396e-014<br/><br/>
1.可以看到字节写的和内置的fft时效相差很大，<br/>
不过作为原理模拟，这不是主要问题<br/>
2.通过实序列算法计算，效率是基础算法（这里用的dit2）的两倍<br/>
3.计算出的序列和内置fft有一定的误差，<br/>
这时由于不同路径产生的，<br/>
不过其量值很小，可以忽略。<br/><br/><font color="#0000ff">下一步：</font><br/><br/>
1.基4的算法<br/>
2.任意基的算法<br/>
3.质数长度的序列计算<br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/12/20/MATLAB%E7%AC%A6%E5%8F%B7%E8%BF%90%E7%AE%97%E6%B1%82%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2%EF%BC%88%E5%8F%8D%E5%8F%98%E6%8D%A2%EF%BC%89/">MATLAB符号运算求傅立叶变换（反变换）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-12-20T12:54:00+08:00" pubdate data-updated="true">Dec 20<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.12.20<br/><br/>
今天抽到一道题，<br/>
在频域上给了一个矩形脉冲，<br/>
让求出连续信号的时域波形和频谱，<br/>
以及采样后信号的时域波形和频谱。<br/><br/>
之前看其他人做的样题，<br/>
就是把点取得很密，<br/>
然后用ifft这样的方法去算。<br/>
最后plot出来虽然看起来是连续的，<br/>
但是根据取点数的不同，<br/>
其幅度都有变化。。<br/>
本质上也是画的时间或频率采样后的信号，<br/>
不是原模拟信号。<br/><br/>
于是当时想了手算表达式，然后取点来画。<br/>
最后觉得时间有点短，没有囧出来。<br/>
回来又整了下，发现这个问题应该用matlab的符号运算来解决。<br/>
通过符号运算，推得时域的准确表达式，<br/>
再subs函数得到需要画的点的值就可以了。<br/><br/>
最后剩下的问题就是怎么构造频域的那个矩形脉冲了。<br/>
用heaviside可以构造出阶跃函数，<br/>
（跟平时的阶跃有点不同，可以参考help）<br/>
让它与频移后的阶跃相减就可以了。<br/><br/><font color="#0000ff">代码：</font><br/><br/>
clear ;<br/>
clc ;<br/>
close all ;<br/><br/>
syms f t ;<br/><br/>
Y = heaviside(f) - heaviside(f - 10000) ;<br/>
ff = linspace(0 , 20000 , 100) ;<br/>
YY = subs(Y , f , ff) ;<br/>
subplot(2 , 1 , 1) ;<br/>
plot(ff , YY) ;<br/>
axis([-100 20100 -0.1 1.1]) ;<br/>
y = ifourier(Y , f , t) <br/>
tt = linspace(-0.0025 ,0.0025 ,  200) ;<br/>
yy = subs(y , t , tt) ;<br/>
subplot(2 , 1 , 2) ;<br/>
plot(tt , abs(yy)) ;<br/><br/><font color="#0000ff">样图：<br/></font><br/><span><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/a3fb991362e649b06438dbd7.jpg" small="0" class="blogimg"/></span><br/>
上面是题目给的矩形脉冲，下面是反变换后的时域信号。<br/><br/>
朝死。。夕闻到。。也可。。<br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/12/19/DSP%E7%9A%84MATLAB%E7%BB%83%E4%B9%A0%E9%A2%98/">DSP的MATLAB练习题</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-12-19T21:14:00+08:00" pubdate data-updated="true">Dec 19<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.12.19<br/><br/>
其实也就是为了应付DSP的机考，囧。<br/>
曾经有份盛传的样题和答案，<br/>
感觉有些有点问题的样子。<br/>
于是把24道题都重新写了一下，<br/>
有些基本上是照搬的，有些不一样。<br/><br/>
另外根据这些题加了点笔记。<br/><br/>
最近也没做啥像样的东西，<br/>
就把这个弄上来。<br/>
有兴趣用MATLAB练习一下<br/>
基本的信号分析和滤波器设计的同学可以看下。<br/><br/>
当然UESTC.SCIE的同学可以拿去打印一份。。<br/>
哥马上就要去打印店了。。<br/>
由于大家考试时间不一样，所以是可以时分复用的。<br/><br/><a href="http://www.box.net/shared/gjr20l3mfj" target="_blank">下载</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/12/16/PCM%E6%8A%98%E7%BA%BF%E7%BC%96%E7%A0%81%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%AE%B5/">PCM折线编码的程序段</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-12-16T10:10:00+08:00" pubdate data-updated="true">Dec 16<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.12.16</p>


<p>最近赶通原作业，顺便做了。<br/>
其实上学期的信息论的时候就想写的，<br/>
又是一直放在那没动。。<br/>
这回要整作业，写出来好用。。<br/>
mu律的程序类似。</p>


<p>function main<br/>
clc ;<br/>
clear ;<br/>
pcm_a(0.12)<br/>
pcm_a(0.3)<br/>
pcm_a(-0.7)<br/>
return</p>


<p>function code = pcm_a(x)</p>


<p>if x &gt;= 0 <br/>
     sign = &#8216;1&#8217; ;<br/>
else <br/>
     sign = &#8216;0&#8217; ;<br/>
     x = -x ;<br/>
end</p>


<p>b(1) = 1 / 128 ;<br/>
b(2) = 1 / 128 ;<br/>
c(1) = 0 ;<br/>
c(2) = b(1) ;<br/>
for i = 3:8<br/>
    b(i) = b(i - 1) * 2 ;<br/>
    c(i) = c(i - 1) + b(i - 1) ;<br/>
end</p>


<p>seg = sum(c &lt;= x) ;<br/>
% [b&#8217; , c&#8217;]&#8217;<br/>
% x<br/>
% c(seg)<br/>
% b(seg)<br/>
offset = 16 * (x - c(seg)) / b(seg) ;</p>


<p>code = [sign , dec2bin(seg - 1, 3) , dec2bin(fix(offset) , 4)] ;</p>


<p>return</p>


<p> </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/12/11/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C%E6%9D%82%E8%AE%B0%E4%B8%89%E5%88%99%EF%BC%88MATLAB%29%EF%BC%88freqz%E6%B1%82%E6%97%B6%E5%9F%9F%E5%BA%8F%E5%88%97%E7%9A%84%E9%A2%91%E5%93%8D%EF%BC%8C%E4%B8%8B%E6%A0%87%EF%BC%8Cfdatool%E5%AF%BC%E5%87%BA%E7%9A%84IIR%E6%BB%A4%E6%B3%A2%E5%99%A8%E7%9A%84SOS%29/">信号处理实验杂记三则（MATLAB)（freqz求时域序列的频响，下标，fdatool导出的IIR滤波器的SOS)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-12-11T22:30:00+08:00" pubdate data-updated="true">Dec 11<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.12.11<br/><br/><font color="#0000ff">freqz求时域序列的频响</font><br/><br/>
help freqz看到的帮助说是求这种形式的频响<br/>
|                jw               -jw              -jmw <br/>
|         jw  B(e)    b(1) + b(2)e + &#8230;. + b(m+1)e<br/>
|      H(e) = &#8212;- = &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;<br/>
|                jw               -jw              -jnw<br/>
|             A(e)    a(1) + a(2)e + &#8230;. + a(n+1)e<br/>
参数中要求的b，a既是该系统z域上的分子和分母。<br/><br/>
而很多时候是拿到个信号的时域序列，<br/>
这个时候要分析其频域特性就不知道该怎么办了，<br/>
于是用fft加plot自己来完成这个图：<br/><font color="#ff9900">t = linspace(0 , 2 * pi , 100) ;<br/>
x = sin(t) ;<br/>
X = fft(x) ;<br/>
absX = abs(X) ;<br/>
plot([absX(50:end),absX(1:49)]) ;</font><br/>
纠结了很久才反映过来这样就可以了：<br/><font color="#ff9900">N = 100 ;<br/>
w = 2 * pi * (0:N -1) / N ;<br/>
h = freqz(x ,[1] , 100 ) ;<br/>
plot(w , abs(h)) ;</font><br/>
直接把分母a令为1。则系数b和时域序列是一样的。<br/>
把有限长时域序列按照z变换的定义式写出来，<br/>
对比freqz提供的形式就知道了。。<br/>
这样比自己fft再频移要方便很多。<br/><br/><font color="#0000ff"><br/>
下标</font><br/><br/>
写一个升采样函数，写成了这样：<br/><font color="#ff9900">function y = inter(x , L)<br/>
N = length(x) ;<br/>
y = zeros(1 , L * N) ;<br/>
y(L * (0:(N-1))) = x ;<br/>
return </font><br/>
结果报错：<br/><font color="#ff0000">??? Subscript indices must either be real positive integers or logicals.</font><br/>
很多时候出这种问题就是因为下标不是整数，<br/>
而我看了L * (0:(N-1))生成的序列确实是整数啊，<br/>
就算不是，后来把他round一下，都还是不可以。。<br/>
郁闷了很久想起matlab是从1开始的，于是整个序列加1就搞定了。。。<br/>
y(L * (0:(N-1))) = x ;<br/>
其实报错说得很明确了<font color="#ff0000">positive</font>和<font color="#ff0000">integer</font>。<br/>
但是由于经常是integer把我们卡住，于是直接把重心偏移了过去。<br/>
想起了一篇<a target="_blank" href="http://www.matrix67.com/blog/archives/2571">文章</a>。<br/>
是不是这句要这么说呢。。：<br/><font color="#ff0000">??? Subscript indices must either be real god damned positive integers or logicals.</font><br/><br/><font color="#0000ff">fdatool导出的IIR滤波器的SOS</font><br/><br/>
由于<font color="#ff0000">课前没预习，上课栽瞌睡，课后没复习</font>。。<br/>
发现看不懂那个矩阵是什么意思。。<br/>
像FIR设计出来就很直观，只有个Numberator。<br/>
而IIR出来的SOS是个六列的矩阵。。<br/><br/>
后来问了<font color="#ff0000">研究生（<img src="http://img.baidu.com/hi/tsj/t_0027.gif"/>）</font>，才知道这个设计是按照级联型的方式做出来的。<br/>
一横行就是一个模块，左边三是分子，右边三是分母。<br/>
各行乘起来的就是直接型方式设计出来的系数了。<br/><br/>
悲剧。。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/backup-hplonline/blog/page/9/">&larr; Older</a>
    
    <a href="/backup-hplonline/blog/archives">Blog Archives</a>
    
    <a class="next" href="/backup-hplonline/blog/page/7/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/backup-hplonline/blog/2013/05/04/test/">Test</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/04/09/%E5%86%8D%E8%B0%88stl%E7%9A%84rotate/">再谈stl的rotate</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%BA%8C%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、二）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%89%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、三）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%80%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、一）</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - hplonline -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
