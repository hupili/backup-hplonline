
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>hplonline</title>
  <meta name="author" content="hplonline">

  
  <meta name="description" content="(hplonline)2009.12.9
DFT实现简单的语音压缩
compress将声音文件origin.wav压缩为data.bin
decompress从data.bin中解压声音文件并播放原理：
使用fft变换，保留低频部分到数据文件。
通过保留更窄的频段，获得高的压缩比；
通过间隔保留， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hupili.github.io/backup-hplonline/blog/page/9">
  <link href="/backup-hplonline/favicon.png" rel="icon">
  <link href="/backup-hplonline/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/backup-hplonline/atom.xml" rel="alternate" title="hplonline" type="application/atom+xml">
  <script src="/backup-hplonline/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/backup-hplonline/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/backup-hplonline/">hplonline</a></h1>
  
    <h2>backup from 2006 to 2012 (original hi.baidu.com/hplonline/)</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/backup-hplonline/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hupili.github.io/backup-hplonline" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/backup-hplonline/">Blog</a></li>
  <li><a href="/backup-hplonline/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/12/09/DFT%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%AD%E9%9F%B3%E5%8E%8B%E7%BC%A9%EF%BC%88%E4%B8%80%EF%BC%89/">DFT实现简单的语音压缩（一）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-12-09T20:51:00+08:00" pubdate data-updated="true">Dec 9<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.12.9<br/><br/>
DFT实现简单的语音压缩<br/><br/>
compress将声音文件origin.wav压缩为data.bin<br/>
decompress从data.bin中解压声音文件并播放<br/><br/><font color="#0000ff">原理：</font><br/>
使用fft变换，保留低频部分到数据文件。<br/>
通过保留更窄的频段，获得高的压缩比；<br/>
通过间隔保留，获得成倍数提高的压缩比；<br/>
通过将数据保留为更小的存储单元，获得更高的压缩比。<br/><br/>
本程序中，保留10到3000Hz的频段，<br/>
每间隔1个点进行保留，使用single存储。<br/><br/><font color="#0000ff">待完成的其他工作：</font><br/>
1.既然是实信号，可以用N/2长度的复信号fft进行运算，获得更高效率<br/>
2.自动寻找能量较高的频段，进行保留<br/>
3.对保留的频谱再次量化，使用huffman编码等进一步压缩<br/>
4.将原序列分段fft，再进行频谱搬移，叠加之后ifft，得到更短的声音序列<br/>
（此法不仅可以压缩，同时只需传送普通wav文件，但播放出无意义的声音）<br/><br/><font color="#0000ff">程序和样例下载：</font><br/><br/><a href="http://www.box.net/shared/yhbd59jpij" target="_blank">here</a><br/><br/><br/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/11/27/rip%E4%B8%AD%E8%A7%A6%E5%8F%91%E6%9B%B4%E6%96%B0%E7%9A%84%E4%B8%80%E7%82%B9%E7%BB%86%E8%8A%82/">Rip中触发更新的一点细节</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-11-27T19:52:00+08:00" pubdate data-updated="true">Nov 27<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.11.27</p>


<p>今天做RIP实验的时候，<br/>
有幸观察到了一般人没RP观察到的现象，<br/>
把老师都冏了几分钟。<br/>
不过老师很强大，很快就反映过来了。<br/>
于是现在回来找RFC深挖一点。</p>


<p><font color="#0000ff">RIP基本要点：</font></p>


<p>周期性地发送自己拥有的路由条目，<br/>
包含所有可达路由。</p>


<p>当有链路变化的时候，<br/>
发送触发更新的路由只包含有变动的路由。</p>


<p>因为路由响应报文的类型只有一种，<br/>
所以根据上面两点，从携带的条目数量，<br/>
来判断是不是有路由发生变化的触发更新。</p>


<p><font color="#0000ff">实验过程：</font></p>


<p>1.先打开各个路由器等路由收敛<br/>
2.关闭某路由器的端口，观察触发更新<br/>
3.开启某路由器的端口，观察触发更新</p>


<p><font color="#0000ff">数据样例：</font></p>


<p>1.关闭端口的时候某连续的三份报文内容<br/>
&#8212;-<br/>
IP Address: 172.16.1.0, Metric: 2<br/>
IP Address: 172.16.2.0, Metric: 1<br/>
&#8212;-<br/>
IP Address: 172.16.1.0, Metric: 16<br/>
IP Address: 172.16.2.0, Metric: 1<br/>
&#8212;-<br/>
IP Address: 172.16.1.0, Metric: 16<br/>
&#8212;-</p>


<p>第一份是周期更新的报文。<br/>
第二份从数量上来看也是周期更新的报文。<br/>
第三份是触发更新的报文。</p>


<p>问题就在于，既然触发更新是一收到改变就立即发送，<br/>
（这是为了加速收敛和避免环路所设的机制）<br/>
为什么会在周期更新的报文发送之后才到。</p>


<p>况且在这个情况下，<br/>
邻居路由器收到第二份报文的时候，<br/>
相当于已经知道了172.168.1.0的不可达性了，<br/>
没有必要再发送一个单独的“不可达”触发更新啊。</p>


<p>========</p>


<p>2.开启端口的时候某连续三份报文的内容<br/>
&#8212;-<br/>
IP Address: 172.16.2.0, Metric: 1<br/>
&#8212;-<br/>
IP Address: 172.16.1.0, Metric: 2<br/>
IP Address: 172.16.2.0, Metric: 1<br/>
&#8212;-<br/>
IP Address: 172.16.1.0, Metric: 2<br/>
&#8212;-</p>


<p>第一份是周期更新的报文，<br/>
因为前面的有个网路已经断开，<br/>
稳定后，只有一个条目。<br/>
第二份是周期更新的报文，<br/>
而且因为有两个条目，<br/>
肯定是链路恢复之后的周期更新。<br/>
第三份刚好是第一份到第二份的增量，<br/>
这是一个触发更新 ，通知网络可达。</p>


<p>这里的问题和上面一样，<br/>
触发更新怎么会在周期更新之后？</p>


<p><font color="#0000ff">解释：</font></p>


<p>在RFC1058的28页可以找到详细的描述。<br/>
当有触发更新出现的时候，<br/>
要随机延迟1到5秒。</p>


<p>想一想，其实很有道理。<br/>
当某网络变化的时候，<br/>
应该有若干路由器能侦测到，<br/>
如果大家都在同一时间发送触发更新，<br/>
则会导致较高的负载。<br/>
通过随机延迟，就错开了这个时间。</p>


<p>另外，RFC中还说了，<br/>
当有周期更新即将发送的时候，<br/>
触发更新会受到抑制。</p>


<p><font color="#0000ff">算算概率：</font></p>


<p>貌似这么多同学，没人去问老师这个问题。。<br/>
而我不仅遇到了，开启和关闭还遇到了两次。。</p>


<p>做点假设，<br/>
1.周期更新严格按照30s间隔发生。<br/>
2.触发更新的延迟时间在1到5秒均匀分布。<br/>
3.两次遇到这种情况是独立的</p>


<p><font color="#ff0000">&gt;&gt; syms t x<br/>
&gt;&gt; P=1-int(1/4 , 1 ,(30-t))<br/>
P =<br/>
t/4 - 25/4<br/>
&gt;&gt; 1/30*int(P,25,29) + 1/30<br/>
ans = <br/>
1/10</font></p>


<p>于是我今天撞到了<font color="#ff0000">1/100</font>的概率。</p>


<p>而我把第一个情况给老师看的时候，<br/>
老师说是在周期的时候才会检查，<br/>
所以周期在前，触发在后。。</p>


<p>要是今天运气不好，没撞到另外的1/10，<br/>
这个为什么的问题就会不得而知了。。</p>


<p><br/>
========================RFC1058笔记</p>


<p>(hplonline)2009.11.27</p>


<p>由于在实验中侦测到了两个触发更新在周期更新通告之后发生的情况，<br/>
于是要查找一下关于定时器设置的问题。</p>


<p>》》3.3. Timers</p>


<p>    Every 30 seconds, the output process is instructed to generate a<br/>
complete response to every neighboring gateway.  When there are many<br/>
gateways on a single network, there is a tendency for them to<br/>
synchronize with each other such that they all issue updates at the<br/>
same time.  This can happen whenever the 30 second timer is affected<br/>
by the processing load on the system.  It is undesirable for the<br/>
update messages to become synchronized, since it can lead to<br/>
unnecessary collisions on broadcast networks.  Thus, implementations<br/>
are required to take one of two precautions.</p>


<p>       - The 30-second updates are triggered by a clock whose rate<br/>
is not affected by system load or the time required to<br/>
service the previous update timer.</p>


<p>       - The 30-second timer is offset by addition of a small random<br/>
time each time it is set.</p>


<p>每30秒发送一个响应报文，<br/>
但是为了避免所有路由器都在同一时间发送，<br/>
要提前或延后一段随机时间。</p>


<p>扫描。。</p>


<p>    See section 3.5 for a discussion of a delay that is required in<br/>
carrying out triggered updates.  Although implementation of that<br/>
delay will require a timer, it is more natural to discuss it in<br/>
section 3.5 than here.</p>


<p>看来关于这个问题要在输出描述中</p>


<p>》》3.5. Output Processing</p>


<p>       - by input processing when a request is seen.  In this case,<br/>
the resulting message is sent to only one destination.<br/>
- by the regular routing update.  Every 30 seconds, a<br/>
response containing the whole routing table is sent to<br/>
every neighboring gateway.  (See section 3.3.)<br/>
- by triggered updates.  Whenever the metric for a route is<br/>
changed, an update is triggered.  (The update may be<br/>
delayed; see below.)</p>


<p>这里总结了三种需要输出路由表的情况。<br/>
1.收到了请求<br/>
2.周期性地发送路由表（30s）<br/>
3.有触发更新的时候</p>


<p>    Triggered updates require special handling for two reasons.  First,<br/>
experience shows that triggered updates can cause excessive loads on<br/>
networks with limited capacity or with many gateways on them.  Thus<br/>
the protocol requires that implementors include provisions to limit<br/>
the frequency of triggered updates.  After a triggered update is<br/>
sent, a timer should be set for a random time between 1 and 5<br/>
seconds.  If other changes that would trigger updates occur before<br/>
the timer expires, a single update is triggered when the timer<br/>
expires, and the timer is then set to another random value between 1<br/>
and 5 seconds.  Triggered updates may be suppressed if a regular<br/>
update is due by the time the triggered update would be sent.</p>


<p>触发更新可能导致额外的负载。<br/>
当触发更新被发送的时候，设置一个1到5之间的定时器；<br/>
该定时器超时之前，若有其他将触发更新的改动发生了，<br/>
在这个定时器超时的时候，只会发送一个更新，并且重置定时器到1和5之间；<br/>
当有周期更新发送时，触发更新将会受到抑制。</p>


<p>    Second, triggered updates do not need to include the entire routing<br/>
table.  In principle, only those routes that have changed need to be<br/>
included.  Thus messages generated as part of a triggered update must<br/>
include at least those routes that have their route change flag set.<br/>
They may include additional routes, or all routes, at the discretion<br/>
of the implementor; however, when full routing updates require<br/>
multiple packets, sending all routes is strongly discouraged.  When a<br/>
triggered update is processed, messages should be generated for every<br/>
directly-connected network.  Split horizon processing is done when<br/>
generating triggered updates as well as normal updates (see below).</p>


<p>触发更新不包含整张表，原则上只有改变的路由。<br/>
但实际上可以包含更多的条目，有实现者决定。<br/>
触发更新仍然要使用水平分割。<br/>
（在试验中观察到的cisco路由器，<br/>
在发送链路失效更新的时候，不进行水平分割）</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/11/25/%E5%B7%A9%E5%9B%BA%E4%B8%80%E4%B8%8Bether_ip_tcp%E7%9A%84%E6%A0%BC%E5%BC%8F/">巩固一下ether_ip_tcp的格式</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-11-25T19:40:00+08:00" pubdate data-updated="true">Nov 25<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p style="margin: 0cm 0cm 0pt" class="MsoNormal"><span><font face="Times New Roman">(hplonline)2009.11.24</font></span></p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><span><font face="Times New Roman"> </font></span></p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><span style=" mso-ascii- mso-hansi-">由于手工填充</span><span><font face="Times New Roman">TCP</font></span><span style=" mso-ascii- mso-hansi-">的实验报告太繁琐了，所以尝试写了一个程序。</span></p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><span style=" mso-ascii- mso-hansi-">数据是用</span><span><font face="Times New Roman">dinamips</font></span><span style=" mso-ascii- mso-hansi-">捕获的</span><span><font face="Times New Roman">.cap</font></span><span style=" mso-ascii- mso-hansi-">文件，用</span><span><font face="Times New Roman">wireshark</font></span><span style=" mso-ascii- mso-hansi-">打开，另存为</span><span><font face="Times New Roman">K12 TEXT FILE </font></span><span style=" mso-ascii- mso-hansi-">。</span></p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><span style=" mso-ascii- mso-hansi-">其实</span><span><font face="Times New Roman">.cap</font></span><span style=" mso-ascii- mso-hansi-">也可以分析的，就是没时间去研究他的格式了。</span></p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><span style=" mso-ascii- mso-hansi-">而导出的</span><span><font face="Times New Roman">txt</font></span><span style=" mso-ascii- mso-hansi-">文件，一看就明白文件结构是怎样的，</span></p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><span style=" mso-ascii- mso-hansi-">于是对着相关的几个课件试着弄了一下。</span></p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><span><font face="Times New Roman"> </font></span></p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><span style=" mso-ascii- mso-hansi-">之前看帧格式的时候，觉得也就那么回事，没多在意，</span></p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><span style=" mso-ascii- mso-hansi-">写了一下，发现还是有不少理解有出入的地方。</span></p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><span><font face="Times New Roman"> </font></span></p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><font color="#0000ff"><span><font face="Times New Roman">ETHER</font></span><span style=" mso-ascii- mso-hansi-">帧：</span></font></p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"> </p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><span style=" mso-ascii- mso-hansi-"><span><img class="blogimg" border="0" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/1f1e11d5ca8583eb53da4b60.jpg"/><br/></span></span></p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><span><font face="Times New Roman"> </font></span></p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><span/></p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><span><font face="Times New Roman">1.</font></span><span style=" mso-ascii- mso-hansi-">首先前面的</span><span><font face="Times New Roman">7BYTE</font></span><span style=" mso-ascii- mso-hansi-">的</span><span><font face="Times New Roman">preamble </font></span><span style=" mso-ascii- mso-hansi-">和</span><span><font face="Times New Roman">SFD</font></span><span style=" mso-ascii- mso-hansi-">在抓上来的包中是看不到的，他们是用来同步的交替</span><span><font face="Times New Roman">01</font></span><span style=" mso-ascii- mso-hansi-">序列和一个起始位。</span></p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><span><font face="Times New Roman">2.</font></span><span style=" mso-ascii- mso-hansi-">我们平常说</span><span><font face="Times New Roman">MAC</font></span><span style=" mso-ascii- mso-hansi-">帧头长</span><span><font face="Times New Roman">18BYTE</font></span><span style=" mso-ascii- mso-hansi-">是包含了最后的</span><span><font face="Times New Roman">FCS</font></span><span style=" mso-ascii- mso-hansi-">的，不同于一般想到的“头”就一定是放在前面的部分。</span></p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><span><font face="Times New Roman">3.DA</font></span><span style=" mso-ascii- mso-hansi-">放在</span><span><font face="Times New Roman">SA</font></span><span style=" mso-ascii- mso-hansi-">前面，应该是为了在链路层更高效的转发。这样收到</span><span><font face="Times New Roman">DA</font></span><span style=" mso-ascii- mso-hansi-">之后就可以将帧“直通”出去了。而</span><span><font face="Times New Roman">IP</font></span><span style=" mso-ascii- mso-hansi-">里面的顺序是先</span><span><font face="Times New Roman">SIP</font></span><span style=" mso-ascii- mso-hansi-">再</span><span><font face="Times New Roman">DIP</font></span><span style=" mso-ascii- mso-hansi-">，</span><span><font face="Times New Roman">TCP</font></span><span style=" mso-ascii- mso-hansi-">里面的顺序是</span><span><font face="Times New Roman">SPORT</font></span><span style=" mso-ascii- mso-hansi-">再</span><span><font face="Times New Roman">DPORT</font></span><span style=" mso-ascii- mso-hansi-">。</span></p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><span><font face="Times New Roman"> </font></span></p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><font color="#0000ff"><span><font face="Times New Roman">IP</font></span><span style=" mso-ascii- mso-hansi-">分组：</span></font></p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"> </p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><span style=" mso-ascii- mso-hansi-"><span><img class="blogimg" border="0" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/4868b8b7d14f52db33add162.jpg"/><br/></span></span></p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"> </p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"> </p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><span style=" mso-ascii- mso-hansi-">这里主要涉及的就是大小尾顺序的问题了。这些图都是从上到下，从左到右，地址值增加的。要在程序里面处理的时候，一般都是读成</span><span><font face="Times New Roman">BYTE,WORD,DWORD</font></span><span style=" mso-ascii- mso-hansi-">长度的变量，然后进行分析。当遇到不是</span><span><font face="Times New Roman">8bit</font></span><span style=" mso-ascii- mso-hansi-">整数倍的域时，理解就有问题了。比如我之前以为</span><span><font face="Times New Roman">VER</font></span><span style=" mso-ascii- mso-hansi-">既然放在</span><span><font face="Times New Roman">HLEN</font></span><span style=" mso-ascii- mso-hansi-">前面，那么我把</span><span><font face="Times New Roman">IP</font></span><span style=" mso-ascii- mso-hansi-">头读入一个字节，低位就是</span><span><font face="Times New Roman">VER</font></span><span style=" mso-ascii- mso-hansi-">，高位就是</span><span><font face="Times New Roman">HLEN</font></span><span style=" mso-ascii- mso-hansi-">，结果刚好是反着的。。后面用红框划了的</span><span><font face="Times New Roman">FLAGS</font></span><span style=" mso-ascii- mso-hansi-">和</span><span><font face="Times New Roman">Fragmentation offset</font></span><span style=" mso-ascii- mso-hansi-">也是这样的。</span></p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><span><font face="Times New Roman"> </font></span></p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><font color="#0000ff"><span><font face="Times New Roman">TCP</font></span><span style=" mso-ascii- mso-hansi-">流：</span></font></p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"> </p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><span style=" mso-ascii- mso-hansi-"><span><img class="blogimg" border="0" small="0" src="http://hiphotos.baidu.com/hplonline/pic/item/f437ed118b0028e9a5ef3f6c.jpg"/><br/></span></span></p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"> </p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"> </p>


<p style="text-indent: -18pt; margin: 0cm 0cm 0pt 18pt; mso-list: l0 level1 lfo1; " class="MsoNormal"><span style="mso-fareast-"><span style="mso-list: Ignore"><font face="Times New Roman">1.<span style="font: 7pt  Times New Roman ">        </span></font></span></span><span style=" mso-ascii- mso-hansi-">用红框划起来的一段和在上一节中说的问题一样。因为不是整字节，不方便直接处理，我是先按照</span><span><font face="Times New Roman">16bit</font></span><span style=" mso-ascii- mso-hansi-">读进来，然后高</span><span><font face="Times New Roman">4</font></span><span style=" mso-ascii- mso-hansi-">位</span><span><font face="Times New Roman">HLEN</font></span><span style=" mso-ascii- mso-hansi-">，中间</span><span><font face="Times New Roman">6</font></span><span style=" mso-ascii- mso-hansi-">位保留，其他的</span><span><font face="Times New Roman">FIN,SYN</font></span><span style=" mso-ascii- mso-hansi-">之类的标志放在最低位。一开始以为这些标志是放在该</span><span><font face="Times New Roman">16</font></span><span style=" mso-ascii- mso-hansi-">字节的最高位，导致结果不一致。</span></p>


<p style="text-indent: -18pt; margin: 0cm 0cm 0pt 18pt; mso-list: l0 level1 lfo1; " class="MsoNormal"><font face="Times New Roman"><span style="mso-fareast-"><span style="mso-list: Ignore">2.<span style="font: 7pt  Times New Roman ">        </span></span></span><span>TCP</span></font><span style=" mso-ascii- mso-hansi-">的数据长度没有直接写出来，用</span><span><font face="Times New Roman">IP</font></span><span style=" mso-ascii- mso-hansi-">的总长</span><span><font face="Times New Roman">-IP</font></span><span style=" mso-ascii- mso-hansi-">的头长</span><span><font face="Times New Roman">-TCP</font></span><span style=" mso-ascii- mso-hansi-">的头长即可。</span></p>


<p style="text-indent: -18pt; margin: 0cm 0cm 0pt 18pt; mso-list: l0 level1 lfo1; " class="MsoNormal"> </p>


<p style="text-indent: -18pt; margin: 0cm 0cm 0pt 18pt; mso-list: l0 level1 lfo1; " class="MsoNormal"> </p>


<p style="text-indent: -18pt; margin: 0cm 0cm 0pt 18pt; mso-list: l0 level1 lfo1; " class="MsoNormal"> </p>


<p style="text-indent: -18pt; margin: 0cm 0cm 0pt 18pt; mso-list: l0 level1 lfo1; " class="MsoNormal"><span style=" mso-ascii- mso-hansi-"><span><font face="Times New Roman">数据和程序文件：<a target="_blank" href="http://www.box.net/shared/b7focz9xdn">下载</a></font><font face="Times New Roman"> </font></span></span></p>


<p style="text-indent: -18pt; margin: 0cm 0cm 0pt 18pt; mso-list: l0 level1 lfo1; " class="MsoNormal"><span style=" mso-ascii- mso-hansi-">（不知道明年会不会有UESTC.NE的小朋友无意碰到这个东西。。）</span></p>


<p style="text-indent: -18pt; margin: 0cm 0cm 0pt 18pt; mso-list: l0 level1 lfo1; " class="MsoNormal"><span style=" mso-ascii- mso-hansi-"><span/></span> </p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><span/> </p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><span/></p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><span/> </p>


<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><span><font face="Times New Roman"> </font></span></p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/11/23/MATRIXLIB%28pureC%29/">MATRIX LIB (Pure C)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-11-23T13:06:00+08:00" pubdate data-updated="true">Nov 23<span>rd</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.11.23</p>


<p><font color="#0000ff">BACKGROUND:</font></p>


<p><a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/ede99845db316435869473c9.html">CLAPACK</a> is efficient but <a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/0832b63e5cd883f0838b1386.html">hard to use</a>.<br/>
We often care about a few of its returning values.<br/>
So I wrapped functions for eigenvectors , eigenvalues and solving linear equation here.<br/>
BTW , some basic operation must be realised first ,<br/>
like CREATE , COPY , DESTROY &#8230;<br/>
This results in about 650 lines pure C code , <br/>
appearing like a simple MATRIX LIB .</p>


<p>Any bug report is welcome .</p>


<p><font color="#0000ff">CODE :</font></p>


<p><font color="#ff9900">/*matrix_lib.h*/</font></p>


<p>#ifndef __H_MATRIX_LIB_<br/>
#define __H_MATRIX_LIB_</p>


<p>typedef struct mat_type{<br/>
 int height ;<br/>
 int width ;<br/>
 double **space ;<br/>
}MAT ;</p>


<p>int _toint(double d) ;</p>


<p>MAT m_create(int iHeight , int iWidth);<br/>
void m_destroy(MAT *pM);<br/>
void m_copy(MAT *pMdst , MAT *pMsrc);<br/>
MAT m_get(MAT *pM , MAT *pRow , MAT *pCol);<br/>
void m_set(MAT *pMdst , MAT *pRow , MAT *pCol , MAT *pMsrc);<br/>
void m_add(MAT *pMdst , MAT *pMsrc);<br/>
MAT m_multiply(MAT *pM1 , MAT *pM2);<br/>
void m_scale(MAT *pM , double k);<br/>
MAT m_repmat(MAT *pM , int iHeight , int iWidth);<br/>
MAT m_sort(MAT *pM);<br/>
MAT m_zeros(int iHeight , int iWidth);<br/>
MAT m_ones(int iHeight , int iWidth);<br/>
MAT m_eye(int iHeight , int iWidth);<br/>
void m_print(MAT *pM);<br/>
int m_solve(MAT *pA , MAT *pb , MAT *px) ;<br/>
void m_inv(MAT *pM);<br/>
int m_eig(MAT *pM , MAT *pD , MAT *pV);<br/>
MAT m_series(int begin , int end);<br/>
MAT m_transpose(MAT *pM) ;</p>


<p>#endif</p>


<p><br/>
==============================================</p>


<p><font color="#ff9900">/*matrix_lib.c*/</font></p>


<p>/*<br/>
MATRIX LIB , for quick programming in C .<br/>
Efficiency is not in consideration .</p>


<p>initiated when I have to translate a MATLAB file into C .</p>


<p>functions:<br/>
create<br/>
destroy<br/>
copy<br/>
get<br/>
set<br/>
transpose<br/>
series<br/>
add<br/>
multiply<br/>
scale<br/>
repmat<br/>
sort<br/>
zeros<br/>
ones<br/>
eye<br/>
solve ( built on CLAPACK )<br/>
inv ( a wrapping of &#8216;solve&#8217; for A*X=I)<br/>
eig ( built on CLAPACK )</p>


<p>MAT is the structure for my MATRIX.<br/>
remember to destroy it after the work is completed.</p>


<p>all parameter of MAT is in pointer style , <br/>
while returning MAT is not .</p>


<p>I simply use double as the element type .</p>


<p>indices start from 0 .</p>


<p>it&#8217;s disturbing that the CLIENT should keep in mind that <br/>
MAT must be DESTROYED after using .<br/>
space allocation of returning MAT and OUTPUT MAT structure is done by the functions themself , <br/>
while INPUT MAT should be properly created by the CLIENT .</p>


<p>&#8212;&#8212;&#8212;&#8212;code by hplonline</p>


<p>*/</p>


<p>#include &lt;stdio.h&gt;<br/>
#include &lt;assert.h&gt;</p>


<p>#include &#8220;matrix_lib.h&#8221;</p>


<p>/*<br/>
these lines are for VC6 .<br/>
please add these lib files for your own compiler<br/>
*/<br/>
#pragma comment(lib , &#8220;blas.lib&#8221;) <br/>
#pragma comment(lib , &#8220;clapack.lib&#8221;)</p>


<p>/*<br/>
since some functions in stdlib.h collide with ones in clapack.h&#8221; , <br/>
I make these declarations mannually<br/>
*/<br/>
void *malloc(size_t n) ;<br/>
void free(void* p) ;</p>


<p>#include &#8220;f2c.h&#8221;<br/>
#include &#8220;clapack.h&#8221;</p>


<p>/*<br/>
memory is managed through an Iliffle vector.<br/>
so reference to the elements is rather simple :</p>


<p>  m.space[0][1] = 3 ;<br/>
*/</p>


<p>int _toint(double d){<br/>
 return (int)(d + 0.5) ;<br/>
}</p>


<p>MAT m_create(int iHeight , int iWidth){<br/>
 int i ;<br/>
 MAT tmp ;<br/>
 tmp.width = iWidth ;<br/>
 tmp.height = iHeight ;<br/>
 tmp.space = (double **)malloc(iHeight * sizeof(double*)) ;<br/>
 for ( i = 0 ; i &lt; iHeight ; i ++ ){<br/>
   tmp.space[i] = (double *)malloc(iWidth * sizeof(double)) ;<br/>
 }<br/>
 return tmp ;<br/>
}</p>


<p>/*<br/>
return a row vector from begin to end<br/>
ie.<br/>
begin = 1 , end = 4 ;<br/>
return :<br/>
1 2 3 4 <br/>
*/<br/>
MAT m_series(int begin , int end){<br/>
 MAT tmp ;<br/>
 int i ;</p>


<p> assert(end &gt; begin) ;</p>


<p> tmp = m_create(1 , end - begin + 1) ;<br/>
 for ( i = 0 ; i &lt; tmp.width ; i ++ ){<br/>
   tmp.space[0][i] = (double)(begin + i) ; <br/>
 }<br/>
 return tmp ;<br/>
}</p>


<p>MAT m_transpose(MAT *pM){<br/>
 MAT tmp ;<br/>
 int i , j ;</p>


<p> assert(pM-&gt;space != NULL) ;</p>


<p> tmp = m_create(pM-&gt;width , pM-&gt;height) ;<br/>
 for ( i = 0 ; i &lt; pM-&gt;height ; i ++ ){<br/>
   for ( j = 0 ; j &lt; pM-&gt;width ; j ++ ){<br/>
    tmp.space[j][i] = pM-&gt;space[i][j] ;<br/>
   }<br/>
 }<br/>
 return tmp ;<br/>
}</p>


<p>void m_destroy(MAT *pM){<br/>
 int i ;</p>


<p> assert(pM-&gt;space != NULL) ;</p>


<p> for ( i = 0 ; i &lt; pM-&gt;height ; i ++ ){<br/>
   free(pM-&gt;space[i]) ;<br/>
 }<br/>
 free(pM-&gt;space) ;<br/>
 pM-&gt;space = NULL ;<br/>
 pM-&gt;height = 0 ;<br/>
 pM-&gt;width = 0 ;<br/>
}</p>


<p>void m_copy(MAT *pMdst , MAT *pMsrc){<br/>
 int i , j ;</p>


<p> assert(pMsrc-&gt;space != NULL) ;</p>


<p> m_destroy(pMdst) ;<br/>
 *pMdst = m_create(pMsrc-&gt;height , pMsrc-&gt;width) ;<br/>
 for ( i = 0 ; i &lt; pMsrc-&gt;height ; i ++ ){<br/>
   for ( j = 0 ; j &lt; pMsrc-&gt;width ; j ++ ){<br/>
    pMdst-&gt;space[i][j] = pMsrc-&gt;space[i][j] ;<br/>
   }<br/>
 }<br/>
}</p>


<p>/*<br/>
pRow and pCol must be row vectors <br/>
pM-&gt;:<br/>
1 2 3 <br/>
4 5 6<br/>
7 8 9<br/>
pRow-&gt;:<br/>
0 2 <br/>
pCol-&gt;:<br/>
0 1<br/>
return:<br/>
1 2 <br/>
7 8<br/>
*/<br/>
MAT m_get(MAT *pM , MAT *pRow , MAT *pCol){<br/>
 MAT tmp ;<br/>
 int i , j ;<br/>
 tmp = m_create(pRow-&gt;width , pCol-&gt;width) ;<br/>
 for ( i = 0 ; i &lt; pRow-&gt;width ; i ++ ){<br/>
   for ( j = 0 ; j &lt; pCol-&gt;width ; j ++ ){<br/>
    tmp.space[i][j] = <br/>
     pM-&gt;space[_toint(pRow-&gt;space[0][i])][_toint(pCol-&gt;space[0][j])] ;<br/>
   }<br/>
 }<br/>
 return tmp ;<br/>
}</p>


<p>void m_set(MAT *pMdst , MAT *pRow , MAT *pCol , MAT *pMsrc){<br/>
 int i , j ;</p>


<p> assert(pRow-&gt;width == pMsrc-&gt;height &amp;&amp; pCol-&gt;width == pMsrc-&gt;width) ;</p>


<p> for ( i = 0 ; i &lt; pRow-&gt;width ; i ++ ){<br/>
   for ( j = 0 ; j &lt; pCol-&gt;width ; j ++ ){<br/>
    pMdst-&gt;space[_toint(pRow-&gt;space[0][i])][_toint(pCol-&gt;space[0][j])]<br/>
     = pMsrc-&gt;space[i][j] ;<br/>
   }<br/>
 }</p>


<p>}</p>


<p>/* add *pMsrc to *pMdst */<br/>
void m_add(MAT *pMdst , MAT *pMsrc){<br/>
 int i , j ;</p>


<p> assert(pMdst-&gt;height == pMsrc-&gt;height <br/>
   &amp;&amp; pMdst-&gt;width == pMsrc-&gt;width) ;</p>


<p> for ( i = 0 ; i &lt; pMsrc-&gt;height ; i ++ ){<br/>
   for ( j = 0 ; j &lt; pMsrc-&gt;width ; j ++ ){<br/>
    pMdst-&gt;space[i][j] += pMsrc-&gt;space[i][j] ;<br/>
   }<br/>
 }<br/>
}</p>


<p>/*<br/>
return *m1 multiply *m2<br/>
*/<br/>
MAT m_multiply(MAT *pM1 , MAT *pM2){ <br/>
 MAT tmp ;<br/>
 int i , j , k ;</p>


<p> assert(pM1-&gt;width == pM2-&gt;height) ;</p>


<p> tmp = m_create(pM1-&gt;height , pM2-&gt;width) ;<br/>
 for ( i = 0 ; i &lt; tmp.height ; i ++ ){<br/>
   for ( j = 0 ; j &lt; tmp.width ; j ++ ){<br/>
    tmp.space[i][j] = (double)0.0 ;<br/>
    for ( k = 0 ; k &lt; pM1-&gt;width ; k ++ ){<br/>
     tmp.space[i][j] += <br/>
      pM1-&gt;space[i][k] * pM2-&gt;space[k][j] ;<br/>
    }<br/>
   }<br/>
 }</p>


<p> return tmp ;<br/>
}</p>


<p>/*<br/>
return k*A<br/>
*/<br/>
void m_scale(MAT *pM , double k){<br/>
 int i , j ;<br/>
 for ( i = 0 ; i &lt; pM-&gt;height ; i ++ ){<br/>
   for ( j = 0 ; j &lt; pM-&gt;width ; j ++ ){<br/>
    pM-&gt;space[i][j] *= k ;<br/>
   }<br/>
 }<br/>
}</p>


<p>/*<br/>
pm-&gt;:<br/>
1 2<br/>
3 4<br/>
repmat(pm , 1 , 2)-&gt;:<br/>
1 2 <br/>
3 4<br/>
1 2<br/>
3 4<br/>
*/</p>


<p>MAT m_repmat(MAT *pM , int iHeight , int iWidth){<br/>
 int i , j , ii , jj;<br/>
 MAT tmp ;<br/><br/>
 assert(pM-&gt;space != NULL) ;</p>


<p> tmp = m_create(pM-&gt;height * iHeight , pM-&gt;width * iWidth) ;<br/>
 for ( i = 0 ; i &lt; iHeight ; i ++ ){<br/>
   for ( j = 0 ; j &lt; iWidth ; j ++ ){<br/>
    for ( ii = 0 ; ii &lt; pM-&gt;height ; ii ++ ){<br/>
     for ( jj = 0 ; jj &lt; pM-&gt;width ; jj ++ ){<br/>
      tmp.space[i * pM-&gt;height + ii][j * pM-&gt;width + jj]<br/>
       = pM-&gt;space[ii][jj] ;<br/>
     }<br/>
    }<br/>
   }<br/>
 }</p>


<p> return tmp ;<br/>
}</p>


<p>/*<br/>
sort each column<br/>
return indice</p>


<p>using select sorting <br/>
*/</p>


<p>MAT m_sort(MAT *pM){<br/>
 int i , j , k ;<br/>
 MAT  index ;<br/>
 double tmp ;<br/><br/>
 index = m_create(pM-&gt;height , pM-&gt;width) ;<br/>
 for ( j = 0 ; j &lt; pM-&gt;width ; j ++ ){<br/>
   for ( i = 0 ; i &lt; pM-&gt;height ; i ++ ){<br/>
    index.space[i][j] = i ;<br/>
   }<br/>
   for ( i = 0 ; i &lt; pM-&gt;height - 1 ; i ++ ){<br/>
    for ( k = i + 1 ; k &lt; pM-&gt;height ; k ++ ){<br/>
     if ( pM-&gt;space[k][j] &lt; pM-&gt;space[i][j] ) {<br/>
      tmp = pM-&gt;space[k][j] ;<br/>
      pM-&gt;space[k][j] = pM-&gt;space[i][j] ;<br/>
      pM-&gt;space[i][j] = tmp ;<br/>
    <br/>
      tmp = index.space[k][j] ;<br/>
      index.space[k][j] = index.space[i][j] ;<br/>
      index.space[i][j] = tmp ;     <br/>
     }<br/>
    }<br/>
   }<br/>
 }</p>


<p> return index ;<br/>
}</p>


<p>MAT m_zeros(int iHeight , int iWidth){<br/>
 MAT tmp ;<br/>
 int i , j ;<br/>
 tmp = m_create(iHeight , iWidth) ;<br/>
 for ( i = 0 ; i &lt; iHeight ; i ++ ){<br/>
   for ( j = 0 ; j &lt; iWidth ; j ++ ){<br/>
    tmp.space[i][j] = 0 ;<br/>
   }<br/>
 }<br/>
 return tmp ;<br/>
}</p>


<p>MAT m_ones(int iHeight , int iWidth){<br/>
 MAT tmp ;<br/>
 int i , j ;<br/>
 tmp = m_create(iHeight , iWidth) ;<br/>
 for ( i = 0 ; i &lt; iHeight ; i ++ ){<br/>
   for ( j = 0 ; j &lt; iWidth ; j ++ ){<br/>
    tmp.space[i][j] = 1 ;<br/>
   }<br/>
 }<br/>
 return tmp ;<br/>
}</p>


<p>MAT m_eye(int iHeight , int iWidth){<br/>
 MAT tmp ;<br/>
 int i , j ;<br/>
 tmp = m_create(iHeight , iWidth) ;<br/>
 for ( i = 0 ; i &lt; iHeight ; i ++ ){<br/>
   for ( j = 0 ; j &lt; iWidth ; j ++ ){<br/>
    if ( i ==j ) {<br/>
     tmp.space[i][j] = 1 ;<br/>
    }else{<br/>
     tmp.space[i][j] = 0 ;<br/>
    }<br/>
   }<br/>
 }<br/>
 return tmp ;<br/>
}</p>


<p>void m_print(MAT *pM){<br/>
 int i , j ;<br/>
 printf(&#8220;%d * %d :\n&#8221; , pM-&gt;height , pM-&gt;width) ;<br/>
 for ( i = 0 ; i &lt; pM-&gt;height ; i ++ ){<br/>
   for ( j = 0 ; j &lt; pM-&gt;width ; j ++ ){<br/>
    printf(&#8220;%8.2f&#8221; , pM-&gt;space[i][j]) ;<br/>
   }<br/>
   printf(&#8220;\n&#8221;) ;<br/>
 }<br/>
}</p>


<p>/*<br/>
Ax=b<br/>
return x<br/>
*/<br/>
int m_solve(MAT *pA , MAT *pb , MAT *px){<br/>
 integer n , nrhs , lda , *ipiv , ldb , info ;<br/>
 doublereal *a , *b;<br/>
 int i , j ;<br/>
     <br/>
 n = pA-&gt;width ;<br/>
 nrhs = pb-&gt;width ;<br/>
 lda = pA-&gt;height ;<br/>
 ldb = pb-&gt;height ;<br/>
 ipiv = (integer*) malloc(sizeof(integer) * n) ;</p>


<p> a = (doublereal*) malloc(sizeof(doublereal) * n * lda) ;<br/>
 for ( j = 0 ; j &lt; n ; j ++ ){<br/>
   for ( i = 0 ; i &lt; lda ; i ++ ){<br/>
    a[lda * j + i] = pA-&gt;space[i][j] ;<br/>
   }<br/>
 }</p>


<p> b = (doublereal*) malloc(sizeof(doublereal) * nrhs * ldb) ;<br/>
 for ( j = 0 ; j &lt; nrhs ; j ++ ){<br/>
   for ( i = 0 ; i &lt; ldb ; i ++ ){<br/>
    b[ldb * j + i] = pb-&gt;space[i][j] ;<br/>
   }<br/>
 }</p>


<p> dgesv_(&amp;n, &amp;nrhs, a, &amp;lda, ipiv, b, &amp;ldb, &amp;info) ;</p>


<p> if ( info != 0 ) return info ;</p>


<p> printf(&#8220;\ntesting ipiv:\n&#8221;) ;<br/>
 for ( i = 0 ; i &lt; n ; i ++ ){<br/>
   printf(&#8220;%d &#8221; , ipiv[i]) ;<br/>
 }<br/>
 printf(&#8220;\ntesting ipiv end\n\n&#8221;) ;</p>


<p> printf(&#8220;\ntesting A\n&#8221;) ;<br/>
 for ( i = 0 ; i &lt; lda ; i ++ ){<br/>
   for ( j = 0 ; j &lt; n ; j ++ ){<br/>
    printf(&#8220;%8.2f&#8221; , a[j * lda + i]) ;<br/>
   }<br/>
   printf(&#8220;\n&#8221;) ;<br/>
 }<br/>
 printf(&#8220;\ntesting matrix A end..\n\n&#8221;) ;</p>


<p> *px = m_create(n , nrhs) ;<br/>
 for ( j = 0 ; j &lt; nrhs ; j ++ ){<br/>
   for ( i = 0 ; i &lt; n ; i ++ ){<br/>
    px-&gt;space[i][j] = b[j * n + i] ;<br/>
   }<br/>
 }</p>


<p> free(ipiv) ;<br/>
 free(a) ;<br/>
 free(b) ;<br/>
 return info ;<br/>
}</p>


<p>/*<br/>
inverse *pM<br/>
*/</p>


<p>void m_inv(MAT *pM){<br/>
 MAT I , x ;<br/>
 I = m_eye(pM-&gt;height , pM-&gt;height) ;<br/>
 m_solve(pM , &amp;I , &amp;x) ;<br/>
 m_copy(pM , &amp;x) ;<br/>
 m_destroy(&amp;I) ;<br/>
 m_destroy(&amp;x) ;<br/>
}</p>


<p>/* <br/>
return eigenvectors in *pV and eigenvalues in *pD<br/>
only tested for *pM is square<br/>
*/</p>


<p>int m_eig(MAT *pM , MAT *pD , MAT *pV){<br/>
 int i , j ;<br/>
 char jobvl , jobvr;<br/>
 integer n , lda , info , ldvr , ldvl , lwork ;<br/>
 doublereal *a , *wr , *wi , *vl , *vr , *work;</p>


<p> jobvl = &#8216;N&#8217; ;<br/>
 jobvr = &#8216;V&#8217; ;<br/>
 n = pM-&gt;width ;<br/>
 lda = pM-&gt;height ;</p>


<p> wr = (doublereal*)malloc( sizeof(doublereal) * n) ;<br/>
 wi = (doublereal*)malloc( sizeof(doublereal) * n) ; </p>


<p> ldvr = pM-&gt;height ;<br/>
 vr = (doublereal*)malloc( sizeof(doublereal) * n * ldvr) ;<br/>
 ldvl = ldvr ;<br/>
 vl = vr ;</p>


<p> a = (doublereal*) malloc(sizeof(doublereal) * n * lda) ;<br/>
 for ( j = 0 ; j &lt; n ; j ++ ){<br/>
   for ( i = 0 ; i &lt; lda ; i ++ ){<br/>
    a[lda * j + i] = pM-&gt;space[i][j] ;<br/>
   }<br/>
 }</p>


<p>/* ldvl = 3 ;<br/>
 vl = (doublereal*)malloc( sizeof(doublereal) * n * ldvl) ;*/</p>


<p> lwork = n * 4 ;<br/>
 work = (doublereal*)malloc( sizeof(doublereal) * lwork) ;</p>


<p> dgeev_(&amp;jobvl, &amp;jobvr, &amp;n, a,  &amp;lda, wr, wi, vl , &amp;ldvl , vr, &amp;ldvr, work, &amp;lwork, &amp;info) ;</p>


<p> if ( info != 0 ) return info ;</p>


<p> *pD = m_create(n , n) ;<br/>
 for ( j = 0 ; j &lt; n ; j ++ ){<br/>
   for ( i = 0 ; i &lt; n ; i ++ ){<br/>
    if ( i == j ){<br/>
     pD-&gt;space[i][j] = wr[i] ;<br/>
    }else{<br/>
     pD-&gt;space[i][j] = 0.0 ;<br/>
    }<br/>
   }<br/>
 }</p>


<p> *pV = m_create(n , n) ;<br/>
 for ( j = 0 ; j &lt; n ; j ++ ){<br/>
   for ( i = 0 ; i &lt; n ; i ++ ){<br/>
    pV-&gt;space[i][j] = vr[j * n + i] ;<br/>
   }<br/>
 }</p>


<p> free(a) ;<br/>
 free(wr) ;<br/>
 free(wi) ;<br/>
 free(work) ;<br/>
 free(vr) ;</p>


<p> return info ;</p>


<p>/* printf(&#8220;info:%d\n&#8221; , info) ;<br/>
 printf(&#8220;D = \n&#8221;) ;<br/>
 for ( i = 0 ; i &lt; n ; i ++ ){<br/>
   for ( j = 0 ; j &lt; n ; j ++ ){<br/>
    if ( i == j ) printf(&#8220;%10.5f&#8221; , wr[i]) ;<br/>
    else printf(&#8220;%10.5f&#8221; , 0.0) ;<br/>
   }<br/>
   printf(&#8220;\n&#8221;) ;<br/>
 }<br/>
 printf(&#8220;Vl = \n&#8221;) ;<br/>
 for ( i = 0 ; i &lt; n ; i ++ ){<br/>
   for ( j = 0 ; j &lt; n ; j ++ ){<br/>
    printf(&#8220;%10.5f&#8221; , vl[n * j + i]) ;<br/>
   }<br/>
   printf(&#8220;\n&#8221;) ;<br/>
 }<br/>
 printf(&#8220;Vr = \n&#8221;) ;<br/>
 for ( i = 0 ; i &lt; n ; i ++ ){<br/>
   for ( j = 0 ; j &lt; n ; j ++ ){<br/>
    printf(&#8220;%10.5f&#8221; , vr[n * j + i]) ;<br/>
   }<br/>
   printf(&#8220;\n&#8221;) ;<br/>
 }<br/>
*/</p>


<p>}</p>


<p>/*<br/>
tests of :<br/>
eigs , solve , inv , sort<br/>
*/</p>


<p>int main(){<br/>
 int i , j ;<br/>
 double data_a[3][3] = {<br/>
   {1 , 3 , 5} ,<br/>
   {2 , 7 , 1} , <br/>
   {9 , 2 , 4}<br/>
 } ;<br/>
 double data_b[3] = {5 , 1 , 2} ;<br/>
 MAT A , b , x , D , V , index;</p>


<p> A = m_create(3 , 3) ;<br/>
 for ( i = 0 ; i &lt; 3 ; i ++ ){<br/>
   for ( j = 0 ; j &lt; 3 ; j ++ ){<br/>
    A.space[i][j] = data_a[i][j] ;<br/>
   }<br/>
 }<br/>
 b = m_create(3 , 1) ;<br/>
 for ( i = 0 ; i &lt; 3 ; i ++ ){<br/>
   b.space[i][0] = data_b[i] ;<br/>
 }</p>


<p> printf(&#8220;A=\n&#8221;) ;<br/>
 m_print(&amp;A) ;<br/>
 printf(&#8220;b=\n&#8221;) ;<br/>
 m_print(&amp;b) ;</p>


<p> m_eig(&amp;A , &amp;D , &amp;V) ;<br/>
 printf(&#8220;D=\n&#8221;) ;<br/>
 m_print(&amp;D) ;<br/>
 printf(&#8220;V=\n&#8221;) ;<br/>
 m_print(&amp;V) ;</p>


<p> m_solve(&amp;A , &amp;b ,&amp;x) ;<br/>
 printf(&#8220;solving A*x = b\n&#8221;) ;<br/>
 printf(&#8220;x=\n&#8221;) ;<br/>
 m_print(&amp;x) ;</p>


<p> m_inv(&amp;A) ;<br/>
 printf(&#8220;inversing A\n&#8221;) ;<br/>
 printf(&#8220;A=&#8221;) ;<br/>
 m_print(&amp;A) ;</p>


<p> index = m_sort(&amp;A) ;<br/>
 printf(&#8220;sorting A:\n&#8221;) ;<br/>
 m_print(&amp;A) ;<br/>
 printf(&#8220;index is:\n&#8221;) ;<br/>
 m_print(&amp;index) ;</p>


<p> m_destroy(&amp;index) ;<br/>
 m_destroy(&amp;A) ;<br/>
 m_destroy(&amp;b) ;<br/>
 m_destroy(&amp;x) ;<br/>
 m_destroy(&amp;D) ;<br/>
 m_destroy(&amp;V) ;</p>


<p> return 0 ;<br/>
}</p>


<p> </p>


<p>/*<br/>
tests of :<br/>
get , set , series<br/>
*/</p>


<p>/*<br/>
int main(){<br/>
 int i , j ;<br/>
 MAT m1 , m2 , col , row ;</p>


<p> m1 = m_create(3 , 3) ;<br/>
 for ( i = 0 ; i &lt; 3 ; i ++ ){<br/>
   for ( j = 0 ; j &lt; 3 ; j ++ ){<br/>
    m1.space[i][j] = i * 3 + j + 1 ;<br/>
   }<br/>
 }<br/>
 m_print(&amp;m1) ;</p>


<p> col = m_create(1 , 2) ;<br/>
 col.space[0][0] = 0 ;<br/>
 col.space[0][1] = 1 ;</p>


<p> row = m_create(1 , 2) ;<br/>
 row.space[0][0] = 0 ;<br/>
 row.space[0][1] = 2 ;</p>


<p> m2 = m_get(&amp;m1 , &amp;row ,  &amp;col) ;<br/>
 m_print(&amp;m2) ;</p>


<p> m_destroy(&amp;m2) ;<br/>
 m2 = m_zeros(2,2) ;<br/>
 col.space[0][1] = 2 ;<br/>
 m_set(&amp;m1 , &amp;row , &amp;col , &amp;m2) ;<br/>
 m_print(&amp;m1) ;</p>


<p> m_destroy(&amp;col) ;<br/>
 m_destroy(&amp;m2) ;<br/>
 col = m_series(0 , 2) ;<br/>
 m2 = m_get(&amp;m1 , &amp;row  , &amp;col) ;<br/>
 m_print(&amp;m2) ;</p>


<p> m_destroy(&amp;m1) ;<br/>
 m_destroy(&amp;m2) ;<br/>
 m_destroy(&amp;col) ;<br/>
 m_destroy(&amp;row) ;</p>


<p> return 0 ;<br/>
}<br/>
*/</p>


<p>/*<br/>
basic tests :<br/>
create ,destroy , copy , print ,eye ,ones ,zeros ,repmat ,add ,multiply , scale , transpose<br/>
*/</p>


<p>/*<br/>
int main(){<br/>
 MAT m , mm , a , b , c;<br/>
 int i , j ;</p>


<p> m = m_zeros(2 , 3) ;<br/>
 m.space[1][2] = 1 ;<br/>
 m_print(&amp;m) ;<br/>
 mm = m_repmat(&amp;m , 3 , 2) ;<br/>
 m_print(&amp;mm) ;<br/>
 m_destroy(&amp;mm) ;<br/>
 m_destroy(&amp;m) ;</p>


<p> m = m_ones(6 , 5) ;<br/>
 m_print(&amp;m) ;<br/>
 m_destroy(&amp;m) ;</p>


<p> m = m_eye(3 , 4) ;<br/>
 m_print(&amp;m) ;<br/>
 m_destroy(&amp;m) ;</p>


<p> m = m_eye(4 , 3) ;<br/>
 m_print(&amp;m) ;<br/>
 m_destroy(&amp;m) ;</p>


<p> a = m_ones(2 , 3) ;<br/>
 b = m_ones(3 , 2) ;<br/>
 m_print(&amp;a) ;<br/>
 m_print(&amp;b) ;<br/>
 c = m_multiply(&amp;a , &amp;b) ;<br/>
 m_print(&amp;c) ;<br/>
 m_destroy(&amp;a) ;<br/>
 m_destroy(&amp;b) ;<br/>
 m_destroy(&amp;c) ;</p>


<p> a = m_ones(2 , 3) ;<br/>
 b = m_ones(2 , 3) ;<br/>
 m_scale(&amp;b , 1.7) ;<br/>
 m_print(&amp;b) ;<br/>
 m_add(&amp;a , &amp;b) ;<br/>
 m_print(&amp;a) ;</p>


<p> m_destroy(&amp;b) ;<br/>
 b = m_transpose(&amp;a) ;<br/>
 m_print(&amp;b) ;<br/>
 m_destroy(&amp;a) ;<br/>
 m_destroy(&amp;b) ;</p>


<p> return 0 ;<br/>
}<br/>
*/</p>


<p><font color="#0000ff">TO BE CONTINUED:</font></p>


<p>It&#8217;s well-known that the memory management in C is hard to done ,<br/>
for you should always keep in mind where you put a MALLOC <br/>
and whether you put a corresponding FREE .</p>


<p>My next step is to convert it to C++ class .<br/>
This can free the client from memory management , <br/>
which must be done in the CTOR and DTOR of a class .</p>


<p> </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/11/15/CLAPACK%E7%9A%84dgeev_%E6%B1%82%E7%89%B9%E5%BE%81%E5%80%BC/">CLAPACK的dgeev_求特征值</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-11-15T16:07:00+08:00" pubdate data-updated="true">Nov 15<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.11.15</p>


<p>CLAPACK在<a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/ede99845db316435869473c9.html">上一篇</a>介绍过了。<br/>
虽然这个库很强大，<br/>
但是参数太冏了，<br/>
看了很久才搞定。。</p>


<p>这篇讲解dgeev_函数的用法，<br/>
从这一个函数也可以认识LAPACK的一些习惯问题，<br/>
进而可以使用其他的函数。</p>


<p><font color="#0000ff">》》特征值和特征向量</font></p>


<p>我们平时使用的一般都是右特征向量，定义为：<br/>
A*alpha = lamda * alpha<br/>
另外还有一种定义的左特征向量：<br/>
beta*A = lamda * beta</p>


<p>而该函数被设计为可以选择求出：<br/>
只有特征值，左边特征向量，右边特征向量</p>


<p><font color="#0000ff">》》关于参数的解释</font></p>


<p>从头文件里面直接摘录的原型如下：</p>


<p>int dgeev_(char *jobvl, char *jobvr, integer *n, doublereal *<br/>
     a, integer *lda, doublereal *wr,</p>


<p>doublereal *wi, doublereal *vl, <br/>
     integer *ldvl, doublereal *vr, integer *ldvr, doublereal *work, <br/></p>


<p>  integer *lwork, integer *info);</p>


<p>首先，最明显的是，所有参数都按照指针传入。<br/>
然后这套函数库有个共同的习惯，<br/>
即要求调用者来处理空间，<br/>
包括提供返回值的空间，<br/>
用来计算的临时空间。</p>


<p><font color="#ff9900">函数命名：</font></p>


<p>d表示double。<br/>
ge表示general，说明是普通矩阵，按照列主序存储。<br/>
ev表示eigenvector吧（疑问语气），表达的是函数的功能。</p>


<p><font color="#ff9900">用到的类型解释：</font></p>


<p>char*，是字符串类型，但LAPACK的函数只关注该字符串的第一个字符<br/>
integer,就是C里面的int，一般用来指定维度<br/>
doublereal，就是C里面的double，参数类型和函数前缀统一（这里是d）</p>


<p><font color="#ff9900">各个参数：</font></p>


<p>char *jobvl, 第一个字符为&#8217;N&#8217;，表示不求左特征向量，为&#8217;V&#8217;表示要求<br/>
char *jobvr, 同上，是对右特征向量的选项<br/>
integer *n, 矩阵的列数<br/>
doublereal *<br/>
a, 存储A矩阵的空间（列主序！！）<br/>
integer *lda, A矩阵的行数<br/>
doublereal *wr, 返回的特征值，实部<br/>
doublereal *wi, 返回的特征值，虚部<br/>
doublereal *vl, 左特征向量的存储空间，大小为ldvl*n<br/>
integer *ldvl, 左特征向量存储空间的行数<br/>
doublereal *vr, 右特征向量的存储空间，大小为ldvr*n<br/>
integer *ldvr, 右特征向量存储空间的行数<br/>
doublereal *work, 工作空间，一般至少要4*n<br/>
integer *lwork, 工作空间的大小<br/>
integer *info，返回信息，0表示成功，-i表示第i个参数有问题，+i表示执行错误</p>


<p>具体的看一下代码就明白了，<br/>
实在觉得恼火的，照搬着用也行。。</p>


<p><font color="#ff9900">示例代码：</font></p>


<p>#include &lt; stdio.h&gt;</p>


<p>#pragma comment(lib , &#8220;blas.lib&#8221;) <br/>
#pragma comment(lib , &#8220;clapack.lib&#8221;)</p>


<p>void *malloc(size_t n) ;</p>


<p>#include &#8220;f2c.h&#8221;<br/>
#include &#8220;clapack.h&#8221;</p>


<p>int main(void)<br/>
{<br/>
     /* 3x3 matrix A<br/>
      * 76 25 11<br/>
      * 27 89 51<br/>
      * 18 60 32<br/>
      */<br/>
     doublereal A[9] = {76, 27, 18, 25, 89, 60, 11, 51, 32};</p>


<p>     integer info ;<br/>
     int i , j ;</p>


<p>     char jobvl = &#8216;V&#8217; ;<br/>
     char jobvr = &#8216;V&#8217; ;<br/>
     integer n = 3 ;<br/>
     doublereal *a = A ;<br/>
     integer lda = 3 ;<br/>
     <br/>
     doublereal* wr = (doublereal*)malloc( sizeof(doublereal) * n) ;<br/>
     doublereal* wi = (doublereal*)malloc( sizeof(doublereal) * n) ;   </p>


<p>     integer ldvr = 3 ;<br/>
     doublereal* vr = (doublereal*)malloc( sizeof(doublereal) * n * ldvr) ;</p>


<p>     integer ldvl = 3 ;<br/>
     doublereal* vl = (doublereal*)malloc( sizeof(doublereal) * n * ldvl) ;</p>


<p>     integer lwork = n * 4 ;<br/>
     doublereal *work = (doublereal*)malloc( sizeof(doublereal) * lwork) ;</p>


<p>     dgeev_(&amp;jobvl, &amp;jobvr, &amp;n, a,  &amp;lda, wr, wi, vl , &amp;ldvl , vr, &amp;ldvr, work, &amp;lwork, &amp;info) ;</p>


<p>     printf(&#8220;info:%d\n&#8221; , info) ;<br/>
     printf(&#8220;D = \n&#8221;) ;<br/>
     for ( i = 0 ; i &lt; n ; i ++ ){<br/>
         for ( j = 0 ; j &lt; n ; j ++ ){<br/>
             if ( i == j ) printf(&#8220;%10.5f&#8221; , wr[i]) ;<br/>
             else printf(&#8220;%10.5f&#8221; , 0.0) ;<br/>
         }<br/>
         printf(&#8220;\n&#8221;) ;<br/>
     }<br/>
     printf(&#8220;Vl = \n&#8221;) ;<br/>
     for ( i = 0 ; i &lt; n ; i ++ ){<br/>
         for ( j = 0 ; j &lt; n ; j ++ ){<br/>
             printf(&#8220;%10.5f&#8221; , vl[n * j + i]) ;<br/>
         }<br/>
         printf(&#8220;\n&#8221;) ;<br/>
     }<br/>
     printf(&#8220;Vr = \n&#8221;) ;<br/>
     for ( i = 0 ; i &lt; n ; i ++ ){<br/>
         for ( j = 0 ; j &lt; n ; j ++ ){<br/>
             printf(&#8220;%10.5f&#8221; , vr[n * j + i]) ;<br/>
         }<br/>
         printf(&#8220;\n&#8221;) ;<br/>
     }<br/>
     return info;<br/>
}</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/11/15/C%E7%9A%84%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97%E5%BA%93CLAPACK%EF%BC%88VC6%EF%BC%89/">C的矩阵运算库CLAPACK（VC6）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-11-15T14:55:00+08:00" pubdate data-updated="true">Nov 15<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.11.14</p>


<p><font color="#0000ff">》》各种资料和笔记</font></p>


<p>主页<br/><a href="http://www.netlib.org/clapack/">http://www.netlib.org/clapack/</a></p>


<p>一份简单的CLAPACK的hello world<br/><a href="http://www.cs.rochester.edu/~bh/cs400/using_lapack.html">http://www.cs.rochester.edu/~bh/cs400/using_lapack.html</a></p>


<p>vc6的工具包intro<br/><a href="http://www.netlib.org/clapack/readme.claw32">http://www.netlib.org/clapack/readme.claw32</a><br/>
（这个可以直接用）</p>


<p>winNT下安装一些hint<br/><a href="http://www.netlib.org/clapack/faq.html#1.10">http://www.netlib.org/clapack/faq.html#1.10</a></p>


<p>一篇比较详尽地从BLAS到LAPACK的方法<br/><a href="http://icl.cs.utk.edu/lapack-forum/viewtopic.php?f=2&amp;t=1595&amp;sid=0365ef1e599136085d9385ebb1a6c588">http://icl.cs.utk.edu/lapack-forum/viewtopic.php?f=2&amp;t=1595&amp;sid=0365ef1e599136085d9385ebb1a6c588</a></p>


<p>CLAPACK的readme<br/><a href="http://www.netlib.org/clapack/readme">http://www.netlib.org/clapack/readme</a></p>


<p><font color="#ff9900">1.命名方式</font></p>


<p>使用<br/>
#include &#8220;f2c.h&#8221;<br/>
其中包含一些变量类型和函数类型的定义</p>


<p>在fortran里面写作<br/>
call func(..)<br/>
在C里面写作<br/>
func_()</p>


<p><font color="#ff9900">2.参数传递方式</font></p>


<p>要求都以“引用”传递，<br/>
在C里面表现为全部是指针。</p>


<p><font color="#ff9900">3.字符（串）参数</font></p>


<p>在除了测试和定时代码(timing code)的所有地方，<br/>
函数关注的都仅仅是第一个字符。</p>


<p>引用readme里面的例子，</p>


<p>fortran：<br/>
#     call dpotrf( &#8216;Upper&#8217;, n, a, lda, info )</p>


<p>C：<br/>
#     char s = &#8216;U&#8217;;<br/>
#     dpotrf_(&amp;s, &amp;n, a, &amp;lda, &amp;info);</p>


<p><font color="#ff9900">4.矩阵的主序问题</font></p>


<p>在fortran里面是列主序，<br/>
C中是行主序。</p>


<p>C中调用的正确方法应该是，<br/>
申请一个一维数组，<br/>
然后按照列主序给元素赋值。</p>


<p>（原readme指出，<br/>
a[M][N]这样的二维定义，<br/>
可能被编译器实现为不连续的空间。<br/>
即Iliffle向量（ECP中的叫法）的方式。）</p>


<p><br/>
手册：<br/><a href="http://www.netlib.org/lapack/lug/">http://www.netlib.org/lapack/lug/</a></p>


<p>使用dgeev_的问题：<br/><a href="https://icl.cs.utk.edu/lapack-forum/viewtopic.php?f=2&amp;t=661">https://icl.cs.utk.edu/lapack-forum/viewtopic.php?f=2&amp;t=661</a></p>


<p>手册中关于参数的解释：<br/><a href="http://www.netlib.org/lapack/lug/node110.html">http://www.netlib.org/lapack/lug/node110.html</a></p>


<p>&#8212;&#8212;&#8212;-参数传递的习惯</p>


<p>N 问题的尺寸，也即列的数量<br/>
LD?? (Leading Dimension)，即行的数量<br/>
info 0表示成功，-i表示第i个参数错误，+i计算错误<br/>
work 工作空间<br/>
lwork 工作空间的大小，可以传入-1以从work返回需要的空间<br/>
(这个功能一直没有尝试成功喃。。。）</p>


<p>&#8212;&#8212;&#8212;-</p>


<p><font color="#0000ff">》》环境搭建和第一个简单程序（VC6)</font></p>


<p>我就直接用的下面这个编译好的库：<br/><a href="http://www.netlib.org/clapack/CLAw32.zip">http://www.netlib.org/clapack/CLAw32.zip</a><br/>
在对应的地方去把clapack.lib和blas.lib复制到工程目录下。</p>


<p>把clapack.h复制到工程目录下（从<a href="http://www.netlib.org/clapack/">http://www.netlib.org/clapack/</a>下载）</p>


<p><br/>
#include &lt; stdio.h&gt;</p>


<p>#pragma comment(lib , &#8220;blas.lib&#8221;) <br/>
#pragma comment(lib , &#8220;clapack.lib&#8221;)</p>


<p>#include &#8220;f2c.h&#8221;<br/>
#include &#8220;clapack.h&#8221;</p>


<p>int main(void)<br/>
{<br/>
     /* 3x3 matrix A<br/>
      * 76 25 11<br/>
      * 27 89 51<br/>
      * 18 60 32<br/>
      */<br/>
     double A[9] = {76, 27, 18, 25, 89, 60, 11, 51, 32};<br/>
     double b[3] = {10, 7, 43};</p>


<p>     int N = 3;<br/>
     int nrhs = 1;<br/>
     int lda = 3;<br/>
     int ipiv[3];<br/>
     int ldb = 3;<br/>
     int info;<br/>
     <br/>
     dgesv_(&amp;N, &amp;nrhs, A, &amp;lda, ipiv, b, &amp;ldb, &amp;info);</p>


<p>     if(info == 0) /*  succeed */ <br/>
 printf(&#8220;The solution is %lf %lf %lf\n&#8221;, b[0], b[1], b[2]);<br/>
     else<br/>
 fprintf(stderr, &#8220;dgesv_ fails %d\n&#8221;, info);</p>


<p>     return info;<br/>
}</p>


<p><font color="#0000ff">》》遗留问题</font></p>


<p>直接下载的源码没有编译通，<br/>
搞不懂，据说是VS05的工程，<br/>
我在VS08下没有搞定。。</p>


<p>然后CLAPACK里面函数参数实在是太抽象了，<br/>
不符合通常的应用习惯，需要再次进行封装。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/11/15/%E4%BD%BF%E7%94%A8MATLABEngine%E5%AE%9E%E7%8E%B0%E4%B8%8EC%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/">使用MATLAB Engine实现与C混合编程</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-11-15T11:33:00+08:00" pubdate data-updated="true">Nov 15<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.11.10</p>


<p><font color="#0000ff">》》目的：</font></p>


<p>1.实现快速结果验证<br/>
2.方便的矩阵运算<br/>
3.方便的绘图模块</p>


<p><font color="#0000ff">》》环境：</font></p>


<p>VISTA+MATLAB2009a+VC6.0</p>


<p><font color="#0000ff">》》资料：</font></p>


<p>以安装路径“E:\Program Files\MATLAB\R2009a\”为例</p>


<p>MATLAB外部支持文件夹：<br/>
E:\Program Files\MATLAB\R2009a\extern<br/>
matlab自带的c例程：<br/>
E:\Program Files\MATLAB\R2009a\extern\examples\eng_mat</p>


<p>engine.h的位置：<br/>
E:\Program Files\MATLAB\R2009a\extern\include</p>


<p>各种lib的位置：<br/>
E:\Program Files\MATLAB\R2009a\extern\lib\win32\microsoft</p>


<p>在matlab帮助中输入“C language”即可找到有关MATLAB Engine的一个页面。<br/>
从这个页面开始，学习各种关键词，<br/>
就能够找到一切你需要的资料。</p>


<p>使用MATLAB Engine一般用两套函数就可以了。<br/><font color="#ff0000">1.engXXXX，关于Engine本身的操作，包括打开/关闭，设置/取得变量，执行语句等等。<br/>
2.mxXXXX，关于数据类型mxArray的操作，与MATLAB交互的左右类型全部为mxArray。</font></p>


<p><font color="#0000ff">》》一个搭建实例</font></p>


<p>先在VC6的tools-&gt;options-&gt;directories里添加相关目录</p>


<p><font color="#ff0000">include files:<br/>
E:\Program Files\MATLAB\R2009a\extern\include</font></p>


<p><font color="#ff0000">library files:<br/>
E:\Program Files\MATLAB\R2009a\extern\lib\win32\microsoft</font></p>


<p>做好这些后，如果我们环境一样，<br/>
下面的代码应该能够编通并且正常执行，<br/>
其中包含了常用的一些函数，<br/>
一般来说使用Engine的时候也就用这些了。</p>


<p>#include &lt;stdlib.h&gt;<br/>
#include &lt;stdio.h&gt;<br/>
#include &lt;string.h&gt;</p>


<p>#include &#8220;engine.h&#8221;<br/>
#include &#8220;matrix.h&#8221;</p>


<p>#pragma comment(lib,&#8221;libeng.lib&#8221;) <br/>
#pragma comment(lib,&#8221;libmx.lib&#8221;)</p>


<p>int main()<br/>
{<br/>
     Engine *ep;<br/>
     int i , j ;</p>


<p>     //show how to open MATLAB engine<br/>
     //for remote ones:<br/>
     //engOpen( ADDRESS OF REMOTE SYSTEM ) ;</p>


<p>     if (!(ep = engOpen(&#8220;\0&#8221;))){<br/>
         fprintf(stderr, &#8220;\nCan&#8217;t start MATLAB engine\n&#8221;);<br/>
         return EXIT_FAILURE;<br/>
     }</p>


<p>     //show how to create matrix<br/>
     mxArray *Y = mxCreateDoubleMatrix(1 , 3 , mxREAL) ;<br/>
     <br/>
     //show how to put data in matrix<br/>
     double tmp[3] = {1.0 , 2.0 , 3.0} ;<br/>
     memcpy(mxGetPr(Y) , tmp , sizeof(tmp)) ;</p>


<p>     //show how to put variables in the Engine<br/>
     engPutVariable(ep , &#8220;Y&#8221; , Y) ;</p>


<p>     //show how to execute commands in MATLAB<br/>
     engEvalString(ep, &#8220;X = ones(5,1) * Y&#8221;);<br/>
     <br/>
     //show how to get variables from the Engine<br/>
     mxArray *X = engGetVariable(ep , &#8220;X&#8221;) ;<br/>
     <br/>
     //show how to manipulate dimensions<br/>
     int dims[10] ;<br/>
     int ndims ;<br/>
     ndims = mxGetNumberOfDimensions(X) ;<br/>
     printf(&#8220;total number of dimensions is %d\n&#8221; , ndims) ;<br/>
     memcpy(dims , mxGetDimensions(X) , ndims * sizeof(int)) ;<br/>
     for ( i = 0 ; i &lt; ndims ; i ++ ){<br/>
         printf(&#8220;dimension %d : %d\n&#8221; , i , dims[i]) ;<br/>
     }<br/>
     printf(&#8220;\n&#8221;) ;</p>


<p>     //show how the data is stored in the memory<br/>
     double *p = (double*)mxGetData(X) ;     <br/>
     for ( i = 0 ; i &lt; dims[0] ; i ++ ){<br/>
         for ( j = 0 ; j &lt; dims[1] ; j ++ ){<br/>
             printf(&#8220;%8.2f&#8221; , p[j * dims[0] + i]) ;<br/>
         }<br/>
         printf(&#8220;\n&#8221;) ;<br/>
     }</p>


<p>     //&#8212;important, to release resources<br/>
     mxDestroyArray(X) ;<br/>
     mxDestroyArray(Y) ;</p>


<p>     //show how to hide and unhide MATLAB command window<br/>
     printf(&#8220;type RETURN to hide the MATLAB command window&#8230;\n&#8221;) ;<br/>
     getchar() ;<br/>
     engSetVisible(ep , false) ;<br/>
     printf(&#8220;type RETURN to unhide the MATLAB command window&#8230;\n&#8221;) ;<br/>
     getchar() ;<br/>
     engSetVisible(ep , true) ;</p>


<p>     printf(&#8220;type RETURN to END this program&#8230;\n&#8221;) ;<br/>
     getchar() ;     <br/>
     //remembering to close it is important .<br/>
     //but if you are debugging your programs , <br/>
     //annotate the following line will save you a lot of time ,<br/>
     //for you needn&#8217;t to restart the Engine .<br/>
     engClose(ep) ;<br/>
     <br/>
     //when your work is accomplished , type &#8220;exit&#8221; in MATLAB command window</p>


<p>     return EXIT_SUCCESS;<br/>
}</p>


<p> </p>


<p><br/><font color="#0000ff">》》某些问题</font></p>


<p>如果出现这个：</p>


<p>engdemo.obj : error LNK2001: unresolved external symbol _engClose<br/>
engdemo.obj : error LNK2001: unresolved external symbol _engSetVisible<br/>
engdemo.obj : error LNK2001: unresolved external symbol _mxDestroyArray<br/>
engdemo.obj : error LNK2001: unresolved external symbol _mxGetData<br/>
engdemo.obj : error LNK2001: unresolved external symbol _mxGetDimensions_730<br/>
engdemo.obj : error LNK2001: unresolved external symbol _mxGetNumberOfDimensions_730<br/>
engdemo.obj : error LNK2001: unresolved external symbol _engGetVariable<br/>
engdemo.obj : error LNK2001: unresolved external symbol _engEvalString<br/>
engdemo.obj : error LNK2001: unresolved external symbol _engPutVariable<br/>
engdemo.obj : error LNK2001: unresolved external symbol _mxGetPr<br/>
engdemo.obj : error LNK2001: unresolved external symbol _mxCreateDoubleMatrix_730<br/>
engdemo.obj : error LNK2001: unresolved external symbol _engOpen</p>


<p>其实就是lib没有添加好。</p>


<p>在代码中写上：<br/>
#pragma comment(lib,&#8221;libeng.lib&#8221;) <br/>
#pragma comment(lib,&#8221;libmx.lib&#8221;)<br/>
就可以了。</p>


<p>或者可以在工程的连接设置里面添加这两个库。<br/>
不过我倾向于前者，这样在发布源码的同时，<br/>
就尽最大可能地保证能够编译，<br/>
而不用其他人学习的时候再去设置。</p>


<p>当然，由于#pragma是由编译器自己决定的，<br/>
所以代码的可移植性存在一些问题。</p>


<p>如果还是报上面的错误，估计是没有将lib的路径添加对。<br/>
具体参考上面的那个实例，然后注意把路径换成自己机器上的。</p>


<p><font color="#0000ff">》》小结</font></p>


<p>前几天围观了一个人用MATCOM混编，<br/>
发现确实很混。。。<br/>
比如调用rand的时候，直接就被MATLAB的rand给覆盖了。<br/>
因为他的头文件里面有类似<br/>
#define rand randM ?????<br/>
这样的东西，<br/>
于是在编译器接到代码之前，该代码已经被预处理替换了。<br/>
这样根本不会出现函数重复的编译或者连接错误。<br/>
这在某种意义上带来了一些隐患，影响调试。<br/>
（当时帮他看了半天才反映过来。。。）</p>


<p>使用MATLAB Engine的话，双方代码的隔离性很好。<br/>
由于使用字符串进行代码交互，开发效率可能会低一点。<br/>
另外在数据交互上比较麻烦一点，需要mxXXX系列的函数。<br/>
（<br/>
用MATCOM的时候甚至可以直接写出<br/>
mVar = CVar ;<br/>
这样的赋值。。。<br/>
由已经实现好的强大的类库来完成底层的转换。<br/>
）</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/11/09/%EF%BC%83line%EF%BC%88VC6%EF%BC%89/">＃line（VC6）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-11-09T20:27:00+08:00" pubdate data-updated="true">Nov 9<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.11.9<br/><br/>
昨天观摩一个人用MATLAB和C混合编程，<br/>
看到了一个以前没用过的东西。。<br/><br/></p>

<h1>line<br/><br/></h1>

<p>其作用是指示编译器改变当前的行号和文件名，用法为：<br/><br/></p>

<h1>line 2 &#8220;1.txt&#8221;<br/></h1>

<p>int a ;<br/>
f x ;<br/><br/>
这样，当编译到f x;这句，出现错误，会提示：<br/>
1.txt(3) : error C2146: syntax error : missing &#8216;;&#8217; before identifier &#8216;x&#8217;<br/>
1.txt(3) : error C2501: &#8216;f&#8217; : missing storage-class or type specifiers<br/>
1.txt(3) : fatal error C1004: unexpected end of file found<br/><br/>
双击其中的某行，就会打开1.txt，并且定位到第3行，非常方便。<br/><br/>
不过没有找到怎么返回默认的文件名和行号，<br/>
C#倒是有一个#line default。。<br/>
找到了再回来更新。<br/><br/>
想了下这个东西存在的意义，<br/>
发现那是相当的有用。<br/><br/>
当matcom自带的编译器把m文件翻译成cpp的时候，<br/>
很可能会弄错一些语句。<br/>
如果不重新定义行号和文件名的话，<br/>
编译器会把错误定向到cpp文件。<br/>
而重新定义了就可以找到其本源，即某m文件，而且行号对应。<br/><br/>
不过这样做也不一定是必须的，<br/>
因为一般情况下，我们会先在m-file编辑器里调试好，<br/>
然后由相关组件翻译成cpp，一般就不会有问题了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/10/29/1-n%E7%9A%84%E6%95%B0%E7%BB%84%E6%88%90%E7%9A%84huffman%E6%A0%91%E7%9A%84%E6%9D%83%E9%87%8D/">1-n的数组成的huffman树的权重</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-10-29T16:27:00+08:00" pubdate data-updated="true">Oct 29<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.10.29</p>


<p>在某群上听到这个题，<br/>
正好没啥事干，找了下规律，弄了个结论出来。</p>


<p>首先，关于huffman树的定义这里不重复了。<br/>
然后权重的意思就是每个节点的值乘上路径长度的总合。</p>


<p>先企图直接推点东西出来，找不到下手的地方。<br/>
故干脆把前面一些n值对应的权重打出来，然后找规律。<br/>
用之前写过的<a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/ede9984524881f3787947397.html">程序</a>，比较方便：<br/>
acl(1:n,huffman(1:n))</p>


<p>前面几组是这样的：<br/>
2 3<br/>
3 9<br/>
4 19<br/>
5 33<br/>
6 51<br/>
7 74<br/>
8 102<br/>
9 135<br/>
10 173<br/>
11 216<br/>
12 264</p>


<p>跟指数比起来，显得小了不少，<br/>
感觉通项应该是个多项式。</p>


<p>于是在matlab里面用polyfit试了下，<br/>
发现各种低阶多项式都是有残差的，<br/>
也就是说没有完全满足这个规律的。</p>


<p>在一个群友的提示下，前后作差试试。<br/>
出来的数列b有点那个意思了，像个等差数列。<br/>
再次差分，能够得到公差k。</p>


<p><font color="#ff0000">由于作了两次差分，<br/>
那么在k为常数的情况下，<br/>
写出来的通项应该是个二次多项式。<br/></font>不过这个k都还在变化。</p>


<p>将前2-90的情况打印出来。<br/>
其中i是编号。<br/>
关键就是想办法<font color="#ff0000">描述出k的变化规律</font>就行了。</p>


<p><br/>
            i            n            a            b            k <br/>
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-<br/>
            1            2            3            6            4<br/>
            2            3            9           10            4<br/>
            3            4           19           14            4<br/>
            4            5           33           18            5<br/>
            5            6           51           23            5<br/>
            6            7           74           28            5<br/>
            7            8          102           33            5<br/>
            8            9          135           38            5<br/>
            9           10          173           43            5<br/>
           10           11          216           48            6<br/>
           11           12          264           54            6<br/>
           12           13          318           60            6<br/>
           13           14          378           66            6<br/>
           14           15          444           72            6<br/>
           15           16          516           78            6<br/>
           16           17          594           84            6<br/>
           17           18          678           90            6<br/>
           18           19          768           96            6<br/>
           19           20          864          102            6<br/>
           20           21          966          108            6<br/>
           21           22         1074          114            6<br/>
           22           23         1188          120            7<br/>
           23           24         1308          127            7<br/>
           24           25         1435          134            7<br/>
           25           26         1569          141            7<br/>
           26           27         1710          148            7<br/>
           27           28         1858          155            7<br/>
           28           29         2013          162            7<br/>
           29           30         2175          169            7<br/>
           30           31         2344          176            7<br/>
           31           32         2520          183            7<br/>
           32           33         2703          190            7<br/>
           33           34         2893          197            7<br/>
           34           35         3090          204            7<br/>
           35           36         3294          211            7<br/>
           36           37         3505          218            7<br/>
           37           38         3723          225            7<br/>
           38           39         3948          232            7<br/>
           39           40         4180          239            7<br/>
           40           41         4419          246            7<br/>
           41           42         4665          253            7<br/>
           42           43         4918          260            7<br/>
           43           44         5178          267            7<br/>
           44           45         5445          274            7<br/>
           45           46         5719          281            7<br/>
           46           47         6000          288            8<br/>
           47           48         6288          296            8<br/>
           48           49         6584          304            8<br/>
           49           50         6888          312            8<br/>
           50           51         7200          320            8<br/>
           51           52         7520          328            8<br/>
           52           53         7848          336            8<br/>
           53           54         8184          344            8<br/>
           54           55         8528          352            8<br/>
           55           56         8880          360            8<br/>
           56           57         9240          368            8<br/>
           57           58         9608          376            8<br/>
           58           59         9984          384            8<br/>
           59           60        10368          392            8<br/>
           60           61        10760          400            8<br/>
           61           62        11160          408            8<br/>
           62           63        11568          416            8<br/>
           63           64        11984          424            8<br/>
           64           65        12408          432            8<br/>
           65           66        12840          440            8<br/>
           66           67        13280          448            8<br/>
           67           68        13728          456            8<br/>
           68           69        14184          464            8<br/>
           69           70        14648          472            8<br/>
           70           71        15120          480            8<br/>
           71           72        15600          488            8<br/>
           72           73        16088          496            8<br/>
           73           74        16584          504            8<br/>
           74           75        17088          512            8<br/>
           75           76        17600          520            8<br/>
           76           77        18120          528            8<br/>
           77           78        18648          536            8<br/>
           78           79        19184          544            8<br/>
           79           80        19728          552            8<br/>
           80           81        20280          560            8<br/>
           81           82        20840          568            8<br/>
           82           83        21408          576            8<br/>
           83           84        21984          584            8<br/>
           84           85        22568          592            8<br/>
           85           86        23160          600            8<br/>
           86           87        23760          608            8<br/>
           87           88        24368          616            8</p>


<p>看一下各个k值对应的数据个数：<br/>
4，3<br/>
5，6<br/>
6，12<br/>
7，24<br/>
。。。</p>


<p>看来这个就是要找的规律了。<br/>
对于每一段<br/>
b = k * (m - 1) + b1 ;<br/>
a = (m - 1) * b1 + k * ( m - 2 ) * ( m - 1 ) / 2 + a1 ;<br/>
m即为从段首开始的计数。</p>


<p>设L为段长，那么从上一个段的首项推下一个段的首项，<br/>
取的m应该为L+1。</p>


<p>从第一段开始递推，即可得到答案。<br/>
因为段长是每次加倍的，<br/>
所以能在n的对数级解决问题。</p>


<p>演示程序如下：</p>


<p>n = 90 ;%要求的输入<br/>
n = n - 2 ;<br/>
a1 = 3 ;<br/>
b1 = 6 ;<br/>
L = 3 ;<br/>
k = 4 ;<br/>
while L &lt;= n<br/>
     m = L + 1 ;<br/>
     b = k * (m - 1) ;<br/>
     a = (m - 1) * b1 + k * ( m - 2 ) * ( m - 1 ) / 2 ;<br/>
     n = n - L ;<br/>
     L = L * 2 ;<br/>
     k = k + 1 ;<br/>
     a1 = a + a1 ;<br/>
     b1 = b + b1 ;<br/>
     <br/>
end</p>


<p>n = n + 1 ;<br/>
m = n ;<br/>
a = (m - 1) * b1 + k * ( m - 2 ) * ( m - 1 ) / 2 ;<br/>
a1 = a + a1 ;</p>


<p>result = a1</p>


<p>由于是演示，就没作输入检验了。<br/>
因为这个关系是从2开始的，<br/>
所以对输入1，特殊输出为0即可。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/backup-hplonline/blog/2009/10/26/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%88%B1%E5%9B%A0%E6%96%AF%E5%9D%A6%E7%9A%84%E9%A2%98%EF%BC%88%E6%9A%B4%E5%8A%9B%E6%B3%95%EF%BC%89/">传说中爱因斯坦的题（暴力法）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-10-26T19:34:00+08:00" pubdate data-updated="true">Oct 26<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(hplonline)2009.10.26</p>


<p>好久没暴力过了，比较手痒，<br/>
今天看有同学在讨论这个题。。。<br/>
发现可以用暴力解决。</p>


<p><font color="#0000ff">题目：</font></p>


<p>================</p>


<p>来看看这道爱因斯坦出的智商测试题, 他说世界上有98%的人回答不出, 看看你是否属于另外的2%：</p>


<p>1. 有5栋5种颜色的房子</p>


<p>2. 每一位房子的主人国籍都不同</p>


<p>3. 这5个人每人只喝一个牌子的饮料, 只抽一个牌子的香烟, 只养一种宠物</p>


<p>4. 没有人有相同的宠物, 抽相同牌子的香烟, 喝相同的饮料</p>


<p>已知:</p>


<p>1. 英国人住在红房子里</p>


<p>2. 瑞典人养了一条狗</p>


<p>3. 丹麦人喝茶</p>


<p>4. 绿房子在白房子左边</p>


<p>5. 绿房子主人喝咖啡</p>


<p>6. 抽PALL MALL烟的人养了一只鸟</p>


<p>7. 黄房子主人抽DUNHILL烟</p>


<p>8. 住在中间那间房子的人喝牛奶</p>


<p>9. 挪威人住在第一间房子</p>


<p>10. 抽混合烟的人住在养猫人的旁边</p>


<p>11. 养马人住在DUNHILL烟的人旁边</p>


<p>12. 抽BLUE MASTER烟的人喝啤酒</p>


<p>13. 德国人抽PRINCE烟</p>


<p>14. 挪威人住在蓝房子旁边</p>


<p>15、抽Blends香烟的人有一个喝水的邻居</p>


<p>             so, 是谁养鱼？</p>


<p>====================</p>


<p>由于这个题流传甚广，版本也就很多。<br/>
在这里的叙述中有个“混合烟”，<br/>
经过考证就是最后的BLEND烟。</p>


<p>另外“4. 绿房子在白房子左边”是一句有歧义的话，<br/>
我开始枚举出来有多种答案，<br/>
后来发现这句的理解很关键，原文可能是：<br/>
&#8220;green house is <font color="#ff0000">to</font> the left of white house&#8221;<br/>
或者<br/>
&#8220;green house is <font color="#ff0000">on</font> the left of white house&#8221;<br/>
这会导致第一个关于房子的判断出现两种写法：<br/>
if ( green &lt; white ) return true ;<br/>
if ( green == white - 1 ) return true ;</p>


<p><font color="#0000ff">程序：</font></p>


<p>每个人和各种属性都是一一对应的，<br/>
所以最简单的方法就是进行全排列，<br/>
用C++的next_permutation可以比较方便。</p>


<p>如果直接枚举的话，工作量为(5!)^5，<br/>
这个数字是相当大的，<br/>
所以适当剪枝。</p>


<p>说是剪枝，也就是边枚举边判断罢了，<br/>
避免堆到最后来一起判断。</p>


<p>#include &lt;stdio.h&gt;<br/>
#include &lt;algorithm&gt;<br/>
#include &lt;iostream&gt;<br/>
#include &lt;math.h&gt;</p>


<p>using namespace std ;</p>


<p>int color[5] ;     //red,green,white,yellow,blue<br/>
int nation[5] ;     //english,swede,dane,norwegian,german<br/>
int pet[5] ;     //dog,bird,cat,horse,fish?<br/>
int drink[5] ;     //tea,coffee,milk,beer,water<br/>
int cig[5] ;     //PALL MALL,DUNHILL,BLEND,BLUE MASTER,PRINCE</p>


<p>#define make_string_array(a,b,c,d,e) {#a,#b,#c,#d,#e} ;<br/>
char *color_name[] = make_string_array(red,green,white,yellow,blue) ;<br/>
char *nation_name[] = make_string_array(english,swede,dane,norwegian,german) ;<br/>
char *pet_name[] = make_string_array(dog,bird,cat,horse,fish) ;<br/>
char *drink_name[] = make_string_array(tea,coffee,milk,beer,water) ;<br/>
char *cig_name[] = make_string_array(PALL MALL,DUNHILL,BLEND,BLUE MASTER,PRINCE) ;</p>


<p>void init(int *a){<br/>
     int i ;<br/>
     for ( i = 0 ; i &lt; 5 ; i ++ ) a[i] = i ;<br/>
}</p>


<p>bool check_color(){<br/>
     //4. 绿房子在白房子左边     <br/>
     int *green = find(color , color + 5 , 1) ;<br/>
     int *white = find(color , color + 5 , 2) ;<br/>
     //at first , I thought &#8220;green house is to the left of white house&#8221;<br/>
     //but most likely case is &#8220;green house is on the left of white house&#8221;<br/>
     if ( green == white - 1 ) return true ;</p>


<p>     else return false ;<br/>
}</p>


<p>bool check_nation(){<br/>
     //1. 英国人住在红房子里     <br/>
     int *english = find(nation , nation + 5 , 0) ;<br/>
     int *red = find(color , color + 5 , 0) ;<br/>
     if ( english - nation != red - color ) return false ;<br/>
     //9. 挪威人住在第一间房子<br/>
     if ( nation[0] != 3 ) return false ;<br/>
     //14. 挪威人住在蓝房子旁边<br/>
     //第二间是蓝房子<br/>
     if ( color[1] != 4 ) return false ;</p>


<p>     return true ;<br/>
}</p>


<p>bool check_pet(){<br/>
     //2. 瑞典人养了一条狗     <br/>
     int *dog = find(pet , pet + 5 , 0) ;<br/>
     int *swade = find(nation , nation + 5 , 1) ;<br/>
     if ( dog - pet != swade - nation ) return false ;</p>


<p>     return true ;<br/>
}</p>


<p>bool check_drink(){<br/>
     //3. 丹麦人喝茶<br/>
     int *dane = find(nation , nation + 5 , 2) ;<br/>
     int *tea = find(drink , drink + 5 , 0) ;<br/>
     if ( dane - nation != tea - drink ) return false ;<br/>
     //5. 绿房子主人喝咖啡<br/>
     int *green = find(color , color + 5 , 1) ;<br/>
     int *coffee = find(drink , drink + 5 , 1) ;<br/>
     if ( green - color != coffee - drink ) return false ;<br/>
     //8. 住在中间那间房子的人喝牛奶     <br/>
     if ( drink[2] != 2 ) return false ;</p>


<p>     return true ;<br/>
}</p>


<p>bool check_cig(){<br/>
     //6. 抽PALL MALL烟的人养了一只鸟<br/>
     int *pallmall = find(cig , cig + 5 , 0) ;<br/>
     int *bird = find(pet , pet + 5 , 1) ;<br/>
     if ( pallmall - cig != bird - pet ) return false ;<br/>
     //7. 黄房子主人抽DUNHILL烟<br/>
     int *dunhill = find(cig , cig + 5 , 1) ;<br/>
     int *yellow = find(color , color + 5 , 3) ;<br/>
     if ( dunhill - cig != yellow - color ) return false ;<br/>
     //10. 抽BLEND的人住在养猫人的旁边<br/>
     int *blend = find(cig , cig + 5 , 2) ;<br/>
     int *cat = find(pet , pet + 5 , 2) ;<br/>
     if ( abs((blend - cig) - (cat - pet)) != 1 ) return false ;<br/>
     //11. 养马人住在DUNHILL烟的人旁边<br/>
     int *horse = find(pet , pet + 5 , 3) ;<br/>
     if ( abs((horse - pet) - (dunhill - cig)) != 1 ) return false ;<br/>
     //12. 抽BLUE MASTER烟的人喝啤酒<br/>
     int *bluemaster = find(cig , cig + 5 , 3) ;<br/>
     int *beer = find(drink , drink + 5 , 3) ;<br/>
     if ( bluemaster - cig != beer - drink ) return false ;<br/>
     //13. 德国人抽PRINCE烟<br/>
     int *german = find(nation , nation + 5 , 4) ;<br/>
     int *prince = find(cig , cig + 5 , 4) ;<br/>
     if ( german - nation != prince - cig) return false ;<br/>
     //15、抽Blends香烟的人有一个喝水的邻居<br/>
     int *water = find(drink , drink + 5 , 4) ;<br/>
     if ( abs((water - drink) - (blend - cig)) != 1 ) return false ;</p>


<p>     return true ;<br/>
}</p>


<p>void out_elem(int *a , char **s){<br/>
     int i ;<br/>
     for ( i = 0 ; i &lt; 5 ; i ++ ){<br/>
         printf(&#8220;%-15s&#8221; , s[a[i]]) ;<br/>
     }<br/>
     cout&lt;&lt;endl ;<br/>
}</p>


<p>void output(){<br/>
     static cs = 0 ;<br/>
     cs ++ ;<br/>
     cout &lt;&lt; &#8220;case:&#8221; &lt;&lt; cs &lt;&lt; endl ;<br/>
     out_elem(color , color_name) ;<br/>
     out_elem(nation , nation_name) ;<br/>
     out_elem(pet , pet_name) ;<br/>
     out_elem(drink , drink_name) ;<br/>
     out_elem(cig , cig_name) ;<br/>
}</p>


<p>int main(){<br/>
     init(color) ;<br/>
     do{<br/>
         if ( check_color() ) {<br/>
             init(nation) ;<br/>
             do{<br/>
                 if ( check_nation() ) {     <br/>
                     init(pet) ;<br/>
                     do{<br/>
                         if ( check_pet() ) {<br/>
                             init(drink) ;<br/>
                             do{<br/>
                                 if ( check_drink() ) {                                     <br/>
                                     init(cig) ;<br/>
                                     do{<br/>
                                         if ( check_cig() ) {                             <br/>
                                             output() ;<br/>
                                         }<br/>
                                     }while ( next_permutation(cig , cig + 5) ) ;     <br/>
                                 }<br/>
                             }while ( next_permutation(drink , drink + 5) ) ;     <br/>
                         }<br/>
                     }while ( next_permutation(pet , pet + 5) ) ;     <br/>
                 }<br/>
             }while ( next_permutation(nation , nation + 5) ) ;                 <br/>
         }<br/>
     }while ( next_permutation(color , color + 5) ) ;<br/>
     return 0 ;<br/>
}</p>


<p><font color="#0000ff">输出：</font></p>


<p>case:1<br/>
yellow          blue            red             green           white<br/>
norwegian       dane            english         german          swede<br/>
cat             horse           bird            fish            dog<br/>
water           tea             milk            coffee          beer<br/>
DUNHILL         BLEND           PALL MALL       PRINCE          BLUE MASTER</p>


<p>估计这道题的最初意思是让人直接用脑袋想，<br/>
不过很多人用纸和笔等等。</p>


<p>但是现在我们有电脑。。。。。</p>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/backup-hplonline/blog/page/10/">&larr; Older</a>
    
    <a href="/backup-hplonline/blog/archives">Blog Archives</a>
    
    <a class="next" href="/backup-hplonline/blog/page/8/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/backup-hplonline/blog/2013/05/04/test/">Test</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/04/09/%E5%86%8D%E8%B0%88stl%E7%9A%84rotate/">再谈stl的rotate</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%BA%8C%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、二）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%89%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、三）</a>
      </li>
    
      <li class="post">
        <a href="/backup-hplonline/blog/2011/02/01/%5Bpaper%5DXORsinTheAir%3APracticalWirelessNetworkCoding%EF%BC%88%E7%BF%BB%E8%AF%91%E3%80%81%E4%B8%80%EF%BC%89/">[paper] XORs in The Air: Practical Wireless Network Coding（翻译、一）</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - hplonline -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
