---
layout: post
title: "C库函数memset()的源码"
date: 2009-02-06  23:16
comments: true
categories: tech
tags: ["Asm"]
_baiduhi_id: 621a8802551274084afb51ca.html
_baiduhi_category: Asm
---

         page     ,132<br/>
         title    memset - set sections of memory all to one byte<br/>
;***<br/>
;memset.asm - set a section of memory to all one byte<br/>
;<br/>
;        Copyright (c) Microsoft Corporation. All rights reserved.<br/>
;<br/>
;Purpose:<br/>
;        contains the memset() routine<br/>
;<br/>
;*******************************************************************************<br/><br/>
         .xlist<br/>
         include cruntime.inc<br/>
         .list<br/><br/>
page<br/>
;***<br/>
;char *memset(dst, value, count) - sets "count" bytes at "dst" to "value"<br/>
;<br/>
;Purpose:<br/>
;        Sets the first "count" bytes of the memory starting<br/>
;        at "dst" to the character value "value".<br/>
;<br/>
;        Algorithm:<br/>
;        char *<br/>
;        memset (dst, value, count)<br/>
;                char *dst;<br/>
;                char value;<br/>
;                unsigned int count;<br/>
;                {<br/>
;                char *start = dst;<br/>
;<br/>
;                while (count--)<br/>
;                        *dst++ = value;<br/>
;                return(start);<br/>
;                }<br/>
;<br/>
;Entry:<br/>
;        char *dst - pointer to memory to fill with value<br/>
;        char value - value to put in dst bytes<br/>
;        int count - number of bytes of dst to fill<br/>
;<br/>
;Exit:<br/>
;        returns dst, with filled bytes<br/>
;<br/>
;Uses:<br/>
;<br/>
;Exceptions:<br/>
;<br/>
;*******************************************************************************<br/><br/>
         CODESEG<br/><br/>
         public  memset<br/>
memset proc<br/><br/>
         .FPO     ( 0, 3, 0, 0, 0, 0 )<br/><br/>
         mov      edx,[esp + 0ch] ; edx = "count"<br/>
         mov      ecx,[esp + 4]    ; ecx points to "dst"<br/><br/>
         test     edx,edx          ; 0?<br/>
         jz       short toend      ; if so, nothing to do<br/><br/>
         xor      eax,eax<br/>
         mov      al,[esp + 8]     ; the byte "value" to be stored<br/><br/><br/>
; Align address on dword boundary<br/><br/>
         push     edi              ; preserve edi<br/>
         mov      edi,ecx          ; edi = dest pointer<br/><br/>
         cmp      edx,4            ; if it's less then 4 bytes<br/>
         jb       tail             ; tail needs edi and edx to be initialized<br/><br/>
         neg      ecx<br/>
         and      ecx,3            ; ecx = # bytes before dword boundary<br/>
         jz       short dwords     ; jump if address already aligned<br/><br/>
         sub      edx,ecx          ; edx = adjusted count (for later)<br/>
adjust_loop:<br/>
         mov      [edi],al<br/>
         add      edi,1<br/>
         sub      ecx,1<br/>
         jnz      adjust_loop<br/><br/>
dwords:<br/>
; set all 4 bytes of eax to [value]<br/>
         mov      ecx,eax          ; ecx=0/0/0/value<br/>
         shl      eax,8            ; eax=0/0/value/0<br/><br/>
         add      eax,ecx          ; eax=0/0val/val<br/><br/>
         mov      ecx,eax          ; ecx=0/0/val/val<br/><br/>
         shl      eax,10h          ; eax=val/val/0/0<br/><br/>
         add      eax,ecx          ; eax = all 4 bytes = [value]<br/><br/>
; Set dword-sized blocks<br/>
         mov      ecx,edx          ; move original count to ecx<br/>
         and      edx,3            ; prepare in edx byte count (for tail loop)<br/>
         shr      ecx,2            ; adjust ecx to be dword count<br/>
         jz       tail             ; jump if it was less then 4 bytes<br/><br/>
         rep      stosd<br/>
main_loop_tail:<br/>
         test     edx,edx          ; if there is no tail bytes,<br/>
         jz       finish           ; we finish, and it's time to leave<br/>
; Set remaining bytes<br/><br/>
tail:<br/>
         mov      [edi],al         ; set remaining bytes<br/>
         add      edi,1<br/><br/>
         sub      edx,1            ; if there is some more bytes<br/>
         jnz      tail             ; continue to fill them<br/><br/>
; Done<br/>
finish:<br/>
         mov      eax,[esp + 8]    ; return dest pointer<br/>
         pop      edi              ; restore edi<br/><br/>
         ret<br/><br/>
toend:<br/>
         mov      eax,[esp + 4]    ; return dest pointer<br/><br/>
         ret<br/><br/>
memset  endp<br/><br/>
         end<br/><br/><br/>
其实上面的C语言算法描述和下面的汇编实现之间还是有很大的区别的。。<br/><br/>
上面只是说了一个外围看进去的意思。<br/><br/>
下面汇编的思路是这样的。<br/><br/>
首先按照32位（4字节）的长度进行内存赋值，<br/><br/>
当小于4字节的时候才一个个字节地赋值，<br/><br/>
而四字节赋值的时候也有个细节处理，就是对齐到双字的地址处，<br/><br/>
这些都是为了在32位平台上加速而设计的。<br/>
