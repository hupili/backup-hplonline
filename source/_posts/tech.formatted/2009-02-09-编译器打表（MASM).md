---
layout: post
title: "编译器打表（MASM)"
date: 2009-02-09  16:16
comments: true
categories: tech
tags: ["Asm"]
_baiduhi_id: 8fbb05b30fb894a0d8335ae9.html
_baiduhi_category: Asm
---

(hplonline)2009.2.9<br/><br/>
打表这个说法对在各大OJ上交题的同学们来说那是相当熟悉了。<br/><br/>
假设有一道题，让你输出<span style="font-size: 10.5pt; color: rgb(0, 0, 0); line-height: normal;"><strong>Fibonacci数列</strong></span>第X个数，<br/>
其实这道题本身没啥讨论的，我们就用一般的递推，主要说打表。<br/><br/>
如果是运行时打表。<br/>
比如，开始的时候先用一段，算出小于XXXX的所有数。<br/>
然后输入一个n，直接读个fib[n]就输出了。<br/>
这种就是常说的预处理。。。<br/><br/>
然后可以在编写代码时打表。<br/>
比如写源代码的时候就<br/>
int fib[NUM] = {1,1,2,3,5,8,13 ....}<br/>
这样写好。这种静态打表就是常说的打表了。<br/><br/>
对于这两种打表，前者仍然占用一定运行时间的，感觉不极致<br/>
后者的话，会造成代码臃肿，还是不爽。<br/><br/>
用C的话，暂时还不知道啥方法了，<br/>
不过最近学了点MASM，很火星地发现编译时解释的宏简直就是强大。。。。<br/><br/>
比如这样：<br/><br/>
.data<br/>
v1 = 1<br/>
v2 = 1                              ;初始值<br/>
fib DWORD v1<br/>
DWORD v2                              ;放置前两个值<br/>
count = 0                         ;一个计数器<br/>
WHILE count LT 20            ;重复20次<br/>
      v3 = v1 + v2            ;Fibonacci的递推公式<br/>
      DWORD v3                        ;放置当前产生的这个值<br/>
      v1 = v2                        ;<br/>
      v2 = v3                        ;递推<br/>
      count = count + 1      ;计数增加<br/>
ENDM                                    ;是ENDM，不是ENDW。。<br/><br/>
在我的数据段fib标号开始的地方就存上了前22个Fibonacci数了。<br/>
这里<strong>WHILE</strong>和<strong>.WHILE</strong> 是不同的。<br/>
后面这个是运行时的。前面这个是发生在编译期间的。<br/><br/>
做一个测试输出<br/>
.code<br/>
      mov ebx , 1<br/>
      .WHILE ebx &lt; count<br/>
            mov eax , ebx<br/>
            dec eax<br/>
            mov eax , fib[eax * 4]<br/>
            invoke WriteInt10 , eax       ;我的输出整数的函数，具体替换<br/>
            call WriteCrLf                              ;我的输出换行的函数，具体替换<br/>
            inc ebx <br/>
      .ENDW<br/><br/>
这段除了两个我自己用的函数，其他都很熟悉的东西了。<br/><br/>
这个姑且就叫编译器打表了吧。。<br/>
配合的还有如IF之类的宏。。几乎可以完成各种计算逻辑。。<br/>
怎一个强大了得。。<br/><br/>
跟前面的打表比来说，代码又不臃肿，又不占运行时间，<br/>
但是如果没写好的话，编译器也可以死循环。。。<br/><br/>
比如：<br/>
WHILE 1<br/>
ENDM<br/>
这样之后，打开任务管理，可以看到ml.exe占满了在跑。。。<br/><br/>
虽然说起来编译器打表很强。。但是现在还没看哪个OJ允许用MASM的吧。。。<br/>
要不你交个上去，打成死循环了杂办呢。。<br/>
