---
layout: post
title: "ASM做标准库，C调用【尝鲜实验，无技术含量】"
date: 2009-02-18  21:10
comments: true
categories: tech
tags: ["Asm"]
_baiduhi_id: 2571093b015122ed14cecbb2.html
_baiduhi_category: Asm
---

(hplonline) 2009.2.14<br/><br/>
理由，在<font color="#ff0000">效率</font>比较关键的地方，可以选择用汇编来实现，这没啥好说的，<br/>
所以先试一下这个功能，至少知道有这么一回事。<br/><br/><font color="#0000ff">一.环境：</font><br/><br/>
VC6:怎么说也很老了，不过经典，用起将就<br/><br/>
MASMPlus:有Plus字样的自然是多两把刷子，不然怎么能叫Plus呢，对吧<br/>
屏蔽了很多编译链接方面繁琐的操作,并且编辑环境也不错,就用他了<br/><br/><font color="#0000ff">二.练习内容：</font><br/>
1.实现简单地给文件异或加密，<br/>
2.当然是试ASM做标准库，然后C来调用<br/>
3.顺便练习一下C++的文件流，想自己以前老是fprintf地。。很土的样子<br/><br/><font color="#0000ff">三.动手：</font><br/><br/>
1.先来做C这边事情，个人习惯是一桩一桩地做好。所以先不管ASM，直接做一个整的程序<br/><br/>
#include &lt;iostream&gt;<br/>
#include &lt;fstream&gt;<br/><br/>
using namespace std;<br/><br/>
const int BUFFERSIZE = 1024 ; <br/><br/>
char buffer[BUFFERSIZE];<br/>
int count ; <br/><br/><font color="#999999">void encode(char *buf , int size , unsigned char code){<br/>
     int i;<br/>
     for ( i = 0 ; i &lt; size ; i ++ )buf[i] ^= code ;<br/>
}</font><br/><br/>
int main(int argv , char *args[]){<br/>
     int code ; <br/><br/>
     if ( argv != 3 ){<br/>
          cout&lt;&lt;"parameter wrong!"&lt;&lt;endl; <br/>
          cout&lt;&lt;"usage: coder infile outfile"&lt;&lt;endl;<br/>
          return 1 ; <br/>
     }<br/><br/>
     ifstream infile(args[1] , ios::binary);<br/>
     ofstream outfile(args[2] , ios::binary);<br/>
     <br/>
     cout&lt;&lt;"input your code[0..255]"&lt;&lt;endl;<br/>
     cin&gt;&gt;code;<br/>
     if ( code &lt; 0 || code &gt; 255 ){<br/>
          cout&lt;&lt;"code range error!!"&lt;&lt;endl;<br/>
          return 2 ;<br/>
     }<br/><br/>
     cout&lt;&lt;"encoding from "&lt;&lt;args[1]&lt;&lt;" to "&lt;&lt;args[2]&lt;&lt;endl;<br/><br/>
     while ( !infile.eof() ){<br/>
          infile.read(buffer , BUFFERSIZE );<br/>
          count = infile.gcount() ; <br/>
          encode(buffer,count, ( unsigned char )code);<br/>
          outfile.write(buffer , count );<br/>
     }<br/><br/>
     return 0 ;<br/>
}<br/><br/>
这个程序是要从命令行输入加密文件名的，<br/>
为了调试方便<br/>
project-&gt;settings-&gt;debug-&gt;programme arguments<br/>
这里可以设置参数<br/>
比如我写成：1.txt 2.txt<br/>
然后在工程目录下建个1.txt,随便写点东西，就可以运行了，<br/>
输入用来异或的CODE,生成加密后的2.txt<br/><br/>
其实从功能上来说，这样就很好了，不过我这里要练习用ASM做标准库，<br/>
所以把 encode函数给注释掉，换成外部的申明<br/><font color="#ff6600"><br/>
#pragma comment(lib,"encode.Lib")<br/>
extern "C" void encode(char *buf , int size , unsigned char code) ;</font><br/><br/>
其实比较重要的也就是这里<br/><font color="#ff6600">extern "C"</font> 一方面是把encode函数申明成外部过程，<br/>
还有就是指定了是C调用约定，因为用C++约定的话。。<br/>
函数名字会被改造成比较复杂的样子，不方便，而在MASM中又没有指定C++约定的项。<br/><br/><font color="#ff6600">#pragma comment(lib,"encode.Lib")       <br/><font color="#000000">这个也是关键地方，意思就是添加encode.lib这个库<br/>
也可以不要这句，而在下面的位置<br/></font></font>project-&gt;settings-&gt;link-&gt;object / library modules<br/>
手动写上encode.lib<br/><br/>
这样C这边就OK了，只等我们把encode 这个库做好，放到工程目录下面，就可以组建了。<br/><br/>
2.MASM<br/><br/>
MASMPlus的方便性很快就体现出来了，直接新建工程，选标准库<br/>
然后选好位置，框架就生成好了。<br/><br/>
不过我们用不了那么臃肿的东西，代码全部删了。<br/>
下面就够了：<br/>
.386<br/><font color="#ff6600">.model flat, C</font><br/>
option casemap :none <br/><br/>
.CODE<br/><br/>
encode proc C uses ecx esi eax ,  lpBuffer:DWORD , lSize:DWORD , ucCode:BYTE<br/>
     mov esi , lpBuffer<br/>
     mov ecx , lSize<br/>
     mov al , ucCode<br/>
     _l:<br/>
     xor BYTE PTR[esi] , al<br/>
     inc esi <br/>
     loop _l<br/>
     ret<br/>
encode endp<br/><br/>
END<br/><br/>
第二句比较关键，指定C调用约定，这样才好跟我们在VC中编的程序接口<br/>
而函数本身也没啥说的，从C的代码很容易就翻译过来了。<br/><br/>
于是组建这个工程，生成了*.lib文件。<br/>
改名encode.lib，复制到开始VC的工程目录下。就可以运行了。<br/><br/><br/>
于是就做完了。。纯粹是因为之前没这样搞过 ，觉得新鲜而已。。<br/>
好吧，下次我们用C编写库，让MASM来调用。
