---
layout: post
title: "KEIL C 编译的TRICK探究2（int类型）"
date: 2009-03-01  21:51
comments: true
categories: tech
tags: ["Scm"]
_baiduhi_id: f8ceb299ae9349006f068ce0.html
_baiduhi_category: Scm
---

(hplonline)2009.3.1<br/><br/>
这也是值得探讨的一个地方。<br/>
因为51机是8位的，但我们用C写的时候又经常用到16-bit int。<br/>
那么编译器肯定有某种实现吧！<br/><br/>
我们用下面的代码：<br/>
      int va,vb,vc ;<br/>
      va = 0x1101;<br/>
      vb = 0x2202 ;<br/>
      vc = va + vb ;<br/>
      while (1) ;<br/><br/>
为什么要选这两个数字，后面再说<br/><br/>
C:0x0800      7401       MOV        A,#0x01<br/>
C:0x0802      2402       ADD        A,#0x02<br/>
C:0x0804      F509       MOV        0x09,A<br/><br/>
C:0x0806      7411       MOV        A,#0x11<br/>
C:0x0808      3422       ADDC       A,#0x22<br/>
C:0x080A      F508       MOV        0x08,A<br/><br/>
这个0x08就是vc的高位存放的地址<br/>
0x09就是vc的低位存放的地址<br/><br/>
这就有趣了，跟我们常用的PC平台不一样。这里居然是大尾顺序。<br/>
不过也不能这么说，因为51本来就是8位运算。且存储单元习惯上按字节来分。<br/>
所有的运算指令也是8位操作。所以，平台本身并没有关于某尾的特征。<br/>
这种实现只是我用的编译器的行为而已。<br/>
我们完全可以仿照实现小尾顺序。<br/><br/>
再说前面的加法，上面半截就是算低地址。<br/>
因为可能有进位，所有下面半截按照带进位加法运算。<br/><br/>
这样就完成了16-bit int 的操作了。<br/>
仿照这种思想，可以实现更多位数的，比如32-bit,64-bit int，<br/>
硬件上的进位标志CY,<br/>
指令里的ADDC ，SUBB等本身就为大整数运算提供了很好支持<br/><br/>
最后来说为啥要选那两个数，主要目的就是为了好辨认。<br/>
还有保证高低位都有值，避免编译器优化到我们认不到的程度。<br/><br/>
其实这个实验里面，编译器已经进行了常数优化了。<br/>
根本就没用到va,vb的空间，直接拿常数参与运算
