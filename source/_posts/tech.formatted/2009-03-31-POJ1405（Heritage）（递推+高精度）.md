---
layout: post
title: "POJ1405 （Heritage） （递推+高精度）"
date: 2009-03-31  09:15
comments: true
categories: tech
tags: ["算法"]
_baiduhi_id: 1bbfb9194a4ffd4d42a9ad1a.html
_baiduhi_category: 算法
---

(hplonline)2009.3.31<br/><br/><font color="#0000ff">递推：</font><br/><br/>
如果当前还可以分的数为1/a<br/><br/>
那么显然减掉1/(a+1)剩下的是最小的，a+1是比a大的第一个整数。<br/><br/>
剩下的是1/(a*(a+1))<br/><br/>
这个式子仅和a相关，所以前一次剩下的为最小时（a最小），后一次使用此策略为最小。<br/><br/>
那么可以递推下去。<br/><br/>
2，3，7，43.。。<br/><br/><font color="#0000ff">公式：</font><br/><br/>
ans[]为第i个分母，b[i]为辅助乘项<br/><br/>
ans[1] = 2 ;<br/><br/>
i &gt;= 2 <br/>
b[i] = mul(ans[j]) ( 1 &lt;= j &lt; i ) <br/>
ans[i] = b[i] + 1<br/><br/>
这样推可以避免减法。（为什么要避免减法。。是为了将就高精度那边）<br/>
计算b[i]的时候，也不用把前面的都累乘起来，想一下，就两个变量递推起走就行了。<font color="#0000ff"><br/><br/>
代码：</font><br/><br/>
CBigInt num;<br/>
CBigInt pre ;<br/><br/>
int main(){<br/>
       int i , n ; <br/>
       CBigInt one(1);<br/>
       num.init(1);<br/>
       pre.init(1);<br/>
       scanf("%d",&amp;n);<br/>
       for ( i = 1 ; i &lt;= n ; i ++ ){<br/>
              num *= pre ;<br/>
              pre = num ;<br/>
              num += one ;<br/>
              num.output() ;<br/>
              putchar('\n');<br/>
       }<br/>
       return 0;<br/>
}<br/><br/><a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/bebbf9de8308c65c95ee371d.html">CBigInt的实现参考上一篇。</a><br/><br/>
之前RE了若干次，是因为把MAXL算小了。<br/><br/>
这里大概有2W多位的样子。位数是成指数上升的。。<br/><br/>
PS：以<a href="http://hi.baidu.com/hplonline/blog/item/bebbf9de9309d65c95ee371c.html" target="_blank">FFT优化的高精度</a> ， <a href="http://www.box.net/shared/plepep7zbi" target="_blank">1405C++AC完整下载</a>
