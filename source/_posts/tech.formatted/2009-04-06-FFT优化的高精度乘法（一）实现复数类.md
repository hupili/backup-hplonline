---
layout: post
title: "FFT优化的高精度乘法（一）实现复数类"
date: 2009-04-06  20:57
comments: true
categories: tech
tags: ["c","c++"]
_baiduhi_id: bebbf9de9309d65c95ee371c.html
_baiduhi_category: c&c++
---

(hplonline)2009.4.6<br/><br/><font color="#0000ff">前言：</font><br/><br/>
听说过FFT优化的高精度乘法很久了。<br/>
以前借口没学信号与系统，不做。<br/>
后来学了信号与系统，依然不会。<br/><br/>
上周刷POJ1405的时候，发现很慢，于是想做个FFT优化的高精度乘法。<br/><br/>
首先是在网上看了若干资料。到懂不懂。<br/><br/>
又在网上下了一些FFT的代码，一用发现是囧的。。<br/><br/>
于是只好<font color="#ff0000">打消吃快餐的念头</font>。自己动手从头到尾实现一个。<br/><font color="#ff6600">不懂原理的话，拿着别人写囧的东西就不知道怎么改了。。</font><br/><br/>
当然，我这一套是经过刷题验证的，虽然那道题我的程序不怎么快。<br/>
但是在相同条件下，我的FFT优化比不用FFT优化快。<br/><font color="#ff6600"><br/>
1405       Accepted       2336K       766MS       G++       11147B       2009-04-06 20:27:18<br/>
1405       Accepted       2848K       297MS       G++       11151B       2009-04-06 20:25:30<br/>
（上面的是没用FFT的）</font><br/><br/>
可以说，<font color="#ff0000">正确性能够保证，速度至少说有所提高</font>。<br/><br/>
那么，作为一个实践主义者，你也可以不用管这个实现方法，直接使用就行了。<br/>
不过在不同的编译器上可能出现编译错误。<br/>
这点我也没办法，因为我学C++的时候，就学得不太符合标准。<br/>
各位可以根据相关报错，改一下应该是可以的。<br/><br/><font color="#ff0000">我的整套实现是在VC6下完成的</font>（就是这里将会贴出来的代码）。<br/><br/><font color="#ff0000">交题是用G++过的，在DEV下编译出了不少错误</font>，修改过后交题AC。<br/>
（完整的AC代码在<a target="_blank" href="http://www.box.net/shared/plepep7zbi">这里</a>查看）<br/><br/>
那么就省点废话了。下面开始。<br/><br/><font color="#0000ff">复数类：</font><br/><br/>
实现FFT和IFFT的时候要用这个类。<br/>
这个类的意思应该简单明了。<br/>
不过我实现得不一定漂亮，只能说可以用。<br/><br/><font color="#0000ff">complex.h:</font><br/><br/><br/>
#ifndef __COMPLEX_H_<br/><br/>
#define __COMPLEX_H_<br/><br/>
class complex{<br/>
public:<br/>
       double real , imag ;<br/>
       complex();<br/>
       complex(double r , double i) ;<br/>
       complex(double r) ;<br/>
       complex(const complex&amp; c) ;<br/>
       ~complex() ;<br/>
       complex&amp; add(complex&amp; c) ;<br/>
       complex&amp; sub(complex&amp; c) ;<br/>
       complex&amp; mul(complex&amp; c) ;<br/>
       complex&amp; div(complex&amp; c) ;<br/>
       complex&amp; operator= ( complex &amp;c) ;<br/>
       complex&amp; operator+= (complex &amp;c) ;<br/>
       complex&amp; operator-= (complex &amp;c) ;<br/>
       complex&amp; operator*= (complex &amp;c) ;<br/>
       complex&amp; operator/= (complex &amp;c) ;<br/>
       void output() ;<br/>
};<br/><br/>
complex operator+ ( complex &amp;c1 , complex &amp;c2 ) ;<br/>
complex operator- ( complex &amp;c1 , complex &amp;c2 ) ;<br/>
complex operator* ( complex &amp;c1 , complex &amp;c2 ) ;<br/>
complex operator/ ( complex &amp;c1 , complex &amp;c2 ) ;<br/><br/>
const double _COMPLEX_EPS = 1e-10 ;<br/>
const int _COMPLEX_OUTPUT_WIDTH = 0 ;<br/>
const int _COMPLEX_OUTPUT_DECIMAL = 3 ;<br/><br/>
#endif<br/><br/><font color="#0000ff">complex.cpp:</font><br/><br/>
#include "complex.h"<br/>
#include &lt;math.h&gt;<br/>
#include &lt;stdio.h&gt;<br/><br/>
complex::complex(){<br/>
       real = 0 ;<br/>
       imag = 0 ;<br/>
}<br/><br/>
complex::complex(double r , double i){<br/>
       real = r ;<br/>
       imag = i ;<br/>
}<br/><br/>
complex::complex(const complex&amp; c){<br/>
       real = c.real ;<br/>
       imag = c.imag ;<br/>
}<br/><br/>
complex::complex(double r){<br/>
       real = r ;<br/>
       imag = 0 ;<br/>
}<br/><br/>
complex::~complex(){<br/>
       <br/>
}<br/><br/>
complex&amp; complex::operator= ( complex &amp;c){<br/>
       real = c.real ;<br/>
       imag = c.imag ;<br/>
       return *this;<br/>
}<br/><br/>
complex&amp; complex::add(complex&amp; c){<br/>
       real += c.real ;<br/>
       imag += c.imag ;<br/>
       return *this ;<br/>
}<br/><br/>
complex&amp; complex::sub(complex&amp; c){<br/>
       real -= c.real ;<br/>
       imag -= c.imag ;<br/>
       return *this ;<br/>
}<br/><br/>
complex&amp; complex::mul(complex&amp; c){<br/>
       complex tmp ;<br/>
       tmp.real = real * c.real - imag * c.imag ;<br/>
       tmp.imag = real * c.imag + imag * c.real ;<br/>
       *this = tmp ;<br/>
       return *this ;<br/>
}<br/><br/>
complex&amp; complex::div(complex&amp; c){<br/>
       double mo = real * c.real + imag * c.imag ;<br/>
       real = ( real * c.real + imag * c.imag ) / mo ;<br/>
       imag = ( -real * c.imag + imag * c.real ) / mo ;<br/>
       return *this ;<br/>
}<br/><br/>
complex&amp; complex::operator+= (complex &amp;c){<br/>
       return add(c);<br/>
}<br/><br/>
complex&amp; complex::operator-= (complex &amp;c){<br/>
       return sub(c);<br/>
}<br/><br/>
complex&amp; complex::operator*= (complex &amp;c){<br/>
       return mul(c);<br/>
}<br/><br/>
complex&amp; complex::operator/= (complex &amp;c){<br/>
       return div(c);<br/>
}<br/><br/>
complex operator+ ( complex &amp;c1 , complex &amp;c2 ){<br/>
       complex tmp ;<br/>
       tmp = c1 ;<br/>
       tmp.add(c2);<br/>
       return tmp ;<br/>
}<br/><br/>
complex operator- ( complex &amp;c1 , complex &amp;c2 ){<br/>
       complex tmp ;<br/>
       tmp = c1 ;<br/>
       tmp.sub(c2);<br/>
       return tmp ;<br/>
}<br/><br/>
complex operator* ( complex &amp;c1 , complex &amp;c2 ){<br/>
       complex tmp ;<br/>
       tmp = c1 ;<br/>
       tmp.mul(c2);<br/>
       return tmp ;<br/>
}<br/><br/>
complex operator/ ( complex &amp;c1 , complex &amp;c2 ){<br/>
       complex tmp ;<br/>
       tmp = c1 ;<br/>
       tmp.div(c2);<br/>
       return tmp ;<br/>
}<br/><br/>
void complex::output(){<br/>
       printf("%*.*f",_COMPLEX_OUTPUT_WIDTH,_COMPLEX_OUTPUT_DECIMAL,real);<br/>
       if ( fabs(imag) &gt; _COMPLEX_EPS ){<br/>
              if ( imag &gt; 0 ) putchar('+') ;<br/>
              printf("%*.*fi",_COMPLEX_OUTPUT_WIDTH,_COMPLEX_OUTPUT_DECIMAL,imag);<br/>
       }<br/>
}
