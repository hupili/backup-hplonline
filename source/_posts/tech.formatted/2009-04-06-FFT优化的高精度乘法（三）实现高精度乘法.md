---
layout: post
title: "FFT优化的高精度乘法（三）实现高精度乘法"
date: 2009-04-06  21:26
comments: true
categories: tech
tags: ["算法"]
_baiduhi_id: 2739df39469960fb3b87cee8.html
_baiduhi_category: 算法
---

(hplonline)2009.4.6<br/><br/>
上一节涉及的数学方面的东西实在太多。<br/><br/>
没办法细讲，但是拿着实现好的傅立叶类来做一个高精度乘法也是不失乐趣的。<br/><br/><font color="#0000ff">粗糙的"原理":</font><br/><br/>
我得用我不准确的语言来描述以下内容，<br/>
细致一点的还是应该翻书看看。<br/><br/><font color="#0000ff">结论1：</font>时域的卷积可以用频域上的乘积来实现。<br/><font color="#0000ff">结论2：</font>高精度乘法的结果相当于离散序列卷积经过模10整理后的结果<br/><font color="#0000ff">结论3：</font>当DFT的长度为M &gt;= A + B - 1(A,B是两序列的长度时，循环卷积和线性卷积对应）<br/><br/>
那么，我们的步骤如下：<br/><br/><font color="#ff6600">1.选择M = 2 ^ K &amp;&amp; M &gt; A &amp;&amp; M &gt; B ，M作为fft和ifft的长度<br/>
2.将乘数的作为序列的实部，虚部为0 <br/>
3.对两乘数进行FFT变换<br/>
4.对两变换后的序列数对应相乘<br/>
5.对乘积序列做IFFT<br/>
6.把实部整数化，作为离散卷积结果<br/>
7.把卷积结果整理成整数高精度乘法后的结果</font><br/><br/>
用到的<a href="http://hi.baidu.com/hplonline/blog/item/bebbf9de8308c65c95ee371d.html" target="_blank">CBigInt</a>前面已经有了，这里只是多实现一个mul_fft:<br/><br/><font color="#0000ff">在类的声明中添加：</font><br/>
CBigInt&amp; mul_fft(CBigInt &amp;bi) ;<br/><br/><font color="#0000ff">实现：</font><br/><br/>
const int MAXFL = 2 * MAXL ;<br/><br/>
//can be allocated in mul_fft function <br/>
complex a[MAXFL] , b[MAXFL] ;<br/><br/>
CBigInt&amp; CBigInt::mul_fft(CBigInt &amp;bi){<br/>
           int *c ;<br/>
           int i , m ; <br/><br/>
           //实部为乘数的每一位，虚部为0<br/>
           for ( i = 0 ; i &lt; l ; i ++ ){<br/>
                      a[i].real = data[i] ;<br/>
                      a[i].imag = 0 ;<br/>
           }<br/>
           for ( i = 0 ; i &lt; bi.l ; i ++ ){<br/>
                      b[i].real = bi.data[i] ;<br/>
                      b[i].imag = 0 ;<br/>
           }<br/><br/>
           //求出的m是: m = 2 ^ k , 且m &gt; a.l &amp;&amp; m &gt; b.l 的最小数<br/>
           m = 1 ;<br/>
           while ( m &lt; l || m &lt; bi.l ) m &lt;&lt;= 1 ;<br/>
           m &lt;&lt;= 1 ;<br/><br/>
           //把两个串的高位部分置0<br/>
           for ( i = l ; i &lt; m ; i ++ ) {<br/>
                      a[i].real = 0 ;<br/>
                      a[i].imag = 0 ;<br/>
           }<br/>
           for ( i = bi.l ; i &lt; m ; i ++ ){<br/>
                      b[i].real = 0 ;<br/>
                      b[i].imag = 0 ;<br/>
           }<br/><br/>
           //FFT变换<br/>
           fr.fft( a , m ) ;<br/>
           fr.fft( b , m ) ;<br/>
           //相乘<br/>
           for ( i = 0 ; i &lt; m ; i ++ ) a[i] *= b[i] ;<br/><br/>
           //反变换，得到卷积 conv( a , b )  <br/>
           fr.ifft( a , m ) ;<br/>
           <br/>
           //节约空间，直接用b分配的区域<br/>
           c = (int*) b ;<br/>
           memset( c , 0 , sizeof(int) * MAXL ) ;<br/><br/>
           //获取整数部分<br/>
           for ( i = 0 ; i &lt; m ; i ++ ) c[i] = round ( a[i].real ) ;<br/>
           <br/>
           //将卷积整理成乘积<br/>
           for ( i = 0 ; i &lt; m - 1 ; i ++ ) {<br/>
                      c[i + 1] += c[i] / 10 ;<br/>
                      c[i] %= 10 ;<br/>
           }<br/><br/>
           //得到乘积长度<br/>
           for ( i = m - 1 ; i &gt;= 0 ; i -- )if ( c[i] != 0 ) break; <br/>
           l = i + 1 ;<br/>
           for ( i = 0 ; i &lt; l ; i ++ ) data[i] = c[i] ;<br/><br/>
           return *this ;<br/>
}
