---
layout: post
title: "FFT优化的高精度乘法（二）实现傅立叶变换"
date: 2009-04-06  21:24
comments: true
categories: tech
tags: ["算法"]
_baiduhi_id: baf29d2ba29f6ff2e7cd40ee.html
_baiduhi_category: 算法
---

(hplonline)2009.4.6<br/><br/>
这一节，毕竟我的能力有限。<br/><br/>
要画图，写公式，排版，弄一套出来的话，不知会花多少时间去了。<br/>
所以只能简单提一下。<br/><font color="#ff0000">有关发散出去的部分都会标红，可以从其他资料进行了解</font>。<br/><br/>
根据我的经验，先在网上看一些简短的资料，有个大致了解。<br/>
然后还是需要一本DSP的书，认真看一下就懂了。<br/>
网络资料往往很残缺，有许多细节没有提到。<br/><br/>
但是如果是个实践者，也可以不用理会原理性的东西。<br/>
直接找到相应的算法描述框架，写成程序即可。<br/><br/><font color="#0000ff">傅立叶类：</font><br/><br/>
#ifndef _FOURIER_H_<br/><br/>
#define _FOURIER_H_<br/><br/>
#include "complex.h"<br/><br/>
class fourier{<br/>
private:<br/>
        static double PI ;<br/>
        complex *w ;<br/>
        void initw(int size , int dir) ;<br/>
        int rbit(int b , int m ) ;<br/>
        void bitreverse(complex *x , int size , int m ) ;<br/>
        void fft_ifft_common(complex *x , int size ) ;<br/>
public:<br/>
        fourier() ;<br/>
        ~fourier() ;        <br/>
        bool dft(complex *x , int size) ;<br/>
        bool idft(complex *x , int size) ;<br/>
        bool fft(complex *x , int size) ;<br/>
        bool ifft(complex *x , int size) ;<br/>
        void output(complex *x , int size) ;<br/>
};<br/><br/>
#endif<br/><br/>
相应的函数就是对应的FT的名称。<br/>
这里虽然是实现FFT，也先实现一套DFT和IDFT，用于检测FFT和，IFFT的正确性。<br/><br/><font color="#ff0000">FFT和IFFT变换的序列长度一定要是2的方幂</font><br/><br/><font color="#ff6600">w为旋转因子。w[i] = exp(-j * i * 2 * pi / N ) </font><br/><br/>
离散时间傅立叶变换很对称，<br/><font color="#ff0000">正反变换的区别就在于旋转因子的不同和最后系数的不同。</font><br/><br/><font color="#0000ff">1.initw</font><br/><br/>
在做变换之前，要搞定对w的初始化：<br/><br/>
//exp(-j * ( 2 * pi * i / N ) ) <br/>
//size W<br/>
//dir: 1 , increase<br/>
//dir: -1 , decrease<br/>
void fourier::initw(int size , int dir){<br/>
        if ( w != NULL ) free(w);<br/>
        w = (complex *) malloc(size*sizeof(complex)) ;<br/>
        int i ;<br/>
        if ( dir == 1){<br/>
                for ( i = 0 ; i &lt; size ; i ++ ){<br/>
                        w[i].real = cos( 2 * PI * i / size ) ;<br/>
                        w[i].imag = -sin( 2 * PI * i / size ) ;<br/>
                }<br/>
        }<br/>
        else{<br/>
                for ( i = 0 ; i &lt; size ; i ++ ){<br/>
                        w[i].real = cos( 2 * PI * (-i) / size ) ;<br/>
                        w[i].imag = -sin( 2 * PI * (-i) / size ) ;<br/>
                }        <br/>
        }<br/>
}<br/><br/>
这个根据定义是很好理解的。<br/><br/><font color="#0000ff">2.output</font><br/>
输出序列的函数<br/><br/>
void fourier::output(complex *x , int size){<br/>
        int i;<br/>
        for ( i = 0 ; i &lt; size ; i ++ ){<br/>
                x[i].output() ;<br/>
                putchar('\n');<br/>
        }<br/>
}<br/><br/><font color="#0000ff">3.dft和idft</font><br/><br/>
bool fourier::dft(complex *x , int size){<br/>
        initw(size , 1);<br/>
        complex *tmp = ( complex * ) malloc( size * sizeof ( complex )) ;<br/>
        int i , j ;<br/>
        for ( i = 0 ; i &lt; size ; i ++ ) {<br/>
                tmp[i].real = 0 ;<br/>
                tmp[i].imag = 0 ;<br/>
                for ( j = 0 ; j &lt; size ; j ++ ){<br/>
                        tmp[i] += x[j] * w[ i * j % size ] ;<br/>
                }<br/>
        }<br/>
        for ( i = 0 ; i &lt; size ; i ++ ) {<br/>
                x[i] = tmp[i] ;<br/>
        }<br/>
        free(tmp) ;<br/>
        return true ;<br/>
}<br/><br/>
bool fourier::idft(complex *x , int size){<br/>
        initw(size , -1) ;<br/>
        complex *tmp = ( complex * ) malloc( size * sizeof ( complex )) ;<br/>
        int i , j ;<br/>
        for ( i = 0 ; i &lt; size ; i ++ ) {<br/>
                tmp[i].real = 0 ;<br/>
                tmp[i].imag = 0 ;<br/>
                for ( j = 0 ; j &lt; size ; j ++ ){<br/>
                        tmp[i] += x[j] * w[ i * j % size ] ;<br/>
                }<br/>
        }<br/>
        for ( i = 0 ; i &lt; size ; i ++ ) {<br/>
                x[i].real = tmp[i].real / size ;<br/>
                x[i].imag = tmp[i].imag / size ;<br/>
        }<br/>
        free(tmp) ;<br/>
        return true ;<br/>
}<br/><br/>
dft和idft的定义可以查找相关资料，这个就是很直接的实现。<br/><font color="#0000ff"><br/>
4.fft和ifft的基本框架</font><br/><br/>
//pre-condition: size = 2 ^ m<br/>
//post-condition: x be the FT of x<br/>
bool fourier::fft(complex *x , int size){<br/><br/>
        initw(size , 1) ;<br/>
        fft_ifft_common(x , size);<br/>
        <br/>
        return true ;<br/>
}<br/><br/>
//pre-condition: size = 2 ^ m<br/>
//post-condition: x be the FT of x<br/>
bool fourier::ifft(complex *x , int size){<br/>
        int i;<br/><br/>
        initw(size , -1) ;<br/>
        fft_ifft_common(x , size);<br/><br/>
        for ( i = 0 ; i &lt; size ; i ++ ) {<br/>
                x[i].imag /= size ;<br/>
                x[i].real /= size ;<br/>
        }<br/><br/>
        return true ;<br/>
}<br/><br/>
除去公共部分外，正反变换的差异清晰可见。<br/><br/><font color="#0000ff">5.位反序函数</font><br/><br/>
int fourier::rbit(int b , int m){<br/>
        int t = 0 ;<br/>
        int i = 1 ;<br/>
        while ( m -- ) {<br/>
                t &lt;&lt;= 1 ;<br/>
                t |= b &amp; 1 ;<br/>
                b &gt;&gt;= 1;<br/>
        }<br/>
        return t ;<br/>
}<br/><br/>
//bit reverse order for fft caculating<br/>
void fourier::bitreverse(complex *x , int size , int m){<br/>
        int i , j ;<br/>
        complex tmp ;<br/>
        for ( i = 0 ; i &lt; size ; i ++ ){<br/>
                j = rbit(i , m);<br/>
                if ( j &gt; i ) {<br/>
                        tmp = x[i] ;<br/>
                        x[i] = x[j] ;<br/>
                        x[j] = tmp ;<br/>
                }<br/>
        }<br/>
}<br/><br/>
在做相应的变换的时候。首先要<font color="#ff0000">位反序</font>。<br/>
这是为了进行<font color="#ff0000">同址运算</font>的。<br/>
这些概念在DSP的书上应该都有介绍。<br/><br/><font color="#0000ff">6.fft和ifft的公共部分</font><br/><br/>
我使用的是<font color="#ff0000">基于时间的抽取</font><br/><br/>
关键在于<font color="#ff0000">蝶形运算</font><br/><br/>
void fourier::fft_ifft_common(complex *x , int size){<br/>
        int i , j ;<br/>
        int m ;<br/>
        complex high , low ;<br/><br/>
        //caculate power m <br/>
        i = size ;<br/>
        m = 0 ;<br/>
        while ( i ) {<br/>
                m ++ ;<br/>
                i &gt;&gt;= 1 ;<br/>
        }<br/><br/>
        bitreverse(x , size , m - 1 ) ;<br/><br/>
        int group_num = size / 2 ;<br/>
        int group_length = 2 ;<br/>
        int group_step = 1 ;<br/>
        while ( m -- ){<br/>
                for ( i = 0 ; i &lt; group_num ; i ++ ){<br/>
                        int group_start = i * group_length ;<br/>
                        for ( j = 0 ; j &lt; group_step ; j ++ ){<br/>
                                int a = group_start + j ;<br/>
                                int b = group_start + j + group_step ;<br/>
                                high = x[a] ;<br/>
                                low = x[b] * w[j * group_num];<br/>
                                x[a] = high + low ;<br/>
                                x[b] = high - low ;<br/>
                        }<br/>
                }<br/>
                group_num &gt;&gt;= 1 ;<br/>
                group_length &lt;&lt;= 1 ;<br/>
                group_step &lt;&lt;= 1 ;<br/>
        }<br/>
}<br/><br/><font color="#0000ff">7.构造和析构函数</font><br/><br/>
fourier::fourier(){<br/>
       w = NULL ;<br/>
}<br/><br/>
fourier::~fourier(){<br/>
       if ( w != NULL ) free(w);<br/>
}
