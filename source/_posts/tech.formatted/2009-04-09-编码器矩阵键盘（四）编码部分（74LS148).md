---
layout: post
title: "编码器矩阵键盘（四）编码部分（74LS148)"
date: 2009-04-09  20:04
comments: true
categories: tech
tags: ["Scm"]
_baiduhi_id: 72cd68d04bfbf187a1ec9c8f.html
_baiduhi_category: Scm
---

(hplonline)2009.4.9<br/><br/><font color="#0000ff">编码电路：</font><br/><br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/6a065ee7ce73570cb83820cb.jpg" small="0" class="blogimg"/></div>
<br/><a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/2210888be48af6dbfc1f10e2.html">74LS148</a>在之前也用过。<br/><br/>
简单说一下就是，优先编码，EI使能，7到0，优先降低，A2A1A0输出。<br/>
当编码工作的时候GS有效，当编码未工作的时候EO有效。<br/><br/>
熟悉这个芯片的同学，一定很快发现我在设计上的一点缺陷了。<br/><font color="#ff0000">前面我用两个列线的或来表示有没有键按下。<br/>
其实用跟列相关的148（U5)的GS就可以表示。</font><br/>
为低的时候表示有键按下，为高的时候表示没有。<br/>
由于在proteus仿真的时候，老是没有反映，所以放弃这一方法。<br/><br/>
由于优先编码的问题，所以，把148没有用的输入端全部接高。<br/><br/>
编码出来的rowo0和rowo1等都是低有效，当未编码的时候，输出全1。<br/>
所以把行和列的编码输出相与并取反，就可以获得高有效的码了。<br/><br/>
这时，直接从P1口相应位读出来就是按下的键所在列（行）：<br/>
col = (P1 &amp; 0x01 ) + 1;      //获得列值<br/>
这里只用了1位，如果是4*4的就P1 &amp; 0x03就行了。<br/>
后面加1是我对行列从1编号的缘故。<br/><font color="#ff0000">这里要注意的就是&amp;比+的优先级低。</font><br/>
（地球人都知道？确实。。。不过地球人大多爱犯这错。。。）<br/><br/>
再看左端。行线和列线row0,row1,col0,col1都是接下拉电阻到地的。<br/>
所以常态下为低。<br/>
如果我们对row0,row1置高，那么有键按下的那一列就被拉高。<br/>
经过反向后为低有效，对其编码。<br/>
（并且可以知道，多键同时按下的时候，标号大的优先译码）<br/><br/>
还有一点，就是行赋全1的时候，列编码工作，列赋全1的时候，行编码工作。<br/><br/>
所以，留下两个erow和ecol信号来使能两片编码器。
