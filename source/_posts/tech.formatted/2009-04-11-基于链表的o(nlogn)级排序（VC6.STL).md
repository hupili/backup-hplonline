---
layout: post
title: "基于链表的o(nlogn)级排序（VC6.STL)"
date: 2009-04-11  22:37
comments: true
categories: tech
tags: ["算法"]
_baiduhi_id: f6fb9aef629fc1e7cf1b3e2f.html
_baiduhi_category: 算法
---

(hplonline) 2009.4.11<br/><br/>
罪过啊罪过。。前段时间跟同学讲stl的list的sort是o(n^)的。。。<br/><br/>
这也难怪，我们直观一想，作为一个list的某个节点，由于是双向的，<br/>
他可以知道自己的前驱和后继，但仅限于此。他的迭代器不是RandomIterator。<br/><br/>
而&lt;algorithm&gt;里面的sort要求传进去的迭代器是RandomIterator。<br/>
于是就主观认为list的sort肯定不能用快排，而要达到稳定，一定就是冒泡了。。<br/>
（现在想起来真是太主观了）<br/><br/>
近来看STL源码，看到了sort这里。<br/>
参考的是侯捷的那本《STL源码剖析》<br/>
（经典，推荐之）<br/><br/>
本来准备PASS掉的，突然瞟到候老师注释的是<font color="#ff0000">quick sort</font>。<br/><br/>
感觉一震。。于是细看了一下。<br/>
当然，大师只要点到即止，自然没有对该算法的实现做注释了。<br/>
此等杂务交由我辈完成^_^。<br/>
（这也是网络分享的乐趣所在，不同的人按照自己的标准进行剖析，<br/>
自然有需要的人能找到需要的资料。）<br/>
看完了发现是归并排序(<font color="#ff0000">merge sort</font>) 。 不过意思上大致如此。只要是o(nlogn)就行了。<br/><br/>
之所以说<font color="#ff0000">发现</font>，是因为我并不能直接看出来他就是。。<br/>
以前也写过mergesort，但是没想过这个事情还可以换一种角度来做。。<br/>
做得如此有<font color="#ff0000">艺术性</font>，ORZ。。<br/><br/>
下面这个东西是从VC6拷贝出来的。。。<br/>
我觉得长得很难看。。<br/><br/>
     void sort()<br/>
          {if (2 &lt;= size())<br/>
               {const size_t _MAXN = 15;<br/>
               _Myt _X(allocator), _A[_MAXN + 1];<br/>
               size_t _N = 0;<br/>
               while (!empty())<br/>
                    {_X.splice(_X.begin(), *this, begin());<br/>
                    size_t _I;<br/>
                    for (_I = 0; _I &lt; _N &amp;&amp; !_A[_I].empty(); ++_I)<br/>
                         {_A[_I].merge(_X);<br/>
                         _A[_I].swap(_X); }<br/>
                    if (_I == _MAXN)<br/>
                         _A[_I].merge(_X);<br/>
                    else<br/>
                         {_A[_I].swap(_X);<br/>
                         if (_I == _N)<br/>
                              ++_N; }}<br/>
               while (0 &lt; _N)<br/>
                    merge(_A[--_N]); }}<br/><br/>
merge sort的思想就不用废话了。只是不同人的实现上有区别。所以我对照这份给个简要的描述。<br/><br/><font color="#0000ff">先说下他的变量类型：</font><br/>
_Myt _X(allocator), _A[_MAXN + 1];<br/>
_Myt 这个类型和当前需要排序的list是同一个类型。<br/>
_X 是一个临时变量。<br/>
_A 是我所谓的精华（没想过merge sort还可以如此实现）<br/><font color="#ff0000">可以理解为一系列的桶。_A[i]这个桶内list的长度是2^i</font>。<br/>
（所以这里的最大桶支持的长度为32768）<br/>
size_t _N 记录的是当前的最大的桶的编号。<br/><br/><font color="#0000ff">然后有几个已经实现的函数来提一下：</font><br/>
merge。当两个list有序的时候，调用该函数合并出来的list也是有序的。<br/>
splice。是一个实现list剪切，粘贴的函数。<br/><br/><font color="#0000ff">最后来看他的实现思路：</font><br/>
1。从待排链表中取出头节点。放入临时链表_X<br/>
2。让该临时链表从小到大依次和每个桶里的链表merge。<br/>
3。如果已经合并到了当前最大长度的桶处（_N），或者该长度的桶是空的。<br/>
3Y。跳出循环。<br/>
3N。继续合并。<br/>
4。如果这时候应当合并的桶是最大的桶（_MAXN）<br/>
4Y。直接与该桶合并<br/>
4N。把临时链表_X存入此桶。<br/>
5。如果当前指向的桶是当前最大长度桶（_I == _N），扩充当前最大长度桶。<br/>
6。如果待排序链表非空，转1。<br/>
7。依次把每个桶的内容merge到待排序链表中（这步之前他已经为空）<br/><br/><font color="#0000ff">总结：</font><br/>
这份代码和SGI的实现上还是有点差别，总得来说要节省不少空间。<br/><font color="#ff6600">SGI的实现是开够64个桶</font>，想下2^64是多么的大啊。。。我们估计没有那么长的list。<br/>
于是就省去了第4步的判断。<br/>
而VC这份PJ实现只支持到最大桶32768。显然少开了不<font color="#ff0000">少局部变量。这里很省空间</font>。<br/>
如果要顾及时间的话。<br/>
又如果非要用到超长list，那么可以自己<font color="#ff0000">DIY一下这个_MAXN</font>就OK 了。<br/><br/>
以前自己写的时候，一般是做一个步长，从2开始翻倍。<br/>
依次merge该区段里的元素。<br/>
这个写法在连续空间，如数组上写起来比较方便。<br/>
而且，根据步长的翻倍 ，很容易感受到对数级这一概念。<br/><br/>
STL list.srot这种写法真的很隐蔽。。<br/>
在不直接说他是merge sort的时候还真难考虑。<br/>
（因为候老师说是quick sort ，就一直拿quick sort的框架去考虑。。。发现不成）<br/><br/>
精华就在于那一组桶。<font color="#ff0000">从小桶归并到大桶是一个长度翻倍的过程，很自然。</font><br/>
而且不用像步长法那样考虑一些尾巴上的特殊判断。比如7个元素，不是2的方幂。<br/><font color="#ff0000">只要在最后归并完了，依次把所有的桶再merge到该list中就可以了</font>。<br/><br/>
做人。。还是不能太主观了。。
