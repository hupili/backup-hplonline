---
layout: post
title: "STL的堆（堆函数及泛型堆实现）"
date: 2009-04-14  22:49
comments: true
categories: tech
tags: ["c","c++"]
_baiduhi_id: 2790d0b4db87437b8ad4b239.html
_baiduhi_category: c&c++
---

(hplonline)2009.4.14<br/><br/>
STL并没有提供“堆”这个东西，但是提供了一套堆函数，<br/>
以及一个封装好的priority_queue。<br/><br/>
曾经也在网上找了一通，看得迷迷糊糊的。<br/>
今天把堆函数的源码看了，才知道原来是那么回事。<br/><br/><font color="#0000ff">一。封装一个泛型堆</font><br/><br/>
先展示一下这一套堆函数的易用性，紧跟后面再详细阐述他们的用法。<br/><br/>
#include &lt;iostream&gt;<br/>
#include &lt;algorithm&gt;<br/>
#include &lt;vector&gt;<br/>
#include &lt;functional&gt;  <br/><br/>
using namespace std ;<br/><br/>
//接口说明<br/>
//bool empty()            判空<br/>
//size()                  堆大小<br/>
//clear()                  清空堆<br/>
//push(const T&amp; x)      推入元素x<br/>
//const T&amp; top()      堆顶元素<br/>
//pop()                        弹出堆顶<br/>
template&lt;class T , class Compare = less&lt;T&gt; &gt;<br/>
class myheap{<br/>
private:<br/>
      vector&lt;T&gt; data ;<br/>
      Compare comp ;<br/>
public:<br/>
      myheap(){};<br/>
      bool empty(){return data.empty() ;}<br/>
      vector&lt;T&gt;::size_type size(){return data.size();} ;<br/>
      void clear(){data.clear();} ;<br/>
      void push(const T&amp; x){<br/>
            data.push_back(x);<br/>
            push_heap(data.begin() , data.end() , comp) ;<br/>
      }<br/>
      const T&amp; top(){<br/>
            return *(data.begin()) ;<br/>
      }<br/>
      void pop(){<br/>
            pop_heap(data.begin() , data.end() , comp) ;<br/>
            data.pop_back() ;<br/>
      }<br/>
} ;<br/><br/><font color="#0000ff">二。测试该泛型堆</font><br/><br/>
      int a[] = {2,5,1,67,95,9,0,4,6} ;<br/>
      int sz = sizeof(a) / sizeof(int) ;<br/>
      int i;<br/>
      myheap&lt;int&gt; h ;<br/>
      <br/>
      h.clear() ;<br/>
      for ( i = 0 ; i &lt; sz ; i ++ ){<br/>
            h.push(a[i]) ;<br/>
      }<br/>
      for ( i = 0 ; i &lt; sz ; i ++ ) {<br/>
            cout&lt;&lt;h.top()&lt;&lt;' ';<br/>
            h.pop() ;<br/>
      }<br/><br/>
      return 0 ;<br/><br/>
输出：95 67 9 6 5 4 2 1 0<br/><br/>
这里是STL堆算法默认的大顶堆。<br/><br/>
做如下修改：<br/><br/>
      int a[] = {2,5,1,67,95,9,0,4,6} ;<br/>
      int sz = sizeof(a) / sizeof(int) ;<br/>
      int i;<br/>
   <font color="#ff0000"> myheap&lt;int , greater&lt;int&gt; &gt; h ;</font><br/>
      <br/>
      h.clear() ;<br/>
      for ( i = 0 ; i &lt; sz ; i ++ ){<br/>
            h.push(a[i]) ;<br/>
      }<br/>
      for ( i = 0 ; i &lt; sz ; i ++ ) {<br/>
            cout&lt;&lt;h.top()&lt;&lt;' ';<br/>
            h.pop() ;<br/>
      }<br/><br/>
      return 0 ;<br/><br/>
输出：0 1 2 4 5 6 9 67 95<br/><br/>
这一次就是小顶堆了。<br/><br/>
总得来说，这个实现看上去有点别扭，默认传的是less&lt;T&gt;作为比较器，却是大顶堆。<br/>
而传greater&lt;T&gt;却是小顶堆。是因为STL的堆算法按照小于比较的时候排出来的是大顶堆。<br/><br/>
为了改善这个名字上的别扭，可以参考<font color="#ff0000">STL.functional</font>里面的less和greater的写法。<br/>
自己写一个诸如myheap_small_top , myheap_big_top这样的functor。<br/><br/>
（顺便补充一句。。肯定有同学看出来了。其实上面这个泛型堆就是仿照priority_queue的写法。）<br/><br/><font color="#0000ff">三。STL的堆函数</font><br/><br/>
这些函数看别人用起来，觉得别扭，但一看这些函数的实现，却又真是那么回事。<br/>
只不过他们的名字可能取得不太好，所以理解起来有点不容易。<br/><br/><font color="#ff0000">首先，要知道STL的堆函数要求的是RandomIterator 。<br/>
然后，要知道STL普遍采用的是前闭后开的区间表示。</font><br/><br/><font color="#0000ff">push_heap</font><br/>
这个函数与其说是push，更好的说是一个adjust。<br/>
pre-condition:[begin,end-1)区间内已经成堆，end-1放的是新入堆的元素<br/>
post-condition:[begin,end)区间调整成堆。<br/><br/>
所以用法是先把要放进堆的元素放到容器的尾端。<br/>
然后再调用这个函数，把整体的堆区间传进去，将调整好。<br/><br/>
例：<br/>
            data.push_back(x);<br/>
            push_heap(data.begin() , data.end() , comp) ;<br/><br/><font color="#0000ff">pop_heap</font><br/>
这个函数做的是把堆顶的元素放到堆尾，并调整好堆。<br/>
pre-condition:[begin,end)已经成堆<br/>
post-condition:堆顶元素（begin的位置）放到end-1的位置，[begin,end-1)调整成堆<br/><br/>
所以出堆的做法是先调用该函数，然后从底层容器弹出最后的元素。<br/><br/>
例：<br/>
          pop_heap(data.begin() , data.end() , comp) ;<br/>
          data.pop_back() ;<br/><br/><font color="#0000ff">make_heap</font><br/>
建堆的函数。<br/>
pre-condition:无<br/>
post-condition:[begin,end)区间成堆<br/><br/>
这个函数本质上就是区间的一半处开始，依次向前调整成堆。<br/>
调用的是内部使用的_Adjust_heap函数。<br/><br/><font color="#0000ff">sort_heap</font><br/>
这个函数我认为最容易让人误解。<br/>
根据名字，我们知道是“堆排序”，那么就想，<br/>
传进去一个区间，他就使用堆排序把该区间弄成有序的。<br/>
（正如我们调用sort一样）<br/>
但是这个函数是有<font color="#ff0000">前置条件</font>的。（为什么要有这个条件见后）<br/>
pre-condition:[begin,end)已经成堆<br/>
post-condition:[begin,end)被排序<br/><br/><font color="#ff0000">用之前一定要make_heap一下</font><br/><br/>
上面两个函数的综合例子：<br/>
     int a[] = {2,5,1,67,95,9,0,4,6} ;<br/>
     int sz = sizeof(a) / sizeof(int) ;<br/>
     ostream_iterator&lt;int&gt; oit(cout , " ")  ;<br/>
     make_heap(a , a + sz);<br/>
     sort_heap(a , a + sz);<br/>
     copy(a , a + sz , oit) ;cout&lt;&lt;endl;<br/>
输出：<br/>
0 1 2 4 5 6 9 67 95<br/><br/>
如果把make_heap一句注释掉，发现输出的是乱序的。<br/>
这就是前置条件未满足的结果。<br/><br/>
用copy输出，这个用法在一般的讲STL的手册上应该都要出现。不是这里关心的。<br/><br/><font color="#ff0000">从最初的对sort_heap的疑惑，到解决这个疑惑，中间仅仅是看一下代码这么简单。</font><br/>
我把VC中的PJ实现复制过来：<br/><br/>
  template&lt;class _RI&gt; inline<br/>
     void sort_heap(_RI _F, _RI _L)<br/>
     {for (; 1 &lt; _L - _F; --_L)<br/>
          pop_heap(_F, _L); }<br/>
          // TEMPLATE FUNCTION sort_heap WITH PRED<br/><br/>
当看到这么些长得很怪的符号时，不要吓到，耐心读一下就可知其大意。<br/><br/>
这个函数就只有一个循环。<br/>
他不断的对[_F,_L)区间执行pop_heap操作。并且递减右界_L。<br/><br/>
根据前面对pop_heap的说明，<br/>
每一次，该函数把堆顶放到区间尾端，<br/>
同时把除尾元素外的区域调整成堆。<br/><br/>
如果是大顶堆，第一个到尾端的是最大的元素。<br/>
紧接着，第二大的元素到倒数第二个位置。<br/>
。。。<br/>
于是就排好了。<br/><br/><font color="#ff6600">有时候，去理解前人的工作，并不代表我们也要去实现这些东西，<br/>
仅仅是为了更好地使用已有的成果。</font>
