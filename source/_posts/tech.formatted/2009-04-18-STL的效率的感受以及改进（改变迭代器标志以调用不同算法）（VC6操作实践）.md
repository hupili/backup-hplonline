---
layout: post
title: "STL的效率的感受以及改进（改变迭代器标志以调用不同算法）（VC6操作实践）"
date: 2009-04-18  21:31
comments: true
categories: tech
tags: ["c","c++"]
_baiduhi_id: ecf54b34b9e94646241f14b1.html
_baiduhi_category: c&c++
---

(hplonline)2009.4.18<br/><br/>
还只看了一小部分STL的源码，已经对他的效率处理感到惊愕了。。<br/><font color="#ff0000">世界上居然有这么精打细算的东西</font>。。。（虽然也有失误，后面会看到）<br/><br/>
众所周知的copy这样出名的例子，对效率的考虑很详细，讨论也很多了。<br/>
我这里拿来试一下的是rotate这个函数。<br/><br/>
基本用法是rotate(b,m,e)<br/>
这样会把[b,m),[m,e)区间进行交换。<br/><br/>
这个功能是很简单的，初学程序的时候估计很多人都练习过。<br/>
在许多面试题里面，也经常见到让你用常数的辅助空间来解决这个问题。<br/><br/>
算法我会在后面拿出来讨论，STL的实现对<font color="#ff0000">三种</font>不同的迭代器使用了不同的算法。<br/>
（其中对random_access_iterator的实现很不错，效率也是最高的，同时也没怎么看到有人讨论他）<br/><br/><font color="#0000ff">测试程序：</font><br/><br/>
#include &lt;iostream&gt;<br/>
#include &lt;algorithm&gt;<br/>
#include &lt;time.h&gt;<br/><br/>
using namespace std;<br/><br/>
int a[10000] ;<br/><br/>
int main(){<br/>
      int tt = clock() ;  <br/>
      int i;      <br/>
      for ( i = 0 ; i &lt; 1000 ; i ++ )<br/>
            rotate(a , a + 5000 , a + 10000 ) ;<br/>
      printf("%d\n",clock() - tt );<br/>
      return 0 ;  <br/>
}<br/><br/><font color="#ff0000">下面是很关键的部分，需要拿出胆量，因为我们现在要去改STL的源码了</font>。。。<br/>
（我的所有操作是在VC6下做的，其他地方由于采用的STL版本不一样，会有出入）<br/><br/>
改之前先到VC6的include目录下备份<font color="#ff0000">UTILITY</font>这个文件。<br/>
（这是显然的，如果改戳了好恢复啊。。）<br/><br/>
那么开始，为了找到相应的函数，<br/>
在vc里面本来可以在rotate上点右键，然后go to definition of rotate这样。<br/>
我操作的时候老是跑到不知道哪里去，所以换个方法。<br/><br/>
直接进行跟踪。<font color="#ff0000">先跟进rotate</font>。来到这里：<br/><br/>
template&lt;class _FI&gt; inline<br/>
      void rotate(_FI _F, _FI _M, _FI _L)<br/><font color="#ff6600">      {if (_F != _M &amp;&amp; _M != _L)</font><br/>
            _Rotate(_F, _M, _L, _Iter_cat(_F)); }<br/><br/>
光标停在标黄的一行。<br/>
该函数调用了_Rotate。而_Rotate前面的参数就是照搬rotate的参数。<br/><br/>
关键的地方就在于最后一个参数。这个参数决定了将去向哪个函数。<br/><br/>
_Iter_cat是iterator category的缩写。<br/><br/>
这时候向下面浏览一下，有三个函数：<br/><br/>
      void _Rotate(_FI _F, _FI _M, _FI _L,<br/>
            forward_iterator_tag)<br/><br/>
      void _Rotate(_BI _F, _BI _M, _BI _L,<br/>
            bidirectional_iterator_tag)<br/><br/>
      void _Rotate(_RI _F, _RI _M, _RI _L,<br/>
                  random_access_iterator_tag)<br/><br/>
他们也只有最后一个参数有区别，就是上面的_Rotate根据迭代器标志（iterator_tag）选择的去向。<br/><br/>
然后继续跟进，会到<font color="#ff0000">_Iter_cat(</font><br/><br/>
template&lt;class _Ty&gt; inline<br/>
      <font color="#ff0000">random_access_iterator_tag</font> __cdecl _Iter_cat(const _Ty *)<br/>
      {<font color="#ff0000">random_access_iterator_tag</font> _RandIterTag;<br/>
       <font color="#ff0000">random_access_iterator_tag</font>* _pRandIterTag;<br/>
      _pRandIterTag = &amp;_RandIterTag;      // Workaround for C4700 warning<br/><br/>
到达的这个位置其实是_Iter_cat的一个特化版本。<br/>
因为我们调用rotate的时候传的是原生指针，<br/>
而原生指针都是<font color="#ff0000">random_access_iterator。</font>所以这里将返回一个random_access_iterator_tag。<br/><br/>
根据前面对_Rotate的考察，发现他对下面三种迭代器给出了各自的版本：<br/><font color="#ff6600">forward_iterator_tag<br/>
bidirectional_iterator_tag <br/>
random_access_iterator_tag </font><br/>
（这几个迭代器从上到下是派生关系，也就是如果满足下面的标志，那么一定也可以是上面的）<br/><br/>
于是我们现在把上面_Iter_cat中标红的部分依次替换成这几个迭代器标志，<br/>
如：<br/><br/>
template&lt;class _Ty&gt; inline<br/>
      <font color="#ff0000">bidirectional_iterator_tag</font> __cdecl _Iter_cat(const _Ty *)<br/>
      {<font color="#ff0000">bidirectional_iterator_tag</font> _RandIterTag;<br/>
       <font color="#ff0000">bidirectional_iterator_tag</font>* _pRandIterTag;<br/>
      _pRandIterTag = &amp;_RandIterTag;      // Workaround for C4700 warning<br/>
      return (_RandIterTag); }<br/><br/>
这样，分别改成三种，并运行前面的测试程序。得到一个时间。<br/>
三个的时间如下：<br/><br/>
forward_iterator_tag <font color="#ff6600">325</font><br/>
bidirectional_iterator_tag<font color="#0000ff"> </font><font color="#0000ff">665</font><br/>
random_access_iterator_tag <font color="#ff6600">110</font><br/><br/>
可见，三个算法确实效率不同，能用random_iterator的地方，绝对不应该调用前面两种算法。<br/><br/>
可是<font color="#ff0000">这里却似乎是一个败笔</font>。<br/>
我们明显的看到bidirectional_iterator_tag比forward_iterator_tag慢。<br/><br/>
而能够给forward_iterator_tag用的算法，是一定可以给bidirectional_iterator_tag用的。<br/>
那当时为什么给bidirectional_iterator_tag单独设计出一个算法呢？<br/>
况且这个算法还要慢一些。。。<br/><br/>
当然，这只是我的一家之言，也许在其他地方的测试结果不是如此。<br/><br/>
那么，如果在大多数情况下的测试皆是如此，为了达到最大效率。<br/>
可以直接把下面的函数注释掉：<br/><br/><font color="#339966">/*template&lt;class _BI&gt; inline<br/>
      void _Rotate(_BI _F, _BI _M, _BI _L,<br/>
            bidirectional_iterator_tag)<br/>
      {reverse(_F, _M);<br/>
      reverse(_M, _L);<br/>
      reverse(_F, _L); }*/</font><br/><br/>
这是不会出问题的，因为bidirectional_iterator_tag出现时，<br/>
没有找到完全匹配的，会找一个他的基类迭代器标志，于是会进入<br/>
forward_iterator_tag_tag的处理函数。<br/><br/><font color="#0000ff">总结：</font><br/><br/>
STL确实是很精当的东西，不过圣人千虑，必有一失。<br/><br/>
同时，通过这次操作，增加了胆量，满足了动手欲望。。。<br/>
