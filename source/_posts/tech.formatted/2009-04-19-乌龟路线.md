---
layout: post
title: "乌龟路线"
date: 2009-04-19  18:45
comments: true
categories: tech
tags: ["Vc"]
_baiduhi_id: b66cc3174d201e01c83d6d74.html
_baiduhi_category: Vc
---

(hplonline)2009.4.19<br/><br/>
今天跑去传源码，翻出来了这么个东西，<br/>
用到的算法确实很简单，不过当时是才学在VC下的DC的使用，不太熟。<br/><br/>
那天是在百度知道上看到有人在问，于是用VC做了个出来。<br/><br/><font color="#0000ff">所谓乌龟路线：</font><br/>
把四个乌龟放在正方形的四个角上，<br/>
第i个乌龟始终朝着(i + 1) % 4号乌龟走。<br/><br/>
那么你能想出来是什么样子吗？<br/><br/>
其实就是：<br/><br/><div forimg="1"><a href="http://hiphotos.baidu.com/hplonline/pic/item/1dd98d44a9d3e26e500ffe5c.jpg" target="_blank"><img height="200" width="199" border="0" src="http://hiphotos.baidu.com/hplonline/abpic/item/1dd98d44a9d3e26e500ffe5c.jpg" small="1" class="blogimg"/></a></div>
<br/>
在VC里创建一个DLG程序，加一个按钮。<br/>
双击写代码。红色的是你自己的DLG类名和按钮函数名。<br/><br/>
算法就是迭代法。给定一个初始状态，然后按照很小的步长，模拟乌龟的运动。。。<br/><br/>
#include &lt;math.h&gt;<br/><br/><font color="#ff0000">void CMy9Dlg::OnButton1() </font><br/>
{<br/><br/>
#define sqr(x) (x)*(x) <br/><br/>
      typedef struct pt_type{<br/>
            double x,y ;<br/>
      }myPOINT;<br/><br/>
      const double EDGE = 300 ; //the length of each side of the square<br/>
      const double VEL = 2 ; //magnitude of the velocity<br/>
      const double DT = 0.01 ;//the unit time of iteration<br/>
      const int N = 30000 ; //the iteration times<br/>
      <br/>
      myPOINT turtle[4] = {<br/>
            {0,0},{EDGE,0},{EDGE,EDGE},{0,EDGE}<br/>
      };//the position<br/>
      myPOINT last[4]= {<br/>
            {0,0},{EDGE,0},{EDGE,EDGE},{0,EDGE}<br/>
      };//the previous position<br/>
      myPOINT velocity[4] = {<br/>
            {VEL,0},{0,VEL},{-VEL,0},{0,-VEL}<br/>
      };//the heading direction<br/>
      <br/>
      int i;<br/>
      CClientDC dc (this);<br/>
      <br/>
      dc.Rectangle(0,0,EDGE,EDGE);<br/><br/>
      for (int n = 0 ; n &lt; N ;n ++){<br/>
            //paint the route<br/>
            for (i = 0 ; i &lt; 4 ; i ++){<br/>
                  dc.MoveTo(int(last[i].x),int(last[i].y));<br/>
                  dc.LineTo(int(turtle[i].x),int(turtle[i].y));<br/>
                  last[i] = turtle[i];<br/>
            }<br/>
            //iterates for next state<br/>
            for (i = 0 ;i &lt; 4; i ++){<br/>
                        turtle[i].x += DT * velocity[i].x ;<br/>
                  turtle[i].y += DT * velocity[i].y ;<br/>
                  int j = (i + 1) %4;<br/>
                  double mag = sqrt ( sqr(turtle[j].x-turtle[i].x) + sqr(turtle[j].y-turtle[i].y) );<br/>
                  velocity[i].x = VEL / mag * (turtle[j].x-turtle[i].x);<br/>
                  velocity[i].y = VEL / mag * (turtle[j].y-turtle[i].y);<br/>
            }<br/>
      }<br/>
}
