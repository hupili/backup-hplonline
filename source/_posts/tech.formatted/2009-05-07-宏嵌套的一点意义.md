---
layout: post
title: "宏嵌套的一点意义"
date: 2009-05-07  15:44
comments: true
categories: tech
tags: ["c","c++"]
_baiduhi_id: e7ce61609ab7254ceaf8f813.html
_baiduhi_category: c&c++
---

(hplonline)2009.5.7<br/><br/>
还好今天下午把最优化的课逃了，没有错过一个精彩的讨论。。<br/>
又土鳖地学了一招。<br/><br/>
经常在一些很大的项目中看到这种东西：<br/><font color="#ff0000">#define _macro(x) ????<br/>
#define macro(x) _macro(x)<br/></font><br/>
包括微软做的MFC里面也有很多这种形状的代码。<br/>
反正是奇怪了很久，<br/>
你想啊，第二行就是再转为另外一个宏展开而已。。<br/>
那么这样做两层有啥意义吗。。。<br/><br/><font color="#0000ff">示范</font>:<br/>
（改编自zhd32大牛群聊代码）<br/><br/>
#define A abc<br/>
#define B def<br/>
#define _SYM2STR(arg) #arg<br/>
#define SYM2STR(arg) _SYM2STR(arg)<br/><br/>
int main()<br/>
{<br/>
     puts(_SYM2STR(A B));<br/>
     puts(SYM2STR(A B));<br/>
     return 0 ;<br/>
}<br/><br/><font color="#0000ff">输出：</font><br/><br/>
A B<br/>
abc def<br/><br/>
这就是差别了！<br/><br/>
先来看这句：<br/><font color="#ff6600">#define _SYM2STR(arg) #arg</font><br/><br/>
这个宏是把一个符号转化成字符串。<br/>
比如 _SYM2STR(X) 展开后就成了 "X"。<br/>
这属于#搞的鬼。<br/>
另外还搜集了几个，为了不影响阅读流程，放在最后。<br/><br/>
而从上面的结果，可以发现，<br/>
_SYM2STR(A B)的展开是字符串"A B"，说明<font color="#ff6600">A B</font>被当作一个整体了作为arg，<br/>
他并没有进一步展开。<br/>
而SYM2STR(A B)首先要展开成<br/><font color="#ff6600">_SYM2STR(A B)</font><br/>
这时，A,B继续被展开成abc和def。成为：<br/><font color="#ff6600">_SYM2STR(abc def)</font><br/>
于是再通过#化为字符串就成了：<br/><font color="#ff6600">"abc def"<br/></font>了。<br/><br/>
所以，这样的宏嵌套很有意义。<br/><font color="#ff0000">可以在交给最底层的宏去完成实际功能前，<br/>
由一个套在上层的宏帮助把参数中的宏展开。</font><br/><br/><font color="#0000ff">补#define 的几个特殊定义：</font><br/><br/>
#define A(x) T_##x<br/>
#define B(x) #@x<br/>
#define C(x) #x<br/>
我们假设：x=1，则有：<br/>
A(1)------〉T_1<br/>
B(1)------〉'1'<br/>
C(1)------〉"1"<br/>
（这里参考了 hustli的文章）<br/><br/>
我都不知道在哪里逛到的，原样拷贝。。<br/><br/>
