---
layout: post
title: "AVLTree的一个实现（带删除操作）"
date: 2009-05-18  14:14
comments: true
categories: tech
tags: ["算法"]
_baiduhi_id: 4a5fc3ea9cb588dbd439c90a.html
_baiduhi_category: 算法
---

(hplonline)2009.5.18<br/><br/><font color="#0000ff">一。前面的废话<br/></font><br/>
为什么非要在括号里面加个<font color="#ff0000">带删除</font>呢？？<br/>
因为我在网上看到好多放出来的AVL没有删除操作。<br/>
这倒没啥，还有些没有删除操作却在标题里面表明有删除。。<br/>
或者在函数的定义处定义个删除函数却不实现。。囧<br/>
正好也看到网上不少人在寻找这个东西。<br/>
于是憋了一个出来。<br/><br/>
从昨天中午憋到今天中午，终于调好了！<img src="http://img.baidu.com/hi/jx/j_0003.gif"/>。<font color="#ff0000">约500行吧。</font>。。<br/>
基本的情况均有覆盖，最后也有大数据检验。详情见后面的测试代码吧。<br/><font color="#ff0000">(万一谁用的时候发现错误，一定要记载清楚跟我讲啊。。）</font><br/><br/>
听说这个生猛的结构也是有好多年的，一直似是而非地以为自己知道，<br/>
从来没动过手。。两个月前，一个同学问我个问题。。<br/>
我说bfs+hash，他一直说他们老师说的AVLTree。。<br/>
把我吓惨了，大一下，仅有半年C的基础，外加半学期的数据结构基础。。<br/>
能搞出来吗。。？<br/><br/>
于是要是搞不出一个来，我这脸就丢大了啊。。<br/>
真的一搞，发现有些东西还不像以为的那么简单，很多细节容易出错。<br/>
这两天耗费了若干草稿纸：<br/><div forimg="1"><a href="http://hiphotos.baidu.com/hplonline/pic/item/24c0cc5cf6dd3967faf2c090.jpg" target="_blank"><img height="138" border="0" width="200" src="http://hiphotos.baidu.com/hplonline/abpic/item/24c0cc5cf6dd3967faf2c090.jpg" small="1" class="blogimg"/></a></div>
憋出来后觉得神清气爽，发现写AVL的难点其实就在平衡因子的操作上。<br/><font color="#ff0000">要列清楚各种情况，发现其中平衡因子是怎么改变的，就可以搞定了。</font><br/>
这个过程显然是要消耗大量草稿纸的，<br/>
当然，鉴于各位拥有容量更大，运算速度更快的大脑，可以少用一点。<br/><br/>
有一些前导的知识点：<br/><a href="http://hi.baidu.com/hplonline/blog/item/6267a37773b21e13b151b9f7.html" target="_blank">BinarySearchTree</a><br/><br/>
AVL就是在BST的思想上做了一些改进。<br/><br/>
该结构的介绍乃是到处都有，而且往往地球人看了都觉得可以很快写出来。<br/>
所以各位就baidu一下就有了。<br/><br/><font color="#0000ff">二。含一定注释的代码</font><br/><br/>
#include &lt;iostream&gt;<br/>
#include &lt;stdlib.h&gt;<br/><br/>
//元素类型<br/>
typedef int ElemType ;<br/><br/>
//树的节点<br/>
struct ANode{<br/>
       ElemType data ;<br/>
       ANode *left , *right , *parent ;<br/>
       int balance ;//height(left) - height(right) <br/>
       ANode(){} ;<br/>
       ANode(ElemType d){<br/>
              data = d ;<br/>
              left = NULL ;<br/>
              right = NULL ; <br/>
              parent = NULL ;<br/>
              balance = 0 ;<br/>
       }<br/>
       void init(ElemType d){<br/>
              data = d ;<br/>
              left = NULL ;<br/>
              right = NULL ; <br/>
              parent = NULL ;              <br/>
              balance = 0 ;<br/>
       }<br/>
};<br/>
typedef ANode *PANode ;<br/><br/>
//空间分配宏，便于实现其他配置方式<br/>
#define _AVL_initspace <br/>
#define _AVL_allocate() (ANode *)malloc(sizeof(ANode))<br/>
#define _AVL_deallocate(p) free(p) <br/>
//ANode space[1000] , *spacehead ;<br/>
//#define _AVL_initspace spacehead = space <br/>
//#define _AVL_allocate() spacehead++ ;<br/>
//#define _AVL_deallocate(p) <br/><br/>
//AVL<br/>
class AVLTree{<br/>
private:<br/>
       PANode root ;<br/>
       void _delete_node(PANode p) ;<br/>
       PANode _find_subs(PANode pos) ;//寻找删除时用于替换的节点<br/>
       PANode _next_node(PANode p) ;//中继前驱<br/>
       PANode _prev_node(PANode p) ;//中继后继<br/>
       PANode _rotate_left(PANode p ) ;//以p为轴左旋<br/>
       PANode _rotate_right(PANode p ) ;//以p为轴右旋<br/>
       PANode _balance_left(PANode p ) ;//对p的左枝进行平衡<br/>
       PANode _balance_right(PANode p ) ;//对p的右枝进行平衡<br/>
       PANode _find_node(PANode p , ElemType d ) ;//从p开始的位置寻找节点<br/>
       PANode _find_parent(ElemType d ) ;//寻找d的父节点<br/>
       void _in_order(PANode p) ;//p节点的中序遍历<br/>
       void _pre_order(PANode p) ;//p节点的前序遍历<br/>
       int _check_balance(PANode p) ;//用于测试平衡性是否计算正确<br/>
       int _height(PANode p) ;//用于取得子树高度<br/>
public:<br/>
       ANode bad_node ; //用于获取不存在的节点时给出<br/>
       AVLTree() ;//构造空树<br/>
       ~AVLTree() ;//销毁树<br/>
       PANode Find(ElemType d) ;//查找元素，<br/>
       PANode FindMax() ;//查找最大元素，<br/>
       PANode FindMin() ;//查找最小元素，<br/>
       ElemType&amp; Retrieve(PANode p) ;//获取元素<br/>
       PANode Insert(ElemType d) ;//插入元素<br/>
       void Delete(ElemType d) ;//按元素删除<br/>
       void Erase(PANode p) ;//按节点位置删除<br/>
       void Clear() ;//清除整棵树<br/>
       void InOrder() ; //中序遍历<br/>
       void PreOrder() ; //前序遍历<br/>
       static void Sort(ElemType a[] , int n , int d = 1) ;//利用AVL进行排序，静态函数<br/>
} ;<br/><br/>
//d：1，从小到大，0，从大到小<br/>
void AVLTree::Sort(ElemType a[] , int n , int d){<br/>
       AVLTree tree ;<br/>
       int i ;<br/>
       for ( i = 0 ; i &lt; n ; i ++ ){<br/>
              tree.Insert(a[i]) ;<br/>
       }<br/>
       for ( i = 0 ; i &lt; n ; i ++ ){<br/>
              PANode p ;<br/>
              if ( d ) {<br/>
                     p = tree.FindMin() ;<br/>
              }else{<br/>
                     p = tree.FindMax() ;       <br/>
              }<br/>
              a[i] = tree.Retrieve(p) ;<br/>
              tree.Erase(p) ;<br/>
       }<br/>
}<br/><br/>
#define max(x,y) ((x)&gt;(y)?(x):(y))<br/><br/>
int AVLTree::_height(PANode p ){<br/>
       if ( !p ) return -1 ;<br/>
       else return max(_height(p-&gt;left) , _height(p-&gt;right)) + 1 ;<br/>
}<br/><br/>
#undef max<br/><br/>
int AVLTree::_check_balance(PANode p){<br/>
       if ( !p ) return 1 ;<br/>
       if ( !_check_balance(p-&gt;left) || !_check_balance(p-&gt;right) )return 0 ;<br/>
       else {<br/>
              int a = _height(p-&gt;left) ;<br/>
              int b = _height(p-&gt;right) ;<br/>
              return a - b == p-&gt;balance ;<br/>
       }<br/>
}<br/><br/>
AVLTree::AVLTree(){<br/>
       root = NULL ;<br/>
}<br/><br/>
AVLTree::~AVLTree(){<br/>
       Clear() ;<br/>
}<br/><br/>
void AVLTree::_in_order(PANode p){<br/>
       if ( p ) {<br/>
              _in_order(p-&gt;left) ;<br/>
              std::cout&lt;&lt;p-&gt;data&lt;&lt;' ';//&lt;&lt;p-&gt;balance&lt;&lt;',' ;<br/>
              _in_order(p-&gt;right) ;<br/>
       }<br/>
}<br/><br/>
void AVLTree::_pre_order(PANode p){<br/>
       if ( p ) {<br/>
              std::cout&lt;&lt;p-&gt;data&lt;&lt;' ' ;<br/>
              _pre_order(p-&gt;left) ;<br/>
              _pre_order(p-&gt;right) ;<br/>
       }       <br/>
}<br/><br/>
void AVLTree::InOrder(){<br/>
       _in_order(root) ;<br/>
       std::cout&lt;&lt;std::endl;<br/>
}<br/><br/>
void AVLTree::PreOrder(){<br/>
       _pre_order(root) ;<br/>
       std::cout&lt;&lt;std::endl;<br/>
}<br/><br/>
PANode AVLTree::_next_node(PANode p){<br/>
       if ( !p ) return NULL ;<br/>
       if ( p-&gt;right != NULL ){<br/>
              p = p-&gt;right ;<br/>
              while ( p-&gt;left ) p = p-&gt;left ;<br/>
       }else{<br/>
              while ( p-&gt;parent &amp;&amp; p-&gt;parent-&gt;right == p ) p = p-&gt;parent ;<br/>
              p = p-&gt;parent ;<br/>
       }<br/>
       return p ;<br/>
}<br/><br/>
PANode AVLTree::_prev_node(PANode p){<br/>
       if ( !p ) return NULL ;<br/>
       if ( p-&gt;left != NULL ){<br/>
              p = p-&gt;left ;<br/>
              while ( p-&gt;right ) p = p-&gt;right ;<br/>
       }else{<br/>
              while ( p-&gt;parent &amp;&amp; p-&gt;parent-&gt;left == p ) p = p-&gt;parent ;<br/>
              p = p-&gt;parent ;<br/>
       }<br/>
       return p ;       <br/>
}<br/><br/>
PANode AVLTree::Find(ElemType d){       <br/>
       return _find_node(root , d) ;<br/>
}<br/><br/>
PANode AVLTree::FindMax(){<br/>
       if ( root == NULL ) return NULL ;<br/>
       PANode p = root ;<br/>
       while ( p-&gt;right ){<br/>
              p = p-&gt;right ;<br/>
       }<br/>
       return p ;<br/>
}<br/><br/>
PANode AVLTree::FindMin(){<br/>
       if ( root == NULL ) return NULL ;<br/>
       PANode p = root ;<br/>
       while ( p-&gt;left ){<br/>
              p = p-&gt;left ;<br/>
       }<br/>
       return p ;<br/>
}<br/><br/>
ElemType&amp; AVLTree::Retrieve(PANode p){<br/>
       if ( p ) <br/>
              return p-&gt;data ;<br/>
       else return bad_node.data ;<br/>
}<br/><br/>
//左旋<br/>
PANode AVLTree::_rotate_left(PANode p ){<br/>
       PANode child = p-&gt;right ;<br/>
       p-&gt;right = child-&gt;left ;<br/>
       if ( child-&gt;left ) child-&gt;left-&gt;parent = p ;<br/>
       child-&gt;left = p ;<br/>
       PANode ancestor = p-&gt;parent ;<br/>
       if ( ancestor ) {<br/>
              if ( ancestor-&gt;left == p ) ancestor-&gt;left = child ;<br/>
              else ancestor-&gt;right = child ;<br/>
       }else{<br/>
              root = child ;<br/>
       }<br/>
       child-&gt;parent = ancestor ;<br/>
       p-&gt;parent = child ;<br/>
       return child ;<br/>
}<br/><br/>
//右旋<br/>
PANode AVLTree::_rotate_right(PANode p ){<br/>
       PANode child = p-&gt;left ;<br/>
       p-&gt;left = child-&gt;right ;<br/>
       if ( child-&gt;right ) child-&gt;right-&gt;parent = p ;<br/>
       child-&gt;right = p ;<br/>
       PANode ancestor = p-&gt;parent ;<br/>
       if ( ancestor ) {<br/>
              if ( ancestor-&gt;left == p ) ancestor-&gt;left = child ;<br/>
              else ancestor-&gt;right = child ;<br/>
       }else{<br/>
              root = child ;<br/>
       }<br/>
       child-&gt;parent = ancestor ;<br/>
       p-&gt;parent = child ;<br/>
       return child ;<br/>
}<br/><br/>
//左平衡<br/>
PANode AVLTree::_balance_left(PANode p ){<br/>
       PANode child = p-&gt;left ;<br/>
       PANode re ;<br/>
       int tmp ;<br/>
       switch ( child-&gt;balance ) {<br/>
       case 1:<br/>
              re = _rotate_right(p) ;<br/>
              re-&gt;balance = 0 ;<br/>
              re-&gt;right-&gt;balance = 0 ;<br/>
              break;<br/>
       case -1:<br/>
              _rotate_left(child) ;<br/>
              re = _rotate_right(p) ;<br/>
              tmp = re-&gt;balance ;<br/>
              re-&gt;balance = 0 ;<br/>
              switch(tmp){<br/>
              case 0:<br/>
                     re-&gt;left-&gt;balance = 0 ;<br/>
                     re-&gt;right-&gt;balance = 0 ;<br/>
                     break;<br/>
              case 1:<br/>
                     re-&gt;left-&gt;balance = 0 ;<br/>
                     re-&gt;right-&gt;balance = -1 ;<br/>
                     break;<br/>
              case -1:<br/>
                     re-&gt;left-&gt;balance = 1 ;<br/>
                     re-&gt;right-&gt;balance = 0 ;<br/>
                     break;<br/>
              }<br/>
              break;<br/>
       case 0:<br/>
              re = _rotate_right(p) ;<br/>
              re-&gt;balance = -1 ;<br/>
              re-&gt;right-&gt;balance = 1 ;<br/>
              break;<br/>
       default:;<br/>
              //assert("false") ;<br/>
       }<br/>
       return re ;<br/>
}<br/><br/>
//右平衡<br/>
PANode AVLTree::_balance_right(PANode p ){<br/>
       PANode child = p-&gt;right ;<br/>
       PANode re ;<br/>
       int tmp ;<br/>
       switch ( child-&gt;balance ) {<br/>
       case 1:<br/>
              _rotate_right(child) ;<br/>
              re = _rotate_left(p) ;<br/>
              tmp = re-&gt;balance ;<br/>
              re-&gt;balance = 0 ;<br/>
              switch(tmp){<br/>
              case 0:<br/>
                     re-&gt;left-&gt;balance = 0 ;<br/>
                     re-&gt;right-&gt;balance = 0 ;<br/>
                     break;<br/>
              case 1:<br/>
                     re-&gt;left-&gt;balance = 0 ;<br/>
                     re-&gt;right-&gt;balance = -1 ;<br/>
                     break;<br/>
              case -1:<br/>
                     re-&gt;left-&gt;balance = 1 ;<br/>
                     re-&gt;right-&gt;balance = 0 ;<br/>
                     break;<br/>
              }<br/>
              break;<br/>
       case -1:<br/>
              re = _rotate_left(p) ;<br/>
              re-&gt;balance = 0 ;<br/>
              re-&gt;left-&gt;balance = 0 ;<br/>
              break;<br/>
       case 0:<br/>
              re = _rotate_left(p) ;<br/>
              re-&gt;balance = 1 ;<br/>
              re-&gt;left-&gt;balance = -1 ;<br/>
              break;<br/>
       default:;<br/>
              //assert("false") ;<br/>
       }<br/>
       return re ;       <br/>
}<br/><br/>
PANode AVLTree::_find_node(PANode p , ElemType d ){<br/>
       if ( !p ) return root ;//说明p是根节点的父节点<br/>
       while ( p &amp;&amp; p-&gt;data != d ){<br/>
              if ( d &lt; p-&gt;data ) p = p-&gt;left ;<br/>
              else p = p-&gt;right ;<br/>
       }       <br/>
       return p ;<br/>
}<br/><br/>
PANode AVLTree::_find_parent(ElemType d ){<br/>
       if ( root == NULL ) return NULL ;<br/>
       PANode p = NULL ;<br/>
       PANode q = root ;<br/>
       do{<br/>
              if ( q-&gt;data == d ) return p ;<br/>
              p = q ;<br/>
              if ( d &lt; q-&gt;data ) q = q-&gt;left ;<br/>
              else q = q-&gt;right ;<br/>
       }while (q) ;<br/>
       return p ;<br/>
}<br/><br/>
PANode AVLTree::Insert(ElemType d){       <br/>
       //空树<br/>
       if ( !root ) {<br/>
              root = _AVL_allocate() ; <br/>
              root-&gt;init(d) ;<br/>
              return root ;<br/>
       }<br/>
       <br/>
       PANode parent = _find_parent(d) ;<br/>
       PANode child = _find_node(parent , d) ;<br/>
       if ( child ){//已经存在该节点<br/>
              return child ;<br/>
       }<br/><br/>
       //不存在该节点<br/>
       PANode p = _AVL_allocate() ;<br/>
       p-&gt;init(d) ;<br/>
       p-&gt;parent = parent ;<br/>
       if ( d &lt; parent-&gt;data ) parent-&gt;left = p ;<br/>
       else parent-&gt;right = p ;<br/><br/>
       child = p ;<br/>
       //查找待调整的树<br/>
       while ( parent != NULL ){<br/>
              if ( child == parent-&gt;left ){//左枝增高<br/>
                     switch( parent-&gt;balance ){<br/>
                     case 0:<br/>
                            parent-&gt;balance = 1 ;<br/>
                            child = parent ;<br/>
                            parent = parent-&gt;parent ;<br/>
                            break;<br/>
                     case 1:<br/>
                            parent-&gt;balance = 2 ;<br/>
                            _balance_left(parent) ;<br/>
                            return p ;<br/>
                            break;<br/>
                     case -1:<br/>
                            parent-&gt;balance = 0 ;<br/>
                            return p ;<br/>
                            break;<br/>
                     default:;<br/>
                            //assert("false") ;<br/>
                     }<br/>
              }else{//右枝增高<br/>
                     switch( parent-&gt;balance ){<br/>
                     case 0:<br/>
                            parent-&gt;balance = -1 ;<br/>
                            child = parent ;<br/>
                            parent = parent-&gt;parent ;<br/>
                            break;<br/>
                     case 1:<br/>
                            parent-&gt;balance = 0 ;<br/>
                            return p ;<br/>
                            break;<br/>
                     case -1:<br/>
                            parent-&gt;balance = -2 ;<br/>
                            _balance_right(parent) ;<br/>
                            return p ;<br/>
                            break;<br/>
                     default:;<br/>
                            //assert("false") ;<br/>
                     }                     <br/>
              }<br/>
       }<br/>
       <br/>
       return p ;<br/>
}<br/><br/>
//该函数仅被Erase过程调用<br/>
PANode AVLTree::_find_subs(PANode pos){<br/>
       PANode su = pos;<br/>
       //ElemType tmp = pos-&gt;data ;//可删<br/>
       while ( (su-&gt;left != NULL) || (su-&gt;right != NULL) ) {<br/>
              if ( su-&gt;balance == 1 ) {<br/>
                     su = _prev_node(pos) ;<br/>
              }else{<br/>
                     su = _next_node(pos) ;<br/>
              }<br/>
              pos-&gt;data = su-&gt;data ;<br/>
              pos = su ;<br/>
       }<br/>
       //su-&gt;data = tmp ;//可删，<br/>
       return su ;<br/>
}<br/><br/>
void AVLTree::Erase(PANode pos){<br/>
       if ( pos == NULL ) return ;<br/>
       PANode su = _find_subs(pos) ;//替换节点<br/>
       PANode child = su ;<br/>
       PANode parent = child-&gt;parent ;<br/>
       bool over = false ;<br/>
       int tmp ;<br/>
       while ( parent &amp;&amp; !over ) {<br/>
              if ( child == parent-&gt;left ){//左枝<br/>
                     switch (parent-&gt;balance){<br/>
                     case 0:<br/>
                            parent-&gt;balance = -1 ;<br/>
                            over = true ;<br/>
                            break;<br/>
                     case 1:<br/>
                            parent-&gt;balance = 0 ;<br/>
                            child = parent ;<br/>
                            parent = parent-&gt;parent ;<br/>
                            break;<br/>
                     case -1:<br/>
                            parent-&gt;balance = -2 ;<br/>
                            tmp = parent-&gt;right-&gt;balance ;<br/>
                            child = _balance_right(parent) ;<br/>
                            parent = child-&gt;parent ;<br/>
                            if ( tmp == 0 ) over = true ;<br/>
                            break;<br/>
                     default:break;<br/>
                            //assert("false") ;<br/>
                     }<br/>
              }else{//右枝<br/>
                     switch (parent-&gt;balance){<br/>
                     case 0:<br/>
                            parent-&gt;balance = 1 ;<br/>
                            over = true ;<br/>
                            break;<br/>
                     case 1:<br/>
                            parent-&gt;balance = 2 ;<br/>
                            tmp = parent-&gt;left-&gt;balance ;<br/>
                            child = _balance_left(parent) ;<br/>
                            parent = child-&gt;parent ;<br/>
                            if ( tmp == 0 ) over = true ;<br/>
                            break;<br/>
                     case -1:<br/>
                            parent-&gt;balance = 0 ;<br/>
                            child = parent ;<br/>
                            parent = parent-&gt;parent ;<br/>
                            break;<br/>
                     default:break;<br/>
                            //assert("false") ;<br/>
                     }                     <br/>
              }<br/>
       }       <br/>
       if ( su-&gt;parent ){<br/>
              if (su == su-&gt;parent-&gt;left) su-&gt;parent-&gt;left = NULL ;<br/>
              else su-&gt;parent-&gt;right = NULL ;<br/>
       }else{<br/>
              root = NULL ;<br/>
       }<br/>
       _AVL_deallocate(su) ;<br/>
}<br/><br/>
void AVLTree::Delete(ElemType d){<br/>
       PANode p = Find(d) ;<br/>
       if ( p ) {<br/>
              Erase(p) ;<br/>
       }<br/>
}<br/><br/>
void AVLTree::_delete_node(PANode p){<br/>
       if ( p != NULL ){<br/>
              _delete_node(p-&gt;left) ;<br/>
              _delete_node(p-&gt;right) ;<br/>
              _AVL_deallocate(p) ;<br/>
       }<br/>
}<br/><br/>
void AVLTree::Clear(){<br/>
       _delete_node(root) ;<br/>
       root = NULL ;<br/>
}<br/><br/><br/>
//测试代码<br/>
using namespace std;<br/>
#include &lt;algorithm&gt;<br/><br/>
const TOTAL = 50000 ;<br/>
int c[TOTAL] ;<br/><br/>
int main(){<br/>
       int a[] = {3,2,9,7,5,8,6} ;<br/>
//       int a[] = {5 , 2 , 3} ;<br/>
       int b[10] ;<br/>
       int sz = sizeof(a) / sizeof(int)  ;<br/>
       int i;<br/><br/>
       //初始化空间<br/>
        _AVL_initspace ;<br/><br/>
       for ( i = 0 ; i &lt; sz ; i ++ ) b[i] = a[i] ;<br/><br/>
       //排序测试<br/>
       AVLTree::Sort(a , sz , 1) ;<br/>
       for ( i = 0 ; i &lt; sz ; i ++ )cout&lt;&lt;a[i]&lt;&lt;' ';<br/>
       cout&lt;&lt;endl;<br/>
       <br/>
       AVLTree tree ;<br/><br/>
       //插入，删除，中序遍历，空树测试<br/>
       tree.Insert(1) ;<br/>
       tree.InOrder() ;<br/>
       tree.Insert(1) ;<br/>
       tree.InOrder() ;<br/>
       tree.Delete(1) ;<br/>
       tree.InOrder() ;<br/><br/>
       //插入测试，根据中序和前序，可以构造出整树，来检验插入是否正确<br/>
       for ( i = 0 ; i &lt; sz ; i ++ ){<br/>
              tree.Insert(a[i]) ;<br/>
              tree.InOrder() ;<br/>
              tree.PreOrder() ;<br/>
       }<br/>
       cout&lt;&lt;endl;<br/><br/>
       //查找测试<br/>
       //不存在元素<br/>
       cout&lt;&lt;tree.Find(4)&lt;&lt;endl;<br/>
       cout&lt;&lt;endl;<br/>
       //存在的元素<br/>
       cout&lt;&lt;tree.Find(9)&lt;&lt;endl;<br/>
       cout&lt;&lt;tree.Find(9)-&gt;data&lt;&lt;endl;<br/>
       //删除元素<br/>
       tree.Delete(9) ;<br/>
       cout&lt;&lt;tree.Find(9)&lt;&lt;endl;<br/><br/>
       tree.InOrder() ;<br/>
       tree.PreOrder() ;<br/><br/>
       //清除测试<br/>
       cout&lt;&lt;endl;<br/>
       cout&lt;&lt;tree.Find(3)&lt;&lt;endl;<br/>
       cout&lt;&lt;tree.Retrieve(tree.Find(3))&lt;&lt;endl;<br/>
       tree.Clear() ;<br/>
       cout&lt;&lt;tree.Find(3)&lt;&lt;endl;       <br/>
       tree.PreOrder() ;<br/><br/>
//大数据测试<br/>
       for ( i = 0 ; i &lt; TOTAL ; i ++ ) c[i] = i ; <br/>
       random_shuffle(c , c + TOTAL) ;<br/>
//       可选择输出数据检验<br/>
//       for ( i = 0 ; i &lt; TOTAL ; i ++ ) cout&lt;&lt;c[i]&lt;&lt;' ' ;<br/>
//       cout&lt;&lt;endl;<br/>
//       return 0 ;<br/>
       AVLTree::Sort(c , TOTAL , 1) ;<br/>
       for ( i = 0 ; i &lt; TOTAL ; i ++ ) if ( c[i] != i ) break; <br/>
       if ( i == TOTAL ) cout&lt;&lt;"ok"&lt;&lt;endl;<br/>
       else cout&lt;&lt;"bad alg!"&lt;&lt;endl;<br/><br/>
       return 0 ;<br/>
}<br/><br/><font color="#0000ff">三。后面的废话</font><br/><br/>
至于为什么只有少量注释，主要是前面说过了，这个东西的情况太多了。。<br/>
瞟一眼代码就发现很多的if，switch等等。<br/>
要详细地讲一下，总觉得语言已到极限，只有自己边写边画，弄一棵出来就明白其中的道理了。<br/><br/>
还有这东西写到今天早上的时候 ，已经通过了前面的各种测试。<br/>
正想发，又想了下用大数据检验一下。一测，果然有错。。<br/>
于是又郁闷地调了两个多小时。<br/><br/>
可见<font color="#ff0000">大数据</font>的重要性，通过他不能保证程序正确，<br/>
但至少以我们有限的能力来说，对该程序的信任明显增强。<br/><br/>
为了这个东西拖了一屁股的作业。。。赶之去。<img src="http://img.baidu.com/hi/jx/j_0016.gif"/><br/><br/>
下一个目标RBTree<img src="http://img.baidu.com/hi/jx/j_0019.gif"/>。
