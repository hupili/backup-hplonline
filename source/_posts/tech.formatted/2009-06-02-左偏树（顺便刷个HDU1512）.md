---
layout: post
title: "左偏树（顺便刷个HDU1512）"
date: 2009-06-02  22:10
comments: true
categories: tech
tags: ["算法"]
_baiduhi_id: 7a8a0633d33d0ef01b4cff08.html
_baiduhi_category: 算法
---

(hplonline)2009.6.2<br/><br/>
关于左偏树的资料，<br/>
网上到处转载的大多是05年黄源河的论文<br/><a href="http://www.box.net/shared/01tp7616qx" target="_blank">《左偏树》</a><br/>
应该说从理论到实现讲解得很清楚了，分享出来。<br/><br/>
主要在网上搜的时候，很多地方提到HDU1512<br/>
（其实就是一个人提到，到家转出来的）<br/>
于是顺便去刷了下。<br/><br/>
处理猴子认识与否，是典型的<a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/bd4524dd0463bcd18c1029c6.html">并查集</a>擅长解决的。<br/>
每次要得到<font color="#ff0000">strongness</font>最大的。<br/>
（<img src="http://img.baidu.com/hi/jx/j_0016.gif"/>个人认为应该是<font color="#ff0000">strength</font>。。。）<br/>
且打完一架之后要合并，于是需要可并堆来支持。<br/>
左偏树是性价比很高的可并堆的实现方案。<br/><br/>
写法上，和下面的左偏树的实现有点出入：<a href="http://www.box.net/shared/h82h087lxs" target="_blank">HDU1512</a>.txt<br/>
意思上是一样的。<br/><br/><font color="#0000ff">个人的理解：</font><br/><br/>
merge操作作为左偏树的基础。<br/>
按照堆的性质，取出待合并的树中最小的作为根即可。<br/>
由于限制了右树的“距离”更小。<br/>
所以确定根之后，把另一棵树和根的右枝合并。<br/>
可以尽可能地减少合并的次数。<br/><br/>
距离为0的点的右树是空的，这时候merge可以结束。<br/>
而从某节点走到距离为0的节点，只需要他的距离步。<br/>
这样可以保证很高的效率。<br/><br/><font color="#0000ff">我的左偏树代码：</font><br/><br/>
#include &lt;stdio.h&gt;<br/>
#include &lt;stdlib.h&gt;<br/>
#include &lt;iostream&gt;<br/><br/>
typedef int ElemType ;<br/><br/>
typedef struct leftistnode_type{<br/>
       ElemType data ;<br/>
       int dis ;<br/>
       leftistnode_type *left , *right ;<br/>
}LNode ;<br/><br/>
typedef LNode* PLNode ;<br/><br/>
//空间分配宏，便于实现其他配置方式<br/>
#define _L_initspace <br/>
#define _L_allocate() (LNode *)malloc(sizeof(LNode))<br/>
#define _L_deallocate(p) free(p) <br/>
//ANode space[1000] , *spacehead ;<br/>
//#define _L_initspace spacehead = space <br/>
//#define _L_allocate() spacehead++ ;<br/>
//#define _L_deallocate(p) <br/><br/>
class LeftistTree{<br/>
private:<br/>
       PLNode root ;<br/>
       LNode nil_node ;<br/>
       PLNode nil ;<br/>
       PLNode _merge(PLNode t1 , PLNode t2) ;<br/>
       void _delete_node(PLNode p) ;<br/>
public:<br/>
       LeftistTree() ;<br/>
       ~LeftistTree() ;<br/>
       ElemType Root() ;//获得根节点<br/>
       void Join(LeftistTree &amp;t) ;//合并另一个树到该树上<br/>
       void Insert(ElemType d) ;//插入<br/>
       void DeleteRoot() ;//删除<br/>
       void Clear() ;//清空树<br/>
       bool Empty() ;//判空<br/>
       friend LeftistTree ;<br/>
} ;<br/><br/>
PLNode LeftistTree::_merge(PLNode t1 , PLNode t2){<br/>
       if ( t1 == nil ) return t2 ;<br/>
       if ( t2 == nil ) return t1 ;<br/>
       PLNode t ;<br/>
       if ( t1-&gt;data &gt; t2-&gt;data ) {<br/>
              t = t1 ; t1 = t2 ; t2 = t ;<br/>
       }<br/>
       t = _merge(t1-&gt;right , t2) ;<br/>
       if ( t-&gt;dis &gt; t1-&gt;left-&gt;dis ) {<br/>
              t1-&gt;right = t1-&gt;left ;<br/>
              t1-&gt;left = t ;<br/>
       }else{<br/>
              t1-&gt;right = t ;<br/>
       }<br/>
       t1-&gt;dis = t1-&gt;right-&gt;dis + 1 ;<br/>
       return t1 ;<br/>
}<br/><br/>
LeftistTree::LeftistTree(){<br/>
       nil = &amp;nil_node ;<br/>
       nil-&gt;left = nil ;<br/>
       nil-&gt;right = nil ;<br/>
       nil-&gt;dis = -1 ;//为维护左偏性质而规定<br/>
       root = nil ;<br/>
}<br/><br/>
LeftistTree::~LeftistTree(){<br/>
       Clear() ;<br/>
}<br/><br/>
void LeftistTree::_delete_node(PLNode p){<br/>
       if ( p != nil ){<br/>
              _delete_node(p-&gt;left) ;<br/>
              _delete_node(p-&gt;right) ;<br/>
              _L_deallocate(p) ;<br/>
       }<br/>
}<br/><br/>
void LeftistTree::Clear(){<br/>
       _delete_node(root) ;<br/>
}<br/><br/>
ElemType LeftistTree::Root(){<br/>
       return root-&gt;data ;<br/>
}<br/><br/>
void LeftistTree::Insert(ElemType d){<br/>
       PLNode p = _L_allocate() ;<br/>
       p-&gt;data = d ;<br/>
       p-&gt;left = nil ;<br/>
       p-&gt;right = nil ;<br/>
       p-&gt;dis = 0 ;<br/>
       root = _merge(root , p) ;<br/>
}<br/><br/>
void LeftistTree::DeleteRoot(){<br/>
       PLNode p = root ;<br/>
       root = _merge(root-&gt;left , root-&gt;right) ;<br/>
       _L_deallocate(p) ;<br/>
}<br/><br/>
void LeftistTree::Join(LeftistTree &amp;t){<br/>
       root = _merge(root , t.root) ;<br/>
       t.root = t.nil ;<br/>
}<br/><br/>
bool LeftistTree::Empty(){<br/>
       return root == nil ;<br/>
}<br/><br/>
using namespace std ;<br/><br/>
int main(){<br/>
       int a[] = {3 , 2 , 9 , 10 , 5 , 4 , 6 , 7} ;<br/>
       int sz = sizeof(a) / sizeof(a[0]) ;<br/>
       LeftistTree lt ;<br/>
       int i ;<br/>
       for ( i = 0 ; i &lt; sz ; i ++ )<br/>
              lt.Insert(a[i]) ;<br/>
       for ( i = 0 ; i &lt; sz ; i ++ ){<br/>
              cout&lt;&lt;lt.Root() &lt;&lt;endl;<br/>
              lt.DeleteRoot() ;<br/>
       }<br/>
       return 0 ;<br/>
}
