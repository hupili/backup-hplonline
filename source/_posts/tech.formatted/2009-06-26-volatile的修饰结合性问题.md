---
layout: post
title: "volatile的修饰结合性问题"
date: 2009-06-26  19:52
comments: true
categories: tech
tags: ["c","c++"]
_baiduhi_id: 2210888bda828cdafc1f10eb.html
_baiduhi_category: c&c++
---

(hplonline)2009.6.26<br/><br/>
（实验在VC6下完成）<br/><br/>
若干天前，研究了下<a href="http://hi.baidu.com/hplonline/blog/item/baf29d2bb27a5ff2e7cd400b.html" target="_blank">volatile</a>的作用，没有太深入。<br/>
前些天，做了跟<a href="http://hi.baidu.com/hplonline/blog/item/e936db001972dd18738b65a2.html" target="_blank">函数指针的调用约定修饰</a>有关的工作，<br/>
当时也提到了结合性，提到了const之类的。<br/><br/>
今天在看到一群人讨论的时候，才反映过来volatile的修饰也有结合性的问题。<br/><br/>
而同时发现的就是，之前对<a href="http://hi.baidu.com/hplonline/blog/item/baf29d2bb27a5ff2e7cd400b.html" target="_blank">volatile的讨论</a>并不完全。<br/>
这里从当时的最后一个实验开始继续研究。<br/><br/><font color="#0000ff">程序如下：</font><br/><br/>
#include &lt;iostream&gt;<br/>
#include &lt;windows.h&gt;<br/><br/>
using namespace std;<br/><br/>
DWORD v_esp ;<br/><br/>
int one = 1 ;<br/><br/>
DWORD WINAPI ThreadProc(<br/>
LPVOID lpParameter    // thread data<br/>
){<br/>
     Sleep(3000) ;<br/>
     __asm{<br/>
         mov ebx , v_esp ;<br/>
         sub ebx , 4 ;<br/>
         mov eax , OFFSET one ;<br/>
         mov [ebx] , eax ;<br/>
     }<br/>
     return 0 ;<br/>
}<br/><br/>
void wait( int * <font color="#ff0000">volatile</font> p){<br/>
     while ( *p == 0 ) ;<br/>
}<br/><br/>
int main(){<br/>
     int n = 0 ;<br/>
     cout&lt;&lt;"begin"&lt;&lt;endl;<br/>
     CreateThread(NULL , 0 , ThreadProc , &amp;n , NULL , NULL ) ;<br/>
     cout&lt;&lt;"end"&lt;&lt;endl;<br/>
     __asm{<br/>
         mov v_esp , esp ;<br/>
     }<br/>
     wait(&amp;n) ;<br/>
     cout&lt;&lt;"terminated normally"&lt;&lt;endl;<br/>
     return 0 ;<br/>
}<br/><br/><font color="#ff6600">这个程序在release下也可以正常结束了。</font><br/><br/>
而当时的程序在release下就会不停地执行。<br/>
比较一下改动的地方，非常微妙：<br/><br/>
旧：<br/>
void wait(<font color="#ff0000">volatile</font> int *p){<br/><br/>
新：<br/>
void wait( int *<font color="#ff0000"> volatile</font> p){<br/><br/>
第一个volatile是和int结合的，表示指向的int是“<font color="#ff0000">易变的</font>”。<br/>
换言之，在最快速度优化下，会认为p本身是不变的。<br/>
于是每次从p指向的位置读出数据来判断是否为0。<br/>
而p指向的是什么，由于认为不变，可以直接保存在一个寄存器中。<br/><br/>
第二个volatile是和p结合的。意思就是这个指针变量是“<font color="#ff0000">易变的</font>”。<br/>
于是，即使在最快速度优化下，首先要先从放p变量的内存处取得p本身的值。<br/>
然后再从这个地址去读取数据。<br/><br/><font color="#0000ff">wait函数的汇编：</font><br/><br/>
旧：<br/>
00401030  mov      eax, dword ptr [esp+4]<br/>
00401034  cmp      dword ptr [eax], 0<br/>
00401037  jnz      short 0040103E<br/>
00401039  cmp      dword ptr [eax], 0<br/>
0040103C  je       short 00401039<br/>
0040103E  retn<br/><br/>
[esp+4]就是p的位置。很明显编译器把p放在了eax里面。<br/>
即假设了p本身的值在运行过程中不变。<br/><br/>
新：<br/>
00401030  mov      eax, dword ptr [esp+4]<br/>
00401034  mov      ecx, dword ptr [eax]<br/>
00401036  test     ecx, ecx<br/>
00401038  jnz      short 00401044<br/>
0040103A  mov      ecx, dword ptr [esp+4]<br/>
0040103E  mov      eax, dword ptr [ecx]<br/>
00401040  test     eax, eax<br/>
00401042  je       short 0040103A<br/>
00401044  retn<br/><br/>
这个代码就老实到家了，每次都从p处取得一个地址，<br/>
又从这个地址取得一个值，判断是否为0。<br/><br/>
