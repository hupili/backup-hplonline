---
layout: post
title: "贴个win32程序的最小框架（VC6)"
date: 2009-07-17  13:38
comments: true
categories: tech
tags: ["Vc"]
_baiduhi_id: 5b7afc03e4f3f77e3812bb16.html
_baiduhi_category: Vc
---

(hplonline)2009.7.17<br/><br/>
记得两年前，刚开始看孙鑫老师的书时，<br/>
对老师那熟练的打字佩服得五体投地。<br/><br/>
当时完全没法理解，<br/>
后来也在不同的时间又多少做过一些练习。<br/>
昨天突然想起准备玩下DX，<br/>
还是先做个应用程序的框架出来好用。<br/><br/>
没想到那么一拍就出来了。。<br/>
具体的过程居然也貌似可以正背如流了：<br/><br/><font color="#ff6600">设计窗口过程<br/><br/>
设计窗口类<br/>
注册窗口类<br/>
创建窗口<br/><br/>
消息循环</font><br/><br/>
还是卖油翁的那句话：但手熟尔。<br/>
老师其实也是如此。。<br/><br/>
倒是消息循环的设计有一点讲究，<br/>
如果要充分利用计算资源的话，<br/>
可以用PeekMessage。这个函数不会阻塞，<br/>
可以在没有消息处理的时候干点别的事情。<br/><br/>
不过也完全可以就用一般的GetMessage的框架，<br/>
反正要大量计算的时候再开个线程就是了。<br/><br/><font color="#0000ff">代码：</font><br/><br/>
#include &lt;stdio.h&gt;<br/>
#include &lt;windows.h&gt;<br/><br/>
//here:sample of message handling function<br/>
LRESULT OnKeyDown(WPARAM wParam , LPARAM lParam){<br/>
     if ( wParam == VK_ESCAPE ) PostQuitMessage(0) ;<br/>
     return 0 ;//An application should return zero if it processes this message<br/>
}<br/><br/>
LRESULT CALLBACK myWindowProc(<br/>
  HWND hwnd,       // handle to window<br/>
  UINT uMsg,       // message identifier<br/>
  WPARAM wParam,  // first message parameter<br/>
  LPARAM lParam    // second message parameter<br/>
  ){<br/>
     switch(uMsg){<br/>
     case WM_KEYDOWN : return OnKeyDown(wParam , lParam) ; break ;<br/>
          //here:add more message routing<br/>
     default:return DefWindowProc(hwnd , uMsg , wParam , lParam) ;     <br/>
     }<br/>
}<br/><br/>
BOOL myCreateWindow(HINSTANCE hInstance){<br/>
     //here:design your window<br/>
     WNDCLASS myCls ;<br/>
     myCls.cbClsExtra = NULL ;<br/>
     myCls.cbWndExtra = NULL ;<br/>
     myCls.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH) ;<br/>
     myCls.hCursor = LoadCursor(NULL , IDC_ARROW) ;<br/>
     myCls.hIcon = LoadIcon(NULL , IDI_APPLICATION) ;<br/>
     myCls.hInstance = hInstance ;<br/>
     myCls.lpfnWndProc = myWindowProc ;<br/>
     myCls.lpszClassName = "mywndclass" ;<br/>
     myCls.lpszMenuName = NULL ;<br/>
     myCls.style = CS_HREDRAW | CS_VREDRAW ;<br/><br/>
     RegisterClass(&amp;myCls) ;<br/><br/>
     int scrWidth = GetSystemMetrics(SM_CXSCREEN) ;<br/>
     int scrHeight = GetSystemMetrics(SM_CYSCREEN) ;<br/>
     const int wndWidth = 640 ;<br/>
     const int wndHeight = 480 ;<br/><br/>
     HWND hWnd = CreateWindow("mywndclass" , "my window(esc for quit)" , NULL , <br/>
          (scrWidth - wndWidth) / 2 , (scrHeight - wndHeight) / 2 , <br/>
          wndWidth , wndHeight , NULL , NULL , hInstance , NULL) ;<br/><br/>
     ShowWindow(hWnd , SW_SHOW) ;<br/><br/>
     return TRUE ;<br/>
}<br/><br/>
int WINAPI WinMain(<br/>
  HINSTANCE hInstance,  // handle to current instance<br/>
  HINSTANCE hPrevInstance,  // handle to previous instance<br/>
  LPSTR lpCmdLine,       // pointer to command line<br/>
  int nCmdShow           // show state of window<br/>
  ){<br/>
     MSG msg ;<br/>
     <br/>
     myCreateWindow(hInstance) ;<br/>
     <br/>
     while ( GetMessage(&amp;msg , NULL , NULL , NULL) ){<br/>
          TranslateMessage(&amp;msg) ;<br/>
          DispatchMessage(&amp;msg) ;<br/>
     }<br/><br/>
     return msg.wParam ;<br/>
}<br/><br/>
