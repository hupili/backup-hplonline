---
layout: post
title: "scanf的三点不常见但很实用的方法（忽略变量，扫描字符，读入字符个数）"
date: 2009-07-19  01:10
comments: true
categories: tech
tags: ["c","c++"]
_baiduhi_id: 2c875ffb70e6201f6c22eb75.html
_baiduhi_category: c&c++
---

(hplonline)2009.7.19<br/><br/>
一直学得很囫囵吞枣，<br/>
拿到问题的时候，总是很暴力地用已有的知识去解决，<br/>
很少去了解一些新的东西。<br/><br/>
而往往的经验是，<font color="#ff0000">终日而思，不如须臾之所学</font>。<br/><br/>
下面的内容都有相关的实例支撑，<br/>
不使用这些手段也可以解决，<br/>
但是可能稍微费事一点。<br/><font color="#0000ff"><br/></font><font color="#0000ff">一。忽略变量(%*?)</font><br/><br/>
这个还算容易见到一点：<br/><font color="#ff6600"><br/>
      int i ;<br/>
      scanf("%*d %d" , &amp;i) ;<br/>
      printf("%d" , i) ;</font><br/><br/>
输入：<br/>
1 2<br/>
输出：<br/>
2<br/><br/>
不用他当然也可以，定义一个废的变量，<br/>
在实参的地方占个位置，往里面读就行了。<br/><br/>
但是用*的好处在于，减少传参。<br/><br/><font color="#0000ff">二。扫描字符(%[^?])</font><br/><br/>
这个问题比较实际，如果要读入形如下面的数据：<br/>
(123)  (456)<br/>
要的是括号里面的东西，但是不含括号。也就是123和456。<br/><br/>
如果确定了里面都是是数字，当然很好写：<br/><font color="#ff6600"><br/>
      int i1 , i2 ;<br/>
      scanf("(%d) (%d)" , &amp;i1 , &amp;i2) ;<br/>
      printf("%d %d" , i1 , i2) ;</font><br/><br/>
如果告诉你要读入的是串字符呢：<br/>
(aaa) (bbb)<br/><br/>
难道是这样？<br/>
scanf("(%s) (%s)" , s1 , s2) ;<br/><br/>
显然不行。%s会一直读到空格符。<br/><br/>
解决方法：<br/><br/><font color="#ff6600">      char s1[100] , s2[100] ;<br/>
      scanf("(%[^)]) (%[^)])" , s1 , s2 ) ;<br/>
      puts(s1) ;<br/>
      puts(s2) ;<br/></font><br/>
在[^...]里面指定字符串的截止符。<br/><br/>
输入：<br/>
(aaa) (bbb)<br/><br/>
输出：<br/>
aaa<br/>
bbb<br/><br/>
看来是达到效果了。<br/><br/><font color="#0000ff">三。读入字符个数(%n)</font><br/><br/>
这个问题也比较实在。<br/>
比如，有这样一个题。<br/><br/>
给一组整数，每行有多少个无法确定。<br/>
要求给出每行的和。<br/>
数据以end结束。<br/><br/>
比如：<br/><br/>
1 2 3 <br/>
4 5<br/>
6 7 8 9 10<br/>
11 <br/>
end<br/><br/>
题目的意思是相当直观的，<br/>
主要的问题就在于编码上面。<br/><br/>
不妨先动手试做一个，然后看看下面这段：<br/><br/><font color="#ff6600">int main(){<br/>
      char tmp[100] ;<br/>
      int sum , n , base , t;<br/>
      while ( gets(tmp) ){<br/>
            if ( strcmp(tmp , "end") == 0 ) break ;<br/>
            sum = 0 ;<br/>
            base = 0 ;<br/>
            while ( sscanf(tmp + base, "%d%n" , &amp;t , &amp;n) == 1 ){<br/>
                  base += n ;<br/>
                  sum += t ;<br/>
            } <br/>
            printf("%d\n" , sum) ;<br/>
      }<br/>
      return 0 ;<br/>
}</font><br/><br/>
控制台情况：（输入输出均在内）<br/><br/>
1 2 3<br/>
6<br/>
4 5<br/>
9<br/>
6 7 8 9 10<br/>
40<br/>
11<br/>
11<br/>
end<br/>
Press any key to continue<br/><br/>
首先，每一行打头的要么是个整数要么是“end”。<br/>
这就与一般ACM那些以-1结尾的不同了。<br/><br/>
为了检验，只有先按照字符串全部读入。<br/>
就是外层循环的gets。<br/><br/>
之后做个比较，是很普通的一件事。<br/>
如果是end那么退出。<br/><br/>
关键就在于，如果不是end。而一行的数字有多少个没法确定。<br/>
每个数字有多少个位数也不好确定。<br/><br/>
这里，既然数据都到了一个tmp的字符数组里面，<br/>
当然要用sscanf来搞定后面的操作了。<br/><br/>
读入了前面的字符后，通过对tmp加上一定的偏移，<br/>
就可以实现继续读后面的数字，<br/>
而sscanf返回成功读入的变量的个数，<br/>
通过这个可以判断是否读完了。<br/><br/>
最后的问题就在于，怎么得到偏移了多少。<br/>
这时%n就帮上忙了，通过他，可以得知已经读过了多少字符。<br/><br/>
另外，printf的返回值就是打印的字符数，<br/>
有的时候，在向一个缓冲区输出的时，可以直接用他的返回值来偏移。<br/>
而scanf的返回值是成功读入的变量数，<br/>
于是只有把%n利用起来。<br/><br/><font color="#0000ff">总结：</font><br/><br/>
这些内容当然可以用其他的办法解决。<br/>
第一个的已经说了。<br/>
至于后两个，可以用getchar，边读边判断。<br/>
这一定是可行的，因为给你getchar，你可以做出scanf等等。。。<br/><br/>
但有的时候，只要充分了解一点现有的东西，<br/>
就可以少费很多事。<br/>
