---
layout: post
title: "把qq聊天记录转化成比较容易操作的格式"
date: 2009-07-20  22:36
comments: true
categories: tech
tags: ["c","c++"]
_baiduhi_id: c4d3bc00d985528ee850cd0e.html
_baiduhi_category: c&c++
---

(hplonline)2009.7.20<br/><br/><font color="#0000ff">起因：</font><br/><br/>
有个群的管理员提出要踢人的需求。<br/>
那么踢谁留谁总得找点数据说话。<br/>
把qq2009翻了一遍，找到的唯一可以看的信息是，<br/>
某个人最后发言的时间。<br/><br/>
在普通活跃度的群当然，<br/>
凭个最后发言时间，或者发言条数，<br/>
都可以大致觉得这个人的参与程度。<br/><br/>
对于特别活跃的群，就不好说了。<br/>
可能大家都经常发言。<br/>
但是有的人往往是“啊”“哦”“嗯”，<br/>
或者是些乱七八糟的表情。<br/>
另外一些人可能很认真，<br/>
说得虽少，但每次都很有信息量。<br/>
这显然是要区别对待的。<br/><br/>
至于怎么给出这个所谓“参与程度”的标准，<br/>
那是后话了，<br/>
现在首先要解决的就是先把聊天记录整理出来，<br/>
便于实现任何需求的统计。<br/><br/><font color="#0000ff">分析：</font><br/><br/>
qq2009目前支持导出为三种格式：<br/><br/>
.bak，据说是加密的，除了导回之外，没办法提取里面的信息<br/>
（当然，高手来破解除外，即使破解了还要去迁就他的数据编排方式，麻烦）<br/><br/>
.mht，信息是完全保留了的，图片颜色具备<br/>
但是操作起来又麻烦，熟悉mht的格式倒是不很难，<br/>
况且有很多已经做好的库可以使用。<br/>
问题在于整理里面的信息，毕竟含量实在是太丰富了。<br/><br/>
.txt，很直观，编排大致上是有规律的，操作起来比较简单，<br/>
可以依赖现有知识解决，不用去学新的东西。<br/><br/>
所以这里就导出为.txt，然后对这个文件进行操作。<br/><br/><font color="#0000ff">格式上的问题：</font><br/><br/>
导出一个群的记录，<br/>
开头部分基本上是这样的：<br/><br/>
消息记录<br/><br/>
================================================================<br/>
消息分组:群列表<br/>
================================================================<br/>
消息对象:Hello qsh！<br/>
================================================================<br/><br/>
毕竟跟我们后面的消息条目没啥关系，<br/><font color="#ff6600">于是直接手动删掉。</font><br/>
（<font color="#ff0000">用后面给出的程序来提取的话，<br/>
最好是从消息开始的地方，手动复制到结尾，<br/>
重新存个文件。。。我也不知道为什么，<br/>
在原导出的文件上删掉前面的内容，<br/>
虽然视觉一样，读出的东西却有问题。。。。</font>）<br/><br/>
再观察每条消息的格式。<br/><br/>
发现聊天时的回车都被去掉了，自成一行。<br/>
所以大致是下面的样子：<br/><font color="#ff6600"><br/>
2009/1/20 21:00:38 [昵称[&lt;邮箱&gt;]][(qq号)]<br/>
消息<br/><br/>
2009/1/20 21:01:13 [昵称[&lt;邮箱&gt;]][(qq号)]<br/>
消息<br/></font><br/>
装怪就怪在。。有的地方只有qq号，有的地方只有昵称。<br/>
当然有的地方两个都有，还有地方都没有。。。。<br/>
而有昵称的地方，有的有绑定邮箱，有的没有。。。<br/><br/>
当然，这些并不是一开始就观察完全的。。<br/>
所以反复写了好久，RE过多次。<br/><br/>
然后就是结构设计上的问题。<br/>
由于昵称和qq号的不完备性，<br/>
只有额外引入一个本记录中的ID号，作为主键<br/>
用来标识一个用户。<br/><br/>
通过这个ID，来关联一个用户类型的结构体，<br/>
里面存放qq号，昵称，和以后可以添加的各种统计信息。<br/><br/>
另外一个关联类型，就是消息结构。<br/>
其中ID作为外键，另外记录时间和内容。<br/><br/>
最初统计的时候，分别用map来关联昵称或qq号 对应的ID。<br/>
由于之后要求按照ID对用户类型做操作，所以用vector来存放。<br/>
至于消息类型，统计的时候显然是顺次操作，<br/>
读入也是顺次的，于是就直接放list了。<br/><br/><font color="#0000ff">没意思的代码：</font><br/><br/>
下面的代码只对发言条数做过统计，<br/>
仅仅是用来验证读取模块是否正确。<br/>
在这个基础上，可以方便地加入其他的统计，获取感兴趣的方面。<br/><br/>
后来看到其他人用perl和python写的。。。。那真是一个短啊。。囧。。<br/>
于是有时间还是得学一学了，要不显得太土鳖了。。<br/>
不过定位不一样，仅仅做上面提到的按发言排序，就很简洁。<br/>
要多加点其他的东西还是挺费力的。<br/><br/>
#pragma warning(disable:4786) <br/><br/>
#include &lt;iostream&gt;<br/>
#include &lt;stdio.h&gt;<br/>
#include &lt;list&gt;<br/>
#include &lt;map&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;vector&gt;<br/>
#include &lt;algorithm&gt;<br/><br/>
using namespace std ; <br/><br/>
const int MAX_MSG_LENGTH = 10000 ;<br/><br/>
typedef int ID ;<br/><br/>
typedef struct time_type{<br/>
     short year ;<br/>
     char month ;<br/>
     char day ;<br/>
     char hour ;<br/>
     char minute ;<br/>
     char second ;<br/>
}TIME ;<br/><br/>
typedef struct message_type{<br/>
     ID identifier ;<br/>
     TIME time;<br/>
     string content ;<br/>
}MESSAGE ;<br/><br/>
typedef struct user_type{<br/>
     string name ;<br/>
     string num ;<br/>
     int cnt_msg ;<br/>
}USER ;<br/><br/>
class qqmsg{<br/>
public:<br/>
     map&lt;string , int&gt; map_name2id ;<br/>
     map&lt;string , int&gt; map_num2id ;<br/>
     list&lt;MESSAGE&gt; list_msg ;<br/>
     vector&lt;USER&gt; vector_user ;<br/>
     void init() ;<br/>
     ID qqmsg::getid(char *str) ;<br/>
     bool read(char *filename) ;<br/>
     void statistics() ;<br/>
     void output() ;<br/>
} ;<br/><br/>
void qqmsg::init(){<br/>
     map_name2id.clear() ;<br/>
     map_num2id.clear() ;<br/>
     list_msg.clear() ;<br/>
     vector_user.clear() ;<br/>
}<br/><br/>
//标准化名称：<br/>
//name&lt;email@email.com&gt;<br/>
//name<br/>
//所以去掉含有&lt;&gt;的部分<br/>
void std_name(char *s){<br/>
     char *p = strstr(s , "&lt;") ;<br/>
     if ( p != NULL ) {<br/>
          if ( strstr(p , "&gt;")){<br/>
               *p = '\0' ;<br/>
          }<br/>
     }<br/>
}<br/><br/>
ID qqmsg::getid(char *str){<br/>
     char name[50] , blankspace , num[50] ;     <br/>
     USER tmp ;<br/>
     tmp.name = "" ;<br/>
     tmp.num = "" ;<br/>
     int ret = sscanf(str , "%[^(\012](%[^)])" , &amp;name[-1] , num) ; //前面的一个空格读掉name[-1]<br/>
     std_name(name) ;<br/>
     if ( ret == 0 ) {<br/>
          //发生错误,什么都没有？<br/>
          return -1 ;<br/>
     }<br/>
     if ( ret == 2 ){<br/>
          tmp.name = name ;<br/>
          tmp.num = num ; <br/>
          if ( name[0] == '\0' ) {<br/>
               //只有qq号<br/>
               if ( map_num2id.count(tmp.num) ){<br/>
                    return map_num2id[tmp.num] ;     <br/>
               }else{<br/>
                    map_num2id[tmp.num] = vector_user.size() ;<br/>
                    vector_user.push_back(tmp) ;<br/>
                    return vector_user.size() ;<br/>
               }<br/><br/>
          }else{<br/>
               //qq号和昵称都有<br/>
               if ( map_num2id.count(tmp.num)){<br/>
                    int i = map_num2id[tmp.num] ;<br/>
                    map_name2id[tmp.name] = i ;<br/>
                    vector_user[i].name = tmp.name ;<br/>
                    return i ;<br/>
               }<br/>
               if ( map_name2id.count(tmp.name)){<br/>
                    int i = map_name2id[tmp.name] ;<br/>
                    map_num2id[tmp.num] = i ;<br/>
                    vector_user[i].num = tmp.num ;<br/>
                    return i ;<br/>
               }<br/>
               map_num2id[tmp.num] = vector_user.size() ;<br/>
               map_name2id[tmp.name] = vector_user.size() ;<br/>
               vector_user.push_back(tmp) ;<br/>
               return vector_user.size() - 1 ;<br/>
          }<br/>
     }else{<br/>
          //只有昵称<br/>
          tmp.name = name ;<br/>
          if ( map_name2id.count(tmp.name) ){<br/>
               return map_name2id[tmp.name] ;     <br/>
          }else{<br/>
               map_name2id[tmp.name] = vector_user.size() ;<br/>
               vector_user.push_back(tmp) ;<br/>
               return vector_user.size() ;<br/>
          }<br/>
     }<br/>
}<br/><br/>
bool qqmsg::read(char *filename){<br/>
     FILE *fp = fopen(filename , "r") ;<br/>
     if ( fp == NULL ) return false ;<br/>
     <br/>
     char *buffer = new char[MAX_MSG_LENGTH] ;<br/>
     int n ;<br/><br/>
     MESSAGE tmp ;<br/>
     try{<br/>
          while ( 1 ){<br/>
               bool over = false ;<br/>
               while ( 1 ){<br/>
                    if ( !fgets(buffer , MAX_MSG_LENGTH , fp) ){<br/>
                         //读到文件的尾部了<br/>
                         over = true ;<br/>
                         break ;<br/>
                    }<br/>
                    //尝试按照消息头来读取，如果不正常，则忽略掉后面的内容，<br/>
                    //继续把下一行按照消息头来解析<br/>
                    if ( buffer[0] != '\012' ) {<br/>
                         int ret = sscanf(buffer , "%d/%d/%d %d:%d:%d%n" ,<br/>
                              &amp;tmp.time.year , &amp;tmp.time.month , &amp;tmp.time.day ,<br/>
                              &amp;tmp.time.hour , &amp;tmp.time.minute , &amp;tmp.time.second , &amp;n) ;          <br/>
                         if ( ret == 6 ) break ;<br/>
                    }               <br/>
               }<br/>
               if ( over ) break ;     <br/><br/>
               tmp.identifier = getid(buffer + n) ;<br/><br/>
               fgets(buffer , MAX_MSG_LENGTH , fp) ;<br/>
               tmp.content = buffer ;<br/>
               list_msg.push_back(tmp); <br/>
          }<br/>
     }catch(...){<br/>
          puts(buffer) ;<br/>
     }<br/><br/>
     delete buffer ;<br/>
     fclose(fp) ;<br/>
     return true ;<br/>
}<br/><br/>
void qqmsg::statistics(){<br/>
     vector&lt;USER&gt;::iterator vit ;<br/>
     for ( vit = vector_user.begin() ; vit != vector_user.end() ; vit ++ ){<br/>
          (*vit).cnt_msg = 0 ;<br/>
     }     <br/><br/>
     list&lt;MESSAGE&gt;::iterator lit ;<br/>
     for ( lit = list_msg.begin() ; lit != list_msg.end() ; lit ++ ){<br/>
          vector_user[(*lit).identifier].cnt_msg ++ ;<br/>
     }<br/>
}<br/><br/>
bool operator&lt;(const USER &amp;u1 , const USER &amp;u2){<br/>
     return u1.cnt_msg &gt; u2.cnt_msg ;<br/>
}<br/><br/>
void qqmsg::output(){<br/>
     vector&lt;USER&gt;::iterator it ;<br/>
     sort(vector_user.begin() , vector_user.end()) ;<br/>
     for ( it = vector_user.begin() ; it != vector_user.end() ; it ++ ){<br/>
          printf("%40s %10s %d\n" , (*it).name.c_str() , (*it).num.c_str() , (*it).cnt_msg ) ;<br/>
     }<br/>
}<br/><br/>
int main(){<br/>
     qqmsg msg ;<br/>
     msg.init() ;<br/>
     msg.read("3.txt") ;<br/>
     msg.statistics() ;<br/>
     msg.output() ;<br/>
     return 0 ;<br/>
}
