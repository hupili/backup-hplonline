---
layout: post
title: "次小生成树（VIJOS1070,POJ1679)"
date: 2009-08-14  19:46
comments: true
categories: tech
tags: ["算法"]
_baiduhi_id: 56fab312cc7677c7c2fd7819.html
_baiduhi_category: 算法
---

(hplonline)2009.8.14<br/><br/>
结论：<br/><font color="#ff9900">替换最小生成树中的任何一条边，将使总代价变大</font><br/><br/>
根据<font color="#ff0000">路径最优条件</font>，（<a href="http://hi.baidu.com/hplonline/blog/item/8d68db58eb0e1d89810a18c7.html" target="_blank">参考这里</a>）<br/>
MST上的任两点(i,j)的树上路径的所有边的权重，<br/>
均小于w[i][j]。所以结论显然。<br/><br/><font color="#0000ff">次小生成树1，简单解法：</font><br/><br/>
有个比较直观的方法。<br/>
依次把MST上的边删掉，然后再做MST。<br/>
这样的做就是编码简洁，有模块可以重用。<br/>
效率O(n*O(MST))<br/><br/><font color="#0000ff">次小生成树2，优化解法：</font><br/><br/>
既然每替换出去一条边，都将使代价变大。<br/>
所以求次小生成树，只需要替换出去一条边即可。<br/><br/>
枚举不在树上的边eij，<br/>
树上路径上的边权都不大于w[i][j]。<br/>
选取其中最大的与eij替换，<br/>
得到新树的权重。<br/>
选取替换后最小的一个就是次小生成树了。<br/>
这个过程可以做到O(m)<br/><br/>
然后就是计算出path_max[i][j]表示i，j树上路径中的最大边权。<br/>
在计算MST的时候，点是依次加入到树中。<br/>
当前加入的是j，与他相连的是i。<br/>
那么，对所有在树上集合中的k：<br/>
path_max[k][j] = max{ path_max[k][i] , w[i][j] }<br/>
因为path_max[][]的每个元素都要计算，且仅一次。<br/>
累加起来的复杂度是O(n^2)<br/><br/>
总的复杂度：<br/>
O(MST)+O(n^2)+O(m)<br/><br/>
MST的计算采用任何一种方法都可以。<br/><br/><font color="#0000ff">VIJOS1070：</font><br/><br/>
题目就是很明摆着的次小生成树了。<br/>
关于无解的输出是：<br/>
1.首先如果MST都无解，那么显然也不存在次小<br/>
（判断依据为：有没有成功加进n-1条边）<br/>
2.MST有解的情况下，如果m == n-1，<br/>
那么不存在次小生成树，否则一定存在。<br/>
（至少都可以进行一次替换）<br/><br/>
关于这道题的WA。<br/>
首先是把：<br/>
ans_mst - path_max[i][j] + map[i][j]<br/>
写成了：<br/>
ans_mst + path_max[i][j] - map[i][j]<br/><br/>
。。。<br/><br/>
然后是求次小的时候，判断边：<br/>
if ( !edge_in[i][j] &amp;&amp; map[i][j] != MAXINT ){<br/><br/>
最初写的是<br/><br/>
if ( edge_in[i][j]) 。。。。<br/><br/>
注意是枚举不在树中的边，然后要记得判断是不是这个边不存在。<br/>
由于我这里是用MAXINT来表达的边不存在，<br/>
当不存在的时候，下面的加法中会溢出成负数，反而更小。。<br/><font color="#0000ff"><br/>
VIJOS1070代码：</font><br/><br/>
#include &lt;stdio.h&gt;<br/><br/>
const int MAXN = 510 ;<br/>
const int MAXM = MAXN * MAXN ;<br/>
const int MAXINT = 2147483647 ;<br/><br/>
int path_max[MAXN][MAXN] ; //树上路径的最大值<br/>
int d[MAXN] , pre[MAXN] ; //最短边长，前驱点<br/>
int in[MAXN] , num_in ;<br/>
bool isin[MAXN] ;//顶点是否在树内<br/>
bool edge_in[MAXN][MAXN] ;//边是否在树内 <br/><br/>
int map[MAXN][MAXN] ;<br/>
int n , m ;<br/>
int ans_mst ;<br/><br/>
int getmin(int a , int b){<br/>
return a &lt; b ? a : b ;<br/>
}<br/><br/>
int getmax(int a , int b){<br/>
return a &gt; b ? a : b ;<br/>
}<br/><br/>
//最小<br/>
int mst1(){<br/>
int i , j ;<br/>
int min , min_j ;<br/>
int ans = 0 ;<br/>
num_in = 1 ;<br/>
in[0] = 1 ;<br/>
isin[1] = true ;<br/>
d[1] = 0 ;<br/>
for ( i = 2 ; i &lt;= n ; i ++ ){<br/>
d[i] = map[1][i] ;<br/>
pre[i] = 1 ;<br/>
}<br/>
for ( i = 1 ; i &lt; n ; i ++ ){<br/>
min = MAXINT ;<br/>
for ( j = 1 ; j &lt;= n ; j ++ ){<br/>
if ( !isin[j] &amp;&amp; d[j] &lt; min ) {<br/>
min = d[j] ;<br/>
min_j = j ;<br/>
}<br/>
}<br/>
if ( min == MAXINT ) return -1 ;//无法形成树<br/><br/>
//更新树上路径表<br/>
for ( j = 0 ; j &lt; num_in ; j ++ ){<br/>
if ( in[j] != pre[min_j] ) <br/>
path_max[min_j][in[j]] = getmax(path_max[pre[min_j]][in[j]] , map[min_j][pre[min_j]] );<br/>
else <br/>
path_max[min_j][in[j]] = map[min_j][pre[min_j]] ;<br/>
path_max[in[j]][min_j] = path_max[min_j][in[j]] ;<br/>
}<br/><br/>
in[num_in] = min_j ;<br/>
num_in ++ ;<br/>
ans += min ;<br/>
isin[min_j] = true ;<br/>
edge_in[min_j][pre[min_j]] = true ;<br/>
edge_in[pre[min_j]][min_j] = true ;<br/><br/>
//更新最短边记录<br/>
for ( j = 1 ; j &lt;= n ; j ++ ){<br/>
if ( !isin[j] &amp;&amp; map[min_j][j] &lt; d[j] ) {<br/>
d[j] = map[min_j][j] ;<br/>
pre[j] = min_j ;<br/>
}<br/>
}<br/><br/>
}<br/>
ans_mst = ans ;<br/>
return ans ;<br/>
}<br/><br/>
//次小<br/>
int mst2(){<br/>
int ans = MAXINT ;<br/>
int i , j ;<br/>
if ( m == n - 1 ) return -1 ;<br/>
for ( i = 1 ; i &lt;= n - 1 ; i ++ ){<br/>
for ( j = i + 1 ; j &lt;= n ; j ++ ){<br/>
if ( !edge_in[i][j] &amp;&amp; map[i][j] != MAXINT ){<br/>
ans = getmin(ans_mst - path_max[i][j] + map[i][j] , ans) ;<br/>
}<br/>
}<br/>
}<br/>
return ans ;<br/>
}<br/><br/>
int main(){<br/><br/>
int i , j ;<br/>
int x , y , c ;<br/>
scanf("%d%d" , &amp;n , &amp;m) ;<br/>
for ( i = 1 ; i &lt;= n ; i ++ ){<br/>
for ( j = 1 ; j &lt;= n ; j ++ ){<br/>
map[i][j] = MAXINT ;<br/>
}<br/>
}<br/>
for ( i = 0 ; i &lt; m ; i ++ ){<br/>
scanf("%d%d%d" , &amp;x , &amp;y , &amp;c) ;<br/>
map[x][y] = c ;<br/>
map[y][x] = c ;<br/>
}<br/>
int ret = mst1() ;<br/>
printf("Cost: %d\n" , ret) ;<br/>
if ( ret == -1 ) printf("-1\n") ;<br/>
else printf("Cost: %d\n" , mst2()) ;<br/><br/>
return 0 ;<br/>
}<br/><br/><font color="#0000ff">POJ1679：</font><br/><br/>
问的是MST是否唯一。<br/>
那么求出最小生成树和次小生成树，<br/>
如果权重相等，当然就是不唯一的。<br/><br/>
只不过这个想法太直观了，<br/>
干了不少多余的事情。<br/>
直接在MST的计算过程中，就可以判断出来了。<br/><br/>
拿PRIM来说：<br/><br/>
每次添加点的时候，要找出关联边最小的。<br/>
如果这个最小值不唯一，那么就可以直接指出MST不唯一了。<br/><br/>
拿KRUSCAL来说：<br/><br/>
由于边已经按权值排序了，<br/>
那么添加一个边的时候，<br/>
把和他权值相同的边都试添加一次，<br/>
如果有多余一条边可以添加进，也指出不唯一。
