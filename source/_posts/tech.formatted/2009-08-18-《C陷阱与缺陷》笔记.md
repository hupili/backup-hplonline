---
layout: post
title: "《C陷阱与缺陷》笔记"
date: 2009-08-18  19:50
comments: true
categories: tech
tags: ["c","c++"]
_baiduhi_id: d224c9fd0705524cd6887d9e.html
_baiduhi_category: c&c++
---

<p>(hplonline)2009.8.18</p>
<p>书就是<a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/80c99ddd3ebc113d5882dd88.html">这本</a>。</p>
<p><br/><font color="#0000ff">1.关于字符常量的处理</font></p>
<p>P12下方的译注关于VC6的说明是错误的。<br/>
只用一个程序就说明问题：</p>
<p>#include &lt;stdio.h&gt;</p>
<p>int main(){<br/>
     printf("%x%x%x\n" , 'y' , 'e' , 's') ;<br/>
     printf("%x\n" , 'yes') ;<br/>
     return 0 ;<br/>
}</p>
<p>结果：<br/>
796573<br/>
796573</p>
<p>有的时候，译的过程中注一下，<br/>
有助于读者理解一些不熟悉的内容，<br/>
但是不能乱注。</p>
<p><font color="#0000ff">2.ex1-2</font></p>
<p>注释嵌套，个人认为那是相当有必要啊。<br/>
方便写程序，方便调试。<br/>
有时候需要暂时注释掉一段内含注释的代码。</p>
<p><font color="#0000ff">3.时代特征是很有趣的。。</font></p>
<p>比如ex2-2让举例其他语言的语句分割方式。<br/>
我只能想到PASCAL，VB,MATLAB。<br/>
作者的例子是FORTRAN , SNOBOL等。。。</p>
<p><font color="#0000ff">4.数组方面</font></p>
<p>对数组名可以使用&amp;运算。<br/>
     int a[4] ;<br/>
     printf("%x\n%x\n" , a , &amp;a) ;</p>
<p>a[i]和i[a]的等同性。<br/>
使用MASM做过程序就知道，<br/>
赋予i[a]等同的功能是有意义的。</p>
<p><font color="#0000ff">5.函数声明和实现体的关系</font></p>
<p>虽然专门问来知道，但平时却想不起。<br/>
见这个例子：</p>
<p>int* (*malloc)(int x) ;<br/>
int main(){<br/>
     int *p = malloc(4) ;<br/>
     return 0 ;<br/>
}</p>
<p>之前也不用包含stdlib.h。<br/>
这个程序可以正常编译，<br/>
并且不用像往常那样给malloc返回的指针做强制转换。</p>
<p>有的时候，不用机械地包含一大堆东西。<br/>
可以选择性声明，能编译就行。<br/>
而链接的时候，linker并不关心是int *还是char*，<br/>
反正都是一个4字节的值而已。</p>
<p><font color="#0000ff">6.对字符常量修改的限制</font></p>
<p>这个运行正常：<br/>
     char s[] = "123" ;<br/>
     s[0] = 0 ;</p>
<p>这个运行要挂掉：<br/>
     char *s = "123" ;<br/>
     s[0] = 0 ;</p>
<p><font color="#0000ff">7.关于数组越界的检查</font></p>
<p>个人认为在实现上是臃肿而且没有必要的。<br/>
比如：<br/>
int a[10] ;<br/>
a[10] = 1 ;</p>
<p>这样的常量下标可能被检查出来越界。<br/>
但是a[i] = 1 ;呢？？</p>
<p>这在编译阶段完全是没法确定的。<br/>
所以，只有在编译的时候加上相关的条件判断：<br/>
if ( i &lt; 0 || i &gt;= 10 ) {<br/>
     error("???") ;<br/>
}else{<br/>
     a[i] = 1 ;<br/>
}<br/>
这样就是十分的臃肿了。<br/>
况且这是运行时检查，也不是编译期能完成的。</p>
<p>也许是个人知识的不足，<br/>
也希望见识一下有实现的编译器是怎么干的。</p>
<p><font color="#0000ff">8.static的声明</font></p>
<p>在很多时候，最好给函数和外部变量带上。<br/>
这样可以在连接的时候减少外部对象列表，<br/>
也可以很好地避免名称上的冲突。</p>
<p><font color="#0000ff">9.ANSI C允许不声明就调用。。</font></p>
<p>而且函数声明的时候也只用指定返回值即可。。<br/>
如果不指定，就是默认的int型。</p>
<p>这种设计其实也是有道理的。<br/>
在处理变参数个数的变量的时候，<br/>
参数的出入栈都由调用者来控制。<br/>
双方能共同关心的问题仅仅有:<br/>
函数的地址，函数的返回值。</p>
<p><font color="#0000ff">10.函数调用时的自动转换标准</font></p>
<p>float会自动转为double。<br/>
short和char会自动转为int。</p>
<p>这个也就又应证了一下为什么printf<br/>
的格式字符串只有%f来处理float和double两种。</p>
<p>之前关于这点的<a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/c0e3b9de2e24355fcdbf1afc.html">实验和笔记</a>。</p>
<p><font color="#0000ff">11.函数头部的表征意义：</font></p>
<p>int f(c)<br/>
char c ;<br/>
{<br/>
...<br/>
}</p>
<p>相当于：</p>
<p>int f(int i){<br/>
char c = i ;<br/>
...<br/>
}</p>
<p>这个规定在硬件实现上也是有对应的。<br/>
比如IA-32下，push进去的操作数都是32位的，<br/>
正好符合一个int型的空间。<br/>
然后使用变长前缀可以兼容处理16位的操作数。</p>
<p><font color="#0000ff">12.关于getchar的截断处理</font></p>
<p>在VC6下，EOF=-1.<br/>
也就是每个位都是1。<br/>
所以可以截断成任意的长度，<br/>
按照补码翻译过来还是-1，不改变意义。</p>
<p><font color="#0000ff">13.关于fseek的必要性</font></p>
<p>如下程序段：</p>
<p>#include &lt;stdio.h&gt;</p>
<p>int main(){<br/>
     FILE *fp = fopen("file.dat" , "rb+") ;<br/>
     int i = 1 ;</p>
<p>     fread(&amp;i , sizeof(int) , 1 , fp) ;<br/>
     printf("%d\n" , i) ;<br/>
     printf("%d\n" , fseek(fp , (long)(-1*sizeof(int)) , SEEK_CUR)) ;<br/>
     i ++ ;<br/>
     printf("%d\n" , fwrite(&amp;i , sizeof(int) , 1 , fp)) ;</p>
<p>     fread(&amp;i , sizeof(int) , 1 , fp) ;<br/>
     printf("%d\n" , i) ;<br/>
     printf("%d\n" , fseek(fp , (long)(-1*sizeof(int)) , SEEK_CUR)) ;<br/>
     i ++ ;<br/>
     printf("%d\n" , fwrite(&amp;i , sizeof(int) , 1 , fp)) ;<br/>
     <br/>
     fclose(fp) ;<br/>
     return 0 ;<br/>
}</p>
<p>可以正常执行，而在中间的fwrite，<br/>
和fread之间没有fseek(fp , 0 , SEEK_SET) 这一语句。</p>
<p>说明书中所讲为历史问题。测试环境：VISTA+VC6。</p>
<p><font color="#0000ff">14.关于signal</font></p>
<p>在处理过程中有可能继续产生信号。<br/>
所以处理函数唯一安全的做法就是打印出错信息，然后退出程序。<br/>
或者可以设置某些标志，<br/>
让主程序在某个时候检查到这些标志。</p>
<p><font color="#0000ff">15.包含stdio.h的重要性</font></p>
<p>见P91,ex5-2。</p>
<p>由于该头文件中有getchar的宏定义，<br/>
使得该“函数”的执行会更快。</p>
<p>如果不包含这个头文件，<br/>
编译器只有把getchar当作返回整形的函数，<br/>
然后期待连接器来指出该函数的地址。</p>
<p>而进出函数的开销比较大，<br/>
可能导致效率变低。</p>
<p><font color="#0000ff">16.关于使用宏</font></p>
<p>需要格外注意的是多次求值的问题。<br/>
所以传给宏的参数一定要是non-mutable的。<br/>
即不能是i++这样的在计算表达式的同时改变i的值。</p>
<p><font color="#0000ff">17.宏不是语句</font></p>
<p>P99，chap6.3详细解释了这个问题。<br/>
分析的是assert宏，<br/>
阐释了由||的短路求值来代替if结构的必要性。<br/>
对于自己设计的宏内有条件判断时，<br/>
很有借鉴意义。</p>
<p><font color="#0000ff">18.类型转换</font><br/>
char c<br/>
在做(unsigned)c时。<br/>
按照标准是先转换成int，然后转换成unsigned int。<br/>
所以，可能由于符号扩展的原因，导致不是期望的结果。</p>
<p>有的时候，我们期望的是在多余的位上补零。<br/>
正确的做法是(unsigned int)(unsigned char)c。</p>
<p>而如果c本来就是unsigned char型的，则可以直接到unsigned int。<br/>
下面的代码来验证这个事情：</p>
<p>     char c = (char)0xfe ;<br/>
     unsigned char cc = (unsigned char)0xfe ;</p>
<p>     printf("%x\n" , (unsigned)c) ;<br/>
     printf("%x\n" , (unsigned)(unsigned char)c) ;<br/>
     <br/>
     printf("%x\n" , (unsigned)cc) ;<br/>
     printf("%x\n" , (unsigned)(unsigned char)cc) ;</p>
<p><font color="#0000ff">19.解决字符集不连续的问题</font></p>
<p>P117的。"0123456789"[n % 10] <br/>
这个用法相当巧妙啊。</p>
<p><font color="#0000ff">20.符号数的绝对值转为无符号的</font></p>
<p>比如：<br/>
int n = -1 ;<br/>
unsigned int m = -n ;</p>
<p>作者提到了补码表示中绝对值最大负数，<br/>
在转换成正数的时候会溢出。<br/>
但实际上，可以不用担心。<br/>
因为补码的负数能表示的范围比正数仅多1。</p>
<p>比如下面的程序段：<br/>
     int i ;<br/>
     unsigned u ;<br/>
     i = -2147483648 ;<br/>
     printf("%d\n" , -i) ;<br/>
     u = -i ;<br/>
     printf("%u\n" , u) ;<br/>
     printf("%u\n" , i) ;</p>
<p>因为32-bit的int有个奇特的性质。<br/>
i = -2147483648时i和-i的二进制位是一样的。<br/>
所以-i得到的数，从概念上来说，已经溢出了int的范围了，<br/>
但是机器并不管这点，仍然老实地把值赋给一个unsigned型的，<br/>
这完全是可以的，而且运行结果也是正常的。</p>
<p>这段程序最后还展示了，<br/>
输出时使用不同的格式字符串，<br/>
可以得到的不同效果。</p>
<p> </p>
