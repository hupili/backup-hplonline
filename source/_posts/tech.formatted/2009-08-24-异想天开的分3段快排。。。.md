---
layout: post
title: "异想天开的分3段快排。。。"
date: 2009-08-24  14:23
comments: true
categories: tech
tags: ["算法"]
_baiduhi_id: 6a1e00d126a822da562c8401.html
_baiduhi_category: 算法
---

<p>(hplonline)2009.8.20</p>
<p>看了一份研究报告之后，<br/>
也手痒了，想想能不能把快排变得更快一点。</p>
<p>之前讨论过STL中一个<a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/a8d29150a0f2506a84352447.html">尽量避免爆栈的写法</a>。<br/>
这里突然想到的是改变一下分段数有没有作用。</p>
<p><font color="#0000ff">理论分析：</font></p>
<p>首先说说一般的快排效率，<br/>
我更倾向于立足某个程序实现，分析实际的比较和移动，<br/>
而不是单纯的看个理论的复杂度。</p>
<p>比如下方程序中的qsort2就是市面上常见的经典写法。<br/>
应该说，已经做得很精炼了，而且结构上看着很整齐。<br/>
每次比较的时候区间[l,r]中的每个数都和轴比较了一次。<br/>
而当把整个区间分成m段时，每一段比较的是n/m次，<br/>
总共加起来还是n次。<br/>
也就是说，每次把区间分成两段，不断分下去，形成一棵树。<br/>
这棵树的每层耗掉的比较次数都是n次。<br/>
而这棵树总共只有log2(n)这么高。<br/>
所以总共的耗费是f1=n*log2(n)</p>
<p>qsort3就是后面突发奇想的，<br/>
如果每次分成三段的话，<br/>
效率会怎么样呢。。<br/>
沿用上面的这种分析法。<br/>
分成三段，则需要两个轴元素，每个元素进行两次比较。<br/>
所以每层是2*n次比较，而总共的层数是log3(n)。<br/>
乘起来就是f2=2*n*log3(n)</p>
<p>比较两个式子可以简单使用作商法：<br/>
f1/f2<br/>
=(n*log2(n))/(2*n*log3(n))<br/>
=(ln(n)/ln(2))/(2*ln(n)/ln(3))<br/>
=ln(3)/(2*ln(2))<br/>
=  0.7925 &lt; 1</p>
<p>也就是说，单看比较次数，<br/>
这个想法就很作废了。<br/>
不过我还是写了下程序看看。。。</p>
<p><font color="#0000ff">程序：</font></p>
<p>#include &lt;stdio.h&gt;<br/>
#include &lt;stdlib.h&gt;<br/>
#include &lt;time.h&gt;<br/>
#include &lt;string.h&gt;<br/>
#include &lt;algorithm&gt;</p>
<p>using namespace std ;</p>
<p>const int MAXN = 1000000;</p>
<p>int origin[MAXN] , standard[MAXN];<br/>
int a[MAXN] ;<br/>
int tmp[MAXN] ;</p>
<p>void init(){<br/>
     int i;<br/>
     for ( i = 0 ; i &lt; MAXN ; i ++ ){<br/>
         origin[i] = rand() % 1000 ;<br/>
     }<br/>
     memcpy(standard , origin , sizeof(origin)) ;<br/>
     sort(standard , standard + MAXN) ;<br/>
}</p>
<p>void qsort2(int l , int r){<br/>
     int i , j , t ;<br/>
     i = rand() % ( r - l + 1 ) + l ;<br/>
     t = a[i] ;<br/>
     a[i] = a[l] ;<br/>
     a[l] = t ;<br/>
     <br/>
     i = l ;<br/>
     j = r ;<br/>
     //t == a[i] <br/>
     while ( i &lt; j ){<br/>
         while ( i &lt; j &amp;&amp; t &lt;= a[j] ) j -- ;<br/>
         a[i] = a[j] ;<br/>
         while ( i &lt; j &amp;&amp; a[i] &lt;= t ) i ++ ;<br/>
         a[j] = a[i] ;<br/>
     }<br/>
     a[i] = t ;</p>
<p>     if ( i - 1 &gt; l ) qsort2(l , i - 1) ;<br/>
     if ( i + 1 &lt; r ) qsort2(i + 1 , r) ;<br/>
}</p>
<p>void qsort3(int l , int r){<br/>
     int k , i , i1 , j , j1 , t1 , t2 ;<br/>
     <br/>
     t1 = a[l] ;<br/>
     if ( t1 &gt; a[l + 1] ) {<br/>
         t2 = t1 ;<br/>
         t1 = a[l + 1] ;<br/>
     }else t2 = a[l + 1] ;</p>
<p>     i = l ;<br/>
     j = r ;<br/>
     for ( k = l + 2 ; k &lt;= r ; k ++ ){<br/>
         if ( a[k] &lt; t1 ) tmp[i ++] = a[k] ;<br/>
         else tmp[j --] = a[k] ;<br/>
     }</p>
<p>     memcpy(&amp;a[l] , &amp;tmp[l] , sizeof(int) * (i - l)) ;<br/>
     i1 = i ;<br/>
     a[i ++] = t1 ;</p>
<p>     j1 = j ;<br/>
     j = r ;<br/>
     for ( k = j1 + 1 ; k &lt;= r ; k ++ ){<br/>
         if ( tmp[k] &gt; t2 ) a[j --] = tmp[k] ;<br/>
         else a[i ++] = tmp[k] ;<br/>
     }<br/>
     a[j] = t2 ;<br/>
     <br/>
     if ( i1 - 1 &gt; l ) qsort3(l , i1 - 1) ;<br/>
     if ( j - i1 &gt; 2 ) qsort3(i1 + 1 , j - 1) ;<br/>
     if ( j + 1 &lt; r ) qsort3(j + 1 , r) ;</p>
<p>}</p>
<p>void test(void (*func)(int , int)){<br/>
     memcpy(a , origin , sizeof(origin)) ;<br/>
     int t = clock() ;<br/>
     (*func)(0 , MAXN - 1) ;<br/>
     if ( memcmp(standard , a , sizeof(origin)) == 0 ) printf("right:") ;<br/>
     else printf("wrong:") ;<br/>
     printf("%d\n" , clock() - t) ;<br/>
}</p>
<p>int main(){<br/>
     init() ;<br/>
     test(qsort2) ;<br/>
     test(qsort3) ;<br/>
     return 0 ;<br/>
}</p>
<p> </p>
<p>结果：（debug编译）</p>
<p>right:1576<br/>
right:3010</p>
<p>结论是很显然的，效率没有改进。<br/>
而且慢得比理论推算的比例更多。。</p>
<p>最后再认真想一下，<br/>
发现最初的想法忽略的最重要的一个问题，<br/>
就是分段的均匀性。</p>
<p>上面的f1和f2两个式子都是在分段均匀的情况下得来的。<br/>
如果是分成两段，那么通过随机交换轴元素，可以从统计上说均匀了。<br/>
而分成三段的话，这一点就完全没法保证，<br/>
上面的实现是直接取的区间的前两个元素来做轴的。</p>
<p>尽管这个想法没有实践上的任何意义，<br/>
用来练习编码还是不错的。<br/>
因为3段和2段说起来仅仅是一个数字的不一样，<br/>
实现起来才发现要考虑的东西还真有不少。<br/>
为了保证2*n的比较次数，我用了O(n)的辅助空间，<br/>
也同时引入了大量元素的搬移工作。</p>
