---
layout: post
title: "在栈上分配空间（VC6)"
date: 2009-10-02  19:55
comments: true
categories: tech
tags: ["Asm"]
_baiduhi_id: f1149325ed1e646a35a80f47.html
_baiduhi_category: Asm
---

<p>(hplonline)2009.10.2</p>
<p>有的时候，在某个函数里面要动态分配一段内存，<br/>
这段内存仅仅是作为这个函数处理所用的临时空间，<br/>
并不用在该函数之外的其他地方。</p>
<p>用new比malloc慢就不说了，<br/>
如果还想比malloc快一点，可以直接在栈上分配。</p>
<p>而栈上一般都是编译器放的局部变量。<br/>
因为在编译期间，可以计算得到该函数内部需要的空间，<br/>
进入该函数时，除了在栈上保护相关的寄存器外，<br/>
就是从esp当前的位置向下拉出一段距离，<br/>
供给局部变量使用，<br/>
并且局部变量的偏移位置是预先可以知道的。</p>
<p>由于C中没有直接提供对栈的操作，<br/>
只有使用内联汇编。<br/>
又由于不同环境的汇编不太一样，<br/>
加之不同编译器的栈使用策略可能也不一样。<br/>
以下的内容就选在环境VISTA.VC6.DEBUG下了。</p>
<p>定义了几个宏，好写起来方便一点。<br/>
顺便比较一下和用malloc分配的耗时。</p>
<p><font color="#0000ff">程序：</font></p>
<p>#include &lt;stdio.h&gt;<br/>
#include &lt;stdlib.h&gt;<br/>
#include &lt;time.h&gt;</p>
<p>const int N = 1024 ;<br/>
const int M = 100000 ;</p>
<p>//在需要内存分配的地方调用<br/>
//char *p ;<br/>
//StackAlloc(512) ;<br/>
//StackPtr(p) ;<br/>
#define StackAlloc(x) __asm sub esp , x ;<br/>
#define StackPtr(p) __asm mov p , esp ;</p>
<p>//在函数返回之前归还内存<br/>
//否则debug模式下会报错<br/>
#define StackFree(x) __asm add esp , x ;</p>
<p>void fun1(int n){<br/>
     char *p ;<br/>
     StackAlloc(n) ;<br/>
     StackPtr(p) ;<br/>
     //do something ;<br/>
     StackFree(n) ;<br/>
}</p>
<p>void fun2(int n){<br/>
     char *p ;<br/>
     p = (char*)malloc(n) ;<br/>
     //do something ;<br/>
     free(p) ;<br/>
}</p>
<p>int main(){<br/>
     int i ;<br/>
     int tmp ;</p>
<p>     __asm mov tmp , esp ;<br/>
     printf("%d\n" , tmp) ;<br/>
     clock_t tt = 0 ;<br/>
     for ( i = 0 ; i &lt; M ; i ++ ){<br/>
         fun2(N) ;<br/>
     }<br/>
     __asm mov tmp , esp ;<br/>
     printf("%d\n" , tmp) ;<br/>
     printf("%d\n" , clock() - tt) ;</p>
<p>     return 0 ;<br/>
}</p>
<p>fun1:<br/>
1244912<br/>
1244912<br/>
3</p>
<p>fun2:<br/>
1244912<br/>
1244912<br/>
85</p>
<p>先打印出来的esp指针，<br/>
是为了说明堆栈是平衡的。。</p>
<p> </p>
