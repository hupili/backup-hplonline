---
layout: post
title: "信道均衡的一个MATLAB仿真实验"
date: 2010-01-14  15:53
comments: true
categories: tech
tags: ["Matlab"]
_baiduhi_id: bca1db13f212de095baf53b3.html
_baiduhi_category: Matlab
---

(hplonline)2010.1.14<br/><br/>
这学期学了通原，<br/>
虽然知道点基本概念，<br/>
不过大多会在数日之后搞忘。<br/>
想起前天居然没考信道均衡，<br/>
相当不解。。<br/>
毕竟信道均衡是我们这次新教材添加进的内容。<br/><br/>
再想下平时上课看的课件也有很多老教材的影子，<br/>
可见整个事情就是新瓶旧酒。<br/>
一样的老师，一样的课件，一样的实验，一样的考试，<br/>
就换了本书。<br/><br/>
好不容易所有试都考完了，<br/>
蛋疼一下，做个信道均衡的实验。<br/>
用的就是最简单的迫零均衡，<br/>
不过效果似乎没有想象中的那么好，<br/>
均衡前后听着都是嗡嗡的。<br/>
主要在通过2N+1抽头的均衡器后，<br/>
整个系统响应中间的2N+1个系数满足要求了，<br/>
但之外的系数反而会由零变成有值的，<br/>
同样引入ISI。<br/><br/>
示例程序和音乐<a href="http://www.box.net/shared/jkdz1vpt32" target="_blank">下载</a>。<br/><br/><font color="#0000ff">程序：</font><br/><br/>
（请不要使用太长的音乐，否则会filter很久）<br/><br/>
function main<br/>
[y fs nbits] = wavread('origin.wav') ;<br/><br/>
% wavplay(y , fs) ;<br/><br/>
N = 100 ;<br/>
h = rand(1 , 2 * N + 1) ;<br/>
yy = filter(h , [1] , y) ;<br/>
wavplay(yy , fs) ;<br/><br/>
c = get_equiv(h) ;<br/>
yyy = filter(c , [1] , yy) ;<br/>
wavplay(yyy , fs) ;<br/><br/>
return ;<br/><br/>
%forcing to zero algorithm<br/>
function c = get_equiv(h)<br/>
M = length(h) ;<br/>
N = (length(h) - 1) / 2 ;<br/>
h = fliplr(h) ;<br/>
H = [] ;<br/>
for ii = 1:N<br/>
tmp = h(N - ii + 2 : M) ;<br/>
tmp = [tmp , zeros(1 , N + 1 - ii)] ;<br/>
H = [H ; tmp] ;<br/>
end<br/>
H = [H ; h] ;<br/>
for ii = 1:N<br/>
tmp = zeros(1 , ii) ;<br/>
tmp = [tmp , h(1:M-ii)] ;<br/>
H = [H ; tmp] ;<br/>
end    <br/>
%hE = H * c<br/>
hE = [zeros(N , 1) ; 1 ; zeros(N , 1)] ;<br/>
c = H \ hE ;<br/>
return ;
