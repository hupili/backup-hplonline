---
layout: post
title: "BFS+HASH判重的几点记录（POJ2946）"
date: 2010-02-07  23:28
comments: true
categories: tech
tags: ["算法"]
_baiduhi_id: 88cfb631bba197a35fdf0ed3.html
_baiduhi_category: 算法
---

(hplonline)2010.2.7<br/><br/>
前天的昨天，有个小朋友问这个题。<br/>
他的主要问题在于模仿一般的BFS寻路的那些题，<br/>
开一个flag[][]去记录一个点访问过没有。<br/>
而推倒箱子后，地图的结构就会变化，<br/>
一个(i,j)完全可能去两次，但第二次flag[i][j]已经标记了，就出问题了。<br/><br/>
为了解释BFS里面的节点不是图上的点，<br/>
而是包含图上点的某种集合，<br/>
只好写一个拿去看看。。<br/><br/>
由于第一盘交的时候，实在是太慢，<br/>
于是后面找了很久的原因，改了又交了好多盘，<br/>
终于从约900ms弄到32ms。。<br/>
记录一些细节问题。<br/><br/><font color="#0000ff">1.按照调试方式编写的段落记得还原</font><br/><br/>
一种是freopen这样的问题，交到POJ上可能WA也可能TLE。<br/>
这个问题比较常见了，也有各种解决方案，<br/>
不过现在不常刷题了，也就没这样弄，想着不会怎么反复调试的。<br/><br/>
我这里还囧了一次，就是hash函数的位置。<br/>
为了分块调试，我的hash函数首先是全返回的0的。<br/>
这样相当于就在0的位置拉一个链表，<br/>
可以先排除hash算法本身的影响。<br/>
结果写完了搞忘改这句就交上去了。<br/>
神奇的是没有TLE，还卡着时间过了。<br/><br/>
我动了下hash表的大小，时间也没变，<br/>
还纳闷是为什么，后来才发现是这个return 0 的问题。<br/><br/><font color="#0000ff">2.hash表的大小问题</font><br/><br/>
在修改了很多细节之后，时间都只是一点点改进，<br/>
于是我把hash表调小了，一下就减少了约300ms。。<br/><br/>
所以这个问题也应该注意。<br/>
hash表太小当然容易冲突，链表一拉长，效率就降下来了。<br/>
hash表太大，虽然冲突可能没啥了，<br/>
但是光用memset初始化一下都得很久。<br/><br/><font color="#0000ff">3.hash函数的选取</font><br/><br/>
这个点上的研究应该是无穷无尽的，<br/>
不同的应用构造不同的hash函数，效果肯定不同。<br/>
我也试过好几个，结果网上找到的这个效果很好：<br/><br/>
int hash(char *s)<br/>
{<br/>
int count = sz ;<br/>
unsigned int h=0;<br/>
while ( --count &gt;= 0 )<br/>
{<br/>
h = h * 31 + *s++;<br/>
}<br/>
return h % MAXH;<br/>
}<br/><br/><font color="#0000ff">4.节点的设置</font><br/><br/>
最初的定义：<br/>
typedef struct node_type{<br/>
int i , j ;<br/>
char grids[MAXN][MAXN] ;<br/>
int step ;<br/>
} NODE ;<br/><br/>
最后的定义：<br/>
typedef struct node_type{<br/>
char i , j ;<br/>
char grids[MAXN * MAXN] ;<br/>
} NODE ;<br/><br/>
首先，定义一个二维数组，然后grids[i][j]这样寻址，<br/>
与定义一维数组grids[i * n + j]这样编出来的东西是类似的。<br/>
（二维的话，因为数组尺寸是常量，<br/>
所以可能直接用移位来优化，比如这里的数组是8*8的，<br/>
grids[i][j] = (char*)grids + ( i &lt;&lt; 3 ) + j ）<br/><br/>
单纯访问地图信息来说，两种定义都差不多，<br/>
但一维的定义更能适应hash上面的hash函数。<br/>
因为hash函数是很频繁调用的，<br/>
所以这样搞可以使得关键地方的寻址变简洁：<br/>
while ( --count &gt;= 0 )<br/>
{<br/>
h = h * 31 +<font color="#ff0000"> *s++;</font><br/>
}<br/><br/>
第二处是把step信息移除了，在外面开一个和队列平行的数组：<br/>
NODE q[MAXQ] ;<br/>
int step[MAXQ] ;<br/><br/>
这样的效果在于<font color="#ff0000">NODE节点包含了确定一个局面所必须且只须的信息</font>。<br/>
最明显的是比较两个节点是否相等的函数，可以直接缩成一句：<br/>
return !memcmp(&amp;n1 , &amp;n2 , sz) ;<br/>
直接库函数比较内存，就比最初定义先比较i，j，再二重循环比较地图好多了。<br/>
对于节点比较这样频繁的操作，细算到这里也是值得的。<br/><br/>
第三处是把i，j定义成char了。<br/>
倒不是为了省空间，主要是统一整个节点的表达。<br/>
i，j的范围本身就很小，用不着int，char就足够。<br/>
然后布局也比较trick，先i，j再放地图。<br/>
再加上地图已经一维化了，<br/>
这样，整个结构中只有前面 n*n+2 个字节是有效的。<br/>
于是不管hash还是赋值，都可以直接当成是 n*n+2 的字符串。<br/>
这种处理可以使得操作的内存数量减少不少。<br/><br/><font color="#0000ff">5.hash表存储</font><br/><br/>
我比较习惯的定义是：<br/>
HNODE space[MAXQ] , *spacehead ;<br/>
HNODE *table[MAXH] ;<br/><br/>
space 为节点本身的空间，<br/>
spacehead用来不重复地取得节点空间。<br/>
每处理完一个case，spacehead=space即可复位，<br/>
不用像动态分配那样去挨个元素释放。<br/><br/>
table用来存储每个key对应的链表表头，<br/>
使用链表头插法来维护。<br/><br/>
最初比较喜欢这种指针定义的table，<br/>
从直觉上来说，貌似比下标定义的要好：<br/>
int table[MAXH];<br/>
相应的hash节点的next域也从指针换成int的下标。<br/><br/>
但实际上，两种定义翻译出来的东西都是类似的。<br/>
比方说从next域取得了值放在eax。<br/>
指针定义的下一步是<br/>
mov xxx,[eax + field_offset] ;<br/>
下标定义的是<br/>
mov xxx,[eax * elem_size + array_offset + field_offset] ;<br/>
array_offset + field_offset能用一个32位的常数偏移量表达。<br/>
关键在于elem_size，如果是2、4、8的话，<br/>
在IA-32指令里面，就可以用一句话表达这个意思，<br/>
否则要多一句话算出eax * elem_size。<br/><br/><br/><br/><br/>
