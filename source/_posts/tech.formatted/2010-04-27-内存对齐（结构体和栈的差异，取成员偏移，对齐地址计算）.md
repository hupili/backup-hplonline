---
layout: post
title: "内存对齐（结构体和栈的差异，取成员偏移，对齐地址计算）"
date: 2010-04-27  11:36
comments: true
categories: tech
tags: ["c","c++"]
_baiduhi_id: afe3616341ae146c0d33fae5.html
_baiduhi_category: c&c++
---

(hplonline)2010.4.27<br/><br/>
印象中曾经记录过，不过居然找不到了。<br/>
联系最近听课和给别人讲东西发现的问题，重新详记一次。<br/><br/>
环境：vc6，.cpp文件，debug编译<br/><br/><font color="#0000ff">一。结构体对齐基本实验</font><br/><br/><font color="#ff00ff">程序：</font><br/><br/>
#include &lt;stdio.h&gt;<br/><br/>
struct s1{<br/>
char c1 ;<br/>
short s ;<br/>
char c2 ;<br/>
} ;<br/><br/>
struct s2{<br/>
char c1 ;<br/>
int i ;<br/>
char c2 ;<br/>
} ;<br/><br/>
#pragma pack(1)<br/>
struct s3{<br/>
char c1 ;<br/>
short s ;<br/>
char c2 ;<br/>
} ;<br/>
#pragma pack()<br/><br/>
#pragma pack(8)<br/>
struct s4{<br/>
char c1 ;<br/>
short s ;<br/>
char c2 ;<br/>
} ;<br/>
#pragma pack()<br/><br/>
struct s5{<br/>
char c1 ;<br/>
char c2 ;<br/>
short s ;<br/>
} ;<br/><br/>
int main(){<br/>
printf("%d,%d,%d,%d,%d\n" , <br/>
sizeof(struct s1) ,<br/>
sizeof(struct s2) , <br/>
sizeof(struct s3) ,<br/>
sizeof(struct s4) ,<br/>
sizeof(struct s5)) ;<br/><br/>
return 0 ;<br/>
}<br/><br/><font color="#ff00ff">结果：</font><br/><br/>
6,12,4,6,4<br/><br/><font color="#ff00ff">分析：</font><br/><br/>
s1的结果是用来说明有内存对齐这件事的。<br/>
相信很多人还记得C语言课程考试上，<br/>
问到结构体的大小时，会把它判为4。<br/><br/>
s1和s2的对比得到一个结论：<br/><font color="#ff0000">对齐到的字节数与最大成员所占空间有关。</font><br/><br/>
s3是说明可以用<font color="#ff0000">#pragma pack(xxx)</font>来改变对齐到的字节数。<br/>
当然，用完了只有要用<font color="#ff0000">#pragma pack()</font>来还原，<br/>
否则会对后面的结构造成影响。<br/><br/>
s4是说，虽然用#pragma pack(8)了，但是依然按照两字节对齐。<br/><br/>
从上面三条，可以得到的结论：<br/><font color="#ff0000">对齐到的字节数=min｛当前指定的pack值，最大成员大小｝</font><br/><br/>
s5是用来和s1做对比的。<br/>
可以看到，两个结构的内容一致，仅仅是摆放顺序不一样。<br/>
这里的结论是：<br/><font color="#ff0000">x字节的成员需要对齐到x字节的偏移上。</font><br/>
如果这句说起有点绕口，下面一节将有更深入的探究。<br/><br/><font color="#0000ff">二。结构体成员的偏移观察。</font><br/><br/>
取得指定结构体某成员在结构体内部的偏移可以用一个宏：<br/><font color="#ff0000">#define OFFSETOF(st,mem) (size_t)(&amp;((st*)0)-&gt;mem)</font><br/><br/>
貌似在好些地方看到有人这样用了，<br/>
稍微想一下，原理也就那样，故不解释了。<br/><font color="#ff00ff"><br/>
程序：</font><br/><br/>
#include &lt;stdio.h&gt;<br/><br/>
#define OFFSETOF(st,mem) (size_t)(&amp;((st*)0)-&gt;mem)<br/><br/>
struct s1{<br/>
char c1 ;<br/>
short s ;<br/>
char c2 ;<br/>
} ;<br/><br/>
struct s2{<br/>
char c1 ;<br/>
char c2 ;<br/>
short s ;<br/>
} ;<br/><br/>
int main(){<br/>
printf("%d,%d,%d\n%d,%d,%d\n" ,<br/>
OFFSETOF(s1 , c1) ,<br/>
OFFSETOF(s1 , s) ,<br/>
OFFSETOF(s1 , c2) ,<br/>
OFFSETOF(s2 , c1) ,<br/>
OFFSETOF(s2 , c2) ,<br/>
OFFSETOF(s2 , s) <br/>
) ;<br/>
return 0 ;<br/>
}<br/><br/><font color="#ff00ff">结果：</font><br/><br/>
0,2,4<br/>
0,1,2<br/><br/><font color="#ff00ff">分析：</font><br/><br/>
可以看到，在s1中，因为s是short型的，<br/>
需要被对齐到两字节的偏移上面。<br/><br/><font color="#ff0000">内存对齐不仅仅考虑对齐到某个大小，<br/>
也要考虑对齐到某个偏移。</font><br/><br/><font color="#0000ff">三。栈内容对齐</font><br/><br/><font color="#ff00ff">程序：</font><br/><br/>
#include &lt;stdio.h&gt;<br/><br/>
int main(){<br/>
char c ;<br/>
short s ;<br/>
int i ;<br/>
float f ;<br/>
double d ;<br/>
printf("%x,%x,%x,%x,%x\n" , &amp;c , &amp;s , &amp;i , &amp;f , &amp;d) ;<br/>
return 0 ;<br/>
}<br/><font color="#ff00ff"><br/>
结果：</font><br/><br/>
12ff44,12ff40,12ff3c,12ff38,12ff30<br/><br/>
可以看出，都是对齐到4字节的。<br/>
并且前面的char和short并没有被凑在一起，<br/>
这和结构体内的处理是不同的。<br/><br/><font color="#ff0000">在栈上，不考虑变量本身的大小，统一对齐到4字节。</font><br/><font color="#ff0000">在结构体中，综合考虑变量本身和指定的对齐值。</font><br/><br/>
至于为什么输出的值是变小的，<br/>
属于另外的问题了，<br/>
简要说就是这个平台上的栈是倒着长的。<br/><br/><font color="#0000ff">四。对齐地址的计算</font><br/><br/>
之前记过比较有趣的<a href="http://hi.baidu.com/hplonline/blog/item/2831bcfd2058891e08244d54.html" target="_blank">向上取整</a>写法，可以参考。<br/>
