---
layout: post
title: "初始化类中引用型的成员变量（VC6.C2758）"
date: 2010-05-14  11:13
comments: true
categories: tech
tags: ["c","c++"]
_baiduhi_id: 72cd68d09fee2583a1ec9c80.html
_baiduhi_category: c&c++
---

(hplonline)2010.5.14<br/><br/>
昨天跟T哥讨论实现传递类成员函数指针，<br/>
T哥有份一直没编译通，<br/>
最后发现是这个问题。<br/>
遂试了下，仔细想想很合逻辑，但之前还真没注意到过。<br/><br/>
例子：<br/><br/><font color="#ff9900">class mycls<br/>
{<br/>
int &amp;i ;<br/>
mycls(int &amp;i_in){<br/>
i = i_in ;<br/>
}<br/>
} ;</font><br/><br/>
报错为：<br/><br/><font color="#ff0000">error C2758: 'i' : must be initialized in constructor base/member initializer list</font><br/><br/>
这段代码看上去很逼真，为什么要报错呢。<br/><br/>
其实只要知道引用是由编译器用指针实现的，<br/>
而我们把引用转化为指针一般只有下面几个步骤：<br/><br/><font color="#ff0000">1.定义的地方换成指针（比如int &amp;i换成int *i）<br/>
2.函数形参，把引用也换成指针<br/>
3.函数实参，加取地址符<br/>
4.初始化引用的地方右值取地址<br/>
5.其他代码块中凡是遇到引用变量的表达式，换成脱指针（比如i=1换成*i=1）</font><br/><br/>
例子：<br/><br/>
void f(int &amp;i){}<br/>
int main(){<br/>
int i = 0 ;<br/>
int &amp;r = i;<br/>
f(r) ;<br/>
return 0;<br/>
}<br/><br/>
根据第1、2条：<br/><br/>
void f(int <font color="#ff0000">*i</font>){}<br/>
int main(){<br/>
int i = 0 ;<br/>
int <font color="#ff0000">*r</font> = i;<br/>
f(r) ;<br/>
return 0;<br/>
}<br/><br/>
第4条：<br/><br/>
void f(int *i){}<br/>
int main(){<br/>
int i = 0 ;<br/>
int *r =<font color="#ff0000"> &amp;i;</font><br/>
f(r) ;<br/>
return 0;<br/>
}<br/><br/>
第3、5条：<br/><br/>
void f(int *i){}<br/>
int main(){<br/>
int i = 0 ;<br/>
int *r = &amp;i;<br/>
f(<font color="#ff0000">&amp;*r</font>) ;<br/>
return 0;<br/>
}<br/><br/>
当然，上面的函数部分会被优化一下：<br/><br/>
void f(int *i){}<br/>
int main(){<br/>
int i = 0 ;<br/>
int *r = &amp;i;<br/>
f(r) ;<br/>
return 0;<br/>
}<br/><br/>
改过之后是下面这个样子：<br/><br/><font color="#ff9900">class mycls<br/>
{<br/>
int *i ;<br/>
mycls(int *i_in){<br/>
*i = *i_in ;<br/>
}<br/>
} ;</font><br/><br/>
这段代码可以编过了，但我们一眼就看出问题在哪了。<br/>
i这个指针现在的值根本就没有确定，<br/>
直接脱指针肯定会出问题的。<br/><br/>
但实际上，上面那段引用所想表达的本来意思是：<br/><font color="#ff9900"><br/>
class mycls<br/>
{<br/>
int *i ;<br/>
mycls(int *i_in){<br/>
i = i_in ;<br/>
}<br/>
} ;</font><br/><br/>
这里就是<font color="#ff0000">易用性和灵活性</font>的一个矛盾了。<br/>
引用使我们不用在使用的时候打上&amp;或者*这样的符号，<br/>
这是易用的一面，但同时降低了灵活性，<br/>
每当遇到引用类型的变量名时，<br/>
都是按照脱指针来处理的，<br/>
这样我们想使用该变量内含的地址都没办法了。<br/><br/>
根据C2758后面的提示信息，最前面的代码修改为：<br/><br/><font color="#ff9900">class mycls<br/>
{<br/>
int &amp;i ;<br/>
mycls(int &amp;i_in):i(i_in)<br/>
{<br/>
}<br/>
} ;</font><br/><br/>
就是把引用类型的初始化放到初始化列表中去。<br/><br/>
