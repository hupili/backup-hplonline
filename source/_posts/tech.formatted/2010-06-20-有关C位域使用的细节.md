---
layout: post
title: "有关C位域使用的细节"
date: 2010-06-20  20:43
comments: true
categories: tech
tags: ["c","c++"]
_baiduhi_id: 4411b8fba8d9562f4e4aeaa3.html
_baiduhi_category: c&c++
---

(hplonline)2010.6.20<br/><br/><font color="#0000ff">》》位域</font><br/><br/>
位域就是这样的东西：<br/><br/>
struct _mystr{<br/>
int b:<font color="#ff0000">1 </font>;<br/>
}<br/><br/>
一般写上层程序的时候很少使用，<br/>
毕竟最初发明它主要是出于存储开销的考虑。<br/>
随便一想，就知道这东西其实并不能给执行效率带来什么好处。<br/>
既然是处理位域，那么一个通用的赋值显然有三个部分组成：<br/><font color="#ff0000">1。原变量and上一个掩码，清空要赋值的部分<br/>
2。把要赋的值进行移位，以对齐到位域的最低位<br/>
3。用一个or把值赋上去。</font><br/><br/>
当然，这几个部分可能由编译器进行一定量的合并，<br/>
但这并不能从本质上改进什么东西。<br/><br/>
在很早很早的时候，计算机的容量又小，网络环境又差。<br/>
于是在不少协议中，位域得到了比较广泛的应用。<br/><br/>
关于位域，至少可以想到两个问题：<br/><font color="#ff9900">1。定义顺序和存储顺序？<br/>
2。如何进行内存对齐？</font><br/><br/><font color="#0000ff">》》实验</font><br/><br/><font color="#ff0000">环境：小尾机，VC6.DEBUG，.cpp编译</font><br/><br/>
#include &lt;stdio.h&gt;<br/>
#include &lt;string.h&gt;<br/><br/>
typedef struct _str1{<br/>
unsigned int b1:1 ;<br/>
unsigned int b2:1 ;<br/>
unsigned int b3:1 ;<br/>
unsigned int rest:13 ;<br/>
}STR1 ;<br/><br/>
typedef struct _str2{<br/>
unsigned int b1:1 ;<br/>
unsigned int b2:1 ;<br/>
unsigned int b3:1 ;<br/><font color="#ff0000">unsigned short</font> rest:13 ;<br/>
}STR2 ;<br/><br/>
typedef struct _str3{<br/>
unsigned short b1:1 ;<br/>
unsigned short b2:1 ;<br/>
unsigned short b3:1 ;<br/>
unsigned short rest:13 ;<br/>
}STR3 ;<br/><br/><font color="#ff0000">#pragma pack(1)</font><br/>
typedef struct _str4{<br/>
unsigned int b1:1 ;<br/>
unsigned int b2:1 ;<br/>
unsigned int b3:1 ;<br/>
unsigned short rest:13 ;<br/>
}STR4 ;<br/><font color="#ff0000">#pragma pack()</font><br/><br/>
int main(){<br/>
printf("%d,%d,%d,%d\n" , sizeof(STR1) , sizeof(STR2) , sizeof(STR3) , sizeof(STR4)) ;<br/><br/>
STR1 str ;<br/>
memset(&amp;str , 0 , sizeof(str)) ;<br/>
str.b1 = 1 ;<br/>
printf("%x\n" , (unsigned int)*(unsigned int*)&amp;str) ;<br/>
str.b3 = 1 ;<br/>
printf("%x\n" , (unsigned int)*(unsigned int*)&amp;str) ;<br/>
str.rest = 7 ;<br/>
return 0 ;<br/>
}<br/><br/>
输出：<br/><br/>
4,8,2,6<br/>
1<br/>
5<br/><br/><font color="#0000ff">》》结论</font><br/><br/>
定义顺序和存储顺序与一般的结构成员是一致的：<br/><font color="#ff0000">定义在前面（上面）的元素会放在低位。</font><br/><br/>
内存对齐的原则是，以pack的设置和基类型为标准。（STR1和STR3）<br/>
STR2告诉我们，如果前后的基类型不同，<br/>
不会按照位域进行合并，头一个基类型会直接填充满。<br/>
STR4告诉我们，即使用pack也无法缩减掉基类型中的空白。<br/><br/>
这几个结论，对于刚刚看完百科式C语言教材的人来说，<br/>
也许是显然的，但实验的方法让我们可以应对不同环境。<br/>
并且，这种显然的结论，当自己手写程序的时候，往往就不那么显然了。<br/>
比如，上面定义的几个结构体，其实就是模仿看到的某段IP头结构体的定义。<br/>
congest,df,mf三个1bit的位，加上13bit的offset。<br/><br/>
另外有一点很不爽的是，<br/><font color="#ff0000">C不允许我们对位域取地址（用&amp;操作符）。</font><br/>
在实践中，这实际上会引起一些不方便，<br/><font color="#ff0000">我觉得</font>更合适的定义是：<br/><font color="#ff0000">对位域取地址得到的是其基础类型所在的地址。</font><br/><br/>
