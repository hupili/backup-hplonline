---
layout: post
title: "pthread对多线程访问全局数据结构的支持"
date: 2010-09-20  22:03
comments: true
categories: tech
tags: ["Linux"]
_baiduhi_id: ab4bc711263c261eb8127bcb.html
_baiduhi_category: Linux
---

(hplonline)2010.9.20<br/><br/>
pthread库里有两个函数，<br/>
对多线程访问全局数据结构提供了比较简易的解决方案：<br/>
pthread_<font color="#ff0000">set</font>specific(key,value)<br/>
pthread_<font color="#ff0000">get</font>specific(key)<br/>
使用之前得再man一下，需要create了key才能在这两个函数中使用。<br/>
后面就用set和get来代替他们了。<br/>
set可以将一个线程相关的value绑定到一个全局的key上面；<br/>
get可以从这个全局的key中取得线程相关的value。<br/><br/><font color="#0000ff">》》一个单线程示例</font><br/><br/>
global_data ; // in global scope<br/>
...<br/>
init(){ initialize global_data; }<br/>
...<br/>
op1(){ do something with global_data; }<br/>
op2(){ do something with global_data; }<br/>
...<br/>
opn(){ do something with global_data; }<br/>
...<br/>
work(){<br/>
init();<br/>
op1();<br/>
op2();<br/>
...<br/>
opn();<br/>
}<br/><br/>
比较常见的就是，在init里面，使用malloc之类的分配空间，<br/>
而这个所谓的global_data，就是分配空间后返回的指针。<br/>
在后续的各个操作函数中，通过这个指针去引用一些全局的数据。<br/><br/>
不要问我为什么不封装一下之类的，这个的原因可能很多。<br/>
比如，当年写这段代码的人没这个意识。<br/>
比如，为了少敲点键盘。如果放在参数里的话，每一处都会带上这么个指针。<br/>
反正各种原因和可能性，就不多说了。<br/><br/>
现在的问题是，由于时代发展了，我们想把这样一套东西多线程化。<br/>
但是这样一个global_data并非线程间共享的，<br/>
而是每个线程应该独有的数据结构，就是thread specific。<br/><br/><font color="#0000ff">》》一般的解决方案</font><br/><br/>
arr_global_data[N] ; // in global scope<br/>
...<br/>
init(data){ initialize data; }<br/>
...<br/>
op1(data){ do something with global_data; }<br/>
op2(data){ do something with global_data; }<br/>
...<br/>
opn(data){ do something with global_data; }<br/>
...<br/>
work(data){<br/>
init(data);<br/>
op1(data);<br/>
op2(data);<br/>
...<br/>
opn(data);<br/>
}<br/><br/>
main(){<br/>
create_thread(th0,work,arr_global_data[0]);<br/>
create_thread(th1,work,arr_global_data[1]);<br/>
...<br/>
create_thread(thn,work,arr_global_data[n]);<br/>
}<br/><br/>
这个方法倒是比较通用，<br/>
在各个系统下，创建线程的结构一般都允许传入工作函数和参数。<br/>
不管有多少参数，打包成一个结构，然后传入指针总是可以的。<br/>
之前只有单个的全局变量，现在开成数组即可。<br/><br/>
问题虽然解决了，但是有一点不方便的就是，我们大量修改了接口。<br/>
首先，各个操作函数需要传入参数，标识自己该用哪一块数据。<br/>
然后，可以预见到会有一定量的名称替换。<br/>
不过好处是，这样的写法在各个平台下都行，<br/>
不用依赖某些特殊的线程库的实现。<br/><br/><font color="#0000ff">》》pthread支持的解决方案</font><br/><br/><font color="#ff0000">global_data_key</font> ; // in global scope<br/>
...<br/>
init(){ initialize <font color="#ff00ff">data</font>; set(<font color="#ff0000">global_data_key</font>,<font color="#ff00ff">data</font>)}<br/>
...<br/>
op1(){ <font color="#ff00ff">data</font>=get(<font color="#ff0000">global_data_key</font>) ; do something with <font color="#ff00ff">data</font>; }<br/>
op2(){ <font color="#ff00ff">data</font>=get(<font color="#ff0000">global_data_key</font>) ; do something with <font color="#ff00ff">data</font>; }<br/>
...<br/>
opn(){ <font color="#ff00ff">data</font>=get(<font color="#ff0000">global_data_key</font>) ; do something with <font color="#ff00ff">data</font>; }<br/>
...<br/>
work(){<br/>
init() ;<br/>
op1();<br/>
op2();<br/>
...<br/>
opn();<br/>
}<br/><br/>
main(){<br/><font color="#ff0000">global_data_key </font>= create_key() ;<br/>
create_thread(th0,work,NULL);<br/>
create_thread(th1,work,NULL);<br/>
...<br/>
create_thread(thn,work,NULL);<br/>
}<br/><br/>
可以看到，这套解决方案在全局的位置，只是把data本身替换成了一个key。<br/>
在main函数中，对这个key进行初始化即可。<br/>
各个线程调用init后，可以将自身相关的data绑定到key上。<br/>
后面虽然各个op函数是相同的，但在get操作的时候，<br/>
pthread库帮忙判定是从哪个线程调用该op的，得到的就是对应的data。<br/><br/><font color="#0000ff">》》简评</font><br/><br/>
特别适合用在那种刚开始不是按照多线程进行设计的地方。<br/>
单线程程序work得很好后，通过这套接口来多线程化。<br/>
实际中遇到的项目可能并不像我这里一个work，里面几个op这么简单。<br/>
很可能是各种函数调用，到处都会引用到这样一个<font color="#ff0000">线程全局</font>的结构。<br/>
这时，逐一修改接口的成本是很大的，比较麻烦。<br/><br/>
