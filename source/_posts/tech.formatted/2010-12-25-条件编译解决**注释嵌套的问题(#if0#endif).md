---
layout: post
title: "条件编译解决/**/注释嵌套的问题(#if 0 #endif)"
date: 2010-12-25  18:54
comments: true
categories: tech
tags: ["c","c++"]
_baiduhi_id: 86e03a4eb58583d8d0c86af2.html
_baiduhi_category: c&c++
---

<p>(hplonline)2010.12.25</p><br/><a target="_blank" href="http://hi.baidu.com/hplonline/blog/item/d224c9fd0705524cd6887d9e.html">《C陷阱与缺陷》</a>里面有一个例子，ex1-2，谈到了注释嵌套的问题。<br/>不过这个excercise讲的只是怎么通过写一段代码来检验编译器，并没有给出解决的方法。<br/>就我所看到的C/C++编译器，比较常用的应该还是不支持/**/形式嵌套的。<br/><br/><span style="color: rgb(0, 85, 255);">》》嵌套的意义</span><br/><br/>先说一下嵌套的意义吧。如果不是动那些比较大的代码，可能也没有这个需求。<br/><br/>比如曾经你有一些代码：<br/>code1 ;<br/>code2 ;<br/>code3 ;<br/><br/>某天，你发现code2的功能不用了，当然，从小我们就被教育，养成了注释的好习惯：<br/>code1 ;<br/>/* code2 ; */<br/>code3 ;<br/>因为有些暂时不用的东西以后可能又会想用了，重写一遍不如直接解除注释方便。<br/><br/>又某天，你发现这一大段都不想要了，那么？<br/><span style="color: rgb(255, 0, 0);">/*</span>code1 ;<br/>/* code2 ;<span style="color: rgb(255, 0, 0);">*/</span><br/>
code3 ; */<br/>这样吗？可惜最常见的情况是编译器报一个错。。。<br/>真正匹配起的是标红的两个注释。<br/><br/>所以，支持嵌套注释是非常有必要的。<br/>在一个硕大的工程里面，code[1-3]可能是很长的一块，<br/>更恶心的是，里面有很多别人写的东西，<br/>你不会知道你的 "/*"符号会被哪里的"*/"给截止掉。<br/><br/><span style="color: rgb(0, 85, 255);">》》土办法和洋办法</span><br/><br/>我最早学会的是土办法，因为很多C++的教条都告诉我们尽量使用 "//"，少用/**/。<br/>这样至少有一个好处，就是你用/**/去包含//的时候不会有问题。<br/>但如果要再包含一次，结果还是会被囧掉。<br/><br/>还有另外一个原因，就是我们可能会需要使用不能贯穿一行的注释。<br/><span style="color: rgb(255, 169, 0);">int myfunc(int n <span style="color: rgb(255, 0, 0);">/*number of elements*/</span>, int *a <span style="color: rgb(255, 0, 0);">/*pointer to the first element*/</span>)</span><br/>这个时候，//的用户者又跳出来了，发明一种新格式，并且写如规范：<br/><span style="color: rgb(255, 169, 0);">int myfunc(</span><br/><span style="color: rgb(255, 169, 0);">    int n, <span style="color: rgb(255, 0, 0);">// number of elements</span></span><br/><span style="color: rgb(255, 169, 0);">    int *a <span style="color: rgb(255, 0, 0);">// pointer to the first element</span></span><br/><span style="color: rgb(255, 169, 0);">) ;</span><br/>这样不就解决了注释符号的选择问题，而且看起来似乎可读性还变高了。<br/>前人很happy地把这个写入规范中，后人当然不知道，这个“可读性变高”是土办法的副作用。<br/><br/>其实这些之所以为土办法，是因为他们还是没有解决注释嵌套的问题。<br/>只是在通过种种书写上的方式，来尽量降低这个局限性带来的影响。<br/><br/>后来，无意中看到一个洋办法，真的很洋气啊。。。<br/>其实我们都知道可以用 #if #endif 来条件编译，自己却没想到可以做嵌套用。<br/>比如，前面的code，直接这样就行了：<br/><span style="color: rgb(255, 0, 0);">#if 0</span><br/><span style="color: rgb(255, 169, 0);">code1 ;</span><br/><span style="color: rgb(255, 169, 0);">/* code2 ; */</span><br/><span style="color: rgb(255, 169, 0);">code3 ;</span><br/><span style="color: rgb(255, 0, 0);">#endif</span><br/>这两个标记当然是可以嵌套的，因为预处理器会按照if的结构去解析它。<br/>gcc 3.4.5的gcc和g++都测试过了，可行。<br/><br/>现在大多不建议用宏定义常量或者函数，因为有const和inline可以使用。<br/>顺便小节一下，用预处理命令的主要几个地方：<br/>1、 include guards。就是 #ifndef xx #define xx  ..... #endif这个，用在头文件中。<br/>2、 本篇提到的嵌套注释。#if 0 ... #endif<br/>3、 debug信息的开启开关。 #ifdef _DEBUG ... #endif<br/><br/>至于用条件编译来解决什么跨平台的问题，我们大多数人都很少用到。<br/><br/>
